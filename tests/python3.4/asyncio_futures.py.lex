(LIT "A Future class similar to the one in PEP 3148.")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "CancelledError")
(PUNCT ",")
(LIT "TimeoutError")
(PUNCT ",")
(LIT "InvalidStateError")
(PUNCT ",")
(LIT "Future")
(PUNCT ",")
(LIT "wrap_future")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "_base")
(NEWLINE)
(KEYWORD import)
(ID "logging")
(NEWLINE)
(KEYWORD import)
(ID "reprlib")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "events")
(NEWLINE)
(ID "_PENDING")
(PUNCT "=")
(LIT "PENDING")
(NEWLINE)
(ID "_CANCELLED")
(PUNCT "=")
(LIT "CANCELLED")
(NEWLINE)
(ID "_FINISHED")
(PUNCT "=")
(LIT "FINISHED")
(NEWLINE)
(ID "_PY34")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "version_info")
(PUNCT ">=")
(PUNCT "(")
(LIT 3)
(PUNCT ",")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(ID "Error")
(PUNCT "=")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "_base")
(PUNCT ".")
(ID "Error")
(NEWLINE)
(ID "CancelledError")
(PUNCT "=")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "CancelledError")
(NEWLINE)
(ID "TimeoutError")
(PUNCT "=")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "TimeoutError")
(NEWLINE)
(ID "STACK_DEBUG")
(PUNCT "=")
(ID "logging")
(PUNCT ".")
(ID "DEBUG")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD class)
(ID "InvalidStateError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The operation is not allowed in this state.")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_TracebackLogger")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to log a traceback upon destruction if not cleared.\n\n    This solves a nasty problem with Futures and Tasks that have an\n    exception set: if nobody asks for the exception, the exception is\n    never logged.  This violates the Zen of Python: 'Errors should\n    never pass silently.  Unless explicitly silenced.'\n\n    However, we don't want to log the exception as soon as\n    set_exception() is called: if the calling code is written\n    properly, it will get the exception and handle it properly.  But\n    we *do* want to log it if result() or exception() was never called\n    -- otherwise developers waste a lot of time wondering why their\n    buggy code fails silently.\n\n    An earlier attempt added a __del__() method to the Future class\n    itself, but this backfired because the presence of __del__()\n    prevents garbage collection from breaking cycles.  A way out of\n    this catch-22 is to avoid having a __del__() method on the Future\n    class itself, but instead to have a reference to a helper object\n    with a __del__() method that logs the traceback, where we ensure\n    that the helper object doesn't participate in cycles, and only the\n    Future has a reference to it.\n\n    The helper object is added when set_exception() is called.  When\n    the Future is collected, and the helper is present, the helper\n    object is also collected, and its __del__() method will log the\n    traceback.  When the Future's result() or exception() method is\n    called (and a helper object is present), it removes the helper\n    object, after calling its clear() method to prevent it from\n    logging.\n\n    One downside is that we do a fair amount of work to extract the\n    traceback from the exception, even when it is never logged.  It\n    would seem cheaper to just store the exception object, but that\n    references the traceback, which references stack frames, which may\n    reference the Future, which references the _TracebackLogger, and\n    then the _TracebackLogger would be included in a cycle, which is\n    what we're trying to avoid!  As an optimization, we don't\n    immediately format the exception; we only do the work when\n    activate() is called, which call is delayed until after all the\n    Future's callbacks have run.  Since usually a Future has at least\n    one callback (typically set by 'yield from') and usually that\n    callback extracts the callback, thereby removing the need to\n    format the exception.\n\n    PS. I don't claim credit for this solution.  I first heard of it\n    in a discussion about closing files when they are collected.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "loop")
(PUNCT ",")
(LIT "source_traceback")
(PUNCT ",")
(LIT "exc")
(PUNCT ",")
(LIT "tb")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "future")
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "loop")
(PUNCT "=")
(ID "future")
(PUNCT ".")
(ID "_loop")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "source_traceback")
(PUNCT "=")
(ID "future")
(PUNCT ".")
(ID "_source_traceback")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exc")
(PUNCT "=")
(ID "exc")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tb")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "activate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "exc")
(NEWLINE)
(KEYWORD if)
(ID "exc")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "exc")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tb")
(PUNCT "=")
(ID "traceback")
(PUNCT ".")
(ID "format_exception")
(PUNCT "(")
(ID "exc")
(PUNCT ".")
(ID "__class__")
(PUNCT ",")
(ID "exc")
(PUNCT ",")
(ID "exc")
(PUNCT ".")
(ID "__traceback__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "exc")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tb")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "tb")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Future/Task exception was never retrieved\n")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "source_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "src")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "traceback")
(PUNCT ".")
(ID "format_list")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "source_traceback")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "msg")
(PUNCT "+=")
(LIT "Future/Task created at (most recent call last):\n")
(NEWLINE)
(ID "msg")
(PUNCT "+=")
(LIT "%s\n")
(PUNCT "%")
(ID "src")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "msg")
(PUNCT "+=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "tb")
(PUNCT ")")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "loop")
(PUNCT ".")
(ID "call_exception_handler")
(PUNCT "(")
(PUNCT "{")
(LIT "message")
(PUNCT ":")
(ID "msg")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Future")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This class is *almost* compatible with concurrent.futures.Future.\n\n    Differences:\n\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.\n\n    - Callbacks registered with add_done_callback() are always called\n      via the event loop's call_soon_threadsafe().\n\n    - This class is not compatible with the wait() and as_completed()\n      methods in the concurrent.futures package.\n\n    (In Python 3.4 or later we may be able to unify the implementations.)\n    ")
(NEWLINE)
(ID "_state")
(PUNCT "=")
(ID "_PENDING")
(NEWLINE)
(ID "_result")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_exception")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_loop")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_source_traceback")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_blocking")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "_log_traceback")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "_tb_logger")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Initialize the future.\n\n        The optional event_loop argument allows to explicitly set the event\n        loop object used by the future. If it's not provided, the future uses\n        the default event loop.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT "=")
(ID "loop")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "get_debug")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT "=")
(ID "traceback")
(PUNCT ".")
(ID "extract_stack")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "_getframe")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_format_callbacks")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cb")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(NEWLINE)
(ID "size")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "cb")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cb")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "format_cb")
(PUNCT "(")
(ID "callback")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "events")
(PUNCT ".")
(ID "_format_callback")
(PUNCT "(")
(ID "callback")
(PUNCT ",")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cb")
(PUNCT "=")
(ID "format_cb")
(PUNCT "(")
(ID "cb")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "size")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cb")
(PUNCT "=")
(LIT "{}, {}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "format_cb")
(PUNCT "(")
(ID "cb")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(ID "format_cb")
(PUNCT "(")
(ID "cb")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "size")
(PUNCT ">")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cb")
(PUNCT "=")
(LIT "{}, <{} more>, {}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "format_cb")
(PUNCT "(")
(ID "cb")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(ID "size")
(PUNCT "-")
(LIT 2)
(PUNCT ",")
(ID "format_cb")
(PUNCT "(")
(ID "cb")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "cb=[%s]")
(PUNCT "%")
(ID "cb")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_repr_info")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT "=")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(ID "_FINISHED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exception")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "exception={!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exception")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "reprlib")
(PUNCT ".")
(ID "repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_result")
(PUNCT ")")
(NEWLINE)
(ID "info")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "result={}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_format_callbacks")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "frame")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "info")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "created at %s:%s")
(PUNCT "%")
(PUNCT "(")
(ID "frame")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "frame")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "info")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_repr_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "<%s %s>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "info")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_PY34")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_log_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "exc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exception")
(NEWLINE)
(ID "context")
(PUNCT "=")
(PUNCT "{")
(LIT "message")
(PUNCT ":")
(PUNCT "(")
(LIT "%s exception was never retrieved")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ",")
(LIT "exception")
(PUNCT ":")
(ID "exc")
(PUNCT ",")
(LIT "future")
(PUNCT ":")
(ID "self")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "[")
(LIT "source_traceback")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_exception_handler")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "cancel")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Cancel the future and schedule callbacks.\n\n        If the future is already done or cancelled, return False.  Otherwise,\n        change the future's state to cancelled, schedule the callbacks and\n        return True.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_PENDING")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(ID "_CANCELLED")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_schedule_callbacks")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_schedule_callbacks")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: Ask the event loop to call all callbacks.\n\n        The callbacks are scheduled to be called as soon as possible. Also\n        clears the callback list.\n        ")
(NEWLINE)
(ID "callbacks")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "callbacks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "callback")
(KEYWORD in)
(ID "callbacks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "callback")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "cancelled")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the future was cancelled.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(ID "_CANCELLED")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "done")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the future is done.\n\n        Done means either that a result / exception are available, or that the\n        future was cancelled.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_PENDING")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "result")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the result this future represents.\n\n        If the future has been cancelled, raises CancelledError.  If the\n        future's result isn't yet available, raises InvalidStateError.  If\n        the future is done and has an exception set, this exception is raised.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(ID "_CANCELLED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "CancelledError")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_FINISHED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InvalidStateError")
(PUNCT "(")
(LIT "Result is not ready.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_log_traceback")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exception")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "self")
(PUNCT ".")
(ID "_exception")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "exception")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the exception that was set on this future.\n\n        The exception (or None if no exception was set) is returned only if\n        the future is done.  If the future has been cancelled, raises\n        CancelledError.  If the future isn't done yet, raises\n        InvalidStateError.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(ID "_CANCELLED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "CancelledError")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_FINISHED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InvalidStateError")
(PUNCT "(")
(LIT "Exception is not set.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_log_traceback")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exception")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_done_callback")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add a callback to be run when the future becomes done.\n\n        The callback is called with a single argument - the future object. If\n        the future is already done when this is called, the callback is\n        scheduled with call_soon.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_PENDING")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "fn")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "remove_done_callback")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove all instances of a callback from the \"call when done\" list.\n\n        Returns the number of callbacks removed.\n        ")
(NEWLINE)
(ID "filtered_callbacks")
(PUNCT "=")
(PUNCT "[")
(ID "f")
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(KEYWORD if)
(ID "f")
(PUNCT "!=")
(ID "fn")
(PUNCT "]")
(NEWLINE)
(ID "removed_count")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "filtered_callbacks")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "removed_count")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_callbacks")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "filtered_callbacks")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "removed_count")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_set_result_unless_cancelled")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "result")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper setting the result only if the future was not cancelled.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_result")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "result")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Mark the future done and set its result.\n\n        If the future is already done when this method is called, raises\n        InvalidStateError.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_PENDING")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InvalidStateError")
(PUNCT "(")
(LIT "{}: {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_result")
(PUNCT "=")
(ID "result")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(ID "_FINISHED")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_schedule_callbacks")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_exception")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Mark the future done and set an exception.\n\n        If the future is already done when this method is called, raises\n        InvalidStateError.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(ID "_PENDING")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InvalidStateError")
(PUNCT "(")
(LIT "{}: {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "exception")
(PUNCT ",")
(ID "type")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exception")
(PUNCT "=")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_exception")
(PUNCT "=")
(ID "exception")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(ID "_FINISHED")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_schedule_callbacks")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_PY34")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log_traceback")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(PUNCT "=")
(ID "_TracebackLogger")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exception")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_tb_logger")
(PUNCT ".")
(ID "activate")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_copy_state")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal helper to copy state from another Future.\n\n        The other Future may be a concurrent.futures.Future.\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "other")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exception")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "exception")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_exception")
(PUNCT "(")
(ID "exception")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "result")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_blocking")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(LIT "yield from wasn't used with future")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "result")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "wrap_future")
(PUNCT "(")
(ID "fut")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wrap concurrent.futures.Future object.")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "fut")
(PUNCT ",")
(ID "Future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fut")
(NEWLINE)
(DEDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "fut")
(PUNCT ",")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(PUNCT ",")
(LIT "concurrent.futures.Future is expected, got {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fut")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "new_future")
(PUNCT "=")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_check_cancel_other")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "f")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "new_future")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "_check_cancel_other")
(PUNCT ")")
(NEWLINE)
(ID "fut")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(KEYWORD lambda)
(ID "future")
(PUNCT ":")
(ID "loop")
(PUNCT ".")
(ID "call_soon_threadsafe")
(PUNCT "(")
(ID "new_future")
(PUNCT ".")
(ID "_copy_state")
(PUNCT ",")
(ID "future")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "new_future")
(NEWLINE)
(DEDENT)
(ENDMARKER)
