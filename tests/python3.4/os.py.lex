(LIT "OS routines for NT or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt or ce, e.g. unlink, stat, etc.\n  - os.path is either posixpath or ntpath\n  - os.name is either 'posix', 'nt' or 'ce'.\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator (always '.')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).\n")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "errno")
(NEWLINE)
(KEYWORD import)
(ID "stat")
(KEYWORD as)
(ID "st")
(NEWLINE)
(ID "_names")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "builtin_module_names")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "altsep")
(PUNCT ",")
(LIT "curdir")
(PUNCT ",")
(LIT "pardir")
(PUNCT ",")
(LIT "sep")
(PUNCT ",")
(LIT "pathsep")
(PUNCT ",")
(LIT "linesep")
(PUNCT ",")
(LIT "defpath")
(PUNCT ",")
(LIT "name")
(PUNCT ",")
(LIT "path")
(PUNCT ",")
(LIT "devnull")
(PUNCT ",")
(LIT "SEEK_SET")
(PUNCT ",")
(LIT "SEEK_CUR")
(PUNCT ",")
(LIT "SEEK_END")
(PUNCT ",")
(LIT "fsencode")
(PUNCT ",")
(LIT "fsdecode")
(PUNCT ",")
(LIT "get_exec_path")
(PUNCT ",")
(LIT "fdopen")
(PUNCT ",")
(LIT "popen")
(PUNCT ",")
(LIT "extsep")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "_exists")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "name")
(KEYWORD in)
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_exports_list")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "module")
(PUNCT ".")
(ID "__all__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "n")
(KEYWORD for)
(ID "n")
(KEYWORD in)
(ID "dir")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(KEYWORD if)
(ID "n")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "!=")
(LIT "_")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(LIT "posix")
(KEYWORD in)
(ID "_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(LIT "posix")
(NEWLINE)
(ID "linesep")
(PUNCT "=")
(LIT "\n")
(NEWLINE)
(KEYWORD from)
(ID "posix")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "posix")
(KEYWORD import)
(ID "_exit")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "_exit")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "posixpath")
(KEYWORD as)
(ID "path")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "posix")
(KEYWORD import)
(ID "_have_functions")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(LIT "nt")
(KEYWORD in)
(ID "_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(LIT "nt")
(NEWLINE)
(ID "linesep")
(PUNCT "=")
(LIT "\r\n")
(NEWLINE)
(KEYWORD from)
(ID "nt")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "nt")
(KEYWORD import)
(ID "_exit")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "_exit")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "ntpath")
(KEYWORD as)
(ID "path")
(NEWLINE)
(KEYWORD import)
(ID "nt")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "_get_exports_list")
(PUNCT "(")
(ID "nt")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "nt")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "nt")
(KEYWORD import)
(ID "_have_functions")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(LIT "ce")
(KEYWORD in)
(ID "_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(LIT "ce")
(NEWLINE)
(ID "linesep")
(PUNCT "=")
(LIT "\r\n")
(NEWLINE)
(KEYWORD from)
(ID "ce")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "ce")
(KEYWORD import)
(ID "_exit")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "_exit")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "ntpath")
(KEYWORD as)
(ID "path")
(NEWLINE)
(KEYWORD import)
(ID "ce")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "_get_exports_list")
(PUNCT "(")
(ID "ce")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "ce")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "ce")
(KEYWORD import)
(ID "_have_functions")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ImportError")
(PUNCT "(")
(LIT "no os specific module found")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(LIT "os.path")
(PUNCT "]")
(PUNCT "=")
(ID "path")
(NEWLINE)
(KEYWORD from)
(ID "os")
(PUNCT ".")
(ID "path")
(KEYWORD import)
(PUNCT "(")
(ID "curdir")
(PUNCT ",")
(ID "pardir")
(PUNCT ",")
(ID "sep")
(PUNCT ",")
(ID "pathsep")
(PUNCT ",")
(ID "defpath")
(PUNCT ",")
(ID "extsep")
(PUNCT ",")
(ID "altsep")
(PUNCT ",")
(ID "devnull")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "_names")
(NEWLINE)
(KEYWORD if)
(ID "_exists")
(PUNCT "(")
(LIT "_have_functions")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_globals")
(PUNCT "=")
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_add")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "fn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "fn")
(KEYWORD in)
(ID "_globals")
(PUNCT ")")
(KEYWORD and)
(PUNCT "(")
(ID "str")
(KEYWORD in)
(ID "_have_functions")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_set")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "_globals")
(PUNCT "[")
(ID "fn")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_set")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FACCESSAT")
(PUNCT ",")
(LIT "access")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FCHMODAT")
(PUNCT ",")
(LIT "chmod")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FCHOWNAT")
(PUNCT ",")
(LIT "chown")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FSTATAT")
(PUNCT ",")
(LIT "stat")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FUTIMESAT")
(PUNCT ",")
(LIT "utime")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LINKAT")
(PUNCT ",")
(LIT "link")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_MKDIRAT")
(PUNCT ",")
(LIT "mkdir")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_MKFIFOAT")
(PUNCT ",")
(LIT "mkfifo")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_MKNODAT")
(PUNCT ",")
(LIT "mknod")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_OPENAT")
(PUNCT ",")
(LIT "open")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_READLINKAT")
(PUNCT ",")
(LIT "readlink")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_RENAMEAT")
(PUNCT ",")
(LIT "rename")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_SYMLINKAT")
(PUNCT ",")
(LIT "symlink")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_UNLINKAT")
(PUNCT ",")
(LIT "unlink")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_UNLINKAT")
(PUNCT ",")
(LIT "rmdir")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_UTIMENSAT")
(PUNCT ",")
(LIT "utime")
(PUNCT ")")
(NEWLINE)
(ID "supports_dir_fd")
(PUNCT "=")
(ID "_set")
(NEWLINE)
(ID "_set")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FACCESSAT")
(PUNCT ",")
(LIT "access")
(PUNCT ")")
(NEWLINE)
(ID "supports_effective_ids")
(PUNCT "=")
(ID "_set")
(NEWLINE)
(ID "_set")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FCHDIR")
(PUNCT ",")
(LIT "chdir")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FCHMOD")
(PUNCT ",")
(LIT "chmod")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FCHOWN")
(PUNCT ",")
(LIT "chown")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FDOPENDIR")
(PUNCT ",")
(LIT "listdir")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FEXECVE")
(PUNCT ",")
(LIT "execve")
(PUNCT ")")
(NEWLINE)
(ID "_set")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "stat")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FTRUNCATE")
(PUNCT ",")
(LIT "truncate")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FUTIMENS")
(PUNCT ",")
(LIT "utime")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FUTIMES")
(PUNCT ",")
(LIT "utime")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FPATHCONF")
(PUNCT ",")
(LIT "pathconf")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_exists")
(PUNCT "(")
(LIT "statvfs")
(PUNCT ")")
(KEYWORD and)
(ID "_exists")
(PUNCT "(")
(LIT "fstatvfs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FSTATVFS")
(PUNCT ",")
(LIT "statvfs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "supports_fd")
(PUNCT "=")
(ID "_set")
(NEWLINE)
(ID "_set")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FACCESSAT")
(PUNCT ",")
(LIT "access")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FCHOWNAT")
(PUNCT ",")
(LIT "chown")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FSTATAT")
(PUNCT ",")
(LIT "stat")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LCHFLAGS")
(PUNCT ",")
(LIT "chflags")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LCHMOD")
(PUNCT ",")
(LIT "chmod")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_exists")
(PUNCT "(")
(LIT "lchown")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LCHOWN")
(PUNCT ",")
(LIT "chown")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LINKAT")
(PUNCT ",")
(LIT "link")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LUTIMES")
(PUNCT ",")
(LIT "utime")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_LSTAT")
(PUNCT ",")
(LIT "stat")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_FSTATAT")
(PUNCT ",")
(LIT "stat")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "HAVE_UTIMENSAT")
(PUNCT ",")
(LIT "utime")
(PUNCT ")")
(NEWLINE)
(ID "_add")
(PUNCT "(")
(LIT "MS_WINDOWS")
(PUNCT ",")
(LIT "stat")
(PUNCT ")")
(NEWLINE)
(ID "supports_follow_symlinks")
(PUNCT "=")
(ID "_set")
(NEWLINE)
(KEYWORD del)
(ID "_set")
(NEWLINE)
(KEYWORD del)
(ID "_have_functions")
(NEWLINE)
(KEYWORD del)
(ID "_globals")
(NEWLINE)
(KEYWORD del)
(ID "_add")
(NEWLINE)
(DEDENT)
(ID "SEEK_SET")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "SEEK_CUR")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "SEEK_END")
(PUNCT "=")
(LIT 2)
(NEWLINE)
(KEYWORD def)
(ID "makedirs")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT 511)
(PUNCT ",")
(ID "exist_ok")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "makedirs(name [, mode=0o777][, exist_ok=False])\n\n    Super-mkdir; create a leaf directory and all intermediate ones.  Works like\n    mkdir, except that any intermediate path segment (not just the rightmost)\n    will be created if it does not exist. If the target directory already\n    exists, raise an OSError if exist_ok is False. Otherwise no exception is\n    raised.  This is recursive.\n\n    ")
(NEWLINE)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "head")
(KEYWORD and)
(ID "tail")
(KEYWORD and)
(KEYWORD not)
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "makedirs")
(PUNCT "(")
(ID "head")
(PUNCT ",")
(ID "mode")
(PUNCT ",")
(ID "exist_ok")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "FileExistsError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "cdir")
(PUNCT "=")
(ID "curdir")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "tail")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cdir")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(ID "curdir")
(PUNCT ",")
(LIT "ASCII")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "tail")
(PUNCT "==")
(ID "cdir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mkdir")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "exist_ok")
(KEYWORD or)
(ID "e")
(PUNCT ".")
(ID "errno")
(PUNCT "!=")
(ID "errno")
(PUNCT ".")
(ID "EEXIST")
(KEYWORD or)
(KEYWORD not)
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "removedirs")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "removedirs(name)\n\n    Super-rmdir; remove a leaf directory and all empty intermediate\n    ones.  Works like rmdir except that, if the leaf directory is\n    successfully removed, directories corresponding to rightmost path\n    segments will be pruned away until either the whole path is\n    consumed or an error occurs.  Errors during this latter phase are\n    ignored -- they generally mean that a directory was not empty.\n\n    ")
(NEWLINE)
(ID "rmdir")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "head")
(KEYWORD and)
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rmdir")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "renames")
(PUNCT "(")
(ID "old")
(PUNCT ",")
(ID "new")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "renames(old, new)\n\n    Super-rename; create directories as necessary and delete any left\n    empty.  Works like rename, except creation of any intermediate\n    directories needed to make the new pathname good is attempted\n    first.  After the rename, directories corresponding to rightmost\n    path segments of the old name will be pruned way until either the\n    whole path is consumed or a nonempty directory is found.\n\n    Note: this function can fail with the new directory structure made\n    if you lack permissions needed to unlink the leaf directory or\n    file.\n\n    ")
(NEWLINE)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "new")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "head")
(KEYWORD and)
(ID "tail")
(KEYWORD and)
(KEYWORD not)
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "makedirs")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rename")
(PUNCT "(")
(ID "old")
(PUNCT ",")
(ID "new")
(PUNCT ")")
(NEWLINE)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "old")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "head")
(KEYWORD and)
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "removedirs")
(PUNCT "(")
(ID "head")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "makedirs")
(PUNCT ",")
(LIT "removedirs")
(PUNCT ",")
(LIT "renames")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "walk")
(PUNCT "(")
(ID "top")
(PUNCT ",")
(ID "topdown")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "onerror")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "followlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Directory tree generator.\n\n    For each directory in the directory tree rooted at top (including top\n    itself, but excluding '.' and '..'), yields a 3-tuple\n\n        dirpath, dirnames, filenames\n\n    dirpath is a string, the path to the directory.  dirnames is a list of\n    the names of the subdirectories in dirpath (excluding '.' and '..').\n    filenames is a list of the names of the non-directory files in dirpath.\n    Note that the names in the lists are just names, with no path components.\n    To get a full path (which begins with top) to a file or directory in\n    dirpath, do os.path.join(dirpath, name).\n\n    If optional arg 'topdown' is true or not specified, the triple for a\n    directory is generated before the triples for any of its subdirectories\n    (directories are generated top down).  If topdown is false, the triple\n    for a directory is generated after the triples for all of its\n    subdirectories (directories are generated bottom up).\n\n    When topdown is true, the caller can modify the dirnames list in-place\n    (e.g., via del or slice assignment), and walk will only recurse into the\n    subdirectories whose names remain in dirnames; this can be used to prune the\n    search, or to impose a specific order of visiting.  Modifying dirnames when\n    topdown is false is ineffective, since the directories in dirnames have\n    already been generated by the time dirnames itself is generated. No matter\n    the value of topdown, the list of subdirectories is retrieved before the\n    tuples for the directory and its subdirectories are generated.\n\n    By default errors from the os.listdir() call are ignored.  If\n    optional arg 'onerror' is specified, it should be a function; it\n    will be called with one argument, an OSError instance.  It can\n    report the error to continue with the walk, or raise the exception\n    to abort the walk.  Note that the filename is available as the\n    filename attribute of the exception object.\n\n    By default, os.walk does not follow symbolic links to subdirectories on\n    systems that support them.  In order to get this functionality, set the\n    optional argument 'followlinks' to true.\n\n    Caution:  if you pass a relative pathname for top, don't change the\n    current working directory between resumptions of walk.  walk never\n    changes the current directory, and assumes that the client doesn't\n    either.\n\n    Example:\n\n    import os\n    from os.path import join, getsize\n    for root, dirs, files in os.walk('python/Lib/email'):\n        print(root, \"consumes\", end=\"\")\n        print(sum([getsize(join(root, name)) for name in files]), end=\"\")\n        print(\"bytes in\", len(files), \"non-directory files\")\n        if 'CVS' in dirs:\n            dirs.remove('CVS')  # don't visit CVS directories\n\n    ")
(NEWLINE)
(ID "islink")
(PUNCT ",")
(ID "join")
(PUNCT ",")
(ID "isdir")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT ",")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT ",")
(ID "path")
(PUNCT ".")
(ID "isdir")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(ID "listdir")
(PUNCT "(")
(ID "top")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "onerror")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "dirs")
(PUNCT ",")
(ID "nondirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isdir")
(PUNCT "(")
(ID "join")
(PUNCT "(")
(ID "top")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nondirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "topdown")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "top")
(PUNCT ",")
(ID "dirs")
(PUNCT ",")
(ID "nondirs")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "dirs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_path")
(PUNCT "=")
(ID "join")
(PUNCT "(")
(ID "top")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "followlinks")
(KEYWORD or)
(KEYWORD not)
(ID "islink")
(PUNCT "(")
(ID "new_path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "walk")
(PUNCT "(")
(ID "new_path")
(PUNCT ",")
(ID "topdown")
(PUNCT ",")
(ID "onerror")
(PUNCT ",")
(ID "followlinks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "topdown")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "top")
(PUNCT ",")
(ID "dirs")
(PUNCT ",")
(ID "nondirs")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "walk")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "{")
(ID "open")
(PUNCT ",")
(ID "stat")
(PUNCT "}")
(PUNCT "<=")
(ID "supports_dir_fd")
(KEYWORD and)
(PUNCT "{")
(ID "listdir")
(PUNCT ",")
(ID "stat")
(PUNCT "}")
(PUNCT "<=")
(ID "supports_fd")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "fwalk")
(PUNCT "(")
(ID "top")
(PUNCT "=")
(LIT ".")
(PUNCT ",")
(ID "topdown")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "onerror")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Directory tree generator.\n\n        This behaves exactly like walk(), except that it yields a 4-tuple\n\n            dirpath, dirnames, filenames, dirfd\n\n        `dirpath`, `dirnames` and `filenames` are identical to walk() output,\n        and `dirfd` is a file descriptor referring to the directory `dirpath`.\n\n        The advantage of fwalk() over walk() is that it's safe against symlink\n        races (when follow_symlinks is False).\n\n        If dir_fd is not None, it should be a file descriptor open to a directory,\n          and top should be relative; top will then be relative to that directory.\n          (dir_fd is always supported for fwalk.)\n\n        Caution:\n        Since fwalk() yields file descriptors, those are only valid until the\n        next iteration step, so you should dup() them if you want to keep them\n        for a longer period.\n\n        Example:\n\n        import os\n        for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):\n            print(root, \"consumes\", end=\"\")\n            print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),\n                  end=\"\")\n            print(\"bytes in\", len(files), \"non-directory files\")\n            if 'CVS' in dirs:\n                dirs.remove('CVS')  # don't visit CVS directories\n        ")
(NEWLINE)
(ID "orig_st")
(PUNCT "=")
(ID "stat")
(PUNCT "(")
(ID "top")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "dir_fd")
(PUNCT ")")
(NEWLINE)
(ID "topfd")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "top")
(PUNCT ",")
(ID "O_RDONLY")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "dir_fd")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "follow_symlinks")
(KEYWORD or)
(PUNCT "(")
(ID "st")
(PUNCT ".")
(ID "S_ISDIR")
(PUNCT "(")
(ID "orig_st")
(PUNCT ".")
(ID "st_mode")
(PUNCT ")")
(KEYWORD and)
(ID "path")
(PUNCT ".")
(ID "samestat")
(PUNCT "(")
(ID "orig_st")
(PUNCT ",")
(ID "stat")
(PUNCT "(")
(ID "topfd")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "_fwalk")
(PUNCT "(")
(ID "topfd")
(PUNCT ",")
(ID "top")
(PUNCT ",")
(ID "topdown")
(PUNCT ",")
(ID "onerror")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "close")
(PUNCT "(")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_fwalk")
(PUNCT "(")
(ID "topfd")
(PUNCT ",")
(ID "toppath")
(PUNCT ",")
(ID "topdown")
(PUNCT ",")
(ID "onerror")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(ID "listdir")
(PUNCT "(")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(ID "dirs")
(PUNCT ",")
(ID "nondirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "st")
(PUNCT ".")
(ID "S_ISDIR")
(PUNCT "(")
(ID "stat")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ")")
(PUNCT ".")
(ID "st_mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nondirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "FileNotFoundError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "st")
(PUNCT ".")
(ID "S_ISLNK")
(PUNCT "(")
(ID "stat")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ".")
(ID "st_mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nondirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "FileNotFoundError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "topdown")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "toppath")
(PUNCT ",")
(ID "dirs")
(PUNCT ",")
(ID "nondirs")
(PUNCT ",")
(ID "topfd")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "dirs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "orig_st")
(PUNCT "=")
(ID "stat")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(ID "dirfd")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "O_RDONLY")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "onerror")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "follow_symlinks")
(KEYWORD or)
(ID "path")
(PUNCT ".")
(ID "samestat")
(PUNCT "(")
(ID "orig_st")
(PUNCT ",")
(ID "stat")
(PUNCT "(")
(ID "dirfd")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirpath")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "toppath")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(KEYWORD from)
(ID "_fwalk")
(PUNCT "(")
(ID "dirfd")
(PUNCT ",")
(ID "dirpath")
(PUNCT ",")
(ID "topdown")
(PUNCT ",")
(ID "onerror")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "close")
(PUNCT "(")
(ID "dirfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "topdown")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "toppath")
(PUNCT ",")
(ID "dirs")
(PUNCT ",")
(ID "nondirs")
(PUNCT ",")
(ID "topfd")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "fwalk")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "environ")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NameError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "environ")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execl")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "execl(file, *args)\n\n    Execute the executable file with argument list args, replacing the\n    current process. ")
(NEWLINE)
(ID "execv")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execle")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "execle(file, *args, env)\n\n    Execute the executable file with argument list args and\n    environment env, replacing the current process. ")
(NEWLINE)
(ID "env")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "execve")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execlp")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "execlp(file, *args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process. ")
(NEWLINE)
(ID "execvp")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execlpe")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "execlpe(file, *args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env, replacing the current\n    process. ")
(NEWLINE)
(ID "env")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "execvpe")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execvp")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "execvp(file, args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process.\n    args may be a list or tuple of strings. ")
(NEWLINE)
(ID "_execvpe")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execvpe")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "execvpe(file, args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env , replacing the\n    current process.\n    args may be a list or tuple of strings. ")
(NEWLINE)
(ID "_execvpe")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "execl")
(PUNCT ",")
(LIT "execle")
(PUNCT ",")
(LIT "execlp")
(PUNCT ",")
(LIT "execlpe")
(PUNCT ",")
(LIT "execvp")
(PUNCT ",")
(LIT "execvpe")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_execvpe")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "env")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec_func")
(PUNCT "=")
(ID "execve")
(NEWLINE)
(ID "argrest")
(PUNCT "=")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec_func")
(PUNCT "=")
(ID "execv")
(NEWLINE)
(ID "argrest")
(PUNCT "=")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(ID "env")
(PUNCT "=")
(ID "environ")
(NEWLINE)
(DEDENT)
(ID "head")
(PUNCT ",")
(ID "tail")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "file")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "head")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec_func")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "argrest")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "last_exc")
(PUNCT "=")
(ID "saved_exc")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "saved_tb")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "path_list")
(PUNCT "=")
(ID "get_exec_path")
(PUNCT "(")
(ID "env")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "name")
(PUNCT "!=")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "fsencode")
(PUNCT "(")
(ID "file")
(PUNCT ")")
(NEWLINE)
(ID "path_list")
(PUNCT "=")
(ID "map")
(PUNCT "(")
(ID "fsencode")
(PUNCT ",")
(ID "path_list")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "dir")
(KEYWORD in)
(ID "path_list")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dir")
(PUNCT ",")
(ID "file")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec_func")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(PUNCT "*")
(ID "argrest")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last_exc")
(PUNCT "=")
(ID "e")
(NEWLINE)
(ID "tb")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "e")
(PUNCT ".")
(ID "errno")
(PUNCT "!=")
(ID "errno")
(PUNCT ".")
(ID "ENOENT")
(KEYWORD and)
(ID "e")
(PUNCT ".")
(ID "errno")
(PUNCT "!=")
(ID "errno")
(PUNCT ".")
(ID "ENOTDIR")
(KEYWORD and)
(ID "saved_exc")
(KEYWORD is)
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "saved_exc")
(PUNCT "=")
(ID "e")
(NEWLINE)
(ID "saved_tb")
(PUNCT "=")
(ID "tb")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "saved_exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "saved_exc")
(PUNCT ".")
(ID "with_traceback")
(PUNCT "(")
(ID "saved_tb")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "last_exc")
(PUNCT ".")
(ID "with_traceback")
(PUNCT "(")
(ID "tb")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_exec_path")
(PUNCT "(")
(ID "env")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the sequence of directories that will be searched for the\n    named executable (similar to a shell) when launching a process.\n\n    *env* must be an environment variable dict or None.  If *env* is None,\n    os.environ will be used.\n    ")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(KEYWORD if)
(ID "env")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "env")
(PUNCT "=")
(ID "environ")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "warnings")
(PUNCT ".")
(ID "catch_warnings")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "simplefilter")
(PUNCT "(")
(LIT "ignore")
(PUNCT ",")
(ID "BytesWarning")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path_list")
(PUNCT "=")
(ID "env")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "PATH")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path_list")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "supports_bytes_environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path_listb")
(PUNCT "=")
(ID "env")
(PUNCT "[")
(LIT #"PATH")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "KeyError")
(PUNCT ",")
(ID "TypeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "path_list")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "env cannot contain 'PATH' and b'PATH' keys")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "path_list")
(PUNCT "=")
(ID "path_listb")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "path_list")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "path_list")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path_list")
(PUNCT "=")
(ID "fsdecode")
(PUNCT "(")
(ID "path_list")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "path_list")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path_list")
(PUNCT "=")
(ID "defpath")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "path_list")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "pathsep")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD from)
(ID "_collections_abc")
(KEYWORD import)
(ID "MutableMapping")
(NEWLINE)
(KEYWORD class)
(ID "_Environ")
(PUNCT "(")
(ID "MutableMapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ",")
(ID "encodekey")
(PUNCT ",")
(ID "decodekey")
(PUNCT ",")
(ID "encodevalue")
(PUNCT ",")
(ID "decodevalue")
(PUNCT ",")
(ID "putenv")
(PUNCT ",")
(ID "unsetenv")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "encodekey")
(PUNCT "=")
(ID "encodekey")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "decodekey")
(PUNCT "=")
(ID "decodekey")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "encodevalue")
(PUNCT "=")
(ID "encodevalue")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "decodevalue")
(PUNCT "=")
(ID "decodevalue")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "putenv")
(PUNCT "=")
(ID "putenv")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "unsetenv")
(PUNCT "=")
(ID "unsetenv")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT "=")
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "encodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "decodevalue")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encodevalue")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "putenv")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encodedkey")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "unsetenv")
(PUNCT "(")
(ID "encodedkey")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT "[")
(ID "encodedkey")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "decodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "environ({{{}}})")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "(")
(LIT "{!r}: {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "decodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "decodevalue")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "dict")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setdefault")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_putenv")
(PUNCT "=")
(ID "putenv")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NameError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_putenv")
(PUNCT "=")
(KEYWORD lambda)
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ":")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "putenv")
(KEYWORD not)
(KEYWORD in)
(ID "__all__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "putenv")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_unsetenv")
(PUNCT "=")
(ID "unsetenv")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NameError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_unsetenv")
(PUNCT "=")
(KEYWORD lambda)
(ID "key")
(PUNCT ":")
(ID "_putenv")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "unsetenv")
(KEYWORD not)
(KEYWORD in)
(ID "__all__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "unsetenv")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_createenviron")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT "==")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "check_str")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "str expected, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(ID "encode")
(PUNCT "=")
(ID "check_str")
(NEWLINE)
(ID "decode")
(PUNCT "=")
(ID "str")
(NEWLINE)
(KEYWORD def)
(ID "encodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "encode")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ".")
(ID "upper")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "environ")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "[")
(ID "encodekey")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "getfilesystemencoding")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "encode")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "str expected, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "encodekey")
(PUNCT "=")
(ID "encode")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "environ")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_Environ")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(ID "encodekey")
(PUNCT ",")
(ID "decode")
(PUNCT ",")
(ID "encode")
(PUNCT ",")
(ID "decode")
(PUNCT ",")
(ID "_putenv")
(PUNCT ",")
(ID "_unsetenv")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "environ")
(PUNCT "=")
(ID "_createenviron")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "_createenviron")
(NEWLINE)
(KEYWORD def)
(ID "getenv")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get an environment variable, return None if it doesn't exist.\n    The optional second argument can specify an alternate default.\n    key, default and the result are str.")
(NEWLINE)
(KEYWORD return)
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "supports_bytes_environ")
(PUNCT "=")
(PUNCT "(")
(ID "name")
(PUNCT "!=")
(LIT "nt")
(PUNCT ")")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "(")
(LIT "getenv")
(PUNCT ",")
(LIT "supports_bytes_environ")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "supports_bytes_environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "_check_bytes")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "bytes expected, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(ID "environb")
(PUNCT "=")
(ID "_Environ")
(PUNCT "(")
(ID "environ")
(PUNCT ".")
(ID "_data")
(PUNCT ",")
(ID "_check_bytes")
(PUNCT ",")
(ID "bytes")
(PUNCT ",")
(ID "_check_bytes")
(PUNCT ",")
(ID "bytes")
(PUNCT ",")
(ID "_putenv")
(PUNCT ",")
(ID "_unsetenv")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "_check_bytes")
(NEWLINE)
(KEYWORD def)
(ID "getenvb")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get an environment variable, return None if it doesn't exist.\n        The optional second argument can specify an alternate default.\n        key, default and the result are bytes.")
(NEWLINE)
(KEYWORD return)
(ID "environb")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "(")
(LIT "environb")
(PUNCT ",")
(LIT "getenvb")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fscodec")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "getfilesystemencoding")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "encoding")
(PUNCT "==")
(LIT "mbcs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT "=")
(LIT "strict")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT "=")
(LIT "surrogateescape")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fsencode")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Encode filename to the filesystem encoding with 'surrogateescape' error\n        handler, return bytes unchanged. On Windows, use 'strict' error handler if\n        the file system encoding is 'mbcs' (which is the default encoding).\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "filename")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "filename")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "expect bytes or str, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "fsdecode")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Decode filename from the filesystem encoding with 'surrogateescape' error\n        handler, return str unchanged. On Windows, use 'strict' error handler if\n        the file system encoding is 'mbcs' (which is the default encoding).\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "filename")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "filename")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "expect bytes or str, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "fsencode")
(PUNCT ",")
(ID "fsdecode")
(NEWLINE)
(DEDENT)
(ID "fsencode")
(PUNCT ",")
(ID "fsdecode")
(PUNCT "=")
(ID "_fscodec")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "_fscodec")
(NEWLINE)
(KEYWORD if)
(ID "_exists")
(PUNCT "(")
(LIT "fork")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "_exists")
(PUNCT "(")
(LIT "spawnv")
(PUNCT ")")
(KEYWORD and)
(ID "_exists")
(PUNCT "(")
(LIT "execv")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "P_WAIT")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "P_NOWAIT")
(PUNCT "=")
(ID "P_NOWAITO")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "P_WAIT")
(PUNCT ",")
(LIT "P_NOWAIT")
(PUNCT ",")
(LIT "P_NOWAITO")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_spawnvef")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ",")
(ID "func")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pid")
(PUNCT "=")
(ID "fork")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "pid")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "env")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_exit")
(PUNCT "(")
(LIT 127)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "mode")
(PUNCT "==")
(ID "P_NOWAIT")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "pid")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wpid")
(PUNCT ",")
(ID "sts")
(PUNCT "=")
(ID "waitpid")
(PUNCT "(")
(ID "pid")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "WIFSTOPPED")
(PUNCT "(")
(ID "sts")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "WIFSIGNALED")
(PUNCT "(")
(ID "sts")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(ID "WTERMSIG")
(PUNCT "(")
(ID "sts")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "WIFEXITED")
(PUNCT "(")
(ID "sts")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "WEXITSTATUS")
(PUNCT "(")
(ID "sts")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "Not stopped, signaled or exited???")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "spawnv")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnv(mode, file, args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(KEYWORD return)
(ID "_spawnvef")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "execv")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "spawnve")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnve(mode, file, args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nspecified environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(KEYWORD return)
(ID "_spawnvef")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ",")
(ID "execve")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "spawnvp")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnvp(mode, file, args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(KEYWORD return)
(ID "_spawnvef")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "execvp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "spawnvpe")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnvpe(mode, file, args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(KEYWORD return)
(ID "_spawnvef")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "env")
(PUNCT ",")
(ID "execvpe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "spawnv")
(PUNCT ",")
(LIT "spawnve")
(PUNCT ",")
(LIT "spawnvp")
(PUNCT ",")
(LIT "spawnvpe")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_exists")
(PUNCT "(")
(LIT "spawnv")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "spawnl")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnl(mode, file, *args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(KEYWORD return)
(ID "spawnv")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "spawnle")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnle(mode, file, *args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nsupplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(ID "env")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "spawnve")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "spawnl")
(PUNCT ",")
(LIT "spawnle")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_exists")
(PUNCT "(")
(LIT "spawnvp")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "spawnlp")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnlp(mode, file, *args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(KEYWORD return)
(ID "spawnvp")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "spawnlpe")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "spawnlpe(mode, file, *args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ")
(NEWLINE)
(ID "env")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "spawnvpe")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "args")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "env")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "spawnlp")
(PUNCT ",")
(LIT "spawnlpe")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "popen")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT "r")
(PUNCT ",")
(ID "buffering")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid cmd type (%s, expected string)")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "cmd")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "mode")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "r")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid mode %r")
(PUNCT "%")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "buffering")
(PUNCT "==")
(LIT 0)
(KEYWORD or)
(ID "buffering")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "popen() does not support unbuffered streams")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "subprocess")
(PUNCT ",")
(ID "io")
(NEWLINE)
(KEYWORD if)
(ID "mode")
(PUNCT "==")
(LIT "r")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "proc")
(PUNCT "=")
(ID "subprocess")
(PUNCT ".")
(ID "Popen")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "shell")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "stdout")
(PUNCT "=")
(ID "subprocess")
(PUNCT ".")
(ID "PIPE")
(PUNCT ",")
(ID "bufsize")
(PUNCT "=")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_wrap_close")
(PUNCT "(")
(ID "io")
(PUNCT ".")
(ID "TextIOWrapper")
(PUNCT "(")
(ID "proc")
(PUNCT ".")
(ID "stdout")
(PUNCT ")")
(PUNCT ",")
(ID "proc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "proc")
(PUNCT "=")
(ID "subprocess")
(PUNCT ".")
(ID "Popen")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "shell")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "stdin")
(PUNCT "=")
(ID "subprocess")
(PUNCT ".")
(ID "PIPE")
(PUNCT ",")
(ID "bufsize")
(PUNCT "=")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_wrap_close")
(PUNCT "(")
(ID "io")
(PUNCT ".")
(ID "TextIOWrapper")
(PUNCT "(")
(ID "proc")
(PUNCT ".")
(ID "stdin")
(PUNCT ")")
(PUNCT ",")
(ID "proc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_wrap_close")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "stream")
(PUNCT ",")
(ID "proc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_stream")
(PUNCT "=")
(ID "stream")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_proc")
(PUNCT "=")
(ID "proc")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_stream")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "returncode")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_proc")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "returncode")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "name")
(PUNCT "==")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "returncode")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "returncode")
(PUNCT "<<")
(LIT 8)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_stream")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_stream")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "fdopen")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid fd type (%s, expected integer)")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "fd")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD return)
(ID "io")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
