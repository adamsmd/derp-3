(LIT "Support for tasks, coroutines and the scheduler.")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Task")
(PUNCT ",")
(LIT "FIRST_COMPLETED")
(PUNCT ",")
(LIT "FIRST_EXCEPTION")
(PUNCT ",")
(LIT "ALL_COMPLETED")
(PUNCT ",")
(LIT "wait")
(PUNCT ",")
(LIT "wait_for")
(PUNCT ",")
(LIT "as_completed")
(PUNCT ",")
(LIT "sleep")
(PUNCT ",")
(LIT "async")
(PUNCT ",")
(LIT "gather")
(PUNCT ",")
(LIT "shield")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(NEWLINE)
(KEYWORD import)
(ID "functools")
(NEWLINE)
(KEYWORD import)
(ID "inspect")
(NEWLINE)
(KEYWORD import)
(ID "linecache")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(KEYWORD import)
(ID "weakref")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "coroutines")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "events")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "futures")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "coroutines")
(KEYWORD import)
(ID "coroutine")
(NEWLINE)
(ID "_PY34")
(PUNCT "=")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "version_info")
(PUNCT ">=")
(PUNCT "(")
(LIT 3)
(PUNCT ",")
(LIT 4)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Task")
(PUNCT "(")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A coroutine wrapped in a Future.")
(NEWLINE)
(ID "_all_tasks")
(PUNCT "=")
(ID "weakref")
(PUNCT ".")
(ID "WeakSet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_current_tasks")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "_log_destroy_pending")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "current_task")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the currently running task in an event loop or None.\n\n        By default the current task for the current event loop is returned.\n\n        None is returned when called not in the context of a Task.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "_current_tasks")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "all_tasks")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a set of all tasks for an event loop.\n\n        By default all tasks for the current event loop are returned.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "{")
(ID "t")
(KEYWORD for)
(ID "t")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_all_tasks")
(KEYWORD if)
(ID "t")
(PUNCT ".")
(ID "_loop")
(KEYWORD is)
(ID "loop")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "coro")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "coroutines")
(PUNCT ".")
(ID "iscoroutine")
(PUNCT "(")
(ID "coro")
(PUNCT ")")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "coro")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_coro")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "coro")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "_all_tasks")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_PY34")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(ID "futures")
(PUNCT ".")
(ID "_PENDING")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_log_destroy_pending")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(PUNCT "{")
(LIT "task")
(PUNCT ":")
(ID "self")
(PUNCT ",")
(LIT "message")
(PUNCT ":")
(LIT "Task was destroyed but it is pending!")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "[")
(LIT "source_traceback")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_source_traceback")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_exception_handler")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ".")
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_repr_info")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT "=")
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "_repr_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(LIT "cancelling")
(NEWLINE)
(DEDENT)
(ID "coro")
(PUNCT "=")
(ID "coroutines")
(PUNCT ".")
(ID "_format_coroutine")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_coro")
(PUNCT ")")
(NEWLINE)
(ID "info")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT "coro=<%s>")
(PUNCT "%")
(ID "coro")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "info")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 2)
(PUNCT ",")
(LIT "wait_for=%r")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "info")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_stack")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "limit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the list of stack frames for this task's coroutine.\n\n        If the coroutine is not done, this returns the stack where it is\n        suspended.  If the coroutine has completed successfully or was\n        cancelled, this returns an empty list.  If the coroutine was\n        terminated by an exception, this returns the list of traceback\n        frames.\n\n        The frames are always ordered from oldest to newest.\n\n        The optional limit gives the maximum number of frames to\n        return; by default all available frames are returned.  Its\n        meaning differs depending on whether a stack or a traceback is\n        returned: the newest frames of a stack are returned, but the\n        oldest frames of a traceback are returned.  (This matches the\n        behavior of the traceback module.)\n\n        For reasons beyond our control, only one stack frame is\n        returned for a suspended coroutine.\n        ")
(NEWLINE)
(ID "frames")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_coro")
(PUNCT ".")
(ID "gi_frame")
(NEWLINE)
(KEYWORD if)
(ID "f")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "f")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "limit")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "limit")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "limit")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "frames")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "f_back")
(NEWLINE)
(DEDENT)
(ID "frames")
(PUNCT ".")
(ID "reverse")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_exception")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tb")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exception")
(PUNCT ".")
(ID "__traceback__")
(NEWLINE)
(KEYWORD while)
(ID "tb")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "limit")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "limit")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "limit")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "frames")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ")")
(NEWLINE)
(ID "tb")
(PUNCT "=")
(ID "tb")
(PUNCT ".")
(ID "tb_next")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "frames")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_stack")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "limit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Print the stack or traceback for this task's coroutine.\n\n        This produces output similar to that of the traceback module,\n        for the frames retrieved by get_stack().  The limit argument\n        is passed to get_stack().  The file argument is an I/O stream\n        to which the output is written; by default output is written\n        to sys.stderr.\n        ")
(NEWLINE)
(ID "extracted_list")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "checked")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "get_stack")
(PUNCT "(")
(ID "limit")
(PUNCT "=")
(ID "limit")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "f_lineno")
(NEWLINE)
(ID "co")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "f_code")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_filename")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_name")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(KEYWORD not)
(KEYWORD in)
(ID "checked")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "checked")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "linecache")
(PUNCT ".")
(ID "checkcache")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "linecache")
(PUNCT ".")
(ID "getline")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "f")
(PUNCT ".")
(ID "f_globals")
(PUNCT ")")
(NEWLINE)
(ID "extracted_list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exception")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "extracted_list")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "No stack for %r")
(PUNCT "%")
(ID "self")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "exc")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Traceback for %r (most recent call last):")
(PUNCT "%")
(ID "self")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Stack for %r (most recent call last):")
(PUNCT "%")
(ID "self")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "traceback")
(PUNCT ".")
(ID "print_list")
(PUNCT "(")
(ID "extracted_list")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "exc")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(ID "exc")
(PUNCT ".")
(ID "__class__")
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "cancel")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Request that this task cancel itself.\n\n        This arranges for a CancelledError to be thrown into the\n        wrapped coroutine on the next cycle through the event loop.\n        The coroutine then has a chance to clean up or even deny\n        the request using try/except/finally.\n\n        Unlike Future.cancel, this does not guarantee that the\n        task will be cancelled: the exception might be caught and\n        acted upon, delaying cancellation of the task or preventing\n        cancellation completely.  The task may also return a value or\n        raise a different exception.\n\n        Immediately after this method is called, Task.cancelled() will\n        not return True (unless the task was already cancelled).  A\n        task will be marked as cancelled when the wrapped coroutine\n        terminates with a CancelledError exception (even if cancel()\n        was not called).\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_step")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "exc")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(LIT "_step(): already done: {!r}, {!r}, {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "exc")
(PUNCT ",")
(ID "futures")
(PUNCT ".")
(ID "CancelledError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "CancelledError")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "coro")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_coro")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "_current_tasks")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "exc")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "coro")
(PUNCT ".")
(ID "throw")
(PUNCT "(")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "coro")
(PUNCT ".")
(ID "send")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "coro")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "exc")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "futures")
(PUNCT ".")
(ID "CancelledError")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_exception")
(PUNCT "(")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "BaseException")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_exception")
(PUNCT "(")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "result")
(PUNCT ",")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "result")
(PUNCT ".")
(ID "_blocking")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "_blocking")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "result")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_wakeup")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(PUNCT "=")
(ID "result")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_fut_waiter")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_must_cancel")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "RuntimeError")
(PUNCT "(")
(LIT "yield was used instead of yield from ")
(LIT "in task {!r} with {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "result")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "result")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "inspect")
(PUNCT ".")
(ID "isgenerator")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "RuntimeError")
(PUNCT "(")
(LIT "yield was used instead of yield from for ")
(LIT "generator in task {!r} with {}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "result")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "RuntimeError")
(PUNCT "(")
(LIT "Task got bad yield: {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "_current_tasks")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_wakeup")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "future")
(PUNCT ".")
(ID "result")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_step")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "FIRST_COMPLETED")
(PUNCT "=")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "FIRST_COMPLETED")
(NEWLINE)
(ID "FIRST_EXCEPTION")
(PUNCT "=")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "FIRST_EXCEPTION")
(NEWLINE)
(ID "ALL_COMPLETED")
(PUNCT "=")
(ID "concurrent")
(PUNCT ".")
(ID "futures")
(PUNCT ".")
(ID "ALL_COMPLETED")
(NEWLINE)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "wait")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "return_when")
(PUNCT "=")
(ID "ALL_COMPLETED")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait for the Futures and coroutines given by fs to complete.\n\n    The sequence futures must not be empty.\n\n    Coroutines will be wrapped in Tasks.\n\n    Returns two sets of Future: (done, pending).\n\n    Usage:\n\n        done, pending = yield from asyncio.wait(fs)\n\n    Note: This does not raise TimeoutError! Futures that aren't done\n    when the timeout occurs are returned in the second set.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(KEYWORD or)
(ID "coroutines")
(PUNCT ".")
(ID "iscoroutine")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "expect a list of futures, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "fs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Set of coroutines/Futures is empty.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "return_when")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(ID "FIRST_COMPLETED")
(PUNCT ",")
(ID "FIRST_EXCEPTION")
(PUNCT ",")
(ID "ALL_COMPLETED")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid return_when value: {}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "return_when")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fs")
(PUNCT "=")
(PUNCT "{")
(ID "async")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "set")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(KEYWORD yield)
(KEYWORD from)
(ID "_wait")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(ID "timeout")
(PUNCT ",")
(ID "return_when")
(PUNCT ",")
(ID "loop")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_release_waiter")
(PUNCT "(")
(ID "waiter")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "waiter")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waiter")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "wait_for")
(PUNCT "(")
(ID "fut")
(PUNCT ",")
(ID "timeout")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait for the single Future or coroutine to complete, with timeout.\n\n    Coroutine will be wrapped in Task.\n\n    Returns result of the Future or coroutine.  When a timeout occurs,\n    it cancels the task and raises TimeoutError.  To avoid the task\n    cancellation, wrap it in shield().\n\n    If the wait is cancelled, the task is also cancelled.\n\n    This function is a coroutine.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(KEYWORD yield)
(KEYWORD from)
(ID "fut")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "waiter")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "timeout_handle")
(PUNCT "=")
(ID "loop")
(PUNCT ".")
(ID "call_later")
(PUNCT "(")
(ID "timeout")
(PUNCT ",")
(ID "_release_waiter")
(PUNCT ",")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(ID "cb")
(PUNCT "=")
(ID "functools")
(PUNCT ".")
(ID "partial")
(PUNCT "(")
(ID "_release_waiter")
(PUNCT ",")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(ID "fut")
(PUNCT "=")
(ID "async")
(PUNCT "(")
(ID "fut")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "fut")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "cb")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "waiter")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "futures")
(PUNCT ".")
(ID "CancelledError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT ".")
(ID "remove_done_callback")
(PUNCT "(")
(ID "cb")
(PUNCT ")")
(NEWLINE)
(ID "fut")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "fut")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fut")
(PUNCT ".")
(ID "result")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT ".")
(ID "remove_done_callback")
(PUNCT "(")
(ID "cb")
(PUNCT ")")
(NEWLINE)
(ID "fut")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "futures")
(PUNCT ".")
(ID "TimeoutError")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout_handle")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "_wait")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(ID "timeout")
(PUNCT ",")
(ID "return_when")
(PUNCT ",")
(ID "loop")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal helper for wait() and _wait_for().\n\n    The fs argument must be a collection of Futures.\n    ")
(NEWLINE)
(KEYWORD assert)
(ID "fs")
(PUNCT ",")
(LIT "Set of Futures is empty.")
(NEWLINE)
(ID "waiter")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "timeout_handle")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout_handle")
(PUNCT "=")
(ID "loop")
(PUNCT ".")
(ID "call_later")
(PUNCT "(")
(ID "timeout")
(PUNCT ",")
(ID "_release_waiter")
(PUNCT ",")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "counter")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_on_completion")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD nonlocal)
(ID "counter")
(NEWLINE)
(ID "counter")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "counter")
(PUNCT "<=")
(LIT 0)
(KEYWORD or)
(ID "return_when")
(PUNCT "==")
(ID "FIRST_COMPLETED")
(KEYWORD or)
(ID "return_when")
(PUNCT "==")
(ID "FIRST_EXCEPTION")
(KEYWORD and)
(PUNCT "(")
(KEYWORD not)
(ID "f")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "f")
(PUNCT ".")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "timeout_handle")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout_handle")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "waiter")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waiter")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "fs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "_on_completion")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "waiter")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "timeout_handle")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout_handle")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "done")
(PUNCT ",")
(ID "pending")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "fs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "remove_done_callback")
(PUNCT "(")
(ID "_on_completion")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "f")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "done")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pending")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "done")
(PUNCT ",")
(ID "pending")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "as_completed")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an iterator whose values are coroutines.\n\n    When waiting for the yielded coroutines you'll get the results (or\n    exceptions!) of the original Futures (or coroutines), in the order\n    in which and as soon as they complete.\n\n    This differs from PEP 3148; the proper way to use this is:\n\n        for f in as_completed(fs):\n            result = yield from f  # The 'yield from' may raise.\n            # Use result.\n\n    If a timeout is specified, the 'yield from' will raise\n    TimeoutError when the timeout occurs before all Futures are done.\n\n    Note: The futures 'f' are not necessarily members of fs.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(KEYWORD or)
(ID "coroutines")
(PUNCT ".")
(ID "iscoroutine")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "expect a list of futures, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "loop")
(PUNCT "=")
(ID "loop")
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "todo")
(PUNCT "=")
(PUNCT "{")
(ID "async")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "set")
(PUNCT "(")
(ID "fs")
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "queues")
(KEYWORD import)
(ID "Queue")
(NEWLINE)
(ID "done")
(PUNCT "=")
(ID "Queue")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "timeout_handle")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "_on_timeout")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "todo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "remove_done_callback")
(PUNCT "(")
(ID "_on_completion")
(PUNCT ")")
(NEWLINE)
(ID "done")
(PUNCT ".")
(ID "put_nowait")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "todo")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_on_completion")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "todo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "todo")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "done")
(PUNCT ".")
(ID "put_nowait")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "todo")
(KEYWORD and)
(ID "timeout_handle")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout_handle")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "_wait_for_one")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(KEYWORD yield)
(KEYWORD from)
(ID "done")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "f")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "futures")
(PUNCT ".")
(ID "TimeoutError")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "f")
(PUNCT ".")
(ID "result")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "todo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "_on_completion")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "todo")
(KEYWORD and)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout_handle")
(PUNCT "=")
(ID "loop")
(PUNCT ".")
(ID "call_later")
(PUNCT "(")
(ID "timeout")
(PUNCT ",")
(ID "_on_timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "_")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "todo")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "_wait_for_one")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "sleep")
(PUNCT "(")
(ID "delay")
(PUNCT ",")
(ID "result")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Coroutine that completes after a given time (in seconds).")
(NEWLINE)
(ID "future")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT "=")
(ID "future")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_later")
(PUNCT "(")
(ID "delay")
(PUNCT ",")
(ID "future")
(PUNCT ".")
(ID "_set_result_unless_cancelled")
(PUNCT ",")
(ID "result")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(KEYWORD yield)
(KEYWORD from)
(ID "future")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "async")
(PUNCT "(")
(ID "coro_or_future")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wrap a coroutine in a future.\n\n    If the argument is a Future, it is returned directly.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "coro_or_future")
(PUNCT ",")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "loop")
(KEYWORD is)
(KEYWORD not)
(ID "coro_or_future")
(PUNCT ".")
(ID "_loop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "loop argument must agree with Future")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "coro_or_future")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "coroutines")
(PUNCT ".")
(ID "iscoroutine")
(PUNCT "(")
(ID "coro_or_future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "task")
(PUNCT "=")
(ID "loop")
(PUNCT ".")
(ID "create_task")
(PUNCT "(")
(ID "coro_or_future")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "task")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "task")
(PUNCT ".")
(ID "_source_traceback")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "task")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "A Future or coroutine is required")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_GatheringFuture")
(PUNCT "(")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper for gather().\n\n    This overrides cancel() to cancel all the children and act more\n    like Task.cancel(), which doesn't immediately mark itself as\n    cancelled.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "children")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT "=")
(ID "children")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "cancel")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "child")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "child")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "gather")
(PUNCT "(")
(PUNCT "*")
(ID "coros_or_futures")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "return_exceptions")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a future aggregating results from the given coroutines\n    or futures.\n\n    All futures must share the same event loop.  If all the tasks are\n    done successfully, the returned future's result is the list of\n    results (in the order of the original sequence, not necessarily\n    the order of results arrival).  If *return_exceptions* is True,\n    exceptions in the tasks are treated the same as successful\n    results, and gathered in the result list; otherwise, the first\n    raised exception will be immediately propagated to the returned\n    future.\n\n    Cancellation: if the outer Future is cancelled, all children (that\n    have not completed yet) are also cancelled.  If any child is\n    cancelled, this is treated as if it raised CancelledError --\n    the outer Future is *not* cancelled in this case.  (This is to\n    prevent the cancellation of one child to cause other children to\n    be cancelled.)\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "coros_or_futures")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "outer")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "outer")
(NEWLINE)
(DEDENT)
(ID "arg_to_fut")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "arg")
(KEYWORD in)
(ID "set")
(PUNCT "(")
(ID "coros_or_futures")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT "=")
(ID "async")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "fut")
(PUNCT ".")
(ID "_loop")
(NEWLINE)
(DEDENT)
(ID "fut")
(PUNCT ".")
(ID "_log_destroy_pending")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loop")
(PUNCT "=")
(ID "fut")
(PUNCT ".")
(ID "_loop")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "fut")
(PUNCT ".")
(ID "_loop")
(KEYWORD is)
(KEYWORD not)
(ID "loop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "futures are tied to different event loops")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "arg_to_fut")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT "=")
(ID "fut")
(NEWLINE)
(DEDENT)
(ID "children")
(PUNCT "=")
(PUNCT "[")
(ID "arg_to_fut")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(KEYWORD for)
(ID "arg")
(KEYWORD in)
(ID "coros_or_futures")
(PUNCT "]")
(NEWLINE)
(ID "nchildren")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "children")
(PUNCT ")")
(NEWLINE)
(ID "outer")
(PUNCT "=")
(ID "_GatheringFuture")
(PUNCT "(")
(ID "children")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "nfinished")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "results")
(PUNCT "=")
(PUNCT "[")
(KEYWORD None)
(PUNCT "]")
(PUNCT "*")
(ID "nchildren")
(NEWLINE)
(KEYWORD def)
(ID "_done_callback")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "fut")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD nonlocal)
(ID "nfinished")
(NEWLINE)
(KEYWORD if)
(ID "outer")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "fut")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT ".")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "fut")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "CancelledError")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "return_exceptions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT ".")
(ID "set_exception")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "fut")
(PUNCT ".")
(ID "_exception")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "fut")
(PUNCT ".")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "return_exceptions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT ".")
(ID "set_exception")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "fut")
(PUNCT ".")
(ID "_result")
(NEWLINE)
(DEDENT)
(ID "results")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "=")
(ID "res")
(NEWLINE)
(ID "nfinished")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "nfinished")
(PUNCT "==")
(ID "nchildren")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "results")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "fut")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fut")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "functools")
(PUNCT ".")
(ID "partial")
(PUNCT "(")
(ID "_done_callback")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "outer")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shield")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait for a future, shielding it from cancellation.\n\n    The statement\n\n        res = yield from shield(something())\n\n    is exactly equivalent to the statement\n\n        res = yield from something()\n\n    *except* that if the coroutine containing it is cancelled, the\n    task running in something() is not cancelled.  From the POV of\n    something(), the cancellation did not happen.  But its caller is\n    still cancelled, so the yield-from expression still raises\n    CancelledError.  Note: If something() is cancelled by other means\n    this will still cancel shield().\n\n    If you want to completely ignore cancellation (not recommended)\n    you can combine shield() with a try/except clause, as follows:\n\n        try:\n            res = yield from shield(something())\n        except CancelledError:\n            res = None\n    ")
(NEWLINE)
(ID "inner")
(PUNCT "=")
(ID "async")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "inner")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "inner")
(NEWLINE)
(DEDENT)
(ID "loop")
(PUNCT "=")
(ID "inner")
(PUNCT ".")
(ID "_loop")
(NEWLINE)
(ID "outer")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_done_callback")
(PUNCT "(")
(ID "inner")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "outer")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "inner")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "inner")
(PUNCT ".")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "inner")
(PUNCT ".")
(ID "cancelled")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT ".")
(ID "cancel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc")
(PUNCT "=")
(ID "inner")
(PUNCT ".")
(ID "exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "exc")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT ".")
(ID "set_exception")
(PUNCT "(")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outer")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "inner")
(PUNCT ".")
(ID "result")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "inner")
(PUNCT ".")
(ID "add_done_callback")
(PUNCT "(")
(ID "_done_callback")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "outer")
(NEWLINE)
(DEDENT)
(ENDMARKER)
