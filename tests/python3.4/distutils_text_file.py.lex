(LIT "text_file\n\nprovides the TextFile class, which gives an interface to text files\nthat (optionally) takes care of stripping comments, ignoring blank\nlines, and joining lines with backslashes.")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "os")
(PUNCT ",")
(ID "io")
(NEWLINE)
(KEYWORD class)
(ID "TextFile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Provides a file-like object that takes care of all the things you\n       commonly want to do when processing a text file that has some\n       line-by-line syntax: strip comments (as long as \"#\" is your\n       comment character), skip blank lines, join adjacent lines by\n       escaping the newline (ie. backslash at end of line), strip\n       leading and/or trailing whitespace.  All of these are optional\n       and independently controllable.\n\n       Provides a 'warn()' method so you can generate warning messages that\n       report physical line number, even if the logical line in question\n       spans multiple physical lines.  Also provides 'unreadline()' for\n       implementing line-at-a-time lookahead.\n\n       Constructor is called as:\n\n           TextFile (filename=None, file=None, **options)\n\n       It bombs (RuntimeError) if both 'filename' and 'file' are None;\n       'filename' should be a string, and 'file' a file object (or\n       something that provides 'readline()' and 'close()' methods).  It is\n       recommended that you supply at least 'filename', so that TextFile\n       can include it in warning messages.  If 'file' is not supplied,\n       TextFile creates its own using 'io.open()'.\n\n       The options are all boolean, and affect the value returned by\n       'readline()':\n         strip_comments [default: true]\n           strip from \"#\" to end-of-line, as well as any whitespace\n           leading up to the \"#\" -- unless it is escaped by a backslash\n         lstrip_ws [default: false]\n           strip leading whitespace from each line before returning it\n         rstrip_ws [default: true]\n           strip trailing whitespace (including line terminator!) from\n           each line before returning it\n         skip_blanks [default: true}\n           skip lines that are empty *after* stripping comments and\n           whitespace.  (If both lstrip_ws and rstrip_ws are false,\n           then some lines may consist of solely whitespace: these will\n           *not* be skipped, even if 'skip_blanks' is true.)\n         join_lines [default: false]\n           if a backslash is the last non-newline character on a line\n           after stripping comments and whitespace, join the following line\n           to it to form one \"logical line\"; if N consecutive lines end\n           with a backslash, then N+1 physical lines will be joined to\n           form one logical line.\n         collapse_join [default: false]\n           strip leading whitespace from lines that are joined to their\n           predecessor; only matters if (join_lines and not lstrip_ws)\n         errors [default: 'strict']\n           error handler used to decode the file content\n\n       Note that since 'rstrip_ws' can strip the trailing newline, the\n       semantics of 'readline()' must differ from those of the builtin file\n       object's 'readline()' method!  In particular, 'readline()' returns\n       None for end-of-file: an empty string might just be a blank line (or\n       an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is\n       not.")
(NEWLINE)
(ID "default_options")
(PUNCT "=")
(PUNCT "{")
(LIT "strip_comments")
(PUNCT ":")
(LIT 1)
(PUNCT ",")
(LIT "skip_blanks")
(PUNCT ":")
(LIT 1)
(PUNCT ",")
(LIT "lstrip_ws")
(PUNCT ":")
(LIT 0)
(PUNCT ",")
(LIT "rstrip_ws")
(PUNCT ":")
(LIT 1)
(PUNCT ",")
(LIT "join_lines")
(PUNCT ":")
(LIT 0)
(PUNCT ",")
(LIT "collapse_join")
(PUNCT ":")
(LIT 0)
(PUNCT ",")
(LIT "errors")
(PUNCT ":")
(LIT "strict")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "options")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Construct a new TextFile object.  At least one of 'filename'\n           (a string) and 'file' (a file-like object) must be supplied.\n           They keyword argument options are described above and affect\n           the values returned by 'readline()'.")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "file")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "you must supply either or both of 'filename' and 'file'")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "opt")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "default_options")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "opt")
(KEYWORD in)
(ID "options")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "opt")
(PUNCT ",")
(ID "options")
(PUNCT "[")
(ID "opt")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "opt")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "default_options")
(PUNCT "[")
(ID "opt")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "opt")
(KEYWORD in)
(ID "options")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "opt")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "default_options")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(LIT "invalid TextFile option '%s'")
(PUNCT "%")
(ID "opt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "file")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "file")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "linebuf")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Open a new file named 'filename'.  This overrides both the\n           'filename' and 'file' arguments to the constructor.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(LIT "r")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Close the current file and forget everything we know about it\n           (filename, current line number).")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "gen_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outmsg")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "line")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "current_line")
(NEWLINE)
(DEDENT)
(ID "outmsg")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "+")
(LIT ", ")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outmsg")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "lines %d-%d: ")
(PUNCT "%")
(ID "tuple")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outmsg")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "line %d: ")
(PUNCT "%")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "outmsg")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "outmsg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "error: ")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "gen_error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "warn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Print (to stderr) a warning message tied to the current logical\n           line in the current file.  If the current logical line in the\n           file spans multiple physical lines, the warning refers to the\n           whole range, eg. \"lines 3-5\".  If 'line' supplied, it overrides\n           the current line number; it may be a list or tuple to indicate a\n           range of physical lines, or an integer for a single physical\n           line.")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "warning: ")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "gen_error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT "+")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readline")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read and return a single logical line from the current file (or\n           from an internal buffer if lines have previously been \"unread\"\n           with 'unreadline()').  If the 'join_lines' option is true, this\n           may involve reading multiple physical lines concatenated into a\n           single string.  Updates the current line number, so calling\n           'warn()' after 'readline()' emits a warning about the physical\n           line(s) just read.  Returns None on end-of-file, since the empty\n           string can occur if 'rstrip_ws' is true but 'strip_blanks' is\n           not.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "linebuf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "linebuf")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "linebuf")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(ID "buildup_line")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT "==")
(LIT "")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "strip_comments")
(KEYWORD and)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "#")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "pos")
(PUNCT "==")
(LIT 0)
(KEYWORD or)
(ID "line")
(PUNCT "[")
(ID "pos")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "!=")
(LIT "\\")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "eol")
(PUNCT "=")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "\n")
(PUNCT ")")
(KEYWORD and)
(LIT "\n")
(KEYWORD or)
(LIT "")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(LIT 0)
(PUNCT ":")
(ID "pos")
(PUNCT "]")
(PUNCT "+")
(ID "eol")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\\#")
(PUNCT ",")
(LIT "#")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "join_lines")
(KEYWORD and)
(ID "buildup_line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "continuation line immediately precedes ")
(LIT "end-of-file")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "buildup_line")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "collapse_join")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "buildup_line")
(PUNCT "+")
(ID "line")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "=")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "current_line")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "lstrip_ws")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "rstrip_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "lstrip_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "rstrip_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(PUNCT "(")
(ID "line")
(PUNCT "==")
(LIT "")
(KEYWORD or)
(ID "line")
(PUNCT "==")
(LIT "\n")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "skip_blanks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "join_lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "\\")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buildup_line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "\\\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buildup_line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(LIT 0)
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(PUNCT "+")
(LIT "\n")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "readlines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read and return the list of all logical lines remaining in the\n           current file.")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "line")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lines")
(NEWLINE)
(DEDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "unreadline")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Push 'line' (a string) onto an internal buffer that will be\n           checked by future 'readline()' calls.  Handy for implementing\n           a parser with line-at-a-time lookahead.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "linebuf")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
