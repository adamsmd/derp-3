(LIT "Parser engine for the grammar tables generated by pgen.\n\nThe grammar table must be loaded first.\n\nSee Parser/parser.c in the Python distribution for additional info on\nhow this parsing engine works.\n\n")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "token")
(NEWLINE)
(KEYWORD class)
(ID "ParseError")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Exception to signal the parser is stuck.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Exception")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "%s: type=%r, value=%r, context=%r")
(PUNCT "%")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "=")
(ID "msg")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT "=")
(ID "type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "context")
(PUNCT "=")
(ID "context")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Parser")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parser engine.\n\n    The proper usage sequence is:\n\n    p = Parser(grammar, [converter])  # create instance\n    p.setup([start])                  # prepare for parsing\n    <for each input token>:\n        if p.addtoken(...):           # parse a token; may raise ParseError\n            break\n    root = p.rootnode                 # root of abstract syntax tree\n\n    A Parser instance may be reused by calling setup() repeatedly.\n\n    A Parser instance contains state pertaining to the current token\n    sequence, and should not be used concurrently by different threads\n    to parse separate token sequences.\n\n    See driver.py for how to get input tokens by tokenizing a file or\n    string.\n\n    Parsing is complete when addtoken() returns True; the root of the\n    abstract syntax tree can then be retrieved from the rootnode\n    instance variable.  When a syntax error occurs, addtoken() raises\n    the ParseError exception.  There is no error recovery; the parser\n    cannot be used after a syntax error was reported (but it can be\n    reinitialized by calling setup()).\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "grammar")
(PUNCT ",")
(ID "convert")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor.\n\n        The grammar argument is a grammar.Grammar instance; see the\n        grammar module for more information.\n\n        The parser is not ready yet for parsing; you must call the\n        setup() method to get it started.\n\n        The optional convert argument is a function mapping concrete\n        syntax tree nodes to abstract syntax tree nodes.  If not\n        given, no conversion is done and the syntax tree produced is\n        the concrete syntax tree.  If given, it must be a function of\n        two arguments, the first being the grammar (a grammar.Grammar\n        instance), and the second being the concrete syntax tree node\n        to be converted.  The syntax tree is converted from the bottom\n        up.\n\n        A concrete syntax tree node is a (type, value, context, nodes)\n        tuple, where type is the node type (a token or symbol number),\n        value is None for symbols and a string for tokens, context is\n        None or an opaque value used for error reporting (typically a\n        (lineno, offset) pair), and nodes is a list of children for\n        symbols, and None for tokens.\n\n        An abstract syntax tree node may be anything; this is entirely\n        up to the converter function.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT "=")
(ID "grammar")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "convert")
(PUNCT "=")
(ID "convert")
(KEYWORD or)
(PUNCT "(")
(KEYWORD lambda)
(ID "grammar")
(PUNCT ",")
(ID "node")
(PUNCT ":")
(ID "node")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setup")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "start")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Prepare for parsing.\n\n        This *must* be called before starting to parse.\n\n        The optional argument is an alternative start symbol; it\n        defaults to the grammar's start symbol.\n\n        You can use a Parser instance to parse any number of programs;\n        each time you call setup() the parser is reset to an initial\n        state determined by the (implicit or explicit) start symbol.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "start")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "start")
(NEWLINE)
(DEDENT)
(ID "newnode")
(PUNCT "=")
(PUNCT "(")
(ID "start")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "stackentry")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "dfas")
(PUNCT "[")
(ID "start")
(PUNCT "]")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "newnode")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "=")
(PUNCT "[")
(ID "stackentry")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rootnode")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "used_names")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "addtoken")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add a token; return True iff this is the end of the program.")
(NEWLINE)
(ID "ilabel")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "classify")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dfa")
(PUNCT ",")
(ID "state")
(PUNCT ",")
(ID "node")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "states")
(PUNCT ",")
(ID "first")
(PUNCT "=")
(ID "dfa")
(NEWLINE)
(ID "arcs")
(PUNCT "=")
(ID "states")
(PUNCT "[")
(ID "state")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "newstate")
(KEYWORD in)
(ID "arcs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "labels")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "ilabel")
(PUNCT "==")
(ID "i")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "t")
(PUNCT "<")
(LIT 256)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shift")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "newstate")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "state")
(PUNCT "=")
(ID "newstate")
(NEWLINE)
(KEYWORD while)
(ID "states")
(PUNCT "[")
(ID "state")
(PUNCT "]")
(PUNCT "==")
(PUNCT "[")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "state")
(PUNCT ")")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(ID "dfa")
(PUNCT ",")
(ID "state")
(PUNCT ",")
(ID "node")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "states")
(PUNCT ",")
(ID "first")
(PUNCT "=")
(ID "dfa")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "t")
(PUNCT ">=")
(LIT 256)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "itsdfa")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "dfas")
(PUNCT "[")
(ID "t")
(PUNCT "]")
(NEWLINE)
(ID "itsstates")
(PUNCT ",")
(ID "itsfirst")
(PUNCT "=")
(ID "itsdfa")
(NEWLINE)
(KEYWORD if)
(ID "ilabel")
(KEYWORD in)
(ID "itsfirst")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "push")
(PUNCT "(")
(ID "t")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "dfas")
(PUNCT "[")
(ID "t")
(PUNCT "]")
(PUNCT ",")
(ID "newstate")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "state")
(PUNCT ")")
(KEYWORD in)
(ID "arcs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ParseError")
(PUNCT "(")
(LIT "too much input")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ParseError")
(PUNCT "(")
(LIT "bad input")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "classify")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn a token into a label.  (Internal)")
(NEWLINE)
(KEYWORD if)
(ID "type")
(PUNCT "==")
(ID "token")
(PUNCT ".")
(ID "NAME")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "used_names")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "ilabel")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "keywords")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ilabel")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ilabel")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "ilabel")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ".")
(ID "tokens")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "type")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ilabel")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ParseError")
(PUNCT "(")
(LIT "bad token")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ilabel")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shift")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "newstate")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Shift a token.  (Internal)")
(NEWLINE)
(ID "dfa")
(PUNCT ",")
(ID "state")
(PUNCT ",")
(ID "node")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "newnode")
(PUNCT "=")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "newnode")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "convert")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ",")
(ID "newnode")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "newnode")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "node")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "newnode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "dfa")
(PUNCT ",")
(ID "newstate")
(PUNCT ",")
(ID "node")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "push")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "newdfa")
(PUNCT ",")
(ID "newstate")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Push a nonterminal.  (Internal)")
(NEWLINE)
(ID "dfa")
(PUNCT ",")
(ID "state")
(PUNCT ",")
(ID "node")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "newnode")
(PUNCT "=")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "dfa")
(PUNCT ",")
(ID "newstate")
(PUNCT ",")
(ID "node")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "newdfa")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "newnode")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Pop a nonterminal.  (Internal)")
(NEWLINE)
(ID "popdfa")
(PUNCT ",")
(ID "popstate")
(PUNCT ",")
(ID "popnode")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "newnode")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "convert")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ",")
(ID "popnode")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "newnode")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dfa")
(PUNCT ",")
(ID "state")
(PUNCT ",")
(ID "node")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "node")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "newnode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "rootnode")
(PUNCT "=")
(ID "newnode")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rootnode")
(PUNCT ".")
(ID "used_names")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "used_names")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
