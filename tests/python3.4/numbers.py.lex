(LIT "Abstract Base Classes (ABCs) for numbers, according to PEP 3141.\n\nTODO: Fill out more detailed documentation on the operators.")
(NEWLINE)
(KEYWORD from)
(ID "abc")
(KEYWORD import)
(ID "ABCMeta")
(PUNCT ",")
(ID "abstractmethod")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Number")
(PUNCT ",")
(LIT "Complex")
(PUNCT ",")
(LIT "Real")
(PUNCT ",")
(LIT "Rational")
(PUNCT ",")
(LIT "Integral")
(PUNCT "]")
(NEWLINE)
(KEYWORD class)
(ID "Number")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "All numbers inherit from this class.\n\n    If you just want to check if an argument x is a number, without\n    caring what kind, use isinstance(x, Number).\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "__hash__")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Complex")
(PUNCT "(")
(ID "Number")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Complex defines the operations that work on the builtin complex type.\n\n    In short, those are: a conversion to complex, .real, .imag, +, -,\n    *, /, abs(), .conjugate, ==, and !=.\n\n    If it is given heterogenous arguments, and doesn't have special\n    knowledge about them, it should fall back to the builtin complex\n    type as described below.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__complex__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a builtin complex instance. Called for complex(self).")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bool__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "True if self != 0. Called for bool(self).")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT "!=")
(LIT 0)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "real")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Retrieve the real component of this number.\n\n        This should subclass Real.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "imag")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Retrieve the imaginary component of this number.\n\n        This should subclass Real.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__add__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self + other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__radd__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other + self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__neg__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "-self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__pos__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__sub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self - other")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT "+")
(PUNCT "-")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rsub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other - self")
(NEWLINE)
(KEYWORD return)
(PUNCT "-")
(ID "self")
(PUNCT "+")
(ID "other")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__mul__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self * other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rmul__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other * self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__truediv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self / other: Should promote to float when necessary.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rtruediv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other / self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__pow__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exponent")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self**exponent; should promote to float or complex when necessary.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rpow__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "base")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "base ** self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__abs__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the Real distance from 0. Called for abs(self).")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "conjugate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "(x+y*i).conjugate() returns (x-y*i).")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self == other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Complex")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "complex")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Real")
(PUNCT "(")
(ID "Complex")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "To Complex, Real adds the operations that work on real numbers.\n\n    In short, those are: a conversion to float, trunc(), divmod,\n    %, <, <=, >, and >=.\n\n    Real also provides defaults for the derived operations.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__float__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Any Real can be converted to a native float object.\n\n        Called for float(self).")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__trunc__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "trunc(self): Truncates self to an Integral.\n\n        Returns an Integral i such that:\n          * i>0 iff self>0;\n          * abs(i) <= abs(self);\n          * for any Integral j satisfying the first two conditions,\n            abs(i) >= abs(j) [i.e. i has \"maximal\" abs among those].\n        i.e. \"truncate towards 0\".\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__floor__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Finds the greatest Integral <= self.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__ceil__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Finds the least Integral >= self.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__round__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ndigits")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds self to ndigits decimal places, defaulting to 0.\n\n        If ndigits is omitted or None, returns an Integral, otherwise\n        returns a Real. Rounds half toward even.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__divmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "divmod(self, other): The pair (self // other, self % other).\n\n        Sometimes this can be computed faster than the pair of\n        operations.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT "//")
(ID "other")
(PUNCT ",")
(ID "self")
(PUNCT "%")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rdivmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "divmod(other, self): The pair (self // other, self % other).\n\n        Sometimes this can be computed faster than the pair of\n        operations.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "other")
(PUNCT "//")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "%")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__floordiv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self // other: The floor() of self/other.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rfloordiv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other // self: The floor() of other/self.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__mod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self % other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other % self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self < other\n\n        < on Reals defines a total ordering, except perhaps for NaN.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__le__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self <= other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__complex__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "complex(self) == complex(float(self), 0)")
(NEWLINE)
(KEYWORD return)
(ID "complex")
(PUNCT "(")
(ID "float")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "real")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Real numbers are their real component.")
(NEWLINE)
(KEYWORD return)
(PUNCT "+")
(ID "self")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "imag")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Real numbers have no imaginary component.")
(NEWLINE)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "conjugate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Conjugate is a no-op for Reals.")
(NEWLINE)
(KEYWORD return)
(PUNCT "+")
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Real")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "float")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Rational")
(PUNCT "(")
(ID "Real")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT ".numerator and .denominator should be in lowest terms.")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "numerator")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "denominator")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__float__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "float(self) = self.numerator / self.denominator\n\n        It's important that this conversion use the integer's \"true\"\n        division rather than casting one side to float before dividing\n        so that ratios of huge integers convert without overflowing.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "numerator")
(PUNCT "/")
(ID "self")
(PUNCT ".")
(ID "denominator")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Integral")
(PUNCT "(")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Integral adds a conversion to int and the bit-string operations.")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__int__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "int(self)")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__index__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called whenever an index is needed, such as in slicing")
(NEWLINE)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__pow__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exponent")
(PUNCT ",")
(ID "modulus")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self ** exponent % modulus, but maybe faster.\n\n        Accept the modulus argument if you want to support the\n        3-argument version of pow(). Raise a TypeError if exponent < 0\n        or any argument isn't Integral. Otherwise, just implement the\n        2-argument version described in Complex.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__lshift__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self << other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rlshift__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other << self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rshift__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self >> other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rrshift__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other >> self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__and__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self & other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rand__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other & self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__xor__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self ^ other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__rxor__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other ^ self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__or__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self | other")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__ror__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "other | self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__invert__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "~self")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__float__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "float(self) == float(int(self))")
(NEWLINE)
(KEYWORD return)
(ID "float")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "numerator")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Integers are their own numerators.")
(NEWLINE)
(KEYWORD return)
(PUNCT "+")
(ID "self")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "denominator")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Integers have a denominator of 1.")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Integral")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "int")
(PUNCT ")")
(NEWLINE)
(ENDMARKER)
