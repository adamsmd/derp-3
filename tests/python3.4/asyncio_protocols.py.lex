(LIT "Abstract Protocol class.")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "BaseProtocol")
(PUNCT ",")
(LIT "Protocol")
(PUNCT ",")
(LIT "DatagramProtocol")
(PUNCT ",")
(LIT "SubprocessProtocol")
(PUNCT "]")
(NEWLINE)
(KEYWORD class)
(ID "BaseProtocol")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Common base class for protocol interfaces.\n\n    Usually user implements protocols that derived from BaseProtocol\n    like Protocol or ProcessProtocol.\n\n    The only case when BaseProtocol should be implemented directly is\n    write-only transport like write pipe\n    ")
(NEWLINE)
(KEYWORD def)
(ID "connection_made")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "transport")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when a connection is made.\n\n        The argument is the transport representing the pipe connection.\n        To receive data, wait for data_received() calls.\n        When the connection is closed, connection_lost() is called.\n        ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "connection_lost")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when the connection is lost or closed.\n\n        The argument is an exception object or None (the latter\n        meaning a regular EOF is received or the connection was\n        aborted or closed).\n        ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pause_writing")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when the transport's buffer goes over the high-water mark.\n\n        Pause and resume calls are paired -- pause_writing() is called\n        once when the buffer goes strictly over the high-water mark\n        (even if subsequent writes increases the buffer size even\n        more), and eventually resume_writing() is called once when the\n        buffer size reaches the low-water mark.\n\n        Note that if the buffer size equals the high-water mark,\n        pause_writing() is not called -- it must go strictly over.\n        Conversely, resume_writing() is called when the buffer size is\n        equal or lower than the low-water mark.  These end conditions\n        are important to ensure that things go as expected when either\n        mark is zero.\n\n        NOTE: This is the only Protocol callback that is not called\n        through EventLoop.call_soon() -- if it were, it would have no\n        effect when it's most needed (when the app keeps writing\n        without yielding until pause_writing() is called).\n        ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "resume_writing")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when the transport's buffer drains below the low-water mark.\n\n        See pause_writing() for details.\n        ")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Protocol")
(PUNCT "(")
(ID "BaseProtocol")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Interface for stream protocol.\n\n    The user should implement this interface.  They can inherit from\n    this class but don't need to.  The implementations here do\n    nothing (they don't raise exceptions).\n\n    When the user wants to requests a transport, they pass a protocol\n    factory to a utility function (e.g., EventLoop.create_connection()).\n\n    When the connection is made successfully, connection_made() is\n    called with a suitable transport object.  Then data_received()\n    will be called 0 or more times with data (bytes) received from the\n    transport; finally, connection_lost() will be called exactly once\n    with either an exception object or None as an argument.\n\n    State machine of calls:\n\n      start -> CM [-> DR*] [-> ER?] -> CL -> end\n\n    * CM: connection_made()\n    * DR: data_received()\n    * ER: eof_received()\n    * CL: connection_lost()\n    ")
(NEWLINE)
(KEYWORD def)
(ID "data_received")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when some data is received.\n\n        The argument is a bytes object.\n        ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "eof_received")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when the other end calls write_eof() or equivalent.\n\n        If this returns a false value (including None), the transport\n        will close itself.  If it returns a true value, closing the\n        transport is up to the protocol.\n        ")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DatagramProtocol")
(PUNCT "(")
(ID "BaseProtocol")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Interface for datagram protocol.")
(NEWLINE)
(KEYWORD def)
(ID "datagram_received")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ",")
(ID "addr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when some datagram is received.")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "error_received")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when a send or receive operation raises an OSError.\n\n        (Other than BlockingIOError or InterruptedError.)\n        ")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "SubprocessProtocol")
(PUNCT "(")
(ID "BaseProtocol")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Interface for protocol for subprocess calls.")
(NEWLINE)
(KEYWORD def)
(ID "pipe_data_received")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fd")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when the subprocess writes data into stdout/stderr pipe.\n\n        fd is int file descriptor.\n        data is bytes object.\n        ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pipe_connection_lost")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fd")
(PUNCT ",")
(ID "exc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when a file descriptor associated with the child process is\n        closed.\n\n        fd is the int file descriptor that was closed.\n        ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "process_exited")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when subprocess has exited.")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
