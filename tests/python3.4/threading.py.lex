(LIT "Thread module emulating a subset of Java's threading model.")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(KEYWORD as)
(ID "_sys")
(NEWLINE)
(KEYWORD import)
(ID "_thread")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "time")
(KEYWORD import)
(ID "monotonic")
(KEYWORD as)
(ID "_time")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "time")
(KEYWORD import)
(ID "time")
(KEYWORD as)
(ID "_time")
(NEWLINE)
(DEDENT)
(KEYWORD from)
(ID "traceback")
(KEYWORD import)
(ID "format_exc")
(KEYWORD as)
(ID "_format_exc")
(NEWLINE)
(KEYWORD from)
(ID "_weakrefset")
(KEYWORD import)
(ID "WeakSet")
(NEWLINE)
(KEYWORD from)
(ID "itertools")
(KEYWORD import)
(ID "islice")
(KEYWORD as)
(ID "_islice")
(PUNCT ",")
(ID "count")
(KEYWORD as)
(ID "_count")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_collections")
(KEYWORD import)
(ID "deque")
(KEYWORD as)
(ID "_deque")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "deque")
(KEYWORD as)
(ID "_deque")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "active_count")
(PUNCT ",")
(LIT "Condition")
(PUNCT ",")
(LIT "current_thread")
(PUNCT ",")
(LIT "enumerate")
(PUNCT ",")
(LIT "Event")
(PUNCT ",")
(LIT "Lock")
(PUNCT ",")
(LIT "RLock")
(PUNCT ",")
(LIT "Semaphore")
(PUNCT ",")
(LIT "BoundedSemaphore")
(PUNCT ",")
(LIT "Thread")
(PUNCT ",")
(LIT "Barrier")
(PUNCT ",")
(LIT "Timer")
(PUNCT ",")
(LIT "ThreadError")
(PUNCT ",")
(LIT "setprofile")
(PUNCT ",")
(LIT "settrace")
(PUNCT ",")
(LIT "local")
(PUNCT ",")
(LIT "stack_size")
(PUNCT "]")
(NEWLINE)
(ID "_start_new_thread")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "start_new_thread")
(NEWLINE)
(ID "_allocate_lock")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "allocate_lock")
(NEWLINE)
(ID "_set_sentinel")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "_set_sentinel")
(NEWLINE)
(ID "get_ident")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "get_ident")
(NEWLINE)
(ID "ThreadError")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "error")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_CRLock")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "RLock")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_CRLock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "TIMEOUT_MAX")
(PUNCT "=")
(ID "_thread")
(PUNCT ".")
(ID "TIMEOUT_MAX")
(NEWLINE)
(KEYWORD del)
(ID "_thread")
(NEWLINE)
(ID "_profile_hook")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_trace_hook")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "setprofile")
(PUNCT "(")
(ID "func")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_profile_hook")
(NEWLINE)
(ID "_profile_hook")
(PUNCT "=")
(ID "func")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "settrace")
(PUNCT "(")
(ID "func")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_trace_hook")
(NEWLINE)
(ID "_trace_hook")
(PUNCT "=")
(ID "func")
(NEWLINE)
(DEDENT)
(ID "Lock")
(PUNCT "=")
(ID "_allocate_lock")
(NEWLINE)
(KEYWORD def)
(ID "RLock")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "_CRLock")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_PyRLock")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_CRLock")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_RLock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_block")
(PUNCT "=")
(ID "_allocate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "owner")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_owner")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "owner")
(PUNCT "=")
(ID "_active")
(PUNCT "[")
(ID "owner")
(PUNCT "]")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "<%s owner=%r count=%d>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "owner")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "acquire")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "blocking")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        ")
(NEWLINE)
(ID "me")
(PUNCT "=")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "==")
(ID "me")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "rc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_block")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(ID "blocking")
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "rc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "=")
(ID "me")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "rc")
(NEWLINE)
(DEDENT)
(ID "__enter__")
(PUNCT "=")
(ID "acquire")
(NEWLINE)
(KEYWORD def)
(ID "release")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "!=")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot release un-acquired lock")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "=")
(ID "count")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "count")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_block")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_acquire_restore")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "state")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_block")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "=")
(ID "state")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_release_save")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot release un-acquired lock")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "count")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_count")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "owner")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_owner")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_block")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "count")
(PUNCT ",")
(ID "owner")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_is_owned")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_owner")
(PUNCT "==")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_PyRLock")
(PUNCT "=")
(ID "_RLock")
(NEWLINE)
(KEYWORD class)
(ID "Condition")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lock")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "lock")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lock")
(PUNCT "=")
(ID "RLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT "=")
(ID "lock")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "acquire")
(PUNCT "=")
(ID "lock")
(PUNCT ".")
(ID "acquire")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "=")
(ID "lock")
(PUNCT ".")
(ID "release")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_release_save")
(PUNCT "=")
(ID "lock")
(PUNCT ".")
(ID "_release_save")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_acquire_restore")
(PUNCT "=")
(ID "lock")
(PUNCT ".")
(ID "_acquire_restore")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_is_owned")
(PUNCT "=")
(ID "lock")
(PUNCT ".")
(ID "_is_owned")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_waiters")
(PUNCT "=")
(ID "_deque")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ".")
(ID "__enter__")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ".")
(ID "__exit__")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<Condition(%s, %d)>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_waiters")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_release_save")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_acquire_restore")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "x")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_is_owned")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_lock")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "wait")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_is_owned")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot wait on un-acquired lock")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "waiter")
(PUNCT "=")
(ID "_allocate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "waiter")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_waiters")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(ID "saved_state")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_release_save")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "gotit")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waiter")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "gotit")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "timeout")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "gotit")
(PUNCT "=")
(ID "waiter")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(KEYWORD True)
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "gotit")
(PUNCT "=")
(ID "waiter")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "gotit")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_acquire_restore")
(PUNCT "(")
(ID "saved_state")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "gotit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_waiters")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "wait_for")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "predicate")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        ")
(NEWLINE)
(ID "endtime")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "waittime")
(PUNCT "=")
(ID "timeout")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "predicate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "result")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "waittime")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "endtime")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endtime")
(PUNCT "=")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "waittime")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waittime")
(PUNCT "=")
(ID "endtime")
(PUNCT "-")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "waittime")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(ID "waittime")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "predicate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "notify")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_is_owned")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot notify on un-acquired lock")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "all_waiters")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_waiters")
(NEWLINE)
(ID "waiters_to_notify")
(PUNCT "=")
(ID "_deque")
(PUNCT "(")
(ID "_islice")
(PUNCT "(")
(ID "all_waiters")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "waiters_to_notify")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "waiter")
(KEYWORD in)
(ID "waiters_to_notify")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waiter")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "all_waiters")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "notify_all")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "notify")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_waiters")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "notifyAll")
(PUNCT "=")
(ID "notify_all")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Semaphore")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "semaphore initial value must be >= 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT "=")
(ID "Condition")
(PUNCT "(")
(ID "Lock")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "acquire")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "blocking")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "blocking")
(KEYWORD and)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "can't specify timeout for non-blocking acquire")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rc")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "endtime")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "_value")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "blocking")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "endtime")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endtime")
(PUNCT "=")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "timeout")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout")
(PUNCT "=")
(ID "endtime")
(PUNCT "-")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "timeout")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_value")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(ID "rc")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "rc")
(NEWLINE)
(DEDENT)
(ID "__enter__")
(PUNCT "=")
(ID "acquire")
(NEWLINE)
(KEYWORD def)
(ID "release")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        ")
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_value")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BoundedSemaphore")
(PUNCT "(")
(ID "Semaphore")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Semaphore")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_initial_value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "release")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Release a semaphore, incrementing the internal counter by one.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        ")
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_value")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "_initial_value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Semaphore released too many times")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_value")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Event")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT "=")
(ID "Condition")
(PUNCT "(")
(ID "Lock")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_flag")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_reset_internal_locks")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_set")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return true if and only if the internal flag is true.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_flag")
(NEWLINE)
(DEDENT)
(ID "isSet")
(PUNCT "=")
(ID "is_set")
(NEWLINE)
(KEYWORD def)
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flag")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify_all")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flag")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "wait")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "signaled")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_flag")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "signaled")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "signaled")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "signaled")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Barrier")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously once they have all\n    made that call.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parties")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is uses as the\n        default for all subsequent 'wait()' calls.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT "=")
(ID "Condition")
(PUNCT "(")
(ID "Lock")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_action")
(PUNCT "=")
(ID "action")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_timeout")
(PUNCT "=")
(ID "timeout")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_parties")
(PUNCT "=")
(ID "parties")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "wait")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_timeout")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_enter")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "index")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_count")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "index")
(PUNCT "+")
(LIT 1)
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "_parties")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_wait")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "index")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exit")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_enter")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "_state")
(KEYWORD in)
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "BrokenBarrierError")
(NEWLINE)
(DEDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_release")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_action")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_action")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify_all")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_break")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_wait")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "wait_for")
(PUNCT "(")
(KEYWORD lambda)
(PUNCT ":")
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "!=")
(LIT 0)
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_break")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "BrokenBarrierError")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "BrokenBarrierError")
(NEWLINE)
(DEDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_exit")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(KEYWORD in)
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify_all")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "reset")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        ")
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_count")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify_all")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "abort")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        ")
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_break")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_break")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "=")
(PUNCT "-")
(LIT 2)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cond")
(PUNCT ".")
(ID "notify_all")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "parties")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the number of threads required to trip the barrier.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parties")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "n_waiting")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the number of threads currently waiting at the barrier.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_count")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "broken")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the barrier is in a broken state.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_state")
(PUNCT "==")
(PUNCT "-")
(LIT 2)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BrokenBarrierError")
(PUNCT "(")
(ID "RuntimeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "_counter")
(PUNCT "=")
(ID "_count")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__next__")
(NEWLINE)
(ID "_counter")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_newname")
(PUNCT "(")
(ID "template")
(PUNCT "=")
(LIT "Thread-%d")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "template")
(PUNCT "%")
(ID "_counter")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_active_limbo_lock")
(PUNCT "=")
(ID "_allocate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_active")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "_limbo")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "_dangling")
(PUNCT "=")
(ID "WeakSet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Thread")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    ")
(NEWLINE)
(ID "_initialized")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "_exc_info")
(PUNCT "=")
(ID "_sys")
(PUNCT ".")
(ID "exc_info")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "group")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "target")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "kwargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "daemon")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is the argument tuple for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "group")
(KEYWORD is)
(KEYWORD None)
(PUNCT ",")
(LIT "group argument must be None for now")
(NEWLINE)
(KEYWORD if)
(ID "kwargs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwargs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_target")
(PUNCT "=")
(ID "target")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "name")
(KEYWORD or)
(ID "_newname")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_args")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_kwargs")
(PUNCT "=")
(ID "kwargs")
(NEWLINE)
(KEYWORD if)
(ID "daemon")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_daemonic")
(PUNCT "=")
(ID "daemon")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_daemonic")
(PUNCT "=")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "daemon")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_ident")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT "=")
(ID "Event")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_stderr")
(PUNCT "=")
(ID "_sys")
(PUNCT ".")
(ID "stderr")
(NEWLINE)
(ID "_dangling")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_reset_internal_locks")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "is_alive")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "_reset_internal_locks")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "is_alive")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_set_tstate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ",")
(LIT "Thread.__init__() was not called")
(NEWLINE)
(ID "status")
(PUNCT "=")
(LIT "initial")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "is_set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "status")
(PUNCT "=")
(LIT "started")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "is_alive")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "status")
(PUNCT "=")
(LIT "stopped")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_daemonic")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "status")
(PUNCT "+=")
(LIT " daemon")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_ident")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "status")
(PUNCT "+=")
(LIT " %s")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "_ident")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "<%s(%s, %s)>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "status")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "start")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "thread.__init__() not called")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "is_set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "threads can only be started once")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_limbo")
(PUNCT "[")
(ID "self")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_start_new_thread")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_bootstrap")
(PUNCT ",")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_limbo")
(PUNCT "[")
(ID "self")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_target")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_target")
(PUNCT "(")
(PUNCT "*")
(ID "self")
(PUNCT ".")
(ID "_args")
(PUNCT ",")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_target")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_args")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_kwargs")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_bootstrap")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_bootstrap_inner")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_daemonic")
(KEYWORD and)
(ID "_sys")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_set_ident")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_ident")
(PUNCT "=")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_set_tstate_lock")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set a lock object which will be released by the interpreter when\n        the underlying thread state (see pystate.h) gets deleted.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(PUNCT "=")
(ID "_set_sentinel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_bootstrap_inner")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_set_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_tstate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_active")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_ident")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD del)
(ID "_limbo")
(PUNCT "[")
(ID "self")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_trace_hook")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_sys")
(PUNCT ".")
(ID "settrace")
(PUNCT "(")
(ID "_trace_hook")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_profile_hook")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_sys")
(PUNCT ".")
(ID "setprofile")
(PUNCT "(")
(ID "_profile_hook")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "SystemExit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_sys")
(KEYWORD and)
(ID "_sys")
(PUNCT ".")
(ID "stderr")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Exception in thread %s:\n%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "_format_exc")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_stderr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_stderr")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_type")
(PUNCT ",")
(ID "exc_value")
(PUNCT ",")
(ID "exc_tb")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exc_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(PUNCT "(")
(LIT "Exception in thread ")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "+")
(LIT " (most likely raised during interpreter shutdown):")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_stderr")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT "(")
(LIT "Traceback (most recent call last):")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_stderr")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "exc_tb")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(PUNCT "(")
(LIT "  File \"%s\", line %s, in %s")
(PUNCT "%")
(PUNCT "(")
(ID "exc_tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_filename")
(PUNCT ",")
(ID "exc_tb")
(PUNCT ".")
(ID "tb_lineno")
(PUNCT ",")
(ID "exc_tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_name")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_stderr")
(PUNCT ")")
(NEWLINE)
(ID "exc_tb")
(PUNCT "=")
(ID "exc_tb")
(PUNCT ".")
(ID "tb_next")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(PUNCT "(")
(LIT "%s: %s")
(PUNCT "%")
(PUNCT "(")
(ID "exc_type")
(PUNCT ",")
(ID "exc_value")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_stderr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "exc_type")
(PUNCT ",")
(ID "exc_value")
(PUNCT ",")
(ID "exc_tb")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_active")
(PUNCT "[")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_stop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lock")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(NEWLINE)
(KEYWORD if)
(ID "lock")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "lock")
(PUNCT ".")
(ID "locked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_delete")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove current thread from the dict of currently running threads.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_active")
(PUNCT "[")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "dummy_threading")
(KEYWORD not)
(KEYWORD in)
(ID "_sys")
(PUNCT ".")
(ID "modules")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        isAlive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "Thread.__init__() not called")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "is_set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot join thread before it is started")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(KEYWORD is)
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot join current thread")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_wait_for_tstate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_wait_for_tstate_lock")
(PUNCT "(")
(ID "timeout")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "timeout")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_wait_for_tstate_lock")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "block")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lock")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_tstate_lock")
(NEWLINE)
(KEYWORD if)
(ID "lock")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "lock")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lock")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_stop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ",")
(LIT "Thread.__init__() not called")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_name")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "name")
(PUNCT ".")
(ID "setter")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ",")
(LIT "Thread.__init__() not called")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "ident")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the thread.get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ",")
(LIT "Thread.__init__() not called")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ident")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_alive")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. The module function enumerate()\n        returns a list of all alive threads.\n\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ",")
(LIT "Thread.__init__() not called")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(KEYWORD or)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "is_set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_wait_for_tstate_lock")
(PUNCT "(")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_is_stopped")
(NEWLINE)
(DEDENT)
(ID "isAlive")
(PUNCT "=")
(ID "is_alive")
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "daemon")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when no alive non-daemon threads are\n        left.\n\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ",")
(LIT "Thread.__init__() not called")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_daemonic")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "daemon")
(PUNCT ".")
(ID "setter")
(NEWLINE)
(KEYWORD def)
(ID "daemon")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "daemonic")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_initialized")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "Thread.__init__() not called")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "is_set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "cannot set daemon status of active thread")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_daemonic")
(PUNCT "=")
(ID "daemonic")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isDaemon")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "daemon")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setDaemon")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "daemonic")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "daemon")
(PUNCT "=")
(ID "daemonic")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getName")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setName")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Timer")
(PUNCT "(")
(ID "Thread")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "interval")
(PUNCT ",")
(ID "function")
(PUNCT ",")
(ID "args")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "kwargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Thread")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "interval")
(PUNCT "=")
(ID "interval")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "function")
(PUNCT "=")
(ID "function")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(ID "args")
(KEYWORD if)
(ID "args")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "kwargs")
(PUNCT "=")
(ID "kwargs")
(KEYWORD if)
(ID "kwargs")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "finished")
(PUNCT "=")
(ID "Event")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "cancel")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Stop the timer if it hasn't finished yet.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "finished")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "finished")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "interval")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "finished")
(PUNCT ".")
(ID "is_set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "function")
(PUNCT "(")
(PUNCT "*")
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "finished")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_MainThread")
(PUNCT "(")
(ID "Thread")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Thread")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(LIT "MainThread")
(PUNCT ",")
(ID "daemon")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_tstate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_active")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_ident")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_DummyThread")
(PUNCT "(")
(ID "Thread")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Thread")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(ID "_newname")
(PUNCT "(")
(LIT "Dummy-%d")
(PUNCT ")")
(PUNCT ",")
(ID "daemon")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_started")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_active")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_ident")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_stop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD False)
(PUNCT ",")
(LIT "cannot join a dummy thread")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_active")
(PUNCT "[")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_DummyThread")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "currentThread")
(PUNCT "=")
(ID "current_thread")
(NEWLINE)
(KEYWORD def)
(ID "active_count")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    ")
(NEWLINE)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "_active")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "_limbo")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "activeCount")
(PUNCT "=")
(ID "active_count")
(NEWLINE)
(KEYWORD def)
(ID "_enumerate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "_active")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(ID "list")
(PUNCT "(")
(ID "_limbo")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "enumerate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    ")
(NEWLINE)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "_active")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(ID "list")
(PUNCT "(")
(ID "_limbo")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD from)
(ID "_thread")
(KEYWORD import)
(ID "stack_size")
(NEWLINE)
(ID "_main_thread")
(PUNCT "=")
(ID "_MainThread")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_shutdown")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tlock")
(PUNCT "=")
(ID "_main_thread")
(PUNCT ".")
(ID "_tstate_lock")
(NEWLINE)
(KEYWORD assert)
(ID "tlock")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD assert)
(ID "tlock")
(PUNCT ".")
(ID "locked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "tlock")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_main_thread")
(PUNCT ".")
(ID "_stop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "t")
(PUNCT "=")
(ID "_pickSomeNonDaemonThread")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "t")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "t")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "t")
(PUNCT "=")
(ID "_pickSomeNonDaemonThread")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_main_thread")
(PUNCT ".")
(ID "_delete")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_pickSomeNonDaemonThread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "t")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "t")
(PUNCT ".")
(ID "daemon")
(KEYWORD and)
(ID "t")
(PUNCT ".")
(ID "is_alive")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "t")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "main_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "_main_thread")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_thread")
(KEYWORD import)
(ID "_local")
(KEYWORD as)
(ID "local")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_threading_local")
(KEYWORD import)
(ID "local")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_after_fork")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD global)
(ID "_active_limbo_lock")
(PUNCT ",")
(ID "_main_thread")
(NEWLINE)
(ID "_active_limbo_lock")
(PUNCT "=")
(ID "_allocate_lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "new_active")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "current")
(PUNCT "=")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_main_thread")
(PUNCT "=")
(ID "current")
(NEWLINE)
(KEYWORD with)
(ID "_active_limbo_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "threads")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "_enumerate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "threads")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "_dangling")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "thread")
(KEYWORD in)
(ID "threads")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "thread")
(KEYWORD is)
(ID "current")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "thread")
(PUNCT ".")
(ID "_reset_internal_locks")
(PUNCT "(")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "ident")
(PUNCT "=")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "thread")
(PUNCT ".")
(ID "_ident")
(PUNCT "=")
(ID "ident")
(NEWLINE)
(ID "new_active")
(PUNCT "[")
(ID "ident")
(PUNCT "]")
(PUNCT "=")
(ID "thread")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "thread")
(PUNCT ".")
(ID "_reset_internal_locks")
(PUNCT "(")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "thread")
(PUNCT ".")
(ID "_stop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_limbo")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_active")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_active")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "new_active")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "_active")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
