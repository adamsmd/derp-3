(LIT "Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!\n")
(NEWLINE)
(ID "__about__")
(PUNCT "=")
(LIT "Heap queues\n\n[explanation by FranÃ§ois Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\nan usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "heappush")
(PUNCT ",")
(LIT "heappop")
(PUNCT ",")
(LIT "heapify")
(PUNCT ",")
(LIT "heapreplace")
(PUNCT ",")
(LIT "merge")
(PUNCT ",")
(LIT "nlargest")
(PUNCT ",")
(LIT "nsmallest")
(PUNCT ",")
(LIT "heappushpop")
(PUNCT "]")
(NEWLINE)
(KEYWORD from)
(ID "itertools")
(KEYWORD import)
(ID "islice")
(PUNCT ",")
(ID "count")
(PUNCT ",")
(ID "tee")
(PUNCT ",")
(ID "chain")
(NEWLINE)
(KEYWORD def)
(ID "heappush")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Push item onto heap, maintaining the heap invariant.")
(NEWLINE)
(ID "heap")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(ID "_siftdown")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "heap")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "heappop")
(PUNCT "(")
(ID "heap")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Pop the smallest item off the heap, maintaining the heap invariant.")
(NEWLINE)
(ID "lastelt")
(PUNCT "=")
(ID "heap")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "heap")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "returnitem")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "lastelt")
(NEWLINE)
(ID "_siftup")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "returnitem")
(PUNCT "=")
(ID "lastelt")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "returnitem")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "heapreplace")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Pop and return the current smallest value, and add the new item.\n\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    ")
(NEWLINE)
(ID "returnitem")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "item")
(NEWLINE)
(ID "_siftup")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "returnitem")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "heappushpop")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Fast version of a heappush followed by a heappop.")
(NEWLINE)
(KEYWORD if)
(ID "heap")
(KEYWORD and)
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "<")
(ID "item")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "item")
(PUNCT ",")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "item")
(NEWLINE)
(ID "_siftup")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "item")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "heapify")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Transform list into a heap, in-place, in O(len(x)) time.")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "reversed")
(PUNCT "(")
(ID "range")
(PUNCT "(")
(ID "n")
(PUNCT "//")
(LIT 2)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_siftup")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_heappushpop_max")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Maxheap version of a heappush followed by a heappop.")
(NEWLINE)
(KEYWORD if)
(ID "heap")
(KEYWORD and)
(ID "item")
(PUNCT "<")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "item")
(PUNCT ",")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "item")
(NEWLINE)
(ID "_siftup_max")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "item")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_heapify_max")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Transform list into a maxheap, in-place, in O(len(x)) time.")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "reversed")
(PUNCT "(")
(ID "range")
(PUNCT "(")
(ID "n")
(PUNCT "//")
(LIT 2)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_siftup_max")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "nlargest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find the n largest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, reverse=True)[:n]\n    ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "it")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "islice")
(PUNCT "(")
(ID "it")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "result")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(ID "heapify")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(ID "_heappushpop")
(PUNCT "=")
(ID "heappushpop")
(NEWLINE)
(KEYWORD for)
(ID "elem")
(KEYWORD in)
(ID "it")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_heappushpop")
(PUNCT "(")
(ID "result")
(PUNCT ",")
(ID "elem")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(ID "reverse")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "nsmallest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find the n smallest elements in a dataset.\n\n    Equivalent to:  sorted(iterable)[:n]\n    ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "it")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "islice")
(PUNCT "(")
(ID "it")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "result")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(ID "_heapify_max")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(ID "_heappushpop")
(PUNCT "=")
(ID "_heappushpop_max")
(NEWLINE)
(KEYWORD for)
(ID "elem")
(KEYWORD in)
(ID "it")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_heappushpop")
(PUNCT "(")
(ID "result")
(PUNCT ",")
(ID "elem")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_siftdown")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "startpos")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newitem")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "pos")
(PUNCT ">")
(ID "startpos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parentpos")
(PUNCT "=")
(PUNCT "(")
(ID "pos")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ">>")
(LIT 1)
(NEWLINE)
(ID "parent")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "parentpos")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "newitem")
(PUNCT "<")
(ID "parent")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "parent")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "parentpos")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "newitem")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_siftup")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "heap")
(PUNCT ")")
(NEWLINE)
(ID "startpos")
(PUNCT "=")
(ID "pos")
(NEWLINE)
(ID "newitem")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(NEWLINE)
(ID "childpos")
(PUNCT "=")
(LIT 2)
(PUNCT "*")
(ID "pos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD while)
(ID "childpos")
(PUNCT "<")
(ID "endpos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rightpos")
(PUNCT "=")
(ID "childpos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "rightpos")
(PUNCT "<")
(ID "endpos")
(KEYWORD and)
(KEYWORD not)
(ID "heap")
(PUNCT "[")
(ID "childpos")
(PUNCT "]")
(PUNCT "<")
(ID "heap")
(PUNCT "[")
(ID "rightpos")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "childpos")
(PUNCT "=")
(ID "rightpos")
(NEWLINE)
(DEDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "childpos")
(PUNCT "]")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "childpos")
(NEWLINE)
(ID "childpos")
(PUNCT "=")
(LIT 2)
(PUNCT "*")
(ID "pos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "newitem")
(NEWLINE)
(ID "_siftdown")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "startpos")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_siftdown_max")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "startpos")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Maxheap variant of _siftdown")
(NEWLINE)
(ID "newitem")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "pos")
(PUNCT ">")
(ID "startpos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parentpos")
(PUNCT "=")
(PUNCT "(")
(ID "pos")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ">>")
(LIT 1)
(NEWLINE)
(ID "parent")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "parentpos")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "parent")
(PUNCT "<")
(ID "newitem")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "parent")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "parentpos")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "newitem")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_siftup_max")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Maxheap variant of _siftup")
(NEWLINE)
(ID "endpos")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "heap")
(PUNCT ")")
(NEWLINE)
(ID "startpos")
(PUNCT "=")
(ID "pos")
(NEWLINE)
(ID "newitem")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(NEWLINE)
(ID "childpos")
(PUNCT "=")
(LIT 2)
(PUNCT "*")
(ID "pos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD while)
(ID "childpos")
(PUNCT "<")
(ID "endpos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rightpos")
(PUNCT "=")
(ID "childpos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "rightpos")
(PUNCT "<")
(ID "endpos")
(KEYWORD and)
(KEYWORD not)
(ID "heap")
(PUNCT "[")
(ID "rightpos")
(PUNCT "]")
(PUNCT "<")
(ID "heap")
(PUNCT "[")
(ID "childpos")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "childpos")
(PUNCT "=")
(ID "rightpos")
(NEWLINE)
(DEDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "heap")
(PUNCT "[")
(ID "childpos")
(PUNCT "]")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "childpos")
(NEWLINE)
(ID "childpos")
(PUNCT "=")
(LIT 2)
(PUNCT "*")
(ID "pos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "heap")
(PUNCT "[")
(ID "pos")
(PUNCT "]")
(PUNCT "=")
(ID "newitem")
(NEWLINE)
(ID "_siftdown_max")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "startpos")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_heapq")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "merge")
(PUNCT "(")
(PUNCT "*")
(ID "iterables")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Merge multiple sorted inputs into a single sorted output.\n\n    Similar to sorted(itertools.chain(*iterables)) but returns a generator,\n    does not pull the data into memory all at once, and assumes that each of\n    the input streams is already sorted (smallest to largest).\n\n    >>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))\n    [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]\n\n    ")
(NEWLINE)
(ID "_heappop")
(PUNCT ",")
(ID "_heapreplace")
(PUNCT ",")
(ID "_StopIteration")
(PUNCT "=")
(ID "heappop")
(PUNCT ",")
(ID "heapreplace")
(PUNCT ",")
(ID "StopIteration")
(NEWLINE)
(ID "_len")
(PUNCT "=")
(ID "len")
(NEWLINE)
(ID "h")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "h_append")
(PUNCT "=")
(ID "h")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD for)
(ID "itnum")
(PUNCT ",")
(ID "it")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "iter")
(PUNCT ",")
(ID "iterables")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "next")
(PUNCT "=")
(ID "it")
(PUNCT ".")
(ID "__next__")
(NEWLINE)
(ID "h_append")
(PUNCT "(")
(PUNCT "[")
(ID "next")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "itnum")
(PUNCT ",")
(ID "next")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "_StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "heapify")
(PUNCT "(")
(ID "h")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "_len")
(PUNCT "(")
(ID "h")
(PUNCT ")")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT ",")
(ID "itnum")
(PUNCT ",")
(ID "next")
(PUNCT "=")
(ID "s")
(PUNCT "=")
(ID "h")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD yield)
(ID "v")
(NEWLINE)
(ID "s")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_heapreplace")
(PUNCT "(")
(ID "h")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "_StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_heappop")
(PUNCT "(")
(ID "h")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "h")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT ",")
(ID "itnum")
(PUNCT ",")
(ID "next")
(PUNCT "=")
(ID "h")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD yield)
(ID "v")
(NEWLINE)
(KEYWORD yield)
(KEYWORD from)
(ID "next")
(PUNCT ".")
(ID "__self__")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_nsmallest")
(PUNCT "=")
(ID "nsmallest")
(NEWLINE)
(KEYWORD def)
(ID "nsmallest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "iterable")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find the n smallest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key)[:n]\n    ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "it")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(ID "head")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "islice")
(PUNCT "(")
(ID "it")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "head")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "key")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "min")
(PUNCT "(")
(ID "chain")
(PUNCT "(")
(ID "head")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "[")
(ID "min")
(PUNCT "(")
(ID "chain")
(PUNCT "(")
(ID "head")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "n")
(PUNCT ">=")
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sorted")
(PUNCT "(")
(ID "iterable")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(ID "key")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "key")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "it")
(PUNCT "=")
(ID "zip")
(PUNCT "(")
(ID "iterable")
(PUNCT ",")
(ID "count")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "_nsmallest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "r")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD for)
(ID "r")
(KEYWORD in)
(ID "result")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "in1")
(PUNCT ",")
(ID "in2")
(PUNCT "=")
(ID "tee")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(ID "it")
(PUNCT "=")
(ID "zip")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "in1")
(PUNCT ")")
(PUNCT ",")
(ID "count")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "in2")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "_nsmallest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "r")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(KEYWORD for)
(ID "r")
(KEYWORD in)
(ID "result")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "_nlargest")
(PUNCT "=")
(ID "nlargest")
(NEWLINE)
(KEYWORD def)
(ID "nlargest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "iterable")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find the n largest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]\n    ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "it")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(ID "head")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "islice")
(PUNCT "(")
(ID "it")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "head")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "key")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "max")
(PUNCT "(")
(ID "chain")
(PUNCT "(")
(ID "head")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "[")
(ID "max")
(PUNCT "(")
(ID "chain")
(PUNCT "(")
(ID "head")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "n")
(PUNCT ">=")
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sorted")
(PUNCT "(")
(ID "iterable")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(ID "key")
(PUNCT ",")
(ID "reverse")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "key")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "it")
(PUNCT "=")
(ID "zip")
(PUNCT "(")
(ID "iterable")
(PUNCT ",")
(ID "count")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "_nlargest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "r")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD for)
(ID "r")
(KEYWORD in)
(ID "result")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "in1")
(PUNCT ",")
(ID "in2")
(PUNCT "=")
(ID "tee")
(PUNCT "(")
(ID "iterable")
(PUNCT ")")
(NEWLINE)
(ID "it")
(PUNCT "=")
(ID "zip")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "in1")
(PUNCT ")")
(PUNCT ",")
(ID "count")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "in2")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "_nlargest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "r")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(KEYWORD for)
(ID "r")
(KEYWORD in)
(ID "result")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "heap")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "data")
(PUNCT "=")
(PUNCT "[")
(LIT 1)
(PUNCT ",")
(LIT 3)
(PUNCT ",")
(LIT 5)
(PUNCT ",")
(LIT 7)
(PUNCT ",")
(LIT 9)
(PUNCT ",")
(LIT 2)
(PUNCT ",")
(LIT 4)
(PUNCT ",")
(LIT 6)
(PUNCT ",")
(LIT 8)
(PUNCT ",")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "heappush")
(PUNCT "(")
(ID "heap")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sort")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "heap")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sort")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "heappop")
(PUNCT "(")
(ID "heap")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(ID "sort")
(PUNCT ")")
(NEWLINE)
(KEYWORD import)
(ID "doctest")
(NEWLINE)
(ID "doctest")
(PUNCT ".")
(ID "testmod")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
