(LIT "Parse (absolute and relative) URLs.\n\nurlparse module is based upon the following RFC specifications.\n\nRFC 3986 (STD66): \"Uniform Resource Identifiers\" by T. Berners-Lee, R. Fielding\nand L.  Masinter, January 2005.\n\nRFC 2732 : \"Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter\nand L.Masinter, December 1999.\n\nRFC 2396:  \"Uniform Resource Identifiers (URI)\": Generic Syntax by T.\nBerners-Lee, R. Fielding, and L. Masinter, August 1998.\n\nRFC 2368: \"The mailto URL scheme\", by P.Hoffman , L Masinter, J. Zawinski, July 1998.\n\nRFC 1808: \"Relative Uniform Resource Locators\", by R. Fielding, UC Irvine, June\n1995.\n\nRFC 1738: \"Uniform Resource Locators (URL)\" by T. Berners-Lee, L. Masinter, M.\nMcCahill, December 1994\n\nRFC 3986 is considered the current standard and any future changes to\nurlparse module should conform with it.  The urlparse module is\ncurrently not entirely compliant with this RFC due to defacto\nscenarios for parsing, and for backward compatibility purposes, some\nparsing quirks from older RFCs are retained. The testcases in\ntest_urlparse.py provides a good indicator of parsing behavior.\n")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "collections")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "urlparse")
(PUNCT ",")
(LIT "urlunparse")
(PUNCT ",")
(LIT "urljoin")
(PUNCT ",")
(LIT "urldefrag")
(PUNCT ",")
(LIT "urlsplit")
(PUNCT ",")
(LIT "urlunsplit")
(PUNCT ",")
(LIT "urlencode")
(PUNCT ",")
(LIT "parse_qs")
(PUNCT ",")
(LIT "parse_qsl")
(PUNCT ",")
(LIT "quote")
(PUNCT ",")
(LIT "quote_plus")
(PUNCT ",")
(LIT "quote_from_bytes")
(PUNCT ",")
(LIT "unquote")
(PUNCT ",")
(LIT "unquote_plus")
(PUNCT ",")
(LIT "unquote_to_bytes")
(PUNCT "]")
(NEWLINE)
(ID "uses_relative")
(PUNCT "=")
(PUNCT "[")
(LIT "ftp")
(PUNCT ",")
(LIT "http")
(PUNCT ",")
(LIT "gopher")
(PUNCT ",")
(LIT "nntp")
(PUNCT ",")
(LIT "imap")
(PUNCT ",")
(LIT "wais")
(PUNCT ",")
(LIT "file")
(PUNCT ",")
(LIT "https")
(PUNCT ",")
(LIT "shttp")
(PUNCT ",")
(LIT "mms")
(PUNCT ",")
(LIT "prospero")
(PUNCT ",")
(LIT "rtsp")
(PUNCT ",")
(LIT "rtspu")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(LIT "sftp")
(PUNCT ",")
(LIT "svn")
(PUNCT ",")
(LIT "svn+ssh")
(PUNCT "]")
(NEWLINE)
(ID "uses_netloc")
(PUNCT "=")
(PUNCT "[")
(LIT "ftp")
(PUNCT ",")
(LIT "http")
(PUNCT ",")
(LIT "gopher")
(PUNCT ",")
(LIT "nntp")
(PUNCT ",")
(LIT "telnet")
(PUNCT ",")
(LIT "imap")
(PUNCT ",")
(LIT "wais")
(PUNCT ",")
(LIT "file")
(PUNCT ",")
(LIT "mms")
(PUNCT ",")
(LIT "https")
(PUNCT ",")
(LIT "shttp")
(PUNCT ",")
(LIT "snews")
(PUNCT ",")
(LIT "prospero")
(PUNCT ",")
(LIT "rtsp")
(PUNCT ",")
(LIT "rtspu")
(PUNCT ",")
(LIT "rsync")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(LIT "svn")
(PUNCT ",")
(LIT "svn+ssh")
(PUNCT ",")
(LIT "sftp")
(PUNCT ",")
(LIT "nfs")
(PUNCT ",")
(LIT "git")
(PUNCT ",")
(LIT "git+ssh")
(PUNCT "]")
(NEWLINE)
(ID "uses_params")
(PUNCT "=")
(PUNCT "[")
(LIT "ftp")
(PUNCT ",")
(LIT "hdl")
(PUNCT ",")
(LIT "prospero")
(PUNCT ",")
(LIT "http")
(PUNCT ",")
(LIT "imap")
(PUNCT ",")
(LIT "https")
(PUNCT ",")
(LIT "shttp")
(PUNCT ",")
(LIT "rtsp")
(PUNCT ",")
(LIT "rtspu")
(PUNCT ",")
(LIT "sip")
(PUNCT ",")
(LIT "sips")
(PUNCT ",")
(LIT "mms")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(LIT "sftp")
(PUNCT ",")
(LIT "tel")
(PUNCT "]")
(NEWLINE)
(ID "non_hierarchical")
(PUNCT "=")
(PUNCT "[")
(LIT "gopher")
(PUNCT ",")
(LIT "hdl")
(PUNCT ",")
(LIT "mailto")
(PUNCT ",")
(LIT "news")
(PUNCT ",")
(LIT "telnet")
(PUNCT ",")
(LIT "wais")
(PUNCT ",")
(LIT "imap")
(PUNCT ",")
(LIT "snews")
(PUNCT ",")
(LIT "sip")
(PUNCT ",")
(LIT "sips")
(PUNCT "]")
(NEWLINE)
(ID "uses_query")
(PUNCT "=")
(PUNCT "[")
(LIT "http")
(PUNCT ",")
(LIT "wais")
(PUNCT ",")
(LIT "imap")
(PUNCT ",")
(LIT "https")
(PUNCT ",")
(LIT "shttp")
(PUNCT ",")
(LIT "mms")
(PUNCT ",")
(LIT "gopher")
(PUNCT ",")
(LIT "rtsp")
(PUNCT ",")
(LIT "rtspu")
(PUNCT ",")
(LIT "sip")
(PUNCT ",")
(LIT "sips")
(PUNCT ",")
(LIT "")
(PUNCT "]")
(NEWLINE)
(ID "uses_fragment")
(PUNCT "=")
(PUNCT "[")
(LIT "ftp")
(PUNCT ",")
(LIT "hdl")
(PUNCT ",")
(LIT "http")
(PUNCT ",")
(LIT "gopher")
(PUNCT ",")
(LIT "news")
(PUNCT ",")
(LIT "nntp")
(PUNCT ",")
(LIT "wais")
(PUNCT ",")
(LIT "https")
(PUNCT ",")
(LIT "shttp")
(PUNCT ",")
(LIT "snews")
(PUNCT ",")
(LIT "file")
(PUNCT ",")
(LIT "prospero")
(PUNCT ",")
(LIT "")
(PUNCT "]")
(NEWLINE)
(ID "scheme_chars")
(PUNCT "=")
(PUNCT "(")
(LIT "abcdefghijklmnopqrstuvwxyz")
(LIT "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(LIT "0123456789")
(LIT "+-.")
(PUNCT ")")
(NEWLINE)
(ID "MAX_CACHE_SIZE")
(PUNCT "=")
(LIT 20)
(NEWLINE)
(ID "_parse_cache")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "clear_cache")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Clear the parse cache and the quoters cache.")
(NEWLINE)
(ID "_parse_cache")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_safe_quoters")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_implicit_encoding")
(PUNCT "=")
(LIT "ascii")
(NEWLINE)
(ID "_implicit_errors")
(PUNCT "=")
(LIT "strict")
(NEWLINE)
(KEYWORD def)
(ID "_noop")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "obj")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_encode_result")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "_implicit_encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "_implicit_errors")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "obj")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_decode_args")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "_implicit_encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "_implicit_errors")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "tuple")
(PUNCT "(")
(ID "x")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(KEYWORD if)
(ID "x")
(KEYWORD else)
(LIT "")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_coerce_args")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "str_input")
(PUNCT "=")
(ID "isinstance")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "arg")
(KEYWORD in)
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "arg")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT "!=")
(ID "str_input")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Cannot mix str and non-str arguments")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "str_input")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "args")
(PUNCT "+")
(PUNCT "(")
(ID "_noop")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_decode_args")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "_encode_result")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_ResultMixinStr")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Standard approach to encoding parsed results from str to bytes")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "encode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "ascii")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "strict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_encoded_counterpart")
(PUNCT "(")
(PUNCT "*")
(PUNCT "(")
(ID "x")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_ResultMixinBytes")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Standard approach to decoding parsed results from bytes to str")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "ascii")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "strict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_decoded_counterpart")
(PUNCT "(")
(PUNCT "*")
(PUNCT "(")
(ID "x")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_NetlocResultMixinBase")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Shared methods for the parsed result objects containing a netloc element")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "username")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_userinfo")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "password")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_userinfo")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "hostname")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_hostinfo")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hostname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "hostname")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT "=")
(ID "hostname")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "hostname")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "port")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_hostinfo")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "port")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "port")
(PUNCT ",")
(LIT 10)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(LIT 0)
(PUNCT "<=")
(ID "port")
(PUNCT "<=")
(LIT 65535)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "port")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_NetlocResultMixinStr")
(PUNCT "(")
(ID "_NetlocResultMixinBase")
(PUNCT ",")
(ID "_ResultMixinStr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "_userinfo")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netloc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "netloc")
(NEWLINE)
(ID "userinfo")
(PUNCT ",")
(ID "have_info")
(PUNCT ",")
(ID "hostinfo")
(PUNCT "=")
(ID "netloc")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT "@")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "have_info")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "username")
(PUNCT ",")
(ID "have_password")
(PUNCT ",")
(ID "password")
(PUNCT "=")
(ID "userinfo")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "have_password")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "password")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "username")
(PUNCT "=")
(ID "password")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "username")
(PUNCT ",")
(ID "password")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "_hostinfo")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netloc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "netloc")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "hostinfo")
(PUNCT "=")
(ID "netloc")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT "@")
(PUNCT ")")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "have_open_br")
(PUNCT ",")
(ID "bracketed")
(PUNCT "=")
(ID "hostinfo")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT "[")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "have_open_br")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "bracketed")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT "]")
(PUNCT ")")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "port")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "hostinfo")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "port")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "hostname")
(PUNCT ",")
(ID "port")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_NetlocResultMixinBytes")
(PUNCT "(")
(ID "_NetlocResultMixinBase")
(PUNCT ",")
(ID "_ResultMixinBytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "_userinfo")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netloc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "netloc")
(NEWLINE)
(ID "userinfo")
(PUNCT ",")
(ID "have_info")
(PUNCT ",")
(ID "hostinfo")
(PUNCT "=")
(ID "netloc")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT #"@")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "have_info")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "username")
(PUNCT ",")
(ID "have_password")
(PUNCT ",")
(ID "password")
(PUNCT "=")
(ID "userinfo")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT #":")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "have_password")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "password")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "username")
(PUNCT "=")
(ID "password")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "username")
(PUNCT ",")
(ID "password")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "_hostinfo")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netloc")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "netloc")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "hostinfo")
(PUNCT "=")
(ID "netloc")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT #"@")
(PUNCT ")")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "have_open_br")
(PUNCT ",")
(ID "bracketed")
(PUNCT "=")
(ID "hostinfo")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT #"[")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "have_open_br")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "bracketed")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT #"]")
(PUNCT ")")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "port")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT #":")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "hostinfo")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT #":")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "port")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "hostname")
(PUNCT ",")
(ID "port")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "namedtuple")
(NEWLINE)
(ID "_DefragResultBase")
(PUNCT "=")
(ID "namedtuple")
(PUNCT "(")
(LIT "DefragResult")
(PUNCT ",")
(LIT "url fragment")
(PUNCT ")")
(NEWLINE)
(ID "_SplitResultBase")
(PUNCT "=")
(ID "namedtuple")
(PUNCT "(")
(LIT "SplitResult")
(PUNCT ",")
(LIT "scheme netloc path query fragment")
(PUNCT ")")
(NEWLINE)
(ID "_ParseResultBase")
(PUNCT "=")
(ID "namedtuple")
(PUNCT "(")
(LIT "ParseResult")
(PUNCT ",")
(LIT "scheme netloc path params query fragment")
(PUNCT ")")
(NEWLINE)
(ID "ResultBase")
(PUNCT "=")
(ID "_NetlocResultMixinStr")
(NEWLINE)
(KEYWORD class)
(ID "DefragResult")
(PUNCT "(")
(ID "_DefragResultBase")
(PUNCT ",")
(ID "_ResultMixinStr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "geturl")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "fragment")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "url")
(PUNCT "+")
(LIT "#")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "fragment")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "url")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "SplitResult")
(PUNCT "(")
(ID "_SplitResultBase")
(PUNCT ",")
(ID "_NetlocResultMixinStr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "geturl")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "urlunsplit")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ParseResult")
(PUNCT "(")
(ID "_ParseResultBase")
(PUNCT ",")
(ID "_NetlocResultMixinStr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "geturl")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "urlunparse")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DefragResultBytes")
(PUNCT "(")
(ID "_DefragResultBase")
(PUNCT ",")
(ID "_ResultMixinBytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "geturl")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "fragment")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "url")
(PUNCT "+")
(LIT #"#")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "fragment")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "url")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "SplitResultBytes")
(PUNCT "(")
(ID "_SplitResultBase")
(PUNCT ",")
(ID "_NetlocResultMixinBytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "geturl")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "urlunsplit")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ParseResultBytes")
(PUNCT "(")
(ID "_ParseResultBase")
(PUNCT ",")
(ID "_NetlocResultMixinBytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "geturl")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "urlunparse")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_fix_result_transcoding")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_result_pairs")
(PUNCT "=")
(PUNCT "(")
(PUNCT "(")
(ID "DefragResult")
(PUNCT ",")
(ID "DefragResultBytes")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "SplitResult")
(PUNCT ",")
(ID "SplitResultBytes")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "ParseResult")
(PUNCT ",")
(ID "ParseResultBytes")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "_decoded")
(PUNCT ",")
(ID "_encoded")
(KEYWORD in)
(ID "_result_pairs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_decoded")
(PUNCT ".")
(ID "_encoded_counterpart")
(PUNCT "=")
(ID "_encoded")
(NEWLINE)
(ID "_encoded")
(PUNCT ".")
(ID "_decoded_counterpart")
(PUNCT "=")
(ID "_decoded")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_fix_result_transcoding")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "_fix_result_transcoding")
(NEWLINE)
(KEYWORD def)
(ID "urlparse")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a URL into 6 components:\n    <scheme>://<netloc>/<path>;<params>?<query>#<fragment>\n    Return a 6-tuple: (scheme, netloc, path, params, query, fragment).\n    Note that we don't break the components up in smaller bits\n    (e.g. netloc is a single string) and we don't expand % escapes.")
(NEWLINE)
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(ID "_coerce_args")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT ")")
(NEWLINE)
(ID "splitresult")
(PUNCT "=")
(ID "urlsplit")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT ")")
(NEWLINE)
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT "=")
(ID "splitresult")
(NEWLINE)
(KEYWORD if)
(ID "scheme")
(KEYWORD in)
(ID "uses_params")
(KEYWORD and)
(LIT ";")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT ",")
(ID "params")
(PUNCT "=")
(ID "_splitparams")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "params")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "ParseResult")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_splitparams")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "/")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";")
(PUNCT ",")
(ID "url")
(PUNCT ".")
(ID "rfind")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "url")
(PUNCT ",")
(LIT "")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "url")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_splitnetloc")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "start")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "delim")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(LIT "/?#")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wdelim")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "start")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "wdelim")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "delim")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "delim")
(PUNCT ",")
(ID "wdelim")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "url")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(ID "delim")
(PUNCT "]")
(PUNCT ",")
(ID "url")
(PUNCT "[")
(ID "delim")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urlsplit")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a URL into 5 components:\n    <scheme>://<netloc>/<path>?<query>#<fragment>\n    Return a 5-tuple: (scheme, netloc, path, query, fragment).\n    Note that we don't break the components up in smaller bits\n    (e.g. netloc is a single string) and we don't expand % escapes.")
(NEWLINE)
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(ID "_coerce_args")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT ")")
(NEWLINE)
(ID "allow_fragments")
(PUNCT "=")
(ID "bool")
(PUNCT "(")
(ID "allow_fragments")
(PUNCT ")")
(NEWLINE)
(ID "key")
(PUNCT "=")
(ID "url")
(PUNCT ",")
(ID "scheme")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "scheme")
(PUNCT ")")
(NEWLINE)
(ID "cached")
(PUNCT "=")
(ID "_parse_cache")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "cached")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "cached")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "_parse_cache")
(PUNCT ")")
(PUNCT ">=")
(ID "MAX_CACHE_SIZE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "clear_cache")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "netloc")
(PUNCT "=")
(ID "query")
(PUNCT "=")
(ID "fragment")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT "==")
(LIT "http")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "scheme")
(PUNCT "=")
(ID "url")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(LIT "//")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT "=")
(ID "_splitnetloc")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(LIT "[")
(KEYWORD in)
(ID "netloc")
(KEYWORD and)
(LIT "]")
(KEYWORD not)
(KEYWORD in)
(ID "netloc")
(PUNCT ")")
(KEYWORD or)
(PUNCT "(")
(LIT "]")
(KEYWORD in)
(ID "netloc")
(KEYWORD and)
(LIT "[")
(KEYWORD not)
(KEYWORD in)
(ID "netloc")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid IPv6 URL")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "allow_fragments")
(KEYWORD and)
(LIT "#")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT ",")
(ID "fragment")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "#")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "?")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "?")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "v")
(PUNCT "=")
(ID "SplitResult")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(NEWLINE)
(ID "_parse_cache")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "v")
(NEWLINE)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(KEYWORD not)
(KEYWORD in)
(ID "scheme_chars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rest")
(PUNCT "=")
(ID "url")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "rest")
(KEYWORD or)
(ID "any")
(PUNCT "(")
(ID "c")
(KEYWORD not)
(KEYWORD in)
(LIT "0123456789")
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "rest")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "scheme")
(PUNCT ",")
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "rest")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(LIT "//")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT "=")
(ID "_splitnetloc")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(LIT "[")
(KEYWORD in)
(ID "netloc")
(KEYWORD and)
(LIT "]")
(KEYWORD not)
(KEYWORD in)
(ID "netloc")
(PUNCT ")")
(KEYWORD or)
(PUNCT "(")
(LIT "]")
(KEYWORD in)
(ID "netloc")
(KEYWORD and)
(LIT "[")
(KEYWORD not)
(KEYWORD in)
(ID "netloc")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid IPv6 URL")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "allow_fragments")
(KEYWORD and)
(LIT "#")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT ",")
(ID "fragment")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "#")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "?")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "?")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "v")
(PUNCT "=")
(ID "SplitResult")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(NEWLINE)
(ID "_parse_cache")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "v")
(NEWLINE)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urlunparse")
(PUNCT "(")
(ID "components")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Put a parsed URL back together again.  This may result in a\n    slightly different, but equivalent URL, if the URL that was parsed\n    originally had redundant delimiters, e.g. a ? with an empty query\n    (the draft states that these are equivalent).")
(NEWLINE)
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(PUNCT "(")
(ID "_coerce_args")
(PUNCT "(")
(PUNCT "*")
(ID "components")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "params")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT "=")
(LIT "%s;%s")
(PUNCT "%")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "params")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "urlunsplit")
(PUNCT "(")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urlunsplit")
(PUNCT "(")
(ID "components")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Combine the elements of a tuple as returned by urlsplit() into a\n    complete URL as a string. The data argument can be any five-item iterable.\n    This may result in a slightly different, but equivalent URL, if the URL that\n    was parsed originally had unnecessary delimiters (for example, a ? with an\n    empty query; the RFC states that these are equivalent).")
(NEWLINE)
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(PUNCT "(")
(ID "_coerce_args")
(PUNCT "(")
(PUNCT "*")
(ID "components")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "netloc")
(KEYWORD or)
(PUNCT "(")
(ID "scheme")
(KEYWORD and)
(ID "scheme")
(KEYWORD in)
(ID "uses_netloc")
(KEYWORD and)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT "!=")
(LIT "//")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "url")
(KEYWORD and)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "!=")
(LIT "/")
(PUNCT ":")
(ID "url")
(PUNCT "=")
(LIT "/")
(PUNCT "+")
(ID "url")
(NEWLINE)
(ID "url")
(PUNCT "=")
(LIT "//")
(PUNCT "+")
(PUNCT "(")
(ID "netloc")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT "+")
(ID "url")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "scheme")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT "=")
(ID "scheme")
(PUNCT "+")
(LIT ":")
(PUNCT "+")
(ID "url")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "query")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT "+")
(LIT "?")
(PUNCT "+")
(ID "query")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "fragment")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT "+")
(LIT "#")
(PUNCT "+")
(ID "fragment")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urljoin")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Join a base URL and a possibly relative URL to form an absolute\n    interpretation of the latter.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "base")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "url")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "base")
(NEWLINE)
(DEDENT)
(ID "base")
(PUNCT ",")
(ID "url")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(ID "_coerce_args")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "url")
(PUNCT ")")
(NEWLINE)
(ID "bscheme")
(PUNCT ",")
(ID "bnetloc")
(PUNCT ",")
(ID "bpath")
(PUNCT ",")
(ID "bparams")
(PUNCT ",")
(ID "bquery")
(PUNCT ",")
(ID "bfragment")
(PUNCT "=")
(ID "urlparse")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT ")")
(NEWLINE)
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT "=")
(ID "urlparse")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "bscheme")
(PUNCT ",")
(ID "allow_fragments")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "scheme")
(PUNCT "!=")
(ID "bscheme")
(KEYWORD or)
(ID "scheme")
(KEYWORD not)
(KEYWORD in)
(ID "uses_relative")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "scheme")
(KEYWORD in)
(ID "uses_netloc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "netloc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "urlunparse")
(PUNCT "(")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "netloc")
(PUNCT "=")
(ID "bnetloc")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "path")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "urlunparse")
(PUNCT "(")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "path")
(KEYWORD and)
(KEYWORD not)
(ID "params")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(ID "bpath")
(NEWLINE)
(ID "params")
(PUNCT "=")
(ID "bparams")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "query")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "query")
(PUNCT "=")
(ID "bquery")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "urlunparse")
(PUNCT "(")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "segments")
(PUNCT "=")
(ID "bpath")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "+")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "segments")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT ".")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "segments")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(LIT ".")
(KEYWORD in)
(ID "segments")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "segments")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "segments")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "segments")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "==")
(LIT "..")
(KEYWORD and)
(ID "segments")
(PUNCT "[")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "")
(PUNCT ",")
(LIT "..")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "segments")
(PUNCT "[")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "segments")
(PUNCT "==")
(PUNCT "[")
(LIT "")
(PUNCT ",")
(LIT "..")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "segments")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "segments")
(PUNCT ")")
(PUNCT ">=")
(LIT 2)
(KEYWORD and)
(ID "segments")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "..")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "segments")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "urlunparse")
(PUNCT "(")
(PUNCT "(")
(ID "scheme")
(PUNCT ",")
(ID "netloc")
(PUNCT ",")
(LIT "/")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "segments")
(PUNCT ")")
(PUNCT ",")
(ID "params")
(PUNCT ",")
(ID "query")
(PUNCT ",")
(ID "fragment")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urldefrag")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Removes any existing fragment from URL.\n\n    Returns a tuple of the defragmented URL and the fragment.  If\n    the URL contained no fragments, the second element is the\n    empty string.\n    ")
(NEWLINE)
(ID "url")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(ID "_coerce_args")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "#")
(KEYWORD in)
(ID "url")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT ",")
(ID "n")
(PUNCT ",")
(ID "p")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "q")
(PUNCT ",")
(ID "frag")
(PUNCT "=")
(ID "urlparse")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(ID "defrag")
(PUNCT "=")
(ID "urlunparse")
(PUNCT "(")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "n")
(PUNCT ",")
(ID "p")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "q")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "frag")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "defrag")
(PUNCT "=")
(ID "url")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_coerce_result")
(PUNCT "(")
(ID "DefragResult")
(PUNCT "(")
(ID "defrag")
(PUNCT ",")
(ID "frag")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_hexdig")
(PUNCT "=")
(LIT "0123456789ABCDEFabcdef")
(NEWLINE)
(ID "_hextobyte")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "unquote_to_bytes")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "unquote_to_bytes('abc%20def') -> b'abc def'.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "string")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT ".")
(ID "split")
(NEWLINE)
(KEYWORD return)
(LIT #"")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "utf-8")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bits")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT #"%")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "bits")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "string")
(NEWLINE)
(DEDENT)
(ID "res")
(PUNCT "=")
(PUNCT "[")
(ID "bits")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "append")
(PUNCT "=")
(ID "res")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD global)
(ID "_hextobyte")
(NEWLINE)
(KEYWORD if)
(ID "_hextobyte")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_hextobyte")
(PUNCT "=")
(PUNCT "{")
(PUNCT "(")
(ID "a")
(PUNCT "+")
(ID "b")
(PUNCT ")")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(ID "int")
(PUNCT "(")
(ID "a")
(PUNCT "+")
(ID "b")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "a")
(KEYWORD in)
(ID "_hexdig")
(KEYWORD for)
(ID "b")
(KEYWORD in)
(ID "_hexdig")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "bits")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(ID "_hextobyte")
(PUNCT "[")
(ID "item")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "append")
(PUNCT "(")
(ID "item")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(LIT #"%")
(PUNCT ")")
(NEWLINE)
(ID "append")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_asciire")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "([\u0000-\u007F]+)")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "unquote")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "replace")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Replace %xx escapes by their single-character equivalent. The optional\n    encoding and errors parameters specify how to decode percent-encoded\n    sequences into Unicode characters, as accepted by the bytes.decode()\n    method.\n    By default, percent-encoded sequences are decoded with UTF-8, and invalid\n    sequences are replaced by a placeholder character.\n\n    unquote('abc%20def') -> 'abc def'.\n    ")
(NEWLINE)
(KEYWORD if)
(LIT "%")
(KEYWORD not)
(KEYWORD in)
(ID "string")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT ".")
(ID "split")
(NEWLINE)
(KEYWORD return)
(ID "string")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "errors")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT "=")
(LIT "replace")
(NEWLINE)
(DEDENT)
(ID "bits")
(PUNCT "=")
(ID "_asciire")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(NEWLINE)
(ID "res")
(PUNCT "=")
(PUNCT "[")
(ID "bits")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "append")
(PUNCT "=")
(ID "res")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "bits")
(PUNCT ")")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(ID "unquote_to_bytes")
(PUNCT "(")
(ID "bits")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "append")
(PUNCT "(")
(ID "bits")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_qs")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "strict_parsing")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "replace")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a query given as a string argument.\n\n        Arguments:\n\n        qs: percent-encoded query string to be parsed\n\n        keep_blank_values: flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as\n            blank strings.  The default false value indicates that\n            blank values are to be ignored and treated as if they were\n            not included.\n\n        strict_parsing: flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored.\n            If true, errors raise a ValueError exception.\n\n        encoding and errors: specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n    ")
(NEWLINE)
(ID "parsed_result")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "pairs")
(PUNCT "=")
(ID "parse_qsl")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "pairs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "parsed_result")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parsed_result")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parsed_result")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(ID "value")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "parsed_result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_qsl")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "strict_parsing")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "replace")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a query given as a string argument.\n\n    Arguments:\n\n    qs: percent-encoded query string to be parsed\n\n    keep_blank_values: flag indicating whether blank values in\n        percent-encoded queries should be treated as blank strings.  A\n        true value indicates that blanks should be retained as blank\n        strings.  The default false value indicates that blank values\n        are to be ignored and treated as if they were  not included.\n\n    strict_parsing: flag indicating what to do with parsing errors. If\n        false (the default), errors are silently ignored. If true,\n        errors raise a ValueError exception.\n\n    encoding and errors: specify how to decode percent-encoded sequences\n        into Unicode characters, as accepted by the bytes.decode() method.\n\n    Returns a list, as G-d intended.\n    ")
(NEWLINE)
(ID "qs")
(PUNCT ",")
(ID "_coerce_result")
(PUNCT "=")
(ID "_coerce_args")
(PUNCT "(")
(ID "qs")
(PUNCT ")")
(NEWLINE)
(ID "pairs")
(PUNCT "=")
(PUNCT "[")
(ID "s2")
(KEYWORD for)
(ID "s1")
(KEYWORD in)
(ID "qs")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "&")
(PUNCT ")")
(KEYWORD for)
(ID "s2")
(KEYWORD in)
(ID "s1")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ";")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "r")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name_value")
(KEYWORD in)
(ID "pairs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "name_value")
(KEYWORD and)
(KEYWORD not)
(ID "strict_parsing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "nv")
(PUNCT "=")
(ID "name_value")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "=")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nv")
(PUNCT ")")
(PUNCT "!=")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "strict_parsing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "bad query field: %r")
(PUNCT "%")
(PUNCT "(")
(ID "name_value")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "keep_blank_values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nv")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(KEYWORD or)
(ID "keep_blank_values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "nv")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "unquote")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "_coerce_result")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "nv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "unquote")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "_coerce_result")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unquote_plus")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "replace")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Like unquote(), but also replace plus signs by spaces, as required for\n    unquoting HTML form values.\n\n    unquote_plus('%7e/abc+def') -> '~/abc def'\n    ")
(NEWLINE)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "unquote")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_ALWAYS_SAFE")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(LIT #"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(LIT #"abcdefghijklmnopqrstuvwxyz")
(LIT #"0123456789")
(LIT #"_.-")
(PUNCT ")")
(NEWLINE)
(ID "_ALWAYS_SAFE_BYTES")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(ID "_ALWAYS_SAFE")
(PUNCT ")")
(NEWLINE)
(ID "_safe_quoters")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD class)
(ID "Quoter")
(PUNCT "(")
(ID "collections")
(PUNCT ".")
(ID "defaultdict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A mapping from bytes (in range(0,256)) to strings.\n\n    String values are percent-encoded byte values, unless the key < 128, and\n    in the \"safe\" set (either the specified safe set, or default set).\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "safe: bytes object.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "safe")
(PUNCT "=")
(ID "_ALWAYS_SAFE")
(PUNCT ".")
(ID "union")
(PUNCT "(")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<Quoter %r>")
(PUNCT "%")
(ID "dict")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__missing__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(KEYWORD if)
(ID "b")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "safe")
(KEYWORD else)
(LIT "%{:02X}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT "[")
(ID "b")
(PUNCT "]")
(PUNCT "=")
(ID "res")
(NEWLINE)
(KEYWORD return)
(ID "res")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "quote")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "safe")
(PUNCT "=")
(LIT "/")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "quote('abc def') -> 'abc%20def'\n\n    Each part of a URL, e.g. the path info, the query, etc., has a\n    different set of reserved characters that must be quoted.\n\n    RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists\n    the following reserved characters.\n\n    reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\n                  \"$\" | \",\"\n\n    Each of these characters is reserved in some component of a URL,\n    but not necessarily in all of them.\n\n    By default, the quote function is intended for quoting the path\n    section of a URL.  Thus, it will not encode '/'.  This character\n    is reserved, but in typical usage the quote function is being\n    called on a path where the existing slash characters are used as\n    reserved characters.\n\n    string and safe may be either str or bytes objects. encoding and errors\n    must not be specified if string is a bytes object.\n\n    The optional encoding and errors parameters specify how to deal with\n    non-ASCII characters, as accepted by the str.encode method.\n    By default, encoding='utf-8' (characters are encoded with UTF-8), and\n    errors='strict' (unsupported characters raise a UnicodeEncodeError).\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "string")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "string")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "errors")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT "=")
(LIT "strict")
(NEWLINE)
(DEDENT)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "quote() doesn't support 'encoding' for bytes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "errors")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "quote() doesn't support 'errors' for bytes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "quote_from_bytes")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "quote_plus")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "safe")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Like quote(), but also replace ' ' with '+', as required for quoting\n    HTML form values. Plus signs in the original string are escaped unless\n    they are included in safe. It also does not have safe default to '/'.\n    ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(KEYWORD and)
(LIT " ")
(KEYWORD not)
(KEYWORD in)
(ID "string")
(PUNCT ")")
(KEYWORD or)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(KEYWORD and)
(LIT #" ")
(KEYWORD not)
(KEYWORD in)
(ID "string")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "quote")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "safe")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "space")
(PUNCT "=")
(LIT " ")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "space")
(PUNCT "=")
(LIT #" ")
(NEWLINE)
(DEDENT)
(ID "string")
(PUNCT "=")
(ID "quote")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "safe")
(PUNCT "+")
(ID "space")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "string")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT "+")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "quote_from_bytes")
(PUNCT "(")
(ID "bs")
(PUNCT ",")
(ID "safe")
(PUNCT "=")
(LIT "/")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Like quote(), but accepts a bytes object rather than a str, and does\n    not perform string-to-bytes encoding.  It always returns an ASCII string.\n    quote_from_bytes(b'abc def?') -> 'abc%20def%3f'\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "bs")
(PUNCT ",")
(PUNCT "(")
(ID "bytes")
(PUNCT ",")
(ID "bytearray")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "quote_from_bytes() expected bytes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "bs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "safe")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "safe")
(PUNCT "=")
(ID "safe")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "ignore")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "safe")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(ID "c")
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "safe")
(KEYWORD if)
(ID "c")
(PUNCT "<")
(LIT 128)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "bs")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(ID "_ALWAYS_SAFE_BYTES")
(PUNCT "+")
(ID "safe")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bs")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "quoter")
(PUNCT "=")
(ID "_safe_quoters")
(PUNCT "[")
(ID "safe")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_safe_quoters")
(PUNCT "[")
(ID "safe")
(PUNCT "]")
(PUNCT "=")
(ID "quoter")
(PUNCT "=")
(ID "Quoter")
(PUNCT "(")
(ID "safe")
(PUNCT ")")
(PUNCT ".")
(ID "__getitem__")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "quoter")
(PUNCT "(")
(ID "char")
(PUNCT ")")
(KEYWORD for)
(ID "char")
(KEYWORD in)
(ID "bs")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urlencode")
(PUNCT "(")
(ID "query")
(PUNCT ",")
(ID "doseq")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "safe")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a dict or sequence of two-element tuples into a URL query string.\n\n    If any values in the query arg are sequences and doseq is true, each\n    sequence element is converted to a separate parameter.\n\n    If the query arg is a sequence of two-element tuples, the order of the\n    parameters in the output will match the order of parameters in the\n    input.\n\n    The components of a query arg may each be either a string or a bytes type.\n\n    The safe, encoding, and errors parameters are passed down to quote_plus()\n    (encoding and errors only if a component is a str).\n    ")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "query")
(PUNCT ",")
(LIT "items")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "query")
(PUNCT "=")
(ID "query")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "query")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "query")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ty")
(PUNCT ",")
(ID "va")
(PUNCT ",")
(ID "tb")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "not a valid non-string sequence ")
(LIT "or mapping object")
(PUNCT ")")
(PUNCT ".")
(ID "with_traceback")
(PUNCT "(")
(ID "tb")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "l")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "doseq")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "query")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "k")
(PUNCT ")")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "l")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT "+")
(LIT "=")
(PUNCT "+")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "query")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "k")
(PUNCT ")")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(ID "l")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT "+")
(LIT "=")
(PUNCT "+")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "l")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT "+")
(LIT "=")
(PUNCT "+")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "l")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT "+")
(LIT "=")
(PUNCT "+")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "elt")
(KEYWORD in)
(ID "v")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "elt")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "elt")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "elt")
(PUNCT ",")
(ID "safe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "elt")
(PUNCT "=")
(ID "quote_plus")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "elt")
(PUNCT ")")
(PUNCT ",")
(ID "safe")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "l")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT "+")
(LIT "=")
(PUNCT "+")
(ID "elt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT "&")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "l")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_bytes")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "to_bytes(u\"URL\") --> 'URL'.")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "url")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ASCII")
(PUNCT ")")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnicodeError")
(PUNCT "(")
(LIT "URL ")
(PUNCT "+")
(ID "repr")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT "+")
(LIT " contains non-ASCII characters")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "url")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unwrap")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "unwrap('<URL:type://host/path>') --> 'type://host/path'.")
(NEWLINE)
(ID "url")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "<")
(KEYWORD and)
(ID "url")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT ">")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "url")
(PUNCT "[")
(PUNCT ":")
(LIT 4)
(PUNCT "]")
(PUNCT "==")
(LIT "URL:")
(PUNCT ":")
(ID "url")
(PUNCT "=")
(ID "url")
(PUNCT "[")
(LIT 4)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "url")
(NEWLINE)
(DEDENT)
(ID "_typeprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splittype")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splittype('type:opaquestring') --> 'type', 'opaquestring'.")
(NEWLINE)
(KEYWORD global)
(ID "_typeprog")
(NEWLINE)
(KEYWORD if)
(ID "_typeprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_typeprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^([^/:]+):")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_typeprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "scheme")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "scheme")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "url")
(PUNCT "[")
(ID "len")
(PUNCT "(")
(ID "scheme")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(PUNCT ",")
(ID "url")
(NEWLINE)
(DEDENT)
(ID "_hostprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splithost")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splithost('//host[:port]/path') --> 'host[:port]', '/path'.")
(NEWLINE)
(KEYWORD global)
(ID "_hostprog")
(NEWLINE)
(KEYWORD if)
(ID "_hostprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_hostprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^//([^/?]*)(.*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_hostprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "host_port")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "path")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "path")
(KEYWORD and)
(KEYWORD not)
(ID "path")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(LIT "/")
(PUNCT "+")
(ID "path")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "host_port")
(PUNCT ",")
(ID "path")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(PUNCT ",")
(ID "url")
(NEWLINE)
(DEDENT)
(ID "_userprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splituser")
(PUNCT "(")
(ID "host")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'.")
(NEWLINE)
(KEYWORD global)
(ID "_userprog")
(NEWLINE)
(KEYWORD if)
(ID "_userprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_userprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^(.*)@(.*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_userprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "host")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(KEYWORD return)
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(PUNCT ",")
(ID "host")
(NEWLINE)
(DEDENT)
(ID "_passwdprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splitpasswd")
(PUNCT "(")
(ID "user")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splitpasswd('user:passwd') -> 'user', 'passwd'.")
(NEWLINE)
(KEYWORD global)
(ID "_passwdprog")
(NEWLINE)
(KEYWORD if)
(ID "_passwdprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_passwdprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^([^:]*):(.*)$")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "S")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_passwdprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "user")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(KEYWORD return)
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "user")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "_portprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splitport")
(PUNCT "(")
(ID "host")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splitport('host:port') --> 'host', 'port'.")
(NEWLINE)
(KEYWORD global)
(ID "_portprog")
(NEWLINE)
(KEYWORD if)
(ID "_portprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_portprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^(.*):([0-9]*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_portprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "host")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "port")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "host")
(PUNCT ",")
(ID "port")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "host")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "_nportprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splitnport")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "defport")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Split host and port, returning numeric port.\n    Return given default port if no ':' found; defaults to -1.\n    Return numerical port if a valid number are found after ':'.\n    Return None if ':' but not a valid number.")
(NEWLINE)
(KEYWORD global)
(ID "_nportprog")
(NEWLINE)
(KEYWORD if)
(ID "_nportprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_nportprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^(.*):(.*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_nportprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "host")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "port")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nport")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "port")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nport")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "host")
(PUNCT ",")
(ID "nport")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "host")
(PUNCT ",")
(ID "defport")
(NEWLINE)
(DEDENT)
(ID "_queryprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splitquery")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splitquery('/path?query') --> '/path', 'query'.")
(NEWLINE)
(KEYWORD global)
(ID "_queryprog")
(NEWLINE)
(KEYWORD if)
(ID "_queryprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_queryprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^(.*)\\?([^?]*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_queryprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(KEYWORD return)
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "url")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "_tagprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splittag")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splittag('/path#tag') --> '/path', 'tag'.")
(NEWLINE)
(KEYWORD global)
(ID "_tagprog")
(NEWLINE)
(KEYWORD if)
(ID "_tagprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_tagprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^(.*)#([^#]*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_tagprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(KEYWORD return)
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "url")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "splitattr")
(PUNCT "(")
(ID "url")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splitattr('/path;attr1=value1;attr2=value2;...') ->\n        '/path', ['attr1=value1', 'attr2=value2', ...].")
(NEWLINE)
(ID "words")
(PUNCT "=")
(ID "url")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ";")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "words")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "words")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "_valueprog")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "splitvalue")
(PUNCT "(")
(ID "attr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "splitvalue('attr=value') --> 'attr', 'value'.")
(NEWLINE)
(KEYWORD global)
(ID "_valueprog")
(NEWLINE)
(KEYWORD if)
(ID "_valueprog")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_valueprog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^([^=]*)=(.*)$")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "match")
(PUNCT "=")
(ID "_valueprog")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "attr")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "match")
(PUNCT ":")
(KEYWORD return)
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "attr")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ENDMARKER)
