(LIT "This will be the home for the policy that hooks in the new\ncode that adds all the email6 features.\n")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "_policybase")
(KEYWORD import)
(ID "Policy")
(PUNCT ",")
(ID "Compat32")
(PUNCT ",")
(ID "compat32")
(PUNCT ",")
(ID "_extend_docstrings")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "utils")
(KEYWORD import)
(ID "_has_surrogates")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "headerregistry")
(KEYWORD import)
(ID "HeaderRegistry")
(KEYWORD as)
(ID "HeaderRegistry")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "contentmanager")
(KEYWORD import)
(ID "raw_data_manager")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Compat32")
(PUNCT ",")
(LIT "compat32")
(PUNCT ",")
(LIT "Policy")
(PUNCT ",")
(LIT "EmailPolicy")
(PUNCT ",")
(LIT "default")
(PUNCT ",")
(LIT "strict")
(PUNCT ",")
(LIT "SMTP")
(PUNCT ",")
(LIT "HTTP")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(PUNCT "@")
(ID "_extend_docstrings")
(NEWLINE)
(KEYWORD class)
(ID "EmailPolicy")
(PUNCT "(")
(ID "Policy")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n    PROVISIONAL\n\n    The API extensions enabled by this policy are currently provisional.\n    Refer to the documentation for details.\n\n    This policy adds new header parsing and folding algorithms.  Instead of\n    simple strings, headers are custom objects with custom attributes\n    depending on the type of the field.  The folding algorithm fully\n    implements RFCs 2047 and 5322.\n\n    In addition to the settable attributes listed above that apply to\n    all Policies, this policy adds the following additional attributes:\n\n    refold_source       -- if the value for a header in the Message object\n                           came from the parsing of some source, this attribute\n                           indicates whether or not a generator should refold\n                           that value when transforming the message back into\n                           stream form.  The possible values are:\n\n                           none  -- all source values use original folding\n                           long  -- source values that have any line that is\n                                    longer than max_line_length will be\n                                    refolded\n                           all  -- all values are refolded.\n\n                           The default is 'long'.\n\n    header_factory      -- a callable that takes two arguments, 'name' and\n                           'value', where 'name' is a header field name and\n                           'value' is an unfolded header field value, and\n                           returns a string-like object that represents that\n                           header.  A default header_factory is provided that\n                           understands some of the RFC5322 header field types.\n                           (Currently address fields and date fields have\n                           special treatment, while all other fields are\n                           treated as unstructured.  This list will be\n                           completed before the extension is marked stable.)\n\n    content_manager     -- an object with at least two methods: get_content\n                           and set_content.  When the get_content or\n                           set_content method of a Message object is called,\n                           it calls the corresponding method of this object,\n                           passing it the message object as its first argument,\n                           and any arguments or keywords that were passed to\n                           it as additional arguments.  The default\n                           content_manager is\n                           :data:`~email.contentmanager.raw_data_manager`.\n\n    ")
(NEWLINE)
(ID "refold_source")
(PUNCT "=")
(LIT "long")
(NEWLINE)
(ID "header_factory")
(PUNCT "=")
(ID "HeaderRegistry")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "content_manager")
(PUNCT "=")
(ID "raw_data_manager")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "header_factory")
(KEYWORD not)
(KEYWORD in)
(ID "kw")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "object")
(PUNCT ".")
(ID "__setattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "header_factory")
(PUNCT ",")
(ID "HeaderRegistry")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_max_count")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n        The implementation for this class returns the max_count attribute from\n        the specialized header class that would be used to construct a header\n        of type 'name'.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "header_factory")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT ".")
(ID "max_count")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_source_parse")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sourcelines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n        The name is parsed as everything up to the ':' and returned unmodified.\n        The value is determined by stripping leading whitespace off the\n        remainder of the first line, joining all subsequent lines together, and\n        stripping any trailing carriage return or linefeed characters.  (This\n        is the same as Compat32).\n\n        ")
(NEWLINE)
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "sourcelines")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ":")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT " \t")
(PUNCT ")")
(PUNCT "+")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "sourcelines")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT "\r\n")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_store_parse")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n        The name is returned unchanged.  If the input value has a 'name'\n        attribute and it matches the name ignoring case, the value is returned\n        unchanged.  Otherwise the name and value are passed to header_factory\n        method, and the resulting custom header object is returned as the\n        value.  In this case a ValueError is raised if the input value contains\n        CR or LF characters.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "name")
(PUNCT ")")
(KEYWORD and)
(ID "value")
(PUNCT ".")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Header values may not contain linefeed ")
(LIT "or carriage return characters")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "header_factory")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_fetch_parse")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n        If the value has a 'name' attribute, it is returned to unmodified.\n        Otherwise the name and the value with any linesep characters removed\n        are passed to the header_factory method, and the resulting custom\n        header object is returned.  Any surrogateescaped bytes get turned\n        into the unicode unknown-character glyph.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "header_factory")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fold")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n        Header folding is controlled by the refold_source policy setting.  A\n        value is considered to be a 'source value' if and only if it does not\n        have a 'name' attribute (having a 'name' attribute means it is a header\n        object of some sort).  If a source value needs to be refolded according\n        to the policy, it is converted into a custom header object by passing\n        the name and the value with any linesep characters removed to the\n        header_factory method.  Folding of a custom header object is done by\n        calling its fold method with the current policy.\n\n        Source values are split into lines using splitlines.  If the value is\n        not to be refolded, the lines are rejoined using the linesep from the\n        policy and returned.  The exception is lines containing non-ascii\n        binary data.  In that case the value is refolded regardless of the\n        refold_source setting, which causes the binary data to be CTE encoded\n        using the unknown-8bit charset.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fold")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "refold_binary")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fold_binary")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+\n        The same as fold if cte_type is 7bit, except that the returned value is\n        bytes.\n\n        If cte_type is 8bit, non-ASCII binary data is converted back into\n        bytes.  Headers with binary data are not refolded, regardless of the\n        refold_header setting, since there is no way to know whether the binary\n        data consists of single byte characters or multibyte characters.\n\n        ")
(NEWLINE)
(ID "folded")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fold")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "refold_binary")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cte_type")
(PUNCT "==")
(LIT "7bit")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "folded")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fold")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "refold_binary")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(PUNCT ".")
(ID "fold")
(PUNCT "(")
(ID "policy")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "maxlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "max_line_length")
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "max_line_length")
(KEYWORD else)
(ID "float")
(PUNCT "(")
(LIT "inf")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "refold")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "refold_source")
(PUNCT "==")
(LIT "all")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "refold_source")
(PUNCT "==")
(LIT "long")
(KEYWORD and)
(PUNCT "(")
(ID "lines")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "lines")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT "+")
(LIT 2)
(PUNCT ">")
(ID "maxlen")
(KEYWORD or)
(ID "any")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ">")
(ID "maxlen")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "lines")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "refold")
(KEYWORD or)
(ID "refold_binary")
(KEYWORD and)
(ID "_has_surrogates")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "header_factory")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "fold")
(PUNCT "(")
(ID "policy")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "name")
(PUNCT "+")
(LIT ": ")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "linesep")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "linesep")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "default")
(PUNCT "=")
(ID "EmailPolicy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "default")
(PUNCT ".")
(ID "header_factory")
(NEWLINE)
(ID "strict")
(PUNCT "=")
(ID "default")
(PUNCT ".")
(ID "clone")
(PUNCT "(")
(ID "raise_on_defect")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "SMTP")
(PUNCT "=")
(ID "default")
(PUNCT ".")
(ID "clone")
(PUNCT "(")
(ID "linesep")
(PUNCT "=")
(LIT "\r\n")
(PUNCT ")")
(NEWLINE)
(ID "HTTP")
(PUNCT "=")
(ID "default")
(PUNCT ".")
(ID "clone")
(PUNCT "(")
(ID "linesep")
(PUNCT "=")
(LIT "\r\n")
(PUNCT ",")
(ID "max_line_length")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ENDMARKER)
