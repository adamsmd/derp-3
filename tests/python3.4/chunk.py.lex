(LIT "Simple class to read IFF chunks.\n\nAn IFF chunk (used in formats such as AIFF, TIFF, RMFF (RealMedia File\nFormat)) has the following structure:\n\n+----------------+\n| ID (4 bytes)   |\n+----------------+\n| size (4 bytes) |\n+----------------+\n| data           |\n| ...            |\n+----------------+\n\nThe ID is a 4-byte string which identifies the type of chunk.\n\nThe size field (a 32-bit value, encoded using big-endian byte order)\ngives the size of the whole chunk, including the 8-byte header.\n\nUsually an IFF-type file consists of one or more chunks.  The proposed\nusage of the Chunk class defined here is to instantiate an instance at\nthe start of each chunk and read from the instance until it reaches\nthe end, after which a new instance can be instantiated.  At the end\nof the file, creating a new instance will fail with a EOFError\nexception.\n\nUsage:\nwhile True:\n    try:\n        chunk = Chunk(file)\n    except EOFError:\n        break\n    chunktype = chunk.getname()\n    while True:\n        data = chunk.read(nbytes)\n        if not data:\n            pass\n        # do something with data\n\nThe interface is file-like.  The implemented methods are:\nread, close, seek, tell, isatty.\nExtra methods are: skip() (called by close, skips to the end of the chunk),\ngetname() (returns the name (ID) of the chunk)\n\nThe __init__ method has one required argument, a file-like object\n(including a chunk instance), and one optional argument, a flag which\nspecifies whether or not chunks are aligned on 2-byte boundaries.  The\ndefault is 1, i.e. aligned.\n")
(NEWLINE)
(KEYWORD class)
(ID "Chunk")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "align")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "bigendian")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "inclheader")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "struct")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "align")
(PUNCT "=")
(ID "align")
(NEWLINE)
(KEYWORD if)
(ID "bigendian")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "strflag")
(PUNCT "=")
(LIT ">")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "strflag")
(PUNCT "=")
(LIT "<")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "file")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "chunkname")
(PUNCT "=")
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "chunkname")
(PUNCT ")")
(PUNCT "<")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "EOFError")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "=")
(ID "struct")
(PUNCT ".")
(ID "unpack_from")
(PUNCT "(")
(ID "strflag")
(PUNCT "+")
(LIT "L")
(PUNCT ",")
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 4)
(PUNCT ")")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "struct")
(PUNCT ".")
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "EOFError")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "inclheader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "-")
(LIT 8)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "offset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AttributeError")
(PUNCT ",")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "seekable")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "seekable")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getname")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the name (ID) of the current chunk.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "chunkname")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getsize")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the size of the current chunk.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "chunksize")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "skip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "isatty")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Seek to specified position into the chunk.\n        Default position is 0 (start of chunk).\n        If the file is not seekable, this will result in an error.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "seekable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "cannot seek")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "whence")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "pos")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "size_read")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "whence")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "pos")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pos")
(PUNCT "<")
(LIT 0)
(KEYWORD or)
(ID "pos")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "offset")
(PUNCT "+")
(ID "pos")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "=")
(ID "pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "size_read")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read at most size bytes from the chunk.\n        If size is omitted or negative, read until the end\n        of the chunk.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "size_read")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "size_read")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "align")
(KEYWORD and)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "&")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dummy")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "dummy")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "skip")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Skip the rest of the chunk.\n        If you are not interested in the contents of the chunk,\n        this method should be called so that the file points to\n        the start of the next chunk.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "seekable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "size_read")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "align")
(KEYWORD and)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "&")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "=")
(ID "n")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "+")
(ID "n")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT "<")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(LIT 8192)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "chunksize")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "size_read")
(PUNCT ")")
(NEWLINE)
(ID "dummy")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dummy")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "EOFError")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
