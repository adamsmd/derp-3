(LIT "Module doctest -- a framework for running examples in docstrings.\n\nIn simplest use, end each module M to be tested with:\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == \"__main__\":\n    _test()\n\nThen running the module as a script will cause the examples in the\ndocstrings to get executed and verified:\n\npython M.py\n\nThis won't display anything unless an example fails, in which case the\nfailing example(s) and the cause(s) of the failure(s) are printed to stdout\n(why not stderr? because stderr is a lame hack <0.2 wink>), and the final\nline of output is \"Test failed.\".\n\nRun it with the -v switch instead:\n\npython M.py -v\n\nand a detailed report of all examples tried is printed to stdout, along\nwith assorted summaries at the end.\n\nYou can force verbose mode by passing \"verbose=True\" to testmod, or prohibit\nit by passing \"verbose=False\".  In either of those cases, sys.argv is not\nexamined by testmod.\n\nThere are a variety of other ways to run doctests, including integration\nwith the unittest framework, and support for running non-Python text\nfiles containing doctests.  There are also many ways to override parts\nof doctest's default behaviors.  See the Library Reference Manual for\ndetails.\n")
(NEWLINE)
(ID "__docformat__")
(PUNCT "=")
(LIT "reStructuredText en")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "register_optionflag")
(PUNCT ",")
(LIT "DONT_ACCEPT_TRUE_FOR_1")
(PUNCT ",")
(LIT "DONT_ACCEPT_BLANKLINE")
(PUNCT ",")
(LIT "NORMALIZE_WHITESPACE")
(PUNCT ",")
(LIT "ELLIPSIS")
(PUNCT ",")
(LIT "SKIP")
(PUNCT ",")
(LIT "IGNORE_EXCEPTION_DETAIL")
(PUNCT ",")
(LIT "COMPARISON_FLAGS")
(PUNCT ",")
(LIT "REPORT_UDIFF")
(PUNCT ",")
(LIT "REPORT_CDIFF")
(PUNCT ",")
(LIT "REPORT_NDIFF")
(PUNCT ",")
(LIT "REPORT_ONLY_FIRST_FAILURE")
(PUNCT ",")
(LIT "REPORTING_FLAGS")
(PUNCT ",")
(LIT "FAIL_FAST")
(PUNCT ",")
(LIT "Example")
(PUNCT ",")
(LIT "DocTest")
(PUNCT ",")
(LIT "DocTestParser")
(PUNCT ",")
(LIT "DocTestFinder")
(PUNCT ",")
(LIT "DocTestRunner")
(PUNCT ",")
(LIT "OutputChecker")
(PUNCT ",")
(LIT "DocTestFailure")
(PUNCT ",")
(LIT "UnexpectedException")
(PUNCT ",")
(LIT "DebugRunner")
(PUNCT ",")
(LIT "testmod")
(PUNCT ",")
(LIT "testfile")
(PUNCT ",")
(LIT "run_docstring_examples")
(PUNCT ",")
(LIT "DocTestSuite")
(PUNCT ",")
(LIT "DocFileSuite")
(PUNCT ",")
(LIT "set_unittest_reportflags")
(PUNCT ",")
(LIT "script_from_examples")
(PUNCT ",")
(LIT "testsource")
(PUNCT ",")
(LIT "debug_src")
(PUNCT ",")
(LIT "debug")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "__future__")
(NEWLINE)
(KEYWORD import)
(ID "argparse")
(NEWLINE)
(KEYWORD import)
(ID "difflib")
(NEWLINE)
(KEYWORD import)
(ID "inspect")
(NEWLINE)
(KEYWORD import)
(ID "linecache")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "pdb")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(KEYWORD import)
(ID "unittest")
(NEWLINE)
(KEYWORD from)
(ID "io")
(KEYWORD import)
(ID "StringIO")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "namedtuple")
(NEWLINE)
(ID "TestResults")
(PUNCT "=")
(ID "namedtuple")
(PUNCT "(")
(LIT "TestResults")
(PUNCT ",")
(LIT "failed attempted")
(PUNCT ")")
(NEWLINE)
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "register_optionflag")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT ".")
(ID "setdefault")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(LIT 1)
(PUNCT "<<")
(ID "len")
(PUNCT "(")
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "DONT_ACCEPT_TRUE_FOR_1")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "DONT_ACCEPT_TRUE_FOR_1")
(PUNCT ")")
(NEWLINE)
(ID "DONT_ACCEPT_BLANKLINE")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "DONT_ACCEPT_BLANKLINE")
(PUNCT ")")
(NEWLINE)
(ID "NORMALIZE_WHITESPACE")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "NORMALIZE_WHITESPACE")
(PUNCT ")")
(NEWLINE)
(ID "ELLIPSIS")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "ELLIPSIS")
(PUNCT ")")
(NEWLINE)
(ID "SKIP")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "SKIP")
(PUNCT ")")
(NEWLINE)
(ID "IGNORE_EXCEPTION_DETAIL")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "IGNORE_EXCEPTION_DETAIL")
(PUNCT ")")
(NEWLINE)
(ID "COMPARISON_FLAGS")
(PUNCT "=")
(PUNCT "(")
(ID "DONT_ACCEPT_TRUE_FOR_1")
(PUNCT "|")
(ID "DONT_ACCEPT_BLANKLINE")
(PUNCT "|")
(ID "NORMALIZE_WHITESPACE")
(PUNCT "|")
(ID "ELLIPSIS")
(PUNCT "|")
(ID "SKIP")
(PUNCT "|")
(ID "IGNORE_EXCEPTION_DETAIL")
(PUNCT ")")
(NEWLINE)
(ID "REPORT_UDIFF")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "REPORT_UDIFF")
(PUNCT ")")
(NEWLINE)
(ID "REPORT_CDIFF")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "REPORT_CDIFF")
(PUNCT ")")
(NEWLINE)
(ID "REPORT_NDIFF")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "REPORT_NDIFF")
(PUNCT ")")
(NEWLINE)
(ID "REPORT_ONLY_FIRST_FAILURE")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "REPORT_ONLY_FIRST_FAILURE")
(PUNCT ")")
(NEWLINE)
(ID "FAIL_FAST")
(PUNCT "=")
(ID "register_optionflag")
(PUNCT "(")
(LIT "FAIL_FAST")
(PUNCT ")")
(NEWLINE)
(ID "REPORTING_FLAGS")
(PUNCT "=")
(PUNCT "(")
(ID "REPORT_UDIFF")
(PUNCT "|")
(ID "REPORT_CDIFF")
(PUNCT "|")
(ID "REPORT_NDIFF")
(PUNCT "|")
(ID "REPORT_ONLY_FIRST_FAILURE")
(PUNCT "|")
(ID "FAIL_FAST")
(PUNCT ")")
(NEWLINE)
(ID "BLANKLINE_MARKER")
(PUNCT "=")
(LIT "<BLANKLINE>")
(NEWLINE)
(ID "ELLIPSIS_MARKER")
(PUNCT "=")
(LIT "...")
(NEWLINE)
(KEYWORD def)
(ID "_extract_future_flags")
(PUNCT "(")
(ID "globs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the compiler-flags associated with the future features that\n    have been imported into the given namespace (globs).\n    ")
(NEWLINE)
(ID "flags")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "fname")
(KEYWORD in)
(ID "__future__")
(PUNCT ".")
(ID "all_feature_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "feature")
(PUNCT "=")
(ID "globs")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "fname")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "feature")
(KEYWORD is)
(ID "getattr")
(PUNCT "(")
(ID "__future__")
(PUNCT ",")
(ID "fname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flags")
(PUNCT "|=")
(ID "feature")
(PUNCT ".")
(ID "compiler_flag")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "flags")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_normalize_module")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "depth")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the module specified by `module`.  In particular:\n      - If `module` is a module, then return module.\n      - If `module` is a string, then import and return the\n        module with that name.\n      - If `module` is None, then return the calling module.\n        The calling module is assumed to be the module of\n        the stack frame at the given depth in the call stack.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "module")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "__import__")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "locals")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(PUNCT "[")
(LIT "*")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "sys")
(PUNCT ".")
(ID "_getframe")
(PUNCT "(")
(ID "depth")
(PUNCT ")")
(PUNCT ".")
(ID "f_globals")
(PUNCT "[")
(LIT "__name__")
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Expected a module, string, or None")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_load_testfile")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "package")
(PUNCT ",")
(ID "module_relative")
(PUNCT ",")
(ID "encoding")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "module_relative")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "package")
(PUNCT "=")
(ID "_normalize_module")
(PUNCT "(")
(ID "package")
(PUNCT ",")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "_module_relative_path")
(PUNCT "(")
(ID "package")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "package")
(PUNCT ",")
(LIT "__loader__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "package")
(PUNCT ".")
(ID "__loader__")
(PUNCT ",")
(LIT "get_data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file_contents")
(PUNCT "=")
(ID "package")
(PUNCT ".")
(ID "__loader__")
(PUNCT ".")
(ID "get_data")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "file_contents")
(PUNCT "=")
(ID "file_contents")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "file_contents")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "linesep")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(PUNCT ",")
(ID "filename")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(KEYWORD as)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "filename")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_indent")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(LIT 4)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Add the given number of space characters to the beginning of\n    every non-blank line in `s`, and return the result.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "(?m)^(?!$)")
(PUNCT ",")
(ID "indent")
(PUNCT "*")
(LIT " ")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_exception_traceback")
(PUNCT "(")
(ID "exc_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return a string containing a traceback message for the given\n    exc_info tuple (as returned by sys.exc_info()).\n    ")
(NEWLINE)
(ID "excout")
(PUNCT "=")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "exc_type")
(PUNCT ",")
(ID "exc_val")
(PUNCT ",")
(ID "exc_tb")
(PUNCT "=")
(ID "exc_info")
(NEWLINE)
(ID "traceback")
(PUNCT ".")
(ID "print_exception")
(PUNCT "(")
(ID "exc_type")
(PUNCT ",")
(ID "exc_val")
(PUNCT ",")
(ID "exc_tb")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "excout")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "excout")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_SpoofOut")
(PUNCT "(")
(ID "StringIO")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "getvalue")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "StringIO")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "result")
(KEYWORD and)
(KEYWORD not)
(ID "result")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT "\n")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(ID "StringIO")
(PUNCT ".")
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_ellipsis_match")
(PUNCT "(")
(ID "want")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Essentially the only subtle case:\n    >>> _ellipsis_match('aa...aa', 'aaa')\n    False\n    ")
(NEWLINE)
(KEYWORD if)
(ID "ELLIPSIS_MARKER")
(KEYWORD not)
(KEYWORD in)
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "want")
(PUNCT "==")
(ID "got")
(NEWLINE)
(DEDENT)
(ID "ws")
(PUNCT "=")
(ID "want")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "ELLIPSIS_MARKER")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "ws")
(PUNCT ")")
(PUNCT ">=")
(LIT 2)
(NEWLINE)
(ID "startpos")
(PUNCT ",")
(ID "endpos")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "got")
(PUNCT ")")
(NEWLINE)
(ID "w")
(PUNCT "=")
(ID "ws")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "w")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "got")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "w")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "startpos")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "w")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "ws")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "w")
(PUNCT "=")
(ID "ws")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "w")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "got")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "w")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "w")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "ws")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "startpos")
(PUNCT ">")
(ID "endpos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "w")
(KEYWORD in)
(ID "ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "startpos")
(PUNCT "=")
(ID "got")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "w")
(PUNCT ",")
(ID "startpos")
(PUNCT ",")
(ID "endpos")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "startpos")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "startpos")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "w")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_comment_line")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a commented form of the given line")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "# ")
(PUNCT "+")
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "#")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_strip_exception_details")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "msg")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "i")
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "=")
(ID "msg")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ":")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "i")
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "=")
(ID "msg")
(PUNCT ".")
(ID "rfind")
(PUNCT "(")
(LIT ".")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "msg")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_OutputRedirectingPdb")
(PUNCT "(")
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A specialized version of the python debugger that redirects stdout\n    to a given stream when interacting with the user.  Stdout is *not*\n    redirected when traced code is executed.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "__out")
(PUNCT "=")
(ID "out")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__debugger_used")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "stdout")
(PUNCT "=")
(ID "out")
(PUNCT ",")
(ID "nosigint")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "use_rawinput")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_trace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "__debugger_used")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD if)
(ID "frame")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "frame")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "_getframe")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "f_back")
(NEWLINE)
(DEDENT)
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT ".")
(ID "set_trace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_continue")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "__debugger_used")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT ".")
(ID "set_continue")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "trace_dispatch")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "save_stdout")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__out")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT ".")
(ID "trace_dispatch")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "save_stdout")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_module_relative_path")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Expected a module: %r")
(PUNCT "%")
(ID "module")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "path")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Module-relative files may not have absolute paths")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__file__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basedir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "module")
(PUNCT ".")
(ID "__file__")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "module")
(PUNCT ".")
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT ")")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "!=")
(LIT "")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basedir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basedir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "curdir")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Can't resolve paths relative to the module ")
(PUNCT "+")
(ID "module")
(PUNCT "+")
(LIT " (it has no __file__)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "basedir")
(PUNCT ",")
(PUNCT "*")
(PUNCT "(")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Example")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A single doctest example, consisting of source code and expected\n    output.  `Example` defines the following attributes:\n\n      - source: A single Python statement, always ending with a newline.\n        The constructor adds a newline if needed.\n\n      - want: The expected output from running the source code (either\n        from stdout, or a traceback in case of exception).  `want` ends\n        with a newline unless it's empty, in which case it's an empty\n        string.  The constructor adds a newline if needed.\n\n      - exc_msg: The exception message generated by the example, if\n        the example is expected to generate an exception; or `None` if\n        it is not expected to generate an exception.  This exception\n        message is compared against the return value of\n        `traceback.format_exception_only()`.  `exc_msg` ends with a\n        newline unless it's `None`.  The constructor adds a newline\n        if needed.\n\n      - lineno: The line number within the DocTest string containing\n        this Example where the Example begins.  This line number is\n        zero-based, with respect to the beginning of the DocTest.\n\n      - indent: The example's indentation in the DocTest string.\n        I.e., the number of space characters that precede the\n        example's first prompt.\n\n      - options: A dictionary mapping from option flags to True or\n        False, which is used to override default options for this\n        example.  Any option flags not contained in this dictionary\n        are left at their default value (as specified by the\n        DocTestRunner's optionflags).  By default, no options are set.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "want")
(PUNCT ",")
(ID "exc_msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "options")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "source")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "+=")
(LIT "\n")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "want")
(KEYWORD and)
(KEYWORD not)
(ID "want")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "want")
(PUNCT "+=")
(LIT "\n")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "exc_msg")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "exc_msg")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_msg")
(PUNCT "+=")
(LIT "\n")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "source")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "want")
(PUNCT "=")
(ID "want")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "indent")
(PUNCT "=")
(ID "indent")
(NEWLINE)
(KEYWORD if)
(ID "options")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(ID "options")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT "=")
(ID "options")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exc_msg")
(PUNCT "=")
(ID "exc_msg")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(ID "type")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "source")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "want")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "want")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "lineno")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "indent")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "indent")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "options")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "exc_msg")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "exc_msg")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "want")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "indent")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "exc_msg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DocTest")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A collection of doctest examples that should be run in a single\n    namespace.  Each `DocTest` defines the following attributes:\n\n      - examples: the list of examples.\n\n      - globs: The namespace (aka globals) that the examples should\n        be run in.\n\n      - name: A name identifying the DocTest (typically, the name of\n        the object whose docstring this DocTest was extracted from).\n\n      - filename: The name of the file that this DocTest was extracted\n        from, or `None` if the filename is unknown.\n\n      - lineno: The line number within filename where this DocTest\n        begins, or `None` if the line number is unavailable.  This\n        line number is zero-based, with respect to the beginning of\n        the file.\n\n      - docstring: The string that the examples were extracted from,\n        or `None` if the string is unavailable.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "examples")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "docstring")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Create a new DocTest containing the given examples.  The\n        DocTest's globals are initialized with a copy of `globs`.\n        ")
(NEWLINE)
(KEYWORD assert)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "examples")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ",")
(LIT "DocTest no longer accepts str; use DocTestParser instead")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "examples")
(PUNCT "=")
(ID "examples")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "docstring")
(PUNCT "=")
(ID "docstring")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "examples")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "examples")
(PUNCT "=")
(LIT "no examples")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "examples")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "examples")
(PUNCT "=")
(LIT "1 example")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "examples")
(PUNCT "=")
(LIT "%d examples")
(PUNCT "%")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "examples")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(LIT "<DocTest %s from %s:%s (%s)>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "examples")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(ID "type")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "examples")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "examples")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "docstring")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "docstring")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "globs")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "globs")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "name")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "filename")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "lineno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "docstring")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "DocTest")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "id")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(PUNCT "<")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "id")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DocTestParser")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A class used to parse strings containing doctest examples.\n    ")
(NEWLINE)
(ID "_EXAMPLE_RE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line\n            (?:\\n           [ ]*  \\.\\.\\. .*)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*>>>)  # Not a line starting with PS1\n                     .+$\\n?       # But any other line\n                  )*)\n        ")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT ")")
(NEWLINE)
(ID "_EXCEPTION_RE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\n        # Grab the traceback header.  Different versions of Python have\n        # said different things on the first traceback line.\n        ^(?P<hdr> Traceback\\ \\(\n            (?: most\\ recent\\ call\\ last\n            |   innermost\\ last\n            ) \\) :\n        )\n        \\s* $                # toss trailing whitespace on the header.\n        (?P<stack> .*?)      # don't blink: absorb stuff until...\n        ^ (?P<msg> \\w+ .*)   #     a line *starts* with alphanum.\n        ")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "DOTALL")
(PUNCT ")")
(NEWLINE)
(ID "_IS_BLANK_OR_COMMENT")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^[ ]*(#.*)?$")
(PUNCT ")")
(PUNCT ".")
(ID "match")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(LIT "<string>")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Divide the given string into examples and intervening text,\n        and return them as a list of alternating Examples and strings.\n        Line numbers for the Examples are 0-based.  The optional\n        argument `name` is a name identifying this string, and is only\n        used for error messages.\n        ")
(NEWLINE)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "expandtabs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "min_indent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_min_indent")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "min_indent")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "l")
(PUNCT "[")
(ID "min_indent")
(PUNCT ":")
(PUNCT "]")
(KEYWORD for)
(ID "l")
(KEYWORD in)
(ID "string")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "output")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "charno")
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "m")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_EXAMPLE_RE")
(PUNCT ".")
(ID "finditer")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "string")
(PUNCT "[")
(ID "charno")
(PUNCT ":")
(ID "m")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT "+=")
(ID "string")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(ID "charno")
(PUNCT ",")
(ID "m")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "options")
(PUNCT ",")
(ID "want")
(PUNCT ",")
(ID "exc_msg")
(PUNCT ")")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_parse_example")
(PUNCT "(")
(ID "m")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_IS_BLANK_OR_COMMENT")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "Example")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "want")
(PUNCT ",")
(ID "exc_msg")
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(ID "min_indent")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "indent")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "options")
(PUNCT "=")
(ID "options")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT "+=")
(ID "string")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(ID "m")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "charno")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "output")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "string")
(PUNCT "[")
(ID "charno")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "output")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_doctest")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Extract all doctest examples from the given string, and\n        collect them into a `DocTest` object.\n\n        `globs`, `name`, `filename`, and `lineno` are attributes for\n        the new `DocTest` object.  See the documentation for `DocTest`\n        for more information.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "DocTest")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "get_examples")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "string")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_examples")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(LIT "<string>")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Extract all doctest examples from the given string, and return\n        them as a list of `Example` objects.  Line numbers are\n        0-based, because it's most common in doctests that nothing\n        interesting appears on the same line as opening triple-quote,\n        and so the first interesting line is called \"line 1\" then.\n\n        The optional argument `name` is a name identifying this\n        string, and is only used for error messages.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "x")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "parse")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "Example")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_parse_example")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "m")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Given a regular expression match from `_EXAMPLE_RE` (`m`),\n        return a pair `(source, want)`, where `source` is the matched\n        example's source code (with prompts and indentation stripped);\n        and `want` is the example's expected output (with indentation\n        stripped).\n\n        `name` is the string's name, and `lineno` is the line number\n        where the example starts; both are used for error messages.\n        ")
(NEWLINE)
(ID "indent")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "indent")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "source_lines")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "source")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_check_prompt_blank")
(PUNCT "(")
(ID "source_lines")
(PUNCT ",")
(ID "indent")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_check_prefix")
(PUNCT "(")
(ID "source_lines")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(LIT " ")
(PUNCT "*")
(ID "indent")
(PUNCT "+")
(LIT ".")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(ID "source")
(PUNCT "=")
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "sl")
(PUNCT "[")
(ID "indent")
(PUNCT "+")
(LIT 4)
(PUNCT ":")
(PUNCT "]")
(KEYWORD for)
(ID "sl")
(KEYWORD in)
(ID "source_lines")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "want")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "want")
(PUNCT ")")
(NEWLINE)
(ID "want_lines")
(PUNCT "=")
(ID "want")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "want_lines")
(PUNCT ")")
(PUNCT ">")
(LIT 1)
(KEYWORD and)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT " *$")
(PUNCT ",")
(ID "want_lines")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "want_lines")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_check_prefix")
(PUNCT "(")
(ID "want_lines")
(PUNCT ",")
(LIT " ")
(PUNCT "*")
(ID "indent")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "source_lines")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "want")
(PUNCT "=")
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "wl")
(PUNCT "[")
(ID "indent")
(PUNCT ":")
(PUNCT "]")
(KEYWORD for)
(ID "wl")
(KEYWORD in)
(ID "want_lines")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "m")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_EXCEPTION_RE")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "want")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_msg")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_msg")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "options")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_find_options")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "source")
(PUNCT ",")
(ID "options")
(PUNCT ",")
(ID "want")
(PUNCT ",")
(ID "exc_msg")
(NEWLINE)
(DEDENT)
(ID "_OPTION_DIRECTIVE_RE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "#\\s*doctest:\\s*([^\\n\\'\"]*)$")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_find_options")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a dictionary containing option overrides extracted from\n        option directives in the given source string.\n\n        `name` is the string's name, and `lineno` is the line number\n        where the example starts; both are used for error messages.\n        ")
(NEWLINE)
(ID "options")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "m")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_OPTION_DIRECTIVE_RE")
(PUNCT ".")
(ID "finditer")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "option_strings")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ",")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "option")
(KEYWORD in)
(ID "option_strings")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "option")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(LIT "+-")
(KEYWORD or)
(ID "option")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "line %r of the doctest for %s ")
(LIT "has an invalid option: %r")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "option")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "flag")
(PUNCT "=")
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT "[")
(ID "option")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "options")
(PUNCT "[")
(ID "flag")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "option")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "+")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "options")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_IS_BLANK_OR_COMMENT")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "line %r of the doctest for %s has an option ")
(LIT "directive on a line with no example: %r")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "source")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "options")
(NEWLINE)
(DEDENT)
(ID "_INDENT_RE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^([ ]*)(?=\\S)")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_min_indent")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the minimum indentation of any non-blank line in `s`")
(NEWLINE)
(ID "indents")
(PUNCT "=")
(PUNCT "[")
(ID "len")
(PUNCT "(")
(ID "indent")
(PUNCT ")")
(KEYWORD for)
(ID "indent")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_INDENT_RE")
(PUNCT ".")
(ID "findall")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "indents")
(PUNCT ")")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "min")
(PUNCT "(")
(ID "indents")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_check_prompt_blank")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lines")
(PUNCT ",")
(ID "indent")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Given the lines of a source string (including prompts and\n        leading indentation), check to make sure that every prompt is\n        followed by a space character.  If any line is not followed by\n        a space character, then raise ValueError.\n        ")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "line")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ">=")
(ID "indent")
(PUNCT "+")
(LIT 4)
(KEYWORD and)
(ID "line")
(PUNCT "[")
(ID "indent")
(PUNCT "+")
(LIT 3)
(PUNCT "]")
(PUNCT "!=")
(LIT " ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "line %r of the docstring for %s ")
(LIT "lacks blank after %s: %r")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT "+")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "line")
(PUNCT "[")
(ID "indent")
(PUNCT ":")
(ID "indent")
(PUNCT "+")
(LIT 3)
(PUNCT "]")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_check_prefix")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lines")
(PUNCT ",")
(ID "prefix")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Check that every line in the given list starts with the given\n        prefix; if any line does not, then raise a ValueError.\n        ")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "line")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(KEYWORD and)
(KEYWORD not)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "line %r of the docstring for %s has ")
(LIT "inconsistent leading whitespace: %r")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT "+")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DocTestFinder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A class used to extract the DocTests that are relevant to a given\n    object, from its docstring and the docstrings of its contained\n    objects.  Doctests can currently be extracted from the following\n    object types: modules, functions, classes, methods, staticmethods,\n    classmethods, and properties.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(ID "DocTestParser")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "recurse")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "exclude_empty")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Create a new doctest finder.\n\n        The optional argument `parser` specifies a class or\n        function that should be used to create new DocTest objects (or\n        objects that implement the same interface as DocTest).  The\n        signature for this factory function should match the signature\n        of the DocTest constructor.\n\n        If the optional argument `recurse` is false, then `find` will\n        only examine the given object, and not any contained objects.\n\n        If the optional argument `exclude_empty` is false, then `find`\n        will include tests for objects with empty docstrings.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT "=")
(ID "parser")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_verbose")
(PUNCT "=")
(ID "verbose")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_recurse")
(PUNCT "=")
(ID "recurse")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exclude_empty")
(PUNCT "=")
(ID "exclude_empty")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "module")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extraglobs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a list of the DocTests that are defined by the given\n        object's docstring, or by any of its contained objects'\n        docstrings.\n\n        The optional parameter `module` is the module that contains\n        the given object.  If the module is not specified or is None, then\n        the test finder will attempt to automatically determine the\n        correct module.  The object's module is used:\n\n            - As a default namespace, if `globs` is not specified.\n            - To prevent the DocTestFinder from extracting DocTests\n              from objects that are imported from other modules.\n            - To find the name of the file containing the object.\n            - To help find the line number of the object within its\n              file.\n\n        Contained objects whose module does not match `module` are ignored.\n\n        If `module` is False, no attempt to find the module will be made.\n        This is obscure, of use mostly in tests:  if `module` is False, or\n        is None but cannot be found automatically, then all objects are\n        considered to belong to the (non-existent) module, so all contained\n        objects will (recursively) be searched for doctests.\n\n        The globals for each DocTest is formed by combining `globs`\n        and `extraglobs` (bindings in `extraglobs` override bindings\n        in `globs`).  A new copy of the globals dictionary is created\n        for each DocTest.  If `globs` is not specified, then it\n        defaults to the module's `__dict__`, if specified, or {}\n        otherwise.  If `extraglobs` is not specified, then it defaults\n        to {}.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "__name__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "DocTestFinder.find: name must be given ")
(LIT "when obj.__name__ doesn't exist: %r")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD False)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getmodule")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getsourcefile")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source_lines")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getfile")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "file")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "+")
(ID "file")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "<]>")
(PUNCT ":")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "file")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source_lines")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source_lines")
(PUNCT "=")
(ID "linecache")
(PUNCT ".")
(ID "getlines")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "module")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source_lines")
(PUNCT "=")
(ID "linecache")
(PUNCT ".")
(ID "getlines")
(PUNCT "(")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "source_lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source_lines")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "globs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "extraglobs")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "extraglobs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "__name__")
(KEYWORD not)
(KEYWORD in)
(ID "globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "[")
(LIT "__name__")
(PUNCT "]")
(PUNCT "=")
(LIT "__main__")
(NEWLINE)
(DEDENT)
(ID "tests")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_find")
(PUNCT "(")
(ID "tests")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "source_lines")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(ID "tests")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "tests")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_from_module")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return true if the given object is defined in the given\n        module.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "inspect")
(PUNCT ".")
(ID "getmodule")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "module")
(KEYWORD is)
(ID "inspect")
(PUNCT ".")
(ID "getmodule")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "inspect")
(PUNCT ".")
(ID "isfunction")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "module")
(PUNCT ".")
(ID "__dict__")
(KEYWORD is)
(ID "object")
(PUNCT ".")
(ID "__globals__")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "inspect")
(PUNCT ".")
(ID "ismethoddescriptor")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "object")
(PUNCT ",")
(LIT "__objclass__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj_mod")
(PUNCT "=")
(ID "object")
(PUNCT ".")
(ID "__objclass__")
(PUNCT ".")
(ID "__module__")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "hasattr")
(PUNCT "(")
(ID "object")
(PUNCT ",")
(LIT "__module__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj_mod")
(PUNCT "=")
(ID "object")
(PUNCT ".")
(ID "__module__")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "module")
(PUNCT ".")
(ID "__name__")
(PUNCT "==")
(ID "obj_mod")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "inspect")
(PUNCT ".")
(ID "isclass")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "module")
(PUNCT ".")
(ID "__name__")
(PUNCT "==")
(ID "object")
(PUNCT ".")
(ID "__module__")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "hasattr")
(PUNCT "(")
(ID "object")
(PUNCT ",")
(LIT "__module__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "module")
(PUNCT ".")
(ID "__name__")
(PUNCT "==")
(ID "object")
(PUNCT ".")
(ID "__module__")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "object")
(PUNCT ",")
(ID "property")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "object must be a class or function")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_find")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tests")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "source_lines")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "seen")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Find tests for the given object and any contained objects, and\n        add them to `tests`.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Finding tests in %s")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "id")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(KEYWORD in)
(ID "seen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "seen")
(PUNCT "[")
(ID "id")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "test")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_test")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "source_lines")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "test")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tests")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "test")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_recurse")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "valname")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "obj")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "valname")
(PUNCT "=")
(LIT "%s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "valname")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(ID "inspect")
(PUNCT ".")
(ID "isroutine")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(KEYWORD or)
(ID "inspect")
(PUNCT ".")
(ID "isclass")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_from_module")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_find")
(PUNCT "(")
(ID "tests")
(PUNCT ",")
(ID "val")
(PUNCT ",")
(ID "valname")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "source_lines")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "seen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_recurse")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "valname")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "__test__")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "valname")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "DocTestFinder.find: __test__ keys ")
(LIT "must be strings: %r")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "valname")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "inspect")
(PUNCT ".")
(ID "isroutine")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(KEYWORD or)
(ID "inspect")
(PUNCT ".")
(ID "isclass")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(KEYWORD or)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(KEYWORD or)
(ID "isinstance")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "DocTestFinder.find: __test__ values ")
(LIT "must be strings, functions, methods, ")
(LIT "classes, or modules: %r")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "valname")
(PUNCT "=")
(LIT "%s.__test__.%s")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "valname")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_find")
(PUNCT "(")
(ID "tests")
(PUNCT ",")
(ID "val")
(PUNCT ",")
(ID "valname")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "source_lines")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "seen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "isclass")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_recurse")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "valname")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "obj")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "staticmethod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "val")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "valname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "classmethod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "val")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "valname")
(PUNCT ")")
(PUNCT ".")
(ID "__func__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(ID "inspect")
(PUNCT ".")
(ID "isroutine")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(KEYWORD or)
(ID "inspect")
(PUNCT ".")
(ID "isclass")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(KEYWORD or)
(ID "isinstance")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "property")
(PUNCT ")")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_from_module")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "valname")
(PUNCT "=")
(LIT "%s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "valname")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_find")
(PUNCT "(")
(ID "tests")
(PUNCT ",")
(ID "val")
(PUNCT ",")
(ID "valname")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "source_lines")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "seen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_get_test")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "source_lines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a DocTest for the given object, if it defines a docstring;\n        otherwise, return None.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "docstring")
(PUNCT "=")
(ID "obj")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "obj")
(PUNCT ".")
(ID "__doc__")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "docstring")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "docstring")
(PUNCT "=")
(ID "obj")
(PUNCT ".")
(ID "__doc__")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "docstring")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "docstring")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "docstring")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "docstring")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "lineno")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_find_lineno")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "source_lines")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exclude_empty")
(KEYWORD and)
(KEYWORD not)
(ID "docstring")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__file__")
(PUNCT ",")
(ID "module")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(PUNCT "[")
(PUNCT "-")
(LIT 4)
(PUNCT ":")
(PUNCT "]")
(KEYWORD in)
(PUNCT "(")
(LIT ".pyc")
(PUNCT ",")
(LIT ".pyo")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "filename")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "get_doctest")
(PUNCT "(")
(ID "docstring")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_find_lineno")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "source_lines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a line number of the given object's docstring.  Note:\n        this method assumes that the object has a docstring.\n        ")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "isclass")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "source_lines")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "pat")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^\\s*class\\s*%s\\b")
(PUNCT "%")
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "__name__")
(PUNCT ",")
(LIT "-")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "line")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "source_lines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pat")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "i")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "ismethod")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(ID "obj")
(PUNCT "=")
(ID "obj")
(PUNCT ".")
(ID "__func__")
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "isfunction")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(ID "obj")
(PUNCT "=")
(ID "obj")
(PUNCT ".")
(ID "__code__")
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "istraceback")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(ID "obj")
(PUNCT "=")
(ID "obj")
(PUNCT ".")
(ID "tb_frame")
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "isframe")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(ID "obj")
(PUNCT "=")
(ID "obj")
(PUNCT ".")
(ID "f_code")
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "iscode")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "co_firstlineno")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "lineno")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "source_lines")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lineno")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "pat")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "(^|.*:)\\s*\\w*(\"|')")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "lineno")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "source_lines")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pat")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "source_lines")
(PUNCT "[")
(ID "lineno")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lineno")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DocTestRunner")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A class used to run DocTest test cases, and accumulate statistics.\n    The `run` method is used to process a single DocTest case.  It\n    returns a tuple `(f, t)`, where `t` is the number of test cases\n    tried, and `f` is the number of test cases that failed.\n\n        >>> tests = DocTestFinder().find(_TestClass)\n        >>> runner = DocTestRunner(verbose=False)\n        >>> tests.sort(key = lambda test: test.name)\n        >>> for test in tests:\n        ...     print(test.name, '->', runner.run(test))\n        _TestClass -> TestResults(failed=0, attempted=2)\n        _TestClass.__init__ -> TestResults(failed=0, attempted=2)\n        _TestClass.get -> TestResults(failed=0, attempted=2)\n        _TestClass.square -> TestResults(failed=0, attempted=1)\n\n    The `summarize` method prints a summary of all the test cases that\n    have been run by the runner, and returns an aggregated `(f, t)`\n    tuple:\n\n        >>> runner.summarize(verbose=1)\n        4 items passed all tests:\n           2 tests in _TestClass\n           2 tests in _TestClass.__init__\n           2 tests in _TestClass.get\n           1 tests in _TestClass.square\n        7 tests in 4 items.\n        7 passed and 0 failed.\n        Test passed.\n        TestResults(failed=0, attempted=7)\n\n    The aggregated number of tried examples and failed examples is\n    also available via the `tries` and `failures` attributes:\n\n        >>> runner.tries\n        7\n        >>> runner.failures\n        0\n\n    The comparison between expected outputs and actual outputs is done\n    by an `OutputChecker`.  This comparison may be customized with a\n    number of option flags; see the documentation for `testmod` for\n    more information.  If the option flags are insufficient, then the\n    comparison may also be customized by passing a subclass of\n    `OutputChecker` to the constructor.\n\n    The test runner's display output can be controlled in two ways.\n    First, an output function (`out) can be passed to\n    `TestRunner.run`; this function will be called with strings that\n    should be displayed.  It defaults to `sys.stdout.write`.  If\n    capturing the output is not sufficient, then the display output\n    can be also customized by subclassing DocTestRunner, and\n    overriding the methods `report_start`, `report_success`,\n    `report_unexpected_exception`, and `report_failure`.\n    ")
(NEWLINE)
(ID "DIVIDER")
(PUNCT "=")
(LIT "*")
(PUNCT "*")
(LIT 70)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "checker")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Create a new test runner.\n\n        Optional keyword arg `checker` is the `OutputChecker` that\n        should be used to compare the expected outputs and actual\n        outputs of doctest examples.\n\n        Optional keyword arg 'verbose' prints lots of stuff if true,\n        only failures if false; by default, it's true iff '-v' is in\n        sys.argv.\n\n        Optional argument `optionflags` can be used to control how the\n        test runner compares expected output to actual output, and how\n        it displays failures.  See the documentation for `testmod` for\n        more information.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checker")
(PUNCT "=")
(ID "checker")
(KEYWORD or)
(ID "OutputChecker")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "verbose")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "verbose")
(PUNCT "=")
(LIT "-v")
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "argv")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_verbose")
(PUNCT "=")
(ID "verbose")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "original_optionflags")
(PUNCT "=")
(ID "optionflags")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tries")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "failures")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_name2ft")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fakeout")
(PUNCT "=")
(ID "_SpoofOut")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "report_start")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Report that the test runner is about to process the given\n        example.  (Only displays a message if verbose=True)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "example")
(PUNCT ".")
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT "(")
(LIT "Trying:\n")
(PUNCT "+")
(ID "_indent")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "source")
(PUNCT ")")
(PUNCT "+")
(LIT "Expecting:\n")
(PUNCT "+")
(ID "_indent")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "want")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT "(")
(LIT "Trying:\n")
(PUNCT "+")
(ID "_indent")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "source")
(PUNCT ")")
(PUNCT "+")
(LIT "Expecting nothing\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "report_success")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Report that the given example ran successfully.  (Only\n        displays a message if verbose=True)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT "(")
(LIT "ok\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "report_failure")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Report that the given example failed.\n        ")
(NEWLINE)
(ID "out")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_failure_header")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_checker")
(PUNCT ".")
(ID "output_difference")
(PUNCT "(")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "report_unexpected_exception")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "exc_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Report that the given example raised an unexpected exception.\n        ")
(NEWLINE)
(ID "out")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_failure_header")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ")")
(PUNCT "+")
(LIT "Exception raised:\n")
(PUNCT "+")
(ID "_indent")
(PUNCT "(")
(ID "_exception_traceback")
(PUNCT "(")
(ID "exc_info")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_failure_header")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT "=")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "DIVIDER")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "test")
(PUNCT ".")
(ID "filename")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "test")
(PUNCT ".")
(ID "lineno")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "example")
(PUNCT ".")
(ID "lineno")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "test")
(PUNCT ".")
(ID "lineno")
(PUNCT "+")
(ID "example")
(PUNCT ".")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(LIT "?")
(NEWLINE)
(DEDENT)
(ID "out")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "File \"%s\", line %s, in %s")
(PUNCT "%")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Line %s, in %s")
(PUNCT "%")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "out")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Failed example:")
(PUNCT ")")
(NEWLINE)
(ID "source")
(PUNCT "=")
(ID "example")
(PUNCT ".")
(ID "source")
(NEWLINE)
(ID "out")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "_indent")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "out")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__run")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "compileflags")
(PUNCT ",")
(ID "out")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Run the examples in `test`.  Write the outcome of each example\n        with one of the `DocTestRunner.report_*` methods, using the\n        writer function `out`.  `compileflags` is the set of compiler\n        flags that should be used to execute examples.  Return a tuple\n        `(f, t)`, where `t` is the number of examples tried, and `f`\n        is the number of examples that failed.  The examples are run\n        in the namespace `test.globs`.\n        ")
(NEWLINE)
(ID "failures")
(PUNCT "=")
(ID "tries")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "original_optionflags")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionflags")
(NEWLINE)
(ID "SUCCESS")
(PUNCT ",")
(ID "FAILURE")
(PUNCT ",")
(ID "BOOM")
(PUNCT "=")
(ID "range")
(PUNCT "(")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(ID "check")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_checker")
(PUNCT ".")
(ID "check_output")
(NEWLINE)
(KEYWORD for)
(ID "examplenum")
(PUNCT ",")
(ID "example")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "examples")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "quiet")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "&")
(ID "REPORT_ONLY_FIRST_FAILURE")
(KEYWORD and)
(ID "failures")
(PUNCT ">")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "=")
(ID "original_optionflags")
(NEWLINE)
(KEYWORD if)
(ID "example")
(PUNCT ".")
(ID "options")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(PUNCT "(")
(ID "optionflag")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(KEYWORD in)
(ID "example")
(PUNCT ".")
(ID "options")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "val")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "|=")
(ID "optionflag")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "&=")
(PUNCT "~")
(ID "optionflag")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "&")
(ID "SKIP")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "tries")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "quiet")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "report_start")
(PUNCT "(")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "filename")
(PUNCT "=")
(LIT "<doctest %s[%d]>")
(PUNCT "%")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "examplenum")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec")
(PUNCT "(")
(ID "compile")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "source")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(LIT "single")
(PUNCT ",")
(ID "compileflags")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "test")
(PUNCT ".")
(ID "globs")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "debugger")
(PUNCT ".")
(ID "set_continue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "exception")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyboardInterrupt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exception")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "debugger")
(PUNCT ".")
(ID "set_continue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "got")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fakeout")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fakeout")
(PUNCT ".")
(ID "truncate")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "outcome")
(PUNCT "=")
(ID "FAILURE")
(NEWLINE)
(KEYWORD if)
(ID "exception")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "check")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "want")
(PUNCT ",")
(ID "got")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outcome")
(PUNCT "=")
(ID "SUCCESS")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_msg")
(PUNCT "=")
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(PUNCT "*")
(ID "exception")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "quiet")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "got")
(PUNCT "+=")
(ID "_exception_traceback")
(PUNCT "(")
(ID "exception")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "example")
(PUNCT ".")
(ID "exc_msg")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outcome")
(PUNCT "=")
(ID "BOOM")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "check")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "exc_msg")
(PUNCT ",")
(ID "exc_msg")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outcome")
(PUNCT "=")
(ID "SUCCESS")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "&")
(ID "IGNORE_EXCEPTION_DETAIL")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "check")
(PUNCT "(")
(ID "_strip_exception_details")
(PUNCT "(")
(ID "example")
(PUNCT ".")
(ID "exc_msg")
(PUNCT ")")
(PUNCT ",")
(ID "_strip_exception_details")
(PUNCT "(")
(ID "exc_msg")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outcome")
(PUNCT "=")
(ID "SUCCESS")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "outcome")
(KEYWORD is)
(ID "SUCCESS")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "quiet")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "report_success")
(PUNCT "(")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "outcome")
(KEYWORD is)
(ID "FAILURE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "quiet")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "report_failure")
(PUNCT "(")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "failures")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "outcome")
(KEYWORD is)
(ID "BOOM")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "quiet")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "report_unexpected_exception")
(PUNCT "(")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "exception")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "failures")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD False)
(PUNCT ",")
(PUNCT "(")
(LIT "unknown outcome")
(PUNCT ",")
(ID "outcome")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "failures")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "&")
(ID "FAIL_FAST")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "optionflags")
(PUNCT "=")
(ID "original_optionflags")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__record_outcome")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "failures")
(PUNCT ",")
(ID "tries")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "TestResults")
(PUNCT "(")
(ID "failures")
(PUNCT ",")
(ID "tries")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__record_outcome")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "f")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Record the fact that the given DocTest (`test`) generated `f`\n        failures out of `t` tried examples.\n        ")
(NEWLINE)
(ID "f2")
(PUNCT ",")
(ID "t2")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_name2ft")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_name2ft")
(PUNCT "[")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "f")
(PUNCT "+")
(ID "f2")
(PUNCT ",")
(ID "t")
(PUNCT "+")
(ID "t2")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "failures")
(PUNCT "+=")
(ID "f")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tries")
(PUNCT "+=")
(ID "t")
(NEWLINE)
(DEDENT)
(ID "__LINECACHE_FILENAME_RE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "<doctest ")
(LIT "(?P<name>.+)")
(LIT "\\[(?P<examplenum>\\d+)\\]>$")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__patched_linecache_getlines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "module_globals")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__LINECACHE_FILENAME_RE")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD and)
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "name")
(PUNCT ")")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "example")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT ".")
(ID "examples")
(PUNCT "[")
(ID "int")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "examplenum")
(PUNCT ")")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "example")
(PUNCT ".")
(ID "source")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(ID "keepends")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "save_linecache_getlines")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "module_globals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "compileflags")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "out")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "clear_globs")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Run the examples in `test`, and display the results using the\n        writer function `out`.\n\n        The examples are run in the namespace `test.globs`.  If\n        `clear_globs` is true (the default), then this namespace will\n        be cleared after the test runs, to help with garbage\n        collection.  If you would like to examine the namespace after\n        the test completes, then use `clear_globs=False`.\n\n        `compileflags` gives the set of flags that should be used by\n        the Python compiler when running the examples.  If not\n        specified, then it will default to the set of future-import\n        flags that apply to `globs`.\n\n        The output of each example is checked using\n        `DocTestRunner.check_output`, and the results are formatted by\n        the `DocTestRunner.report_*` methods.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT "=")
(ID "test")
(NEWLINE)
(KEYWORD if)
(ID "compileflags")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "compileflags")
(PUNCT "=")
(ID "_extract_future_flags")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "globs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "save_stdout")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(KEYWORD if)
(ID "out")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "save_stdout")
(PUNCT ".")
(ID "encoding")
(NEWLINE)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "encoding")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "utf-8")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT "=")
(ID "save_stdout")
(PUNCT ".")
(ID "write")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "out")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(LIT "backslashreplace")
(PUNCT ")")
(PUNCT ",")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(ID "save_stdout")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fakeout")
(NEWLINE)
(ID "save_trace")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "gettrace")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "save_set_trace")
(PUNCT "=")
(ID "pdb")
(PUNCT ".")
(ID "set_trace")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "debugger")
(PUNCT "=")
(ID "_OutputRedirectingPdb")
(PUNCT "(")
(ID "save_stdout")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "debugger")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "pdb")
(PUNCT ".")
(ID "set_trace")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "debugger")
(PUNCT ".")
(ID "set_trace")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "save_linecache_getlines")
(PUNCT "=")
(ID "linecache")
(PUNCT ".")
(ID "getlines")
(NEWLINE)
(ID "linecache")
(PUNCT ".")
(ID "getlines")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__patched_linecache_getlines")
(NEWLINE)
(ID "save_displayhook")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "displayhook")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "displayhook")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "__displayhook__")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__run")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "compileflags")
(PUNCT ",")
(ID "out")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "save_stdout")
(NEWLINE)
(ID "pdb")
(PUNCT ".")
(ID "set_trace")
(PUNCT "=")
(ID "save_set_trace")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "settrace")
(PUNCT "(")
(ID "save_trace")
(PUNCT ")")
(NEWLINE)
(ID "linecache")
(PUNCT ".")
(ID "getlines")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "save_linecache_getlines")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "displayhook")
(PUNCT "=")
(ID "save_displayhook")
(NEWLINE)
(KEYWORD if)
(ID "clear_globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT ".")
(ID "globs")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD import)
(ID "builtins")
(NEWLINE)
(ID "builtins")
(PUNCT ".")
(ID "_")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "summarize")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Print a summary of all the test cases that have been run by\n        this DocTestRunner, and return a tuple `(f, t)`, where `f` is\n        the total number of failed examples, and `t` is the total\n        number of tried examples.\n\n        The optional `verbose` argument controls how detailed the\n        summary is.  If the verbosity is not specified, then the\n        DocTestRunner's verbosity is used.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "verbose")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "verbose")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_verbose")
(NEWLINE)
(DEDENT)
(ID "notests")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "passed")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "failed")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "totalt")
(PUNCT "=")
(ID "totalf")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_name2ft")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT ",")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(PUNCT "=")
(ID "x")
(NEWLINE)
(KEYWORD assert)
(ID "f")
(PUNCT "<=")
(ID "t")
(NEWLINE)
(ID "totalt")
(PUNCT "+=")
(ID "t")
(NEWLINE)
(ID "totalf")
(PUNCT "+=")
(ID "f")
(NEWLINE)
(KEYWORD if)
(ID "t")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "notests")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "f")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "passed")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "failed")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "notests")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "notests")
(PUNCT ")")
(PUNCT ",")
(LIT "items had no tests:")
(PUNCT ")")
(NEWLINE)
(ID "notests")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "thing")
(KEYWORD in)
(ID "notests")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "   ")
(PUNCT ",")
(ID "thing")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "passed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "passed")
(PUNCT ")")
(PUNCT ",")
(LIT "items passed all tests:")
(PUNCT ")")
(NEWLINE)
(ID "passed")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "thing")
(PUNCT ",")
(ID "count")
(KEYWORD in)
(ID "passed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT " %3d tests in %s")
(PUNCT "%")
(PUNCT "(")
(ID "count")
(PUNCT ",")
(ID "thing")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "failed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "DIVIDER")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "failed")
(PUNCT ")")
(PUNCT ",")
(LIT "items had failures:")
(PUNCT ")")
(NEWLINE)
(ID "failed")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "thing")
(PUNCT ",")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(KEYWORD in)
(ID "failed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT " %3d of %3d in %s")
(PUNCT "%")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "t")
(PUNCT ",")
(ID "thing")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "totalt")
(PUNCT ",")
(LIT "tests in")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name2ft")
(PUNCT ")")
(PUNCT ",")
(LIT "items.")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "totalt")
(PUNCT "-")
(ID "totalf")
(PUNCT ",")
(LIT "passed and")
(PUNCT ",")
(ID "totalf")
(PUNCT ",")
(LIT "failed.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "totalf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "***Test Failed***")
(PUNCT ",")
(ID "totalf")
(PUNCT ",")
(LIT "failures.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Test passed.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "TestResults")
(PUNCT "(")
(ID "totalf")
(PUNCT ",")
(ID "totalt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "merge")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_name2ft")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(KEYWORD in)
(ID "other")
(PUNCT ".")
(ID "_name2ft")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "d")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f2")
(PUNCT ",")
(ID "t2")
(PUNCT "=")
(ID "d")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "f")
(PUNCT "+")
(ID "f2")
(NEWLINE)
(ID "t")
(PUNCT "=")
(ID "t")
(PUNCT "+")
(ID "t2")
(NEWLINE)
(DEDENT)
(ID "d")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "f")
(PUNCT ",")
(ID "t")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "OutputChecker")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A class used to check the whether the actual output from a doctest\n    example matches the expected output.  `OutputChecker` defines two\n    methods: `check_output`, which compares a given pair of outputs,\n    and returns true if they match; and `output_difference`, which\n    returns a string describing the differences between two outputs.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "_toAscii")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Convert string to hex-escaped ASCII string.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ASCII")
(PUNCT ",")
(LIT "backslashreplace")
(PUNCT ")")
(PUNCT ",")
(LIT "ASCII")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "check_output")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "want")
(PUNCT ",")
(ID "got")
(PUNCT ",")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return True iff the actual output from an example (`got`)\n        matches the expected output (`want`).  These strings are\n        always considered to match if they are identical; but\n        depending on what option flags the test runner is using,\n        several non-exact match types are also possible.  See the\n        documentation for `TestRunner` for more information about\n        option flags.\n        ")
(NEWLINE)
(ID "got")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_toAscii")
(PUNCT "(")
(ID "got")
(PUNCT ")")
(NEWLINE)
(ID "want")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_toAscii")
(PUNCT "(")
(ID "want")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "got")
(PUNCT "==")
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "optionflags")
(PUNCT "&")
(ID "DONT_ACCEPT_TRUE_FOR_1")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "got")
(PUNCT ",")
(ID "want")
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(LIT "True\n")
(PUNCT ",")
(LIT "1\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(PUNCT "(")
(ID "got")
(PUNCT ",")
(ID "want")
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(LIT "False\n")
(PUNCT ",")
(LIT "0\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "optionflags")
(PUNCT "&")
(ID "DONT_ACCEPT_BLANKLINE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "want")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "(?m)^%s\\s*?$")
(PUNCT "%")
(ID "re")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "BLANKLINE_MARKER")
(PUNCT ")")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(ID "want")
(PUNCT ")")
(NEWLINE)
(ID "got")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "(?m)^\\s*?$")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "got")
(PUNCT "==")
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "optionflags")
(PUNCT "&")
(ID "NORMALIZE_WHITESPACE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "got")
(PUNCT "=")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "got")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "want")
(PUNCT "=")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "want")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "got")
(PUNCT "==")
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "optionflags")
(PUNCT "&")
(ID "ELLIPSIS")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_ellipsis_match")
(PUNCT "(")
(ID "want")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_do_a_fancy_diff")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "want")
(PUNCT ",")
(ID "got")
(PUNCT ",")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "optionflags")
(PUNCT "&")
(PUNCT "(")
(ID "REPORT_UDIFF")
(PUNCT "|")
(ID "REPORT_CDIFF")
(PUNCT "|")
(ID "REPORT_NDIFF")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "optionflags")
(PUNCT "&")
(ID "REPORT_NDIFF")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "want")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ">")
(LIT 2)
(KEYWORD and)
(ID "got")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ">")
(LIT 2)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "output_difference")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ",")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a string describing the differences between the\n        expected output for a given example (`example`) and the actual\n        output (`got`).  `optionflags` is the set of option flags used\n        to compare `want` and `got`.\n        ")
(NEWLINE)
(ID "want")
(PUNCT "=")
(ID "example")
(PUNCT ".")
(ID "want")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "optionflags")
(PUNCT "&")
(ID "DONT_ACCEPT_BLANKLINE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "got")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "(?m)^[ ]*(?=\n)")
(PUNCT ",")
(ID "BLANKLINE_MARKER")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_do_a_fancy_diff")
(PUNCT "(")
(ID "want")
(PUNCT ",")
(ID "got")
(PUNCT ",")
(ID "optionflags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "want_lines")
(PUNCT "=")
(ID "want")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(ID "keepends")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "got_lines")
(PUNCT "=")
(ID "got")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(ID "keepends")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "optionflags")
(PUNCT "&")
(ID "REPORT_UDIFF")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "diff")
(PUNCT "=")
(ID "difflib")
(PUNCT ".")
(ID "unified_diff")
(PUNCT "(")
(ID "want_lines")
(PUNCT ",")
(ID "got_lines")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "diff")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "diff")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "kind")
(PUNCT "=")
(LIT "unified diff with -expected +actual")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "optionflags")
(PUNCT "&")
(ID "REPORT_CDIFF")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "diff")
(PUNCT "=")
(ID "difflib")
(PUNCT ".")
(ID "context_diff")
(PUNCT "(")
(ID "want_lines")
(PUNCT ",")
(ID "got_lines")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "diff")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "diff")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "kind")
(PUNCT "=")
(LIT "context diff with expected followed by actual")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "optionflags")
(PUNCT "&")
(ID "REPORT_NDIFF")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "engine")
(PUNCT "=")
(ID "difflib")
(PUNCT ".")
(ID "Differ")
(PUNCT "(")
(ID "charjunk")
(PUNCT "=")
(ID "difflib")
(PUNCT ".")
(ID "IS_CHARACTER_JUNK")
(PUNCT ")")
(NEWLINE)
(ID "diff")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "engine")
(PUNCT ".")
(ID "compare")
(PUNCT "(")
(ID "want_lines")
(PUNCT ",")
(ID "got_lines")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "kind")
(PUNCT "=")
(LIT "ndiff with -expected +actual")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(LIT 0)
(PUNCT ",")
(LIT "Bad diff option")
(NEWLINE)
(DEDENT)
(ID "diff")
(PUNCT "=")
(PUNCT "[")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT "\n")
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "diff")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(LIT "Differences (%s):\n")
(PUNCT "%")
(ID "kind")
(PUNCT "+")
(ID "_indent")
(PUNCT "(")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "diff")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "want")
(KEYWORD and)
(ID "got")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Expected:\n%sGot:\n%s")
(PUNCT "%")
(PUNCT "(")
(ID "_indent")
(PUNCT "(")
(ID "want")
(PUNCT ")")
(PUNCT ",")
(ID "_indent")
(PUNCT "(")
(ID "got")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Expected:\n%sGot nothing\n")
(PUNCT "%")
(ID "_indent")
(PUNCT "(")
(ID "want")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "got")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Expected nothing\nGot:\n%s")
(PUNCT "%")
(ID "_indent")
(PUNCT "(")
(ID "got")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Expected nothing\nGot nothing\n")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DocTestFailure")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A DocTest example has failed in debugging mode.\n\n    The exception instance has variables:\n\n    - test: the DocTest object being run\n\n    - example: the Example object that failed\n\n    - got: the actual output\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT "=")
(ID "test")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "example")
(PUNCT "=")
(ID "example")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "got")
(PUNCT "=")
(ID "got")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "UnexpectedException")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A DocTest example has encountered an unexpected exception\n\n    The exception instance has variables:\n\n    - test: the DocTest object being run\n\n    - example: the Example object that failed\n\n    - exc_info: the exception info\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "exc_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT "=")
(ID "test")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "example")
(PUNCT "=")
(ID "example")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exc_info")
(PUNCT "=")
(ID "exc_info")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "test")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DebugRunner")
(PUNCT "(")
(ID "DocTestRunner")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Run doc tests but raise an exception as soon as there is a failure.\n\n       If an unexpected exception occurs, an UnexpectedException is raised.\n       It contains the test, the example, and the original exception:\n\n         >>> runner = DebugRunner(verbose=False)\n         >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n         ...                                    {}, 'foo', 'foo.py', 0)\n         >>> try:\n         ...     runner.run(test)\n         ... except UnexpectedException as f:\n         ...     failure = f\n\n         >>> failure.test is test\n         True\n\n         >>> failure.example.want\n         '42\\n'\n\n         >>> exc_info = failure.exc_info\n         >>> raise exc_info[1] # Already has the traceback\n         Traceback (most recent call last):\n         ...\n         KeyError\n\n       We wrap the original exception to give the calling application\n       access to the test and example information.\n\n       If the output doesn't match, then a DocTestFailure is raised:\n\n         >>> test = DocTestParser().get_doctest('''\n         ...      >>> x = 1\n         ...      >>> x\n         ...      2\n         ...      ''', {}, 'foo', 'foo.py', 0)\n\n         >>> try:\n         ...    runner.run(test)\n         ... except DocTestFailure as f:\n         ...    failure = f\n\n       DocTestFailure objects provide access to the test:\n\n         >>> failure.test is test\n         True\n\n       As well as to the example:\n\n         >>> failure.example.want\n         '2\\n'\n\n       and the actual output:\n\n         >>> failure.got\n         '1\\n'\n\n       If a failure or error occurs, the globals are left intact:\n\n         >>> del test.globs['__builtins__']\n         >>> test.globs\n         {'x': 1}\n\n         >>> test = DocTestParser().get_doctest('''\n         ...      >>> x = 2\n         ...      >>> raise KeyError\n         ...      ''', {}, 'foo', 'foo.py', 0)\n\n         >>> runner.run(test)\n         Traceback (most recent call last):\n         ...\n         doctest.UnexpectedException: <DocTest foo from foo.py:0 (2 examples)>\n\n         >>> del test.globs['__builtins__']\n         >>> test.globs\n         {'x': 2}\n\n       But the globals are cleared if there is no error:\n\n         >>> test = DocTestParser().get_doctest('''\n         ...      >>> x = 2\n         ...      ''', {}, 'foo', 'foo.py', 0)\n\n         >>> runner.run(test)\n         TestResults(failed=0, attempted=1)\n\n         >>> test.globs\n         {}\n\n       ")
(NEWLINE)
(KEYWORD def)
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "compileflags")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "out")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "clear_globs")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(ID "DocTestRunner")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "compileflags")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "clear_globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT ".")
(ID "globs")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "report_unexpected_exception")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "exc_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnexpectedException")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "exc_info")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "report_failure")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "out")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DocTestFailure")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "example")
(PUNCT ",")
(ID "got")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "master")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "testmod")
(PUNCT "(")
(ID "m")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "report")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extraglobs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "raise_on_error")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "exclude_empty")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "m=None, name=None, globs=None, verbose=None, report=True,\n       optionflags=0, extraglobs=None, raise_on_error=False,\n       exclude_empty=False\n\n    Test examples in docstrings in functions and classes reachable\n    from module m (or the current module if m is not supplied), starting\n    with m.__doc__.\n\n    Also test examples reachable from dict m.__test__ if it exists and is\n    not None.  m.__test__ maps names to functions, classes and strings;\n    function and class docstrings are tested even if the name is private;\n    strings are tested directly, as if they were docstrings.\n\n    Return (#failures, #tests).\n\n    See help(doctest) for an overview.\n\n    Optional keyword arg \"name\" gives the name of the module; by default\n    use m.__name__.\n\n    Optional keyword arg \"globs\" gives a dict to be used as the globals\n    when executing examples; by default, use m.__dict__.  A copy of this\n    dict is actually used for each docstring, so that each docstring's\n    examples start with a clean slate.\n\n    Optional keyword arg \"extraglobs\" gives a dictionary that should be\n    merged into the globals that are used to execute examples.  By\n    default, no extra globals are used.  This is new in 2.4.\n\n    Optional keyword arg \"verbose\" prints lots of stuff if true, prints\n    only failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\n    Optional keyword arg \"report\" prints a summary at the end when true,\n    else prints nothing at the end.  In verbose mode, the summary is\n    detailed, else very brief (in fact, empty if all tests passed).\n\n    Optional keyword arg \"optionflags\" or's together module constants,\n    and defaults to 0.  This is new in 2.3.  Possible values (see the\n    docs for details):\n\n        DONT_ACCEPT_TRUE_FOR_1\n        DONT_ACCEPT_BLANKLINE\n        NORMALIZE_WHITESPACE\n        ELLIPSIS\n        SKIP\n        IGNORE_EXCEPTION_DETAIL\n        REPORT_UDIFF\n        REPORT_CDIFF\n        REPORT_NDIFF\n        REPORT_ONLY_FIRST_FAILURE\n\n    Optional keyword arg \"raise_on_error\" raises an exception on the\n    first unexpected exception or failure. This allows failures to be\n    post-mortem debugged.\n\n    Advanced tomfoolery:  testmod runs methods of a local instance of\n    class doctest.Tester, then merges the results into (or creates)\n    global Tester instance doctest.master.  Methods of doctest.master\n    can be called directly too, if you want to do something unusual.\n    Passing report=0 to testmod is especially useful then, to delay\n    displaying a summary.  Invoke doctest.master.summarize(verbose)\n    when you're done fiddling.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "master")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "__main__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "m")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "testmod: module required; %r")
(PUNCT "%")
(PUNCT "(")
(ID "m")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(DEDENT)
(ID "finder")
(PUNCT "=")
(ID "DocTestFinder")
(PUNCT "(")
(ID "exclude_empty")
(PUNCT "=")
(ID "exclude_empty")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "raise_on_error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT "=")
(ID "DebugRunner")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT "=")
(ID "DocTestRunner")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "test")
(KEYWORD in)
(ID "finder")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "m")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ",")
(ID "extraglobs")
(PUNCT "=")
(ID "extraglobs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "test")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "report")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT ".")
(ID "summarize")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "master")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "master")
(PUNCT "=")
(ID "runner")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "master")
(PUNCT ".")
(ID "merge")
(PUNCT "(")
(ID "runner")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "TestResults")
(PUNCT "(")
(ID "runner")
(PUNCT ".")
(ID "failures")
(PUNCT ",")
(ID "runner")
(PUNCT ".")
(ID "tries")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "testfile")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "module_relative")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "package")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "report")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extraglobs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "raise_on_error")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(ID "DocTestParser")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Test examples in the given file.  Return (#failures, #tests).\n\n    Optional keyword arg \"module_relative\" specifies how filenames\n    should be interpreted:\n\n      - If \"module_relative\" is True (the default), then \"filename\"\n         specifies a module-relative path.  By default, this path is\n         relative to the calling module's directory; but if the\n         \"package\" argument is specified, then it is relative to that\n         package.  To ensure os-independence, \"filename\" should use\n         \"/\" characters to separate path segments, and should not\n         be an absolute path (i.e., it may not begin with \"/\").\n\n      - If \"module_relative\" is False, then \"filename\" specifies an\n        os-specific path.  The path may be absolute or relative (to\n        the current working directory).\n\n    Optional keyword arg \"name\" gives the name of the test; by default\n    use the file's basename.\n\n    Optional keyword argument \"package\" is a Python package or the\n    name of a Python package whose directory should be used as the\n    base directory for a module relative filename.  If no package is\n    specified, then the calling module's directory is used as the base\n    directory for module relative filenames.  It is an error to\n    specify \"package\" if \"module_relative\" is False.\n\n    Optional keyword arg \"globs\" gives a dict to be used as the globals\n    when executing examples; by default, use {}.  A copy of this dict\n    is actually used for each docstring, so that each docstring's\n    examples start with a clean slate.\n\n    Optional keyword arg \"extraglobs\" gives a dictionary that should be\n    merged into the globals that are used to execute examples.  By\n    default, no extra globals are used.\n\n    Optional keyword arg \"verbose\" prints lots of stuff if true, prints\n    only failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\n    Optional keyword arg \"report\" prints a summary at the end when true,\n    else prints nothing at the end.  In verbose mode, the summary is\n    detailed, else very brief (in fact, empty if all tests passed).\n\n    Optional keyword arg \"optionflags\" or's together module constants,\n    and defaults to 0.  Possible values (see the docs for details):\n\n        DONT_ACCEPT_TRUE_FOR_1\n        DONT_ACCEPT_BLANKLINE\n        NORMALIZE_WHITESPACE\n        ELLIPSIS\n        SKIP\n        IGNORE_EXCEPTION_DETAIL\n        REPORT_UDIFF\n        REPORT_CDIFF\n        REPORT_NDIFF\n        REPORT_ONLY_FIRST_FAILURE\n\n    Optional keyword arg \"raise_on_error\" raises an exception on the\n    first unexpected exception or failure. This allows failures to be\n    post-mortem debugged.\n\n    Optional keyword arg \"parser\" specifies a DocTestParser (or\n    subclass) that should be used to extract tests from the files.\n\n    Optional keyword arg \"encoding\" specifies an encoding that should\n    be used to convert the file to unicode.\n\n    Advanced tomfoolery:  testmod runs methods of a local instance of\n    class doctest.Tester, then merges the results into (or creates)\n    global Tester instance doctest.master.  Methods of doctest.master\n    can be called directly too, if you want to do something unusual.\n    Passing report=0 to testmod is especially useful then, to delay\n    displaying a summary.  Invoke doctest.master.summarize(verbose)\n    when you're done fiddling.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "master")
(NEWLINE)
(KEYWORD if)
(ID "package")
(KEYWORD and)
(KEYWORD not)
(ID "module_relative")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Package may only be specified for module-")
(LIT "relative paths.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT ",")
(ID "filename")
(PUNCT "=")
(ID "_load_testfile")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "package")
(PUNCT ",")
(ID "module_relative")
(PUNCT ",")
(ID "encoding")
(KEYWORD or)
(LIT "utf-8")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "globs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "extraglobs")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "extraglobs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "__name__")
(KEYWORD not)
(KEYWORD in)
(ID "globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "[")
(LIT "__name__")
(PUNCT "]")
(PUNCT "=")
(LIT "__main__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "raise_on_error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT "=")
(ID "DebugRunner")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT "=")
(ID "DocTestRunner")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "test")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "get_doctest")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "runner")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "test")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "report")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT ".")
(ID "summarize")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "master")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "master")
(PUNCT "=")
(ID "runner")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "master")
(PUNCT ".")
(ID "merge")
(PUNCT "(")
(ID "runner")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "TestResults")
(PUNCT "(")
(ID "runner")
(PUNCT ".")
(ID "failures")
(PUNCT ",")
(ID "runner")
(PUNCT ".")
(ID "tries")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "run_docstring_examples")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "name")
(PUNCT "=")
(LIT "NoName")
(PUNCT ",")
(ID "compileflags")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Test examples in the given object's docstring (`f`), using `globs`\n    as globals.  Optional argument `name` is used in failure messages.\n    If the optional argument `verbose` is true, then generate output\n    even if there are no failures.\n\n    `compileflags` gives the set of flags that should be used by the\n    Python compiler when running the examples.  If not specified, then\n    it will default to the set of future-import flags that apply to\n    `globs`.\n\n    Optional keyword arg `optionflags` specifies options for the\n    testing and output.  See the documentation for `testmod` for more\n    information.\n    ")
(NEWLINE)
(ID "finder")
(PUNCT "=")
(ID "DocTestFinder")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "recurse")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "runner")
(PUNCT "=")
(ID "DocTestRunner")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "test")
(KEYWORD in)
(ID "finder")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "compileflags")
(PUNCT "=")
(ID "compileflags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_unittest_reportflags")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD def)
(ID "set_unittest_reportflags")
(PUNCT "(")
(ID "flags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Sets the unittest option flags.\n\n    The old flag is returned so that a runner could restore the old\n    value if it wished to:\n\n      >>> import doctest\n      >>> old = doctest._unittest_reportflags\n      >>> doctest.set_unittest_reportflags(REPORT_NDIFF |\n      ...                          REPORT_ONLY_FIRST_FAILURE) == old\n      True\n\n      >>> doctest._unittest_reportflags == (REPORT_NDIFF |\n      ...                                   REPORT_ONLY_FIRST_FAILURE)\n      True\n\n    Only reporting flags can be set:\n\n      >>> doctest.set_unittest_reportflags(ELLIPSIS)\n      Traceback (most recent call last):\n      ...\n      ValueError: ('Only reporting flags allowed', 8)\n\n      >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |\n      ...                                   REPORT_ONLY_FIRST_FAILURE)\n      True\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_unittest_reportflags")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "flags")
(PUNCT "&")
(ID "REPORTING_FLAGS")
(PUNCT ")")
(PUNCT "!=")
(ID "flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Only reporting flags allowed")
(PUNCT ",")
(ID "flags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "old")
(PUNCT "=")
(ID "_unittest_reportflags")
(NEWLINE)
(ID "_unittest_reportflags")
(PUNCT "=")
(ID "flags")
(NEWLINE)
(KEYWORD return)
(ID "old")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "DocTestCase")
(PUNCT "(")
(ID "unittest")
(PUNCT ".")
(ID "TestCase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "test")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "setUp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "tearDown")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "checker")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "unittest")
(PUNCT ".")
(ID "TestCase")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_dt_optionflags")
(PUNCT "=")
(ID "optionflags")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_dt_checker")
(PUNCT "=")
(ID "checker")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT "=")
(ID "test")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_dt_setUp")
(PUNCT "=")
(ID "setUp")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_dt_tearDown")
(PUNCT "=")
(ID "tearDown")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setUp")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_dt_setUp")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_dt_setUp")
(PUNCT "(")
(ID "test")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "tearDown")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_dt_tearDown")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_dt_tearDown")
(PUNCT "(")
(ID "test")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "test")
(PUNCT ".")
(ID "globs")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "runTest")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(NEWLINE)
(ID "old")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(ID "new")
(PUNCT "=")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "optionflags")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_optionflags")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "optionflags")
(PUNCT "&")
(ID "REPORTING_FLAGS")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "optionflags")
(PUNCT "|=")
(ID "_unittest_reportflags")
(NEWLINE)
(DEDENT)
(ID "runner")
(PUNCT "=")
(ID "DocTestRunner")
(PUNCT "(")
(ID "optionflags")
(PUNCT "=")
(ID "optionflags")
(PUNCT ",")
(ID "checker")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_checker")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runner")
(PUNCT ".")
(ID "DIVIDER")
(PUNCT "=")
(LIT "-")
(PUNCT "*")
(LIT 70)
(NEWLINE)
(ID "failures")
(PUNCT ",")
(ID "tries")
(PUNCT "=")
(ID "runner")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(ID "out")
(PUNCT "=")
(ID "new")
(PUNCT ".")
(ID "write")
(PUNCT ",")
(ID "clear_globs")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "old")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "failures")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "self")
(PUNCT ".")
(ID "failureException")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "format_failure")
(PUNCT "(")
(ID "new")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "format_failure")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(NEWLINE)
(KEYWORD if)
(ID "test")
(PUNCT ".")
(ID "lineno")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(LIT "unknown line number")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(LIT "%s")
(PUNCT "%")
(ID "test")
(PUNCT ".")
(ID "lineno")
(NEWLINE)
(DEDENT)
(ID "lname")
(PUNCT "=")
(LIT ".")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(LIT "Failed doctest test for %s\n")
(LIT "  File \"%s\", line %s, in %s\n\n%s")
(PUNCT "%")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "test")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "lname")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Run the test case without results and without catching exceptions\n\n           The unit test framework includes a debug method on test cases\n           and test suites to support post-mortem debugging.  The test code\n           is run in such a way that errors are not caught.  This way a\n           caller can catch the errors and initiate post-mortem debugging.\n\n           The DocTestCase provides a debug method that raises\n           UnexpectedException errors if there is an unexpected\n           exception:\n\n             >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n             ...                {}, 'foo', 'foo.py', 0)\n             >>> case = DocTestCase(test)\n             >>> try:\n             ...     case.debug()\n             ... except UnexpectedException as f:\n             ...     failure = f\n\n           The UnexpectedException contains the test, the example, and\n           the original exception:\n\n             >>> failure.test is test\n             True\n\n             >>> failure.example.want\n             '42\\n'\n\n             >>> exc_info = failure.exc_info\n             >>> raise exc_info[1] # Already has the traceback\n             Traceback (most recent call last):\n             ...\n             KeyError\n\n           If the output doesn't match, then a DocTestFailure is raised:\n\n             >>> test = DocTestParser().get_doctest('''\n             ...      >>> x = 1\n             ...      >>> x\n             ...      2\n             ...      ''', {}, 'foo', 'foo.py', 0)\n             >>> case = DocTestCase(test)\n\n             >>> try:\n             ...    case.debug()\n             ... except DocTestFailure as f:\n             ...    failure = f\n\n           DocTestFailure objects provide access to the test:\n\n             >>> failure.test is test\n             True\n\n           As well as to the example:\n\n             >>> failure.example.want\n             '2\\n'\n\n           and the actual output:\n\n             >>> failure.got\n             '1\\n'\n\n           ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "setUp")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "runner")
(PUNCT "=")
(ID "DebugRunner")
(PUNCT "(")
(ID "optionflags")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_optionflags")
(PUNCT ",")
(ID "checker")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_checker")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "runner")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ",")
(ID "clear_globs")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tearDown")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "id")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(ID "type")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_dt_test")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_dt_optionflags")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_dt_optionflags")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_dt_setUp")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_dt_setUp")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_dt_tearDown")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_dt_tearDown")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_dt_checker")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_dt_checker")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_dt_optionflags")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_dt_setUp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_dt_tearDown")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_dt_checker")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "name")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "%s (%s)")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(LIT ".")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "name")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__str__")
(PUNCT "=")
(ID "__repr__")
(NEWLINE)
(KEYWORD def)
(ID "shortDescription")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Doctest: ")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "SkipDocTestCase")
(PUNCT "(")
(ID "DocTestCase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "module")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "module")
(PUNCT "=")
(ID "module")
(NEWLINE)
(ID "DocTestCase")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setUp")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "skipTest")
(PUNCT "(")
(LIT "DocTestSuite will not work with -O2 and above")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "test_skip")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shortDescription")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Skipping tests from %s")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "module")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(DEDENT)
(ID "__str__")
(PUNCT "=")
(ID "shortDescription")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_DocTestSuite")
(PUNCT "(")
(ID "unittest")
(PUNCT ".")
(ID "TestSuite")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "_removeTestAtIndex")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "DocTestSuite")
(PUNCT "(")
(ID "module")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extraglobs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "test_finder")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "options")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Convert doctest tests for a module to a unittest test suite.\n\n    This converts each documentation string in a module that\n    contains doctest tests to a unittest test case.  If any of the\n    tests in a doc string fail, then the test case fails.  An exception\n    is raised showing the name of the file containing the test and a\n    (sometimes approximate) line number.\n\n    The `module` argument provides the module to be tested.  The argument\n    can be either a module or a module name.\n\n    If no argument is given, the calling module is used.\n\n    A number of options may be provided as keyword arguments:\n\n    setUp\n      A set-up function.  This is called before running the\n      tests in each file. The setUp function will be passed a DocTest\n      object.  The setUp function can access the test globals as the\n      globs attribute of the test passed.\n\n    tearDown\n      A tear-down function.  This is called after running the\n      tests in each file.  The tearDown function will be passed a DocTest\n      object.  The tearDown function can access the test globals as the\n      globs attribute of the test passed.\n\n    globs\n      A dictionary containing initial global variables for the tests.\n\n    optionflags\n       A set of doctest option flags expressed as an integer.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "test_finder")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test_finder")
(PUNCT "=")
(ID "DocTestFinder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "module")
(PUNCT "=")
(ID "_normalize_module")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(NEWLINE)
(ID "tests")
(PUNCT "=")
(ID "test_finder")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ",")
(ID "extraglobs")
(PUNCT "=")
(ID "extraglobs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "tests")
(KEYWORD and)
(ID "sys")
(PUNCT ".")
(ID "flags")
(PUNCT ".")
(ID "optimize")
(PUNCT ">=")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "suite")
(PUNCT "=")
(ID "_DocTestSuite")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "suite")
(PUNCT ".")
(ID "addTest")
(PUNCT "(")
(ID "SkipDocTestCase")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "suite")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "tests")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "has no docstrings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "tests")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "suite")
(PUNCT "=")
(ID "_DocTestSuite")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "test")
(KEYWORD in)
(ID "tests")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "examples")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "test")
(PUNCT ".")
(ID "filename")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__file__")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(PUNCT "[")
(PUNCT "-")
(LIT 4)
(PUNCT ":")
(PUNCT "]")
(KEYWORD in)
(PUNCT "(")
(LIT ".pyc")
(PUNCT ",")
(LIT ".pyo")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "filename")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "test")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(DEDENT)
(ID "suite")
(PUNCT ".")
(ID "addTest")
(PUNCT "(")
(ID "DocTestCase")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(PUNCT "**")
(ID "options")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "suite")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "DocFileCase")
(PUNCT "(")
(ID "DocTestCase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "id")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "_")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "name")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "filename")
(NEWLINE)
(DEDENT)
(ID "__str__")
(PUNCT "=")
(ID "__repr__")
(NEWLINE)
(KEYWORD def)
(ID "format_failure")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(LIT "Failed doctest test for %s\n  File \"%s\", line 0\n\n%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_dt_test")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "DocFileTest")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "module_relative")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "package")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(ID "DocTestParser")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "options")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "globs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "package")
(KEYWORD and)
(KEYWORD not)
(ID "module_relative")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Package may only be specified for module-")
(LIT "relative paths.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "doc")
(PUNCT ",")
(ID "path")
(PUNCT "=")
(ID "_load_testfile")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "package")
(PUNCT ",")
(ID "module_relative")
(PUNCT ",")
(ID "encoding")
(KEYWORD or)
(LIT "utf-8")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "__file__")
(KEYWORD not)
(KEYWORD in)
(ID "globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "[")
(LIT "__file__")
(PUNCT "]")
(PUNCT "=")
(ID "path")
(NEWLINE)
(DEDENT)
(ID "name")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(ID "test")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "get_doctest")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "DocFileCase")
(PUNCT "(")
(ID "test")
(PUNCT ",")
(PUNCT "**")
(ID "options")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "DocFileSuite")
(PUNCT "(")
(PUNCT "*")
(ID "paths")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A unittest suite for one or more doctest files.\n\n    The path to each doctest file is given as a string; the\n    interpretation of that string depends on the keyword argument\n    \"module_relative\".\n\n    A number of options may be provided as keyword arguments:\n\n    module_relative\n      If \"module_relative\" is True, then the given file paths are\n      interpreted as os-independent module-relative paths.  By\n      default, these paths are relative to the calling module's\n      directory; but if the \"package\" argument is specified, then\n      they are relative to that package.  To ensure os-independence,\n      \"filename\" should use \"/\" characters to separate path\n      segments, and may not be an absolute path (i.e., it may not\n      begin with \"/\").\n\n      If \"module_relative\" is False, then the given file paths are\n      interpreted as os-specific paths.  These paths may be absolute\n      or relative (to the current working directory).\n\n    package\n      A Python package or the name of a Python package whose directory\n      should be used as the base directory for module relative paths.\n      If \"package\" is not specified, then the calling module's\n      directory is used as the base directory for module relative\n      filenames.  It is an error to specify \"package\" if\n      \"module_relative\" is False.\n\n    setUp\n      A set-up function.  This is called before running the\n      tests in each file. The setUp function will be passed a DocTest\n      object.  The setUp function can access the test globals as the\n      globs attribute of the test passed.\n\n    tearDown\n      A tear-down function.  This is called after running the\n      tests in each file.  The tearDown function will be passed a DocTest\n      object.  The tearDown function can access the test globals as the\n      globs attribute of the test passed.\n\n    globs\n      A dictionary containing initial global variables for the tests.\n\n    optionflags\n      A set of doctest option flags expressed as an integer.\n\n    parser\n      A DocTestParser (or subclass) that should be used to extract\n      tests from the files.\n\n    encoding\n      An encoding that will be used to convert the files to unicode.\n    ")
(NEWLINE)
(ID "suite")
(PUNCT "=")
(ID "_DocTestSuite")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "kw")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "module_relative")
(PUNCT ",")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kw")
(PUNCT "[")
(LIT "package")
(PUNCT "]")
(PUNCT "=")
(ID "_normalize_module")
(PUNCT "(")
(ID "kw")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "package")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "path")
(KEYWORD in)
(ID "paths")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "suite")
(PUNCT ".")
(ID "addTest")
(PUNCT "(")
(ID "DocFileTest")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "suite")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "script_from_examples")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Extract script from text with examples.\n\n       Converts text with examples to a Python script.  Example input is\n       converted to regular code.  Example output and all other words\n       are converted to comments:\n\n       >>> text = '''\n       ...       Here are examples of simple math.\n       ...\n       ...           Python has super accurate integer addition\n       ...\n       ...           >>> 2 + 2\n       ...           5\n       ...\n       ...           And very friendly error messages:\n       ...\n       ...           >>> 1/0\n       ...           To Infinity\n       ...           And\n       ...           Beyond\n       ...\n       ...           You can use logic if you want:\n       ...\n       ...           >>> if 0:\n       ...           ...    blah\n       ...           ...    blah\n       ...           ...\n       ...\n       ...           Ho hum\n       ...           '''\n\n       >>> print(script_from_examples(text))\n       # Here are examples of simple math.\n       #\n       #     Python has super accurate integer addition\n       #\n       2 + 2\n       # Expected:\n       ## 5\n       #\n       #     And very friendly error messages:\n       #\n       1/0\n       # Expected:\n       ## To Infinity\n       ## And\n       ## Beyond\n       #\n       #     You can use logic if you want:\n       #\n       if 0:\n          blah\n          blah\n       #\n       #     Ho hum\n       <BLANKLINE>\n       ")
(NEWLINE)
(ID "output")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "piece")
(KEYWORD in)
(ID "DocTestParser")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "parse")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "piece")
(PUNCT ",")
(ID "Example")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "piece")
(PUNCT ".")
(ID "source")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "want")
(PUNCT "=")
(ID "piece")
(PUNCT ".")
(ID "want")
(NEWLINE)
(KEYWORD if)
(ID "want")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "# Expected:")
(PUNCT ")")
(NEWLINE)
(ID "output")
(PUNCT "+=")
(PUNCT "[")
(LIT "## ")
(PUNCT "+")
(ID "l")
(KEYWORD for)
(ID "l")
(KEYWORD in)
(ID "want")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "+=")
(PUNCT "[")
(ID "_comment_line")
(PUNCT "(")
(ID "l")
(PUNCT ")")
(KEYWORD for)
(ID "l")
(KEYWORD in)
(ID "piece")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD while)
(ID "output")
(KEYWORD and)
(ID "output")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "#")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "output")
(KEYWORD and)
(ID "output")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "#")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "output")
(PUNCT ")")
(PUNCT "+")
(LIT "\n")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "testsource")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Extract the test sources from a doctest docstring as a script.\n\n    Provide the module (or dotted name of the module) containing the\n    test to be debugged and the name (within the module) of the object\n    with the doc string with tests to be debugged.\n    ")
(NEWLINE)
(ID "module")
(PUNCT "=")
(ID "_normalize_module")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(NEWLINE)
(ID "tests")
(PUNCT "=")
(ID "DocTestFinder")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(NEWLINE)
(ID "test")
(PUNCT "=")
(PUNCT "[")
(ID "t")
(KEYWORD for)
(ID "t")
(KEYWORD in)
(ID "tests")
(KEYWORD if)
(ID "t")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "name")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "test")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(LIT "not found in tests")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "test")
(PUNCT "=")
(ID "test")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "testsrc")
(PUNCT "=")
(ID "script_from_examples")
(PUNCT "(")
(ID "test")
(PUNCT ".")
(ID "docstring")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "testsrc")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug_src")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "pm")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Debug a single doctest docstring, in argument `src`'")
(NEWLINE)
(ID "testsrc")
(PUNCT "=")
(ID "script_from_examples")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(ID "debug_script")
(PUNCT "(")
(ID "testsrc")
(PUNCT ",")
(ID "pm")
(PUNCT ",")
(ID "globs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug_script")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "pm")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "globs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Debug a test script.  `src` is the script, as a string.")
(NEWLINE)
(KEYWORD import)
(ID "pdb")
(NEWLINE)
(KEYWORD if)
(ID "globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(ID "globs")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "globs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pm")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "globs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "p")
(PUNCT "=")
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT "(")
(ID "nosigint")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "p")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "p")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pdb")
(PUNCT ".")
(ID "Pdb")
(PUNCT "(")
(ID "nosigint")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(LIT "exec(%r)")
(PUNCT "%")
(ID "src")
(PUNCT ",")
(ID "globs")
(PUNCT ",")
(ID "globs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "debug")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "pm")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Debug a single doctest docstring.\n\n    Provide the module (or dotted name of the module) containing the\n    test to be debugged and the name (within the module) of the object\n    with the docstring with tests to be debugged.\n    ")
(NEWLINE)
(ID "module")
(PUNCT "=")
(ID "_normalize_module")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(NEWLINE)
(ID "testsrc")
(PUNCT "=")
(ID "testsource")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "debug_script")
(PUNCT "(")
(ID "testsrc")
(PUNCT ",")
(ID "pm")
(PUNCT ",")
(ID "module")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_TestClass")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A pointless class, for sanity-checking of docstring testing.\n\n    Methods:\n        square()\n        get()\n\n    >>> _TestClass(13).get() + _TestClass(-12).get()\n    1\n    >>> hex(_TestClass(13).square().get())\n    '0xa9'\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "val -> _TestClass object with associated value val.\n\n        >>> t = _TestClass(123)\n        >>> print(t.get())\n        123\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "val")
(PUNCT "=")
(ID "val")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "square")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "square() -> square TestClass's associated value\n\n        >>> _TestClass(13).square().get()\n        169\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "val")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "val")
(PUNCT "**")
(LIT 2)
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "get() -> return TestClass's associated value.\n\n        >>> x = _TestClass(-42)\n        >>> print(x.get())\n        -42\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "val")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "__test__")
(PUNCT "=")
(PUNCT "{")
(LIT "_TestClass")
(PUNCT ":")
(ID "_TestClass")
(PUNCT ",")
(LIT "string")
(PUNCT ":")
(LIT "\n                      Example of a string object, searched as-is.\n                      >>> x = 1; y = 2\n                      >>> x + y, x * y\n                      (3, 2)\n                      ")
(PUNCT ",")
(LIT "bool-int equivalence")
(PUNCT ":")
(LIT "\n                                    In 2.2, boolean expressions displayed\n                                    0 or 1.  By default, we still accept\n                                    them.  This can be disabled by passing\n                                    DONT_ACCEPT_TRUE_FOR_1 to the new\n                                    optionflags argument.\n                                    >>> 4 == 4\n                                    1\n                                    >>> 4 == 4\n                                    True\n                                    >>> 4 > 4\n                                    0\n                                    >>> 4 > 4\n                                    False\n                                    ")
(PUNCT ",")
(LIT "blank lines")
(PUNCT ":")
(LIT "\n                Blank lines can be marked with <BLANKLINE>:\n                    >>> print('foo\\n\\nbar\\n')\n                    foo\n                    <BLANKLINE>\n                    bar\n                    <BLANKLINE>\n            ")
(PUNCT ",")
(LIT "ellipsis")
(PUNCT ":")
(LIT "\n                If the ellipsis flag is used, then '...' can be used to\n                elide substrings in the desired output:\n                    >>> print(list(range(1000))) #doctest: +ELLIPSIS\n                    [0, 1, 2, ..., 999]\n            ")
(PUNCT ",")
(LIT "whitespace normalization")
(PUNCT ":")
(LIT "\n                If the whitespace normalization flag is used, then\n                differences in whitespace are ignored.\n                    >>> print(list(range(30))) #doctest: +NORMALIZE_WHITESPACE\n                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n                     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\n                     27, 28, 29]\n            ")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "argparse")
(PUNCT ".")
(ID "ArgumentParser")
(PUNCT "(")
(ID "description")
(PUNCT "=")
(LIT "doctest runner")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-v")
(PUNCT ",")
(LIT "--verbose")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "store_true")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "print very verbose output for all tests")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-o")
(PUNCT ",")
(LIT "--option")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "append")
(PUNCT ",")
(ID "choices")
(PUNCT "=")
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(PUNCT "(")
(LIT "specify a doctest option flag to apply")
(LIT " to the test run; may be specified more")
(LIT " than once to apply multiple options")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-f")
(PUNCT ",")
(LIT "--fail-fast")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "store_true")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(PUNCT "(")
(LIT "stop running tests after first failure (this")
(LIT " is a shorthand for -o FAIL_FAST, and is")
(LIT " in addition to any other -o options)")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "file")
(PUNCT ",")
(ID "nargs")
(PUNCT "=")
(LIT "+")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "file containing the tests to run")
(PUNCT ")")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "parse_args")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "testfiles")
(PUNCT "=")
(ID "args")
(PUNCT ".")
(ID "file")
(NEWLINE)
(ID "verbose")
(PUNCT "=")
(ID "args")
(PUNCT ".")
(ID "verbose")
(NEWLINE)
(ID "options")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "option")
(KEYWORD in)
(ID "args")
(PUNCT ".")
(ID "option")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "options")
(PUNCT "|=")
(ID "OPTIONFLAGS_BY_NAME")
(PUNCT "[")
(ID "option")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "args")
(PUNCT ".")
(ID "fail_fast")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "options")
(PUNCT "|=")
(ID "FAIL_FAST")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "filename")
(KEYWORD in)
(ID "testfiles")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "filename")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT ".py")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirname")
(PUNCT ",")
(ID "filename")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "dirname")
(PUNCT ")")
(NEWLINE)
(ID "m")
(PUNCT "=")
(ID "__import__")
(PUNCT "(")
(ID "filename")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 3)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "sys")
(PUNCT ".")
(ID "path")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "failures")
(PUNCT ",")
(ID "_")
(PUNCT "=")
(ID "testmod")
(PUNCT "(")
(ID "m")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "options")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "failures")
(PUNCT ",")
(ID "_")
(PUNCT "=")
(ID "testfile")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "module_relative")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(PUNCT ",")
(ID "optionflags")
(PUNCT "=")
(ID "options")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "failures")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "exit")
(PUNCT "(")
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
