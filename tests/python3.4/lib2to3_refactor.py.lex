(LIT "Refactoring framework.\n\nUsed as a main program, this can refactor any number of files and/or\nrecursively descend down directories.  Imported as a module, this\nprovides infrastructure to write your own refactoring tool.\n")
(NEWLINE)
(KEYWORD from)
(ID "__future__")
(KEYWORD import)
(ID "with_statement")
(NEWLINE)
(ID "__author__")
(PUNCT "=")
(LIT "Guido van Rossum <guido@python.org>")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "logging")
(NEWLINE)
(KEYWORD import)
(ID "operator")
(NEWLINE)
(KEYWORD import)
(ID "collections")
(NEWLINE)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD from)
(ID "itertools")
(KEYWORD import)
(ID "chain")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "pgen2")
(KEYWORD import)
(ID "driver")
(PUNCT ",")
(ID "tokenize")
(PUNCT ",")
(ID "token")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "fixer_util")
(KEYWORD import)
(ID "find_root")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "pytree")
(PUNCT ",")
(ID "pygram")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "btm_utils")
(KEYWORD as)
(ID "bu")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "btm_matcher")
(KEYWORD as)
(ID "bm")
(NEWLINE)
(KEYWORD def)
(ID "get_all_fix_names")
(PUNCT "(")
(ID "fixer_pkg")
(PUNCT ",")
(ID "remove_prefix")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a sorted list of all available fix names in the given package.")
(NEWLINE)
(ID "pkg")
(PUNCT "=")
(ID "__import__")
(PUNCT "(")
(ID "fixer_pkg")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(LIT "*")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "fixer_dir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "pkg")
(PUNCT ".")
(ID "__file__")
(PUNCT ")")
(NEWLINE)
(ID "fix_names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "sorted")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "fixer_dir")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "fix_")
(PUNCT ")")
(KEYWORD and)
(ID "name")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT ".py")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "remove_prefix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "name")
(PUNCT "[")
(LIT 4)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "fix_names")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 3)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "fix_names")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_EveryNode")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_head_types")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Accepts a pytree Pattern Node and returns a set\n        of the pattern types which will match first. ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(PUNCT "(")
(ID "pytree")
(PUNCT ".")
(ID "NodePattern")
(PUNCT ",")
(ID "pytree")
(PUNCT ".")
(ID "LeafPattern")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pat")
(PUNCT ".")
(ID "type")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "_EveryNode")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "{")
(ID "pat")
(PUNCT ".")
(ID "type")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(ID "pytree")
(PUNCT ".")
(ID "NegatedPattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pat")
(PUNCT ".")
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_get_head_types")
(PUNCT "(")
(ID "pat")
(PUNCT ".")
(ID "content")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "_EveryNode")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(ID "pytree")
(PUNCT ".")
(ID "WildcardPattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "pat")
(PUNCT ".")
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "p")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "_get_head_types")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "Exception")
(PUNCT "(")
(LIT "Oh no! I don't understand pattern %s")
(PUNCT "%")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_headnode_dict")
(PUNCT "(")
(ID "fixer_list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Accepts a list of fixers and returns a dictionary\n        of head node type --> fixer list.  ")
(NEWLINE)
(ID "head_nodes")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "defaultdict")
(PUNCT "(")
(ID "list")
(PUNCT ")")
(NEWLINE)
(ID "every")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "fixer")
(KEYWORD in)
(ID "fixer_list")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fixer")
(PUNCT ".")
(ID "pattern")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "heads")
(PUNCT "=")
(ID "_get_head_types")
(PUNCT "(")
(ID "fixer")
(PUNCT ".")
(ID "pattern")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "_EveryNode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "every")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "node_type")
(KEYWORD in)
(ID "heads")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "head_nodes")
(PUNCT "[")
(ID "node_type")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fixer")
(PUNCT ".")
(ID "_accept_type")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "head_nodes")
(PUNCT "[")
(ID "fixer")
(PUNCT ".")
(ID "_accept_type")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "every")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "node_type")
(KEYWORD in)
(ID "chain")
(PUNCT "(")
(ID "pygram")
(PUNCT ".")
(ID "python_grammar")
(PUNCT ".")
(ID "symbol2number")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "pygram")
(PUNCT ".")
(ID "python_grammar")
(PUNCT ".")
(ID "tokens")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "head_nodes")
(PUNCT "[")
(ID "node_type")
(PUNCT "]")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "every")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "dict")
(PUNCT "(")
(ID "head_nodes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_fixers_from_package")
(PUNCT "(")
(ID "pkg_name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the fully qualified names for fixers in the package pkg_name.\n    ")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "pkg_name")
(PUNCT "+")
(LIT ".")
(PUNCT "+")
(ID "fix_name")
(KEYWORD for)
(ID "fix_name")
(KEYWORD in)
(ID "get_all_fix_names")
(PUNCT "(")
(ID "pkg_name")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_identity")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "obj")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "version_info")
(PUNCT "<")
(PUNCT "(")
(LIT 3)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "codecs")
(NEWLINE)
(ID "_open_with_encoding")
(PUNCT "=")
(ID "codecs")
(PUNCT ".")
(ID "open")
(NEWLINE)
(KEYWORD def)
(ID "_from_system_newlines")
(PUNCT "(")
(ID "input")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "input")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\r\n")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_to_system_newlines")
(PUNCT "(")
(ID "input")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "linesep")
(PUNCT "!=")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "input")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "linesep")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "input")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_open_with_encoding")
(PUNCT "=")
(ID "open")
(NEWLINE)
(ID "_from_system_newlines")
(PUNCT "=")
(ID "_identity")
(NEWLINE)
(ID "_to_system_newlines")
(PUNCT "=")
(ID "_identity")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_detect_future_features")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "have_docstring")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "gen")
(PUNCT "=")
(ID "tokenize")
(PUNCT ".")
(ID "generate_tokens")
(PUNCT "(")
(ID "io")
(PUNCT ".")
(ID "StringIO")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT ".")
(ID "readline")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tok")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "gen")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "tok")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "tok")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "ignore")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(PUNCT "{")
(ID "token")
(PUNCT ".")
(ID "NEWLINE")
(PUNCT ",")
(ID "tokenize")
(PUNCT ".")
(ID "NL")
(PUNCT ",")
(ID "token")
(PUNCT ".")
(ID "COMMENT")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(ID "features")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "tp")
(KEYWORD in)
(ID "ignore")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tp")
(PUNCT "==")
(ID "token")
(PUNCT ".")
(ID "STRING")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "have_docstring")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "have_docstring")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tp")
(PUNCT "==")
(ID "token")
(PUNCT ".")
(ID "NAME")
(KEYWORD and)
(ID "value")
(PUNCT "==")
(LIT "from")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "tp")
(PUNCT "!=")
(ID "token")
(PUNCT ".")
(ID "NAME")
(KEYWORD or)
(ID "value")
(PUNCT "!=")
(LIT "__future__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "tp")
(PUNCT "!=")
(ID "token")
(PUNCT ".")
(ID "NAME")
(KEYWORD or)
(ID "value")
(PUNCT "!=")
(LIT "import")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "tp")
(PUNCT "==")
(ID "token")
(PUNCT ".")
(ID "OP")
(KEYWORD and)
(ID "value")
(PUNCT "==")
(LIT "(")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "tp")
(PUNCT "==")
(ID "token")
(PUNCT ".")
(ID "NAME")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "features")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "tp")
(PUNCT "!=")
(ID "token")
(PUNCT ".")
(ID "OP")
(KEYWORD or)
(ID "value")
(PUNCT "!=")
(LIT ",")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "tp")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "advance")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "frozenset")
(PUNCT "(")
(ID "features")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "FixerError")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A fixer could not be loaded.")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "RefactoringTool")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_default_options")
(PUNCT "=")
(PUNCT "{")
(LIT "print_function")
(PUNCT ":")
(KEYWORD False)
(PUNCT ",")
(LIT "write_unchanged_files")
(PUNCT ":")
(KEYWORD False)
(PUNCT "}")
(NEWLINE)
(ID "CLASS_PREFIX")
(PUNCT "=")
(LIT "Fix")
(NEWLINE)
(ID "FILE_PREFIX")
(PUNCT "=")
(LIT "fix_")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fixer_names")
(PUNCT ",")
(ID "options")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "explicit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Initializer.\n\n        Args:\n            fixer_names: a list of fixers to import\n            options: an dict with configuration.\n            explicit: a list of fixers to run even if they are explicit.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "fixers")
(PUNCT "=")
(ID "fixer_names")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "explicit")
(PUNCT "=")
(ID "explicit")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_default_options")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "options")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "options")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT "[")
(LIT "print_function")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT "=")
(ID "pygram")
(PUNCT ".")
(ID "python_grammar_no_print_statement")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT "=")
(ID "pygram")
(PUNCT ".")
(ID "python_grammar")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "write_unchanged_files")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "write_unchanged_files")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT "=")
(ID "logging")
(PUNCT ".")
(ID "getLogger")
(PUNCT "(")
(LIT "RefactoringTool")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "fixer_log")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "wrote")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "driver")
(PUNCT "=")
(ID "driver")
(PUNCT ".")
(ID "Driver")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "grammar")
(PUNCT ",")
(ID "convert")
(PUNCT "=")
(ID "pytree")
(PUNCT ".")
(ID "convert")
(PUNCT ",")
(ID "logger")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pre_order")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "post_order")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_fixers")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "files")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "BM")
(PUNCT "=")
(ID "bm")
(PUNCT ".")
(ID "BottomMatcher")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bmi_pre_order")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bmi_post_order")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "fixer")
(KEYWORD in)
(ID "chain")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "post_order")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "pre_order")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fixer")
(PUNCT ".")
(ID "BM_compatible")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "BM")
(PUNCT ".")
(ID "add_fixer")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "fixer")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "pre_order")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "bmi_pre_order")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "fixer")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "post_order")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "bmi_post_order")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "bmi_pre_order_heads")
(PUNCT "=")
(ID "_get_headnode_dict")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "bmi_pre_order")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bmi_post_order_heads")
(PUNCT "=")
(ID "_get_headnode_dict")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "bmi_post_order")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_fixers")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Inspects the options to load the requested patterns and handlers.\n\n        Returns:\n          (pre_order, post_order), where pre_order is the list of fixers that\n          want a pre-order AST traversal, and post_order is the list that want\n          post-order traversal.\n        ")
(NEWLINE)
(ID "pre_order_fixers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "post_order_fixers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "fix_mod_path")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "fixers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mod")
(PUNCT "=")
(ID "__import__")
(PUNCT "(")
(ID "fix_mod_path")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ",")
(PUNCT "[")
(LIT "*")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "fix_name")
(PUNCT "=")
(ID "fix_mod_path")
(PUNCT ".")
(ID "rsplit")
(PUNCT "(")
(LIT ".")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "fix_name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "FILE_PREFIX")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fix_name")
(PUNCT "=")
(ID "fix_name")
(PUNCT "[")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "FILE_PREFIX")
(PUNCT ")")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "parts")
(PUNCT "=")
(ID "fix_name")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "_")
(PUNCT ")")
(NEWLINE)
(ID "class_name")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "CLASS_PREFIX")
(PUNCT "+")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "p")
(PUNCT ".")
(ID "title")
(PUNCT "(")
(PUNCT ")")
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "parts")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fix_class")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "mod")
(PUNCT ",")
(ID "class_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "FixerError")
(PUNCT "(")
(LIT "Can't find %s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "fix_name")
(PUNCT ",")
(ID "class_name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fixer")
(PUNCT "=")
(ID "fix_class")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "fixer_log")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "fixer")
(PUNCT ".")
(ID "explicit")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "explicit")
(KEYWORD is)
(KEYWORD not)
(KEYWORD True)
(KEYWORD and)
(ID "fix_mod_path")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "explicit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "Skipping implicit fixer: %s")
(PUNCT ",")
(ID "fix_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Adding transformation: %s")
(PUNCT ",")
(ID "fix_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "fixer")
(PUNCT ".")
(ID "order")
(PUNCT "==")
(LIT "pre")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pre_order_fixers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "fixer")
(PUNCT ".")
(ID "order")
(PUNCT "==")
(LIT "post")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "post_order_fixers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "FixerError")
(PUNCT "(")
(LIT "Illegal fixer order: %r")
(PUNCT "%")
(ID "fixer")
(PUNCT ".")
(ID "order")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "key_func")
(PUNCT "=")
(ID "operator")
(PUNCT ".")
(ID "attrgetter")
(PUNCT "(")
(LIT "run_order")
(PUNCT ")")
(NEWLINE)
(ID "pre_order_fixers")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(ID "key")
(PUNCT "=")
(ID "key_func")
(PUNCT ")")
(NEWLINE)
(ID "post_order_fixers")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(ID "key")
(PUNCT "=")
(ID "key_func")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "pre_order_fixers")
(PUNCT ",")
(ID "post_order_fixers")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called when an error occurs.")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log_message")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Hook to log a message.")
(NEWLINE)
(KEYWORD if)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "%")
(ID "args")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log_debug")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "%")
(ID "args")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_output")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "old_text")
(PUNCT ",")
(ID "new_text")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "equal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called with the old version, new version, and filename of a\n        refactored file.")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "refactor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "items")
(PUNCT ",")
(ID "write")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "doctests_only")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Refactor a list of files and directories.")
(NEWLINE)
(KEYWORD for)
(ID "dir_or_file")
(KEYWORD in)
(ID "items")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "dir_or_file")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "refactor_dir")
(PUNCT "(")
(ID "dir_or_file")
(PUNCT ",")
(ID "write")
(PUNCT ",")
(ID "doctests_only")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "refactor_file")
(PUNCT "(")
(ID "dir_or_file")
(PUNCT ",")
(ID "write")
(PUNCT ",")
(ID "doctests_only")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "refactor_dir")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dir_name")
(PUNCT ",")
(ID "write")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "doctests_only")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Descends down a directory and refactor every Python file found.\n\n        Python files are assumed to have a .py extension.\n\n        Files and subdirectories starting with '.' are skipped.\n        ")
(NEWLINE)
(ID "py_ext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "extsep")
(PUNCT "+")
(LIT "py")
(NEWLINE)
(KEYWORD for)
(ID "dirpath")
(PUNCT ",")
(ID "dirnames")
(PUNCT ",")
(ID "filenames")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "walk")
(PUNCT "(")
(ID "dir_name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Descending into %s")
(PUNCT ",")
(ID "dirpath")
(PUNCT ")")
(NEWLINE)
(ID "dirnames")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "filenames")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "filenames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(ID "py_ext")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dirpath")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "refactor_file")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(ID "write")
(PUNCT ",")
(ID "doctests_only")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "dirnames")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(ID "dn")
(KEYWORD for)
(ID "dn")
(KEYWORD in)
(ID "dirnames")
(KEYWORD if)
(KEYWORD not)
(ID "dn")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_read_python_source")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Do our best to decode a Python source file correctly.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_error")
(PUNCT "(")
(LIT "Can't open %s: %s")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "tokenize")
(PUNCT ".")
(ID "detect_encoding")
(PUNCT "(")
(ID "f")
(PUNCT ".")
(ID "readline")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "_open_with_encoding")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(LIT "r")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(KEYWORD as)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_from_system_newlines")
(PUNCT "(")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "encoding")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "refactor_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "write")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "doctests_only")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Refactors a file.")
(NEWLINE)
(ID "input")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_read_python_source")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "input")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "input")
(PUNCT "+=")
(LIT "\n")
(NEWLINE)
(KEYWORD if)
(ID "doctests_only")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Refactoring doctests in %s")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "output")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "refactor_docstring")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "write_unchanged_files")
(KEYWORD or)
(ID "output")
(PUNCT "!=")
(ID "input")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processed_file")
(PUNCT "(")
(ID "output")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "input")
(PUNCT ",")
(ID "write")
(PUNCT ",")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "No doctest changes in %s")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tree")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "refactor_string")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "write_unchanged_files")
(KEYWORD or)
(PUNCT "(")
(ID "tree")
(KEYWORD and)
(ID "tree")
(PUNCT ".")
(ID "was_changed")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processed_file")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "tree")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "write")
(PUNCT "=")
(ID "write")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "No changes in %s")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "refactor_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Refactor a given input string.\n\n        Args:\n            data: a string holding the code to be refactored.\n            name: a human-readable name for use in error/log messages.\n\n        Returns:\n            An AST corresponding to the refactored input stream; None if\n            there were errors during the parse.\n        ")
(NEWLINE)
(ID "features")
(PUNCT "=")
(ID "_detect_future_features")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "print_function")
(KEYWORD in)
(ID "features")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "driver")
(PUNCT ".")
(ID "grammar")
(PUNCT "=")
(ID "pygram")
(PUNCT ".")
(ID "python_grammar_no_print_statement")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tree")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "driver")
(PUNCT ".")
(ID "parse_string")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_error")
(PUNCT "(")
(LIT "Can't parse %s: %s: %s")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "err")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "driver")
(PUNCT ".")
(ID "grammar")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "grammar")
(NEWLINE)
(DEDENT)
(ID "tree")
(PUNCT ".")
(ID "future_features")
(PUNCT "=")
(ID "features")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Refactoring %s")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "refactor_tree")
(PUNCT "(")
(ID "tree")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "tree")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "refactor_stdin")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "doctests_only")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "input")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "doctests_only")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Refactoring doctests in stdin")
(PUNCT ")")
(NEWLINE)
(ID "output")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "refactor_docstring")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(LIT "<stdin>")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "write_unchanged_files")
(KEYWORD or)
(ID "output")
(PUNCT "!=")
(ID "input")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processed_file")
(PUNCT "(")
(ID "output")
(PUNCT ",")
(LIT "<stdin>")
(PUNCT ",")
(ID "input")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "No doctest changes in stdin")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tree")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "refactor_string")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(LIT "<stdin>")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "write_unchanged_files")
(KEYWORD or)
(PUNCT "(")
(ID "tree")
(KEYWORD and)
(ID "tree")
(PUNCT ".")
(ID "was_changed")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processed_file")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "tree")
(PUNCT ")")
(PUNCT ",")
(LIT "<stdin>")
(PUNCT ",")
(ID "input")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "No changes in stdin")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "refactor_tree")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tree")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Refactors a parse tree (modifying the tree in place).\n\n        For compatible patterns the bottom matcher module is\n        used. Otherwise the tree is traversed node-to-node for\n        matches.\n\n        Args:\n            tree: a pytree.Node instance representing the root of the tree\n                  to be refactored.\n            name: a human-readable name for this tree.\n\n        Returns:\n            True if the tree was modified, False otherwise.\n        ")
(NEWLINE)
(KEYWORD for)
(ID "fixer")
(KEYWORD in)
(ID "chain")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "pre_order")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "post_order")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fixer")
(PUNCT ".")
(ID "start_tree")
(PUNCT "(")
(ID "tree")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "traverse_by")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "bmi_pre_order_heads")
(PUNCT ",")
(ID "tree")
(PUNCT ".")
(ID "pre_order")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "traverse_by")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "bmi_post_order_heads")
(PUNCT ",")
(ID "tree")
(PUNCT ".")
(ID "post_order")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "match_set")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "BM")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "tree")
(PUNCT ".")
(ID "leaves")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "any")
(PUNCT "(")
(ID "match_set")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "fixer")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "BM")
(PUNCT ".")
(ID "fixers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fixer")
(KEYWORD in)
(ID "match_set")
(KEYWORD and)
(ID "match_set")
(PUNCT "[")
(ID "fixer")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "match_set")
(PUNCT "[")
(ID "fixer")
(PUNCT "]")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(ID "key")
(PUNCT "=")
(ID "pytree")
(PUNCT ".")
(ID "Base")
(PUNCT ".")
(ID "depth")
(PUNCT ",")
(ID "reverse")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "fixer")
(PUNCT ".")
(ID "keep_line_order")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "match_set")
(PUNCT "[")
(ID "fixer")
(PUNCT "]")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(ID "key")
(PUNCT "=")
(ID "pytree")
(PUNCT ".")
(ID "Base")
(PUNCT ".")
(ID "get_lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "node")
(KEYWORD in)
(ID "list")
(PUNCT "(")
(ID "match_set")
(PUNCT "[")
(ID "fixer")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "node")
(KEYWORD in)
(ID "match_set")
(PUNCT "[")
(ID "fixer")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "match_set")
(PUNCT "[")
(ID "fixer")
(PUNCT "]")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "node")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "find_root")
(PUNCT "(")
(ID "node")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "node")
(PUNCT ".")
(ID "fixers_applied")
(KEYWORD and)
(ID "fixer")
(KEYWORD in)
(ID "node")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "results")
(PUNCT "=")
(ID "fixer")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "node")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "results")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new")
(PUNCT "=")
(ID "fixer")
(PUNCT ".")
(ID "transform")
(PUNCT "(")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "node")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(ID "new")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "node")
(KEYWORD in)
(ID "new")
(PUNCT ".")
(ID "post_order")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "node")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "node")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "node")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fixer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "new_matches")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "BM")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "new")
(PUNCT ".")
(ID "leaves")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "fxr")
(KEYWORD in)
(ID "new_matches")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "fxr")
(KEYWORD in)
(ID "match_set")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "match_set")
(PUNCT "[")
(ID "fxr")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "match_set")
(PUNCT "[")
(ID "fxr")
(PUNCT "]")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "new_matches")
(PUNCT "[")
(ID "fxr")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "fixer")
(KEYWORD in)
(ID "chain")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "pre_order")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "post_order")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fixer")
(PUNCT ".")
(ID "finish_tree")
(PUNCT "(")
(ID "tree")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "tree")
(PUNCT ".")
(ID "was_changed")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "traverse_by")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fixers")
(PUNCT ",")
(ID "traversal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Traverse an AST, applying a set of fixers to each node.\n\n        This is a helper method for refactor_tree().\n\n        Args:\n            fixers: a list of fixer instances.\n            traversal: a generator that yields AST nodes.\n\n        Returns:\n            None\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "fixers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "node")
(KEYWORD in)
(ID "traversal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "fixer")
(KEYWORD in)
(ID "fixers")
(PUNCT "[")
(ID "node")
(PUNCT ".")
(ID "type")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "results")
(PUNCT "=")
(ID "fixer")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "node")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "results")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new")
(PUNCT "=")
(ID "fixer")
(PUNCT ".")
(ID "transform")
(PUNCT "(")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "node")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(ID "new")
(PUNCT ")")
(NEWLINE)
(ID "node")
(PUNCT "=")
(ID "new")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "processed_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "new_text")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "old_text")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "write")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Called when a file has been refactored and there may be changes.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "files")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "old_text")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "old_text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_read_python_source")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "old_text")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "equal")
(PUNCT "=")
(ID "old_text")
(PUNCT "==")
(ID "new_text")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "print_output")
(PUNCT "(")
(ID "old_text")
(PUNCT ",")
(ID "new_text")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "equal")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "equal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "No changes to %s")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "write_unchanged_files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "write")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "write_file")
(PUNCT "(")
(ID "new_text")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "old_text")
(PUNCT ",")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Not writing changes to %s")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "write_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "new_text")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "old_text")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Writes a string to a file.\n\n        It first shows a unified diff between the old text and the new text, and\n        then rewrites the file; the latter is only done if the write option is\n        set.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "_open_with_encoding")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(LIT "w")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_error")
(PUNCT "(")
(LIT "Can't create %s: %s")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "_to_system_newlines")
(PUNCT "(")
(ID "new_text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_error")
(PUNCT "(")
(LIT "Can't write %s: %s")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Wrote changes to %s")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "wrote")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(ID "PS1")
(PUNCT "=")
(LIT ">>> ")
(NEWLINE)
(ID "PS2")
(PUNCT "=")
(LIT "... ")
(NEWLINE)
(KEYWORD def)
(ID "refactor_docstring")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "input")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Refactors a docstring, looking for doctests.\n\n        This returns a modified version of the input string.  It looks\n        for doctests, which start with a \">>>\" prompt, and may be\n        continued with \"...\" prompts, as long as the \"...\" is indented\n        the same as the \">>>\".\n\n        (Unfortunately we can't use the doctest module's parser,\n        since, like most parsers, it is not geared towards preserving\n        the original source.)\n        ")
(NEWLINE)
(ID "result")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "block")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "block_lineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "indent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "input")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(ID "keepends")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "PS1")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "block")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "refactor_doctest")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "block_lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "block_lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "block")
(PUNCT "=")
(PUNCT "[")
(ID "line")
(PUNCT "]")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "PS1")
(PUNCT ")")
(NEWLINE)
(ID "indent")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(PUNCT "(")
(ID "indent")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(PUNCT "(")
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "PS2")
(PUNCT ")")
(KEYWORD or)
(ID "line")
(PUNCT "==")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "PS2")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT "\n")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "block")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "block")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "refactor_doctest")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "block_lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "block")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "indent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "result")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "block")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "refactor_doctest")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "block_lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "refactor_doctest")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "block")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Refactors one doctest.\n\n        A doctest is given as a block of lines, the first of which starts\n        with \">>>\" (possibly indented), while the remaining lines start\n        with \"...\" (identically indented).\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tree")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "parse_block")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "logging")
(PUNCT ".")
(ID "DEBUG")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "block")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_debug")
(PUNCT "(")
(LIT "Source: %s")
(PUNCT ",")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "log_error")
(PUNCT "(")
(LIT "Can't parse docstring in %s line %s: %s: %s")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "err")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "block")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "refactor_tree")
(PUNCT "(")
(ID "tree")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "tree")
(PUNCT ")")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(ID "keepends")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "clipped")
(PUNCT ",")
(ID "new")
(PUNCT "=")
(ID "new")
(PUNCT "[")
(PUNCT ":")
(ID "lineno")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "new")
(PUNCT "[")
(ID "lineno")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD assert)
(ID "clipped")
(PUNCT "==")
(PUNCT "[")
(LIT "\n")
(PUNCT "]")
(PUNCT "*")
(PUNCT "(")
(ID "lineno")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "clipped")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "new")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "+=")
(LIT "\n")
(NEWLINE)
(DEDENT)
(ID "block")
(PUNCT "=")
(PUNCT "[")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "PS1")
(PUNCT "+")
(ID "new")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "new")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "block")
(PUNCT "+=")
(PUNCT "[")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "PS2")
(PUNCT "+")
(ID "line")
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "new")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "block")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "summarize")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "wrote")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "were")
(PUNCT "=")
(LIT "were")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "were")
(PUNCT "=")
(LIT "need to be")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "No files %s modified.")
(PUNCT ",")
(ID "were")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "Files that %s modified:")
(PUNCT ",")
(ID "were")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "file")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "fixer_log")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "Warnings/messages while refactoring:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "message")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "fixer_log")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(ID "message")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "There was 1 error:")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "There were %d errors:")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "kwds")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "parse_block")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "block")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parses a block into a tree.\n\n        This is necessary to get correct line number / offset information\n        in the parser diagnostics and embedded into the parse tree.\n        ")
(NEWLINE)
(ID "tree")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "driver")
(PUNCT ".")
(ID "parse_tokens")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "wrap_toks")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "tree")
(PUNCT ".")
(ID "future_features")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "tree")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "wrap_toks")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "block")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "indent")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wraps a tokenize stream to systematically modify start/end.")
(NEWLINE)
(ID "tokens")
(PUNCT "=")
(ID "tokenize")
(PUNCT ".")
(ID "generate_tokens")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "gen_lines")
(PUNCT "(")
(ID "block")
(PUNCT ",")
(ID "indent")
(PUNCT ")")
(PUNCT ".")
(ID "__next__")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(PUNCT "(")
(ID "line0")
(PUNCT ",")
(ID "col0")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "line1")
(PUNCT ",")
(ID "col1")
(PUNCT ")")
(PUNCT ",")
(ID "line_text")
(KEYWORD in)
(ID "tokens")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line0")
(PUNCT "+=")
(ID "lineno")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "line1")
(PUNCT "+=")
(ID "lineno")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(PUNCT "(")
(ID "line0")
(PUNCT ",")
(ID "col0")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "line1")
(PUNCT ",")
(ID "col1")
(PUNCT ")")
(PUNCT ",")
(ID "line_text")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "gen_lines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "block")
(PUNCT ",")
(ID "indent")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generates lines as expected by tokenize from a list of lines.\n\n        This strips the first len(indent + self.PS1) characters off each line.\n        ")
(NEWLINE)
(ID "prefix1")
(PUNCT "=")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "PS1")
(NEWLINE)
(ID "prefix2")
(PUNCT "=")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "PS2")
(NEWLINE)
(ID "prefix")
(PUNCT "=")
(ID "prefix1")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "block")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "line")
(PUNCT "[")
(ID "len")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "line")
(PUNCT "==")
(ID "prefix")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "\n")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "line=%r, prefix=%r")
(PUNCT "%")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "prefix")
(PUNCT "=")
(ID "prefix2")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "MultiprocessingUnsupported")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "MultiprocessRefactoringTool")
(PUNCT "(")
(ID "RefactoringTool")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(ID "MultiprocessRefactoringTool")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "output_lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "refactor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "items")
(PUNCT ",")
(ID "write")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "doctests_only")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "num_processes")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "num_processes")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "super")
(PUNCT "(")
(ID "MultiprocessRefactoringTool")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "refactor")
(PUNCT "(")
(ID "items")
(PUNCT ",")
(ID "write")
(PUNCT ",")
(ID "doctests_only")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "multiprocessing")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "MultiprocessingUnsupported")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "queue")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "already doing multiple processes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT "=")
(ID "multiprocessing")
(PUNCT ".")
(ID "JoinableQueue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "output_lock")
(PUNCT "=")
(ID "multiprocessing")
(PUNCT ".")
(ID "Lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "processes")
(PUNCT "=")
(PUNCT "[")
(ID "multiprocessing")
(PUNCT ".")
(ID "Process")
(PUNCT "(")
(ID "target")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_child")
(PUNCT ")")
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "num_processes")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "processes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "p")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "super")
(PUNCT "(")
(ID "MultiprocessRefactoringTool")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "refactor")
(PUNCT "(")
(ID "items")
(PUNCT ",")
(ID "write")
(PUNCT ",")
(ID "doctests_only")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "num_processes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT ".")
(ID "put")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "processes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "p")
(PUNCT ".")
(ID "is_alive")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "p")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_child")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "task")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "task")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT ",")
(ID "kwargs")
(PUNCT "=")
(ID "task")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(ID "MultiprocessRefactoringTool")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "refactor_file")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT ".")
(ID "task_done")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "task")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "refactor_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "queue")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "queue")
(PUNCT ".")
(ID "put")
(PUNCT "(")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "kwargs")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "super")
(PUNCT "(")
(ID "MultiprocessRefactoringTool")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "refactor_file")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
