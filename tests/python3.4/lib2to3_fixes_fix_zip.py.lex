(LIT "\nFixer that changes zip(seq0, seq1, ...) into list(zip(seq0, seq1, ...)\nunless there exists a 'from future_builtins import zip' statement in the\ntop-level namespace.\n\nWe avoid the transformation if the zip() call is directly contained in\niter(<>), list(<>), tuple(<>), sorted(<>), ...join(<>), or for V in <>:.\n")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(PUNCT ".")
(KEYWORD import)
(ID "fixer_base")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(PUNCT ".")
(ID "fixer_util")
(KEYWORD import)
(ID "Name")
(PUNCT ",")
(ID "Call")
(PUNCT ",")
(ID "in_special_context")
(NEWLINE)
(KEYWORD class)
(ID "FixZip")
(PUNCT "(")
(ID "fixer_base")
(PUNCT ".")
(ID "ConditionalFix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "BM_compatible")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "PATTERN")
(PUNCT "=")
(LIT "\n    power< 'zip' args=trailer< '(' [any] ')' >\n    >\n    ")
(NEWLINE)
(ID "skip_on")
(PUNCT "=")
(LIT "future_builtins.zip")
(NEWLINE)
(KEYWORD def)
(ID "transform")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "should_skip")
(PUNCT "(")
(ID "node")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "in_special_context")
(PUNCT "(")
(ID "node")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "new")
(PUNCT "=")
(ID "node")
(PUNCT ".")
(ID "clone")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "new")
(PUNCT ".")
(ID "prefix")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "new")
(PUNCT "=")
(ID "Call")
(PUNCT "(")
(ID "Name")
(PUNCT "(")
(LIT "list")
(PUNCT ")")
(PUNCT ",")
(PUNCT "[")
(ID "new")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "new")
(PUNCT ".")
(ID "prefix")
(PUNCT "=")
(ID "node")
(PUNCT ".")
(ID "prefix")
(NEWLINE)
(KEYWORD return)
(ID "new")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
