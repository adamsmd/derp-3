(LIT " Routines for manipulating RFC2047 encoded words.\n\nThis is currently a package-private API, but will be considered for promotion\nto a public API if there is demand.\n\n")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "base64")
(NEWLINE)
(KEYWORD import)
(ID "binascii")
(NEWLINE)
(KEYWORD import)
(ID "functools")
(NEWLINE)
(KEYWORD from)
(ID "string")
(KEYWORD import)
(ID "ascii_letters")
(PUNCT ",")
(ID "digits")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "errors")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "decode_q")
(PUNCT ",")
(LIT "encode_q")
(PUNCT ",")
(LIT "decode_b")
(PUNCT ",")
(LIT "encode_b")
(PUNCT ",")
(LIT "len_q")
(PUNCT ",")
(LIT "len_b")
(PUNCT ",")
(LIT "decode")
(PUNCT ",")
(LIT "encode")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(ID "_q_byte_subber")
(PUNCT "=")
(ID "functools")
(PUNCT ".")
(ID "partial")
(PUNCT "(")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT #"=([a-fA-F0-9]{2})")
(PUNCT ")")
(PUNCT ".")
(ID "sub")
(PUNCT ",")
(KEYWORD lambda)
(ID "m")
(PUNCT ":")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(ID "int")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "decode_q")
(PUNCT "(")
(ID "encoded")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoded")
(PUNCT "=")
(ID "encoded")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT #"_")
(PUNCT ",")
(LIT #" ")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_q_byte_subber")
(PUNCT "(")
(ID "encoded")
(PUNCT ")")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_QByteMap")
(PUNCT "(")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "safe")
(PUNCT "=")
(LIT #"-!*+/")
(PUNCT "+")
(ID "ascii_letters")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(PUNCT "+")
(ID "digits")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__missing__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "safe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(LIT "={:02X}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_q_byte_map")
(PUNCT "=")
(ID "_QByteMap")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_q_byte_map")
(PUNCT "[")
(ID "ord")
(PUNCT "(")
(LIT " ")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(LIT "_")
(NEWLINE)
(KEYWORD def)
(ID "encode_q")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "_q_byte_map")
(PUNCT "[")
(ID "x")
(PUNCT "]")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "bstring")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "len_q")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sum")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "_q_byte_map")
(PUNCT "[")
(ID "x")
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "bstring")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decode_b")
(PUNCT "(")
(ID "encoded")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defects")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "pad_err")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "encoded")
(PUNCT ")")
(PUNCT "%")
(LIT 4)
(NEWLINE)
(KEYWORD if)
(ID "pad_err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defects")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "errors")
(PUNCT ".")
(ID "InvalidBase64PaddingDefect")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "padded_encoded")
(PUNCT "=")
(ID "encoded")
(PUNCT "+")
(LIT #"===")
(PUNCT "[")
(PUNCT ":")
(LIT 4)
(PUNCT "-")
(ID "pad_err")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "padded_encoded")
(PUNCT "=")
(ID "encoded")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "base64")
(PUNCT ".")
(ID "b64decode")
(PUNCT "(")
(ID "padded_encoded")
(PUNCT ",")
(ID "validate")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ",")
(ID "defects")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defects")
(PUNCT "=")
(PUNCT "[")
(ID "errors")
(PUNCT ".")
(ID "InvalidBase64CharactersDefect")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ",")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "base64")
(PUNCT ".")
(ID "b64decode")
(PUNCT "(")
(ID "encoded")
(PUNCT "+")
(LIT #"=")
(PUNCT "*")
(ID "i")
(PUNCT ",")
(ID "validate")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ",")
(ID "defects")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "i")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defects")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "errors")
(PUNCT ".")
(ID "InvalidBase64PaddingDefect")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "unexpected binascii.Error")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "encode_b")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "base64")
(PUNCT ".")
(ID "b64encode")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "len_b")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "groups_of_3")
(PUNCT ",")
(ID "leftover")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(PUNCT ",")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "groups_of_3")
(PUNCT "*")
(LIT 4)
(PUNCT "+")
(PUNCT "(")
(LIT 4)
(KEYWORD if)
(ID "leftover")
(KEYWORD else)
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_cte_decoders")
(PUNCT "=")
(PUNCT "{")
(LIT "q")
(PUNCT ":")
(ID "decode_q")
(PUNCT ",")
(LIT "b")
(PUNCT ":")
(ID "decode_b")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "ew")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode encoded word and return (string, charset, lang, defects) tuple.\n\n    An RFC 2047/2243 encoded word has the form:\n\n        =?charset*lang?cte?encoded_string?=\n\n    where '*lang' may be omitted but the other parts may not be.\n\n    This function expects exactly such a string (that is, it does not check the\n    syntax and may raise errors if the string is not well formed), and returns\n    the encoded_string decoded first from its Content Transfer Encoding and\n    then from the resulting bytes into unicode using the specified charset.  If\n    the cte-decoded string does not successfully decode using the specified\n    character set, a defect is added to the defects list and the unknown octets\n    are replaced by the unicode 'unknown' character \uFDFF.\n\n    The specified charset and language are returned.  The default for language,\n    which is rarely if ever encountered, is the empty string.\n\n    ")
(NEWLINE)
(ID "_")
(PUNCT ",")
(ID "charset")
(PUNCT ",")
(ID "cte")
(PUNCT ",")
(ID "cte_string")
(PUNCT ",")
(ID "_")
(PUNCT "=")
(ID "ew")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "?")
(PUNCT ")")
(NEWLINE)
(ID "charset")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "lang")
(PUNCT "=")
(ID "charset")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT "*")
(PUNCT ")")
(NEWLINE)
(ID "cte")
(PUNCT "=")
(ID "cte")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "bstring")
(PUNCT "=")
(ID "cte_string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(ID "bstring")
(PUNCT ",")
(ID "defects")
(PUNCT "=")
(ID "_cte_decoders")
(PUNCT "[")
(ID "cte")
(PUNCT "]")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(ID "bstring")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defects")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "errors")
(PUNCT ".")
(ID "UndecodableBytesDefect")
(PUNCT "(")
(LIT "Encoded word ")
(LIT "contains bytes not decodable using {} charset")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "string")
(PUNCT "=")
(ID "bstring")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "LookupError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(ID "bstring")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "charset")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(LIT "unknown-8bit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defects")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "errors")
(PUNCT ".")
(ID "CharsetError")
(PUNCT "(")
(LIT "Unknown charset {} ")
(LIT "in encoded word; decoded as unknown bytes")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "string")
(PUNCT ",")
(ID "charset")
(PUNCT ",")
(ID "lang")
(PUNCT ",")
(ID "defects")
(NEWLINE)
(DEDENT)
(ID "_cte_encoders")
(PUNCT "=")
(PUNCT "{")
(LIT "q")
(PUNCT ":")
(ID "encode_q")
(PUNCT ",")
(LIT "b")
(PUNCT ":")
(ID "encode_b")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "_cte_encode_length")
(PUNCT "=")
(PUNCT "{")
(LIT "q")
(PUNCT ":")
(ID "len_q")
(PUNCT ",")
(LIT "b")
(PUNCT ":")
(ID "len_b")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "encode")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "charset")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "lang")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode string using the CTE encoding that produces the shorter result.\n\n    Produces an RFC 2047/2243 encoded word of the form:\n\n        =?charset*lang?cte?encoded_string?=\n\n    where '*lang' is omitted unless the 'lang' parameter is given a value.\n    Optional argument charset (defaults to utf-8) specifies the charset to use\n    to encode the string to binary before CTE encoding it.  Optional argument\n    'encoding' is the cte specifier for the encoding that should be used ('q'\n    or 'b'); if it is None (the default) the encoding which produces the\n    shortest encoded sequence is used, except that 'q' is preferred if it is up\n    to five characters longer.  Optional argument 'lang' (default '') gives the\n    RFC 2243 language string to specify in the encoded word.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "charset")
(PUNCT "==")
(LIT "unknown-8bit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bstring")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bstring")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qlen")
(PUNCT "=")
(ID "_cte_encode_length")
(PUNCT "[")
(LIT "q")
(PUNCT "]")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(NEWLINE)
(ID "blen")
(PUNCT "=")
(ID "_cte_encode_length")
(PUNCT "[")
(LIT "b")
(PUNCT "]")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(NEWLINE)
(ID "encoding")
(PUNCT "=")
(LIT "q")
(KEYWORD if)
(ID "qlen")
(PUNCT "-")
(ID "blen")
(PUNCT "<")
(LIT 5)
(KEYWORD else)
(LIT "b")
(NEWLINE)
(DEDENT)
(ID "encoded")
(PUNCT "=")
(ID "_cte_encoders")
(PUNCT "[")
(ID "encoding")
(PUNCT "]")
(PUNCT "(")
(ID "bstring")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "lang")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lang")
(PUNCT "=")
(LIT "*")
(PUNCT "+")
(ID "lang")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "=?{}{}?{}?{}?=")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "lang")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "encoded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
