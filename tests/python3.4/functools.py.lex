(LIT "functools.py - Tools for working with functions and callable objects\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "update_wrapper")
(PUNCT ",")
(LIT "wraps")
(PUNCT ",")
(LIT "WRAPPER_ASSIGNMENTS")
(PUNCT ",")
(LIT "WRAPPER_UPDATES")
(PUNCT ",")
(LIT "total_ordering")
(PUNCT ",")
(LIT "cmp_to_key")
(PUNCT ",")
(LIT "lru_cache")
(PUNCT ",")
(LIT "reduce")
(PUNCT ",")
(LIT "partial")
(PUNCT ",")
(LIT "partialmethod")
(PUNCT ",")
(LIT "singledispatch")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_functools")
(KEYWORD import)
(ID "reduce")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD from)
(ID "abc")
(KEYWORD import)
(ID "get_cache_token")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "namedtuple")
(NEWLINE)
(KEYWORD from)
(ID "types")
(KEYWORD import)
(ID "MappingProxyType")
(NEWLINE)
(KEYWORD from)
(ID "weakref")
(KEYWORD import)
(ID "WeakKeyDictionary")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_thread")
(KEYWORD import)
(ID "RLock")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD class)
(ID "RLock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy reentrant lock for builds without threads")
(NEWLINE)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exctype")
(PUNCT ",")
(ID "excinst")
(PUNCT ",")
(ID "exctb")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "WRAPPER_ASSIGNMENTS")
(PUNCT "=")
(PUNCT "(")
(LIT "__module__")
(PUNCT ",")
(LIT "__name__")
(PUNCT ",")
(LIT "__qualname__")
(PUNCT ",")
(LIT "__doc__")
(PUNCT ",")
(LIT "__annotations__")
(PUNCT ")")
(NEWLINE)
(ID "WRAPPER_UPDATES")
(PUNCT "=")
(PUNCT "(")
(LIT "__dict__")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "update_wrapper")
(PUNCT "(")
(ID "wrapper")
(PUNCT ",")
(ID "wrapped")
(PUNCT ",")
(ID "assigned")
(PUNCT "=")
(ID "WRAPPER_ASSIGNMENTS")
(PUNCT ",")
(ID "updated")
(PUNCT "=")
(ID "WRAPPER_UPDATES")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)\n       updated is a tuple naming the attributes of the wrapper that\n       are updated with the corresponding attribute from the wrapped\n       function (defaults to functools.WRAPPER_UPDATES)\n    ")
(NEWLINE)
(KEYWORD for)
(ID "attr")
(KEYWORD in)
(ID "assigned")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "wrapped")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setattr")
(PUNCT "(")
(ID "wrapper")
(PUNCT ",")
(ID "attr")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "attr")
(KEYWORD in)
(ID "updated")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "getattr")
(PUNCT "(")
(ID "wrapper")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "getattr")
(PUNCT "(")
(ID "wrapped")
(PUNCT ",")
(ID "attr")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "wrapper")
(PUNCT ".")
(ID "__wrapped__")
(PUNCT "=")
(ID "wrapped")
(NEWLINE)
(KEYWORD return)
(ID "wrapper")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "wraps")
(PUNCT "(")
(ID "wrapped")
(PUNCT ",")
(ID "assigned")
(PUNCT "=")
(ID "WRAPPER_ASSIGNMENTS")
(PUNCT ",")
(ID "updated")
(PUNCT "=")
(ID "WRAPPER_UPDATES")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    ")
(NEWLINE)
(KEYWORD return)
(ID "partial")
(PUNCT "(")
(ID "update_wrapper")
(PUNCT ",")
(ID "wrapped")
(PUNCT "=")
(ID "wrapped")
(PUNCT ",")
(ID "assigned")
(PUNCT "=")
(ID "assigned")
(PUNCT ",")
(ID "updated")
(PUNCT "=")
(ID "updated")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_gt_from_lt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__lt__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(KEYWORD and)
(ID "self")
(PUNCT "!=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_le_from_lt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__lt__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "op_result")
(KEYWORD or)
(ID "self")
(PUNCT "==")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ge_from_lt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a >= b.  Computed by @total_ordering from (not a < b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__lt__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ge_from_le")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a >= b.  Computed by @total_ordering from (not a <= b) or (a == b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__le__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(KEYWORD or)
(ID "self")
(PUNCT "==")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_lt_from_le")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a < b.  Computed by @total_ordering from (a <= b) and (a != b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__le__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "op_result")
(KEYWORD and)
(ID "self")
(PUNCT "!=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_gt_from_le")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a > b.  Computed by @total_ordering from (not a <= b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__le__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_lt_from_gt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a < b.  Computed by @total_ordering from (not a > b) and (a != b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__gt__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(KEYWORD and)
(ID "self")
(PUNCT "!=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ge_from_gt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a >= b.  Computed by @total_ordering from (a > b) or (a == b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__gt__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "op_result")
(KEYWORD or)
(ID "self")
(PUNCT "==")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_le_from_gt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a <= b.  Computed by @total_ordering from (not a > b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__gt__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_le_from_ge")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a <= b.  Computed by @total_ordering from (not a >= b) or (a == b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__ge__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(KEYWORD or)
(ID "self")
(PUNCT "==")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_gt_from_ge")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a > b.  Computed by @total_ordering from (a >= b) and (a != b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__ge__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "op_result")
(KEYWORD and)
(ID "self")
(PUNCT "!=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_lt_from_ge")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a < b.  Computed by @total_ordering from (not a >= b).")
(NEWLINE)
(ID "op_result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__ge__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op_result")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "op_result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "total_ordering")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Class decorator that fills in missing ordering methods")
(NEWLINE)
(ID "convert")
(PUNCT "=")
(PUNCT "{")
(LIT "__lt__")
(PUNCT ":")
(PUNCT "[")
(PUNCT "(")
(LIT "__gt__")
(PUNCT ",")
(ID "_gt_from_lt")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__le__")
(PUNCT ",")
(ID "_le_from_lt")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__ge__")
(PUNCT ",")
(ID "_ge_from_lt")
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(LIT "__le__")
(PUNCT ":")
(PUNCT "[")
(PUNCT "(")
(LIT "__ge__")
(PUNCT ",")
(ID "_ge_from_le")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__lt__")
(PUNCT ",")
(ID "_lt_from_le")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__gt__")
(PUNCT ",")
(ID "_gt_from_le")
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(LIT "__gt__")
(PUNCT ":")
(PUNCT "[")
(PUNCT "(")
(LIT "__lt__")
(PUNCT ",")
(ID "_lt_from_gt")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__ge__")
(PUNCT ",")
(ID "_ge_from_gt")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__le__")
(PUNCT ",")
(ID "_le_from_gt")
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(LIT "__ge__")
(PUNCT ":")
(PUNCT "[")
(PUNCT "(")
(LIT "__le__")
(PUNCT ",")
(ID "_le_from_ge")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__gt__")
(PUNCT ",")
(ID "_gt_from_ge")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "__lt__")
(PUNCT ",")
(ID "_lt_from_ge")
(PUNCT ")")
(PUNCT "]")
(PUNCT "}")
(NEWLINE)
(ID "roots")
(PUNCT "=")
(PUNCT "[")
(ID "op")
(KEYWORD for)
(ID "op")
(KEYWORD in)
(ID "convert")
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "op")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(ID "getattr")
(PUNCT "(")
(ID "object")
(PUNCT ",")
(ID "op")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "roots")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "must define at least one ordering operation: < > <= >=")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "roots")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "opname")
(PUNCT ",")
(ID "opfunc")
(KEYWORD in)
(ID "convert")
(PUNCT "[")
(ID "root")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "opname")
(KEYWORD not)
(KEYWORD in)
(ID "roots")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opfunc")
(PUNCT ".")
(ID "__name__")
(PUNCT "=")
(ID "opname")
(NEWLINE)
(ID "setattr")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "opname")
(PUNCT ",")
(ID "opfunc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "cls")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "cmp_to_key")
(PUNCT "(")
(ID "mycmp")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert a cmp= function into a key= function")
(NEWLINE)
(KEYWORD class)
(ID "K")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "[")
(LIT "obj")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT "=")
(ID "obj")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "mycmp")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "obj")
(PUNCT ")")
(PUNCT "<")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__gt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "mycmp")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "obj")
(PUNCT ")")
(PUNCT ">")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "mycmp")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "obj")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__le__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "mycmp")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "obj")
(PUNCT ")")
(PUNCT "<=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ge__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "mycmp")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "obj")
(PUNCT ")")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ne__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "mycmp")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "obj")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "obj")
(PUNCT ")")
(PUNCT "!=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "__hash__")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "K")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_functools")
(KEYWORD import)
(ID "cmp_to_key")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "partial")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "keywords")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "New function with partial application of the given arguments\n    and keywords.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "newfunc")
(PUNCT "(")
(PUNCT "*")
(ID "fargs")
(PUNCT ",")
(PUNCT "**")
(ID "fkeywords")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newkeywords")
(PUNCT "=")
(ID "keywords")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "newkeywords")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "fkeywords")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "func")
(PUNCT "(")
(PUNCT "*")
(PUNCT "(")
(ID "args")
(PUNCT "+")
(ID "fargs")
(PUNCT ")")
(PUNCT ",")
(PUNCT "**")
(ID "newkeywords")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "newfunc")
(PUNCT ".")
(ID "func")
(PUNCT "=")
(ID "func")
(NEWLINE)
(ID "newfunc")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "newfunc")
(PUNCT ".")
(ID "keywords")
(PUNCT "=")
(ID "keywords")
(NEWLINE)
(KEYWORD return)
(ID "newfunc")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_functools")
(KEYWORD import)
(ID "partial")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "partialmethod")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Method descriptor with partial application of the given arguments\n    and keywords.\n\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "func")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "keywords")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "callable")
(PUNCT "(")
(ID "func")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(LIT "__get__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "{!r} is not callable or a descriptor")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "func")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(ID "partialmethod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT "=")
(ID "func")
(PUNCT ".")
(ID "func")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(ID "func")
(PUNCT ".")
(ID "args")
(PUNCT "+")
(ID "args")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT "=")
(ID "func")
(PUNCT ".")
(ID "keywords")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "keywords")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT "=")
(ID "func")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT "=")
(ID "keywords")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "repr")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "keywords")
(PUNCT "=")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(LIT "{}={!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "format_string")
(PUNCT "=")
(LIT "{module}.{cls}({func}, {args}, {keywords})")
(NEWLINE)
(KEYWORD return)
(ID "format_string")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "module")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__module__")
(PUNCT ",")
(ID "cls")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "func")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT ",")
(ID "args")
(PUNCT "=")
(ID "args")
(PUNCT ",")
(ID "keywords")
(PUNCT "=")
(ID "keywords")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_make_unbound_method")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "_method")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "keywords")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "call_keywords")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "call_keywords")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "keywords")
(PUNCT ")")
(NEWLINE)
(ID "cls_or_self")
(PUNCT ",")
(PUNCT "*")
(ID "rest")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "call_args")
(PUNCT "=")
(PUNCT "(")
(ID "cls_or_self")
(PUNCT ",")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "+")
(ID "tuple")
(PUNCT "(")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT "(")
(PUNCT "*")
(ID "call_args")
(PUNCT ",")
(PUNCT "**")
(ID "call_keywords")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_method")
(PUNCT ".")
(ID "__isabstractmethod__")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__isabstractmethod__")
(NEWLINE)
(ID "_method")
(PUNCT ".")
(ID "_partialmethod")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD return)
(ID "_method")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__get__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "get")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT ",")
(LIT "__get__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "get")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_func")
(PUNCT "=")
(ID "get")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new_func")
(KEYWORD is)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "partial")
(PUNCT "(")
(ID "new_func")
(PUNCT ",")
(PUNCT "*")
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "__self__")
(PUNCT "=")
(ID "new_func")
(PUNCT ".")
(ID "__self__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "result")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_make_unbound_method")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__get__")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "__isabstractmethod__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "func")
(PUNCT ",")
(LIT "__isabstractmethod__")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_CacheInfo")
(PUNCT "=")
(ID "namedtuple")
(PUNCT "(")
(LIT "CacheInfo")
(PUNCT ",")
(PUNCT "[")
(LIT "hits")
(PUNCT ",")
(LIT "misses")
(PUNCT ",")
(LIT "maxsize")
(PUNCT ",")
(LIT "currsize")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "_HashedSeq")
(PUNCT "(")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " This class guarantees that hash() will be called no more than once\n        per element.  This is important because the lru_cache() will hash\n        the key multiple times on a cache miss.\n\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(LIT "hashvalue")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tup")
(PUNCT ",")
(ID "hash")
(PUNCT "=")
(ID "hash")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "tup")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "hashvalue")
(PUNCT "=")
(ID "hash")
(PUNCT "(")
(ID "tup")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "hashvalue")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_make_key")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "kwds")
(PUNCT ",")
(ID "typed")
(PUNCT ",")
(ID "kwd_mark")
(PUNCT "=")
(PUNCT "(")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ",")
(ID "fasttypes")
(PUNCT "=")
(PUNCT "{")
(ID "int")
(PUNCT ",")
(ID "str")
(PUNCT ",")
(ID "frozenset")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(PUNCT "}")
(PUNCT ",")
(ID "sorted")
(PUNCT "=")
(ID "sorted")
(PUNCT ",")
(ID "tuple")
(PUNCT "=")
(ID "tuple")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "type")
(PUNCT ",")
(ID "len")
(PUNCT "=")
(ID "len")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Make a cache key from optionally typed positional and keyword arguments\n\n    The key is constructed in a way that is flat as possible rather than\n    as a nested structure that would take more memory.\n\n    If there is only a single argument and its data type is known to cache\n    its hash value, then that argument is returned without a wrapper.  This\n    saves space and improves lookup speed.\n\n    ")
(NEWLINE)
(ID "key")
(PUNCT "=")
(ID "args")
(NEWLINE)
(KEYWORD if)
(ID "kwds")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sorted_items")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "kwds")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "key")
(PUNCT "+=")
(ID "kwd_mark")
(NEWLINE)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "sorted_items")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "+=")
(ID "item")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "typed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "+=")
(ID "tuple")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(KEYWORD for)
(ID "v")
(KEYWORD in)
(ID "args")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "kwds")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "+=")
(ID "tuple")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "sorted_items")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "type")
(PUNCT "(")
(ID "key")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(KEYWORD in)
(ID "fasttypes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "key")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_HashedSeq")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "lru_cache")
(PUNCT "(")
(ID "maxsize")
(PUNCT "=")
(LIT 128)
(PUNCT ",")
(ID "typed")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Least-recently-used cache decorator.\n\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(3.0) and f(3) will be treated as distinct calls with\n    distinct results.\n\n    Arguments to the cached function must be hashable.\n\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)\n    with f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n\n    See:  http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "maxsize")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "maxsize")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Expected maxsize to be an integer or None")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sentinel")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "make_key")
(PUNCT "=")
(ID "_make_key")
(NEWLINE)
(ID "PREV")
(PUNCT ",")
(ID "NEXT")
(PUNCT ",")
(ID "KEY")
(PUNCT ",")
(ID "RESULT")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ",")
(LIT 3)
(NEWLINE)
(KEYWORD def)
(ID "decorating_function")
(PUNCT "(")
(ID "user_function")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cache")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "hits")
(PUNCT "=")
(ID "misses")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "full")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "cache_get")
(PUNCT "=")
(ID "cache")
(PUNCT ".")
(ID "get")
(NEWLINE)
(ID "lock")
(PUNCT "=")
(ID "RLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "root")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "root")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(ID "root")
(PUNCT ",")
(ID "root")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "maxsize")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "wrapper")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD nonlocal)
(ID "misses")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "user_function")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(ID "misses")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "maxsize")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "wrapper")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD nonlocal)
(ID "hits")
(PUNCT ",")
(ID "misses")
(NEWLINE)
(ID "key")
(PUNCT "=")
(ID "make_key")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "kwds")
(PUNCT ",")
(ID "typed")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "cache_get")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "sentinel")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "result")
(KEYWORD is)
(KEYWORD not)
(ID "sentinel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hits")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "user_function")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(ID "cache")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "result")
(NEWLINE)
(ID "misses")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "wrapper")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD nonlocal)
(ID "root")
(PUNCT ",")
(ID "hits")
(PUNCT ",")
(ID "misses")
(PUNCT ",")
(ID "full")
(NEWLINE)
(ID "key")
(PUNCT "=")
(ID "make_key")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "kwds")
(PUNCT ",")
(ID "typed")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "link")
(PUNCT "=")
(ID "cache_get")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "link")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "link_prev")
(PUNCT ",")
(ID "link_next")
(PUNCT ",")
(ID "_key")
(PUNCT ",")
(ID "result")
(PUNCT "=")
(ID "link")
(NEWLINE)
(ID "link_prev")
(PUNCT "[")
(ID "NEXT")
(PUNCT "]")
(PUNCT "=")
(ID "link_next")
(NEWLINE)
(ID "link_next")
(PUNCT "[")
(ID "PREV")
(PUNCT "]")
(PUNCT "=")
(ID "link_prev")
(NEWLINE)
(ID "last")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "PREV")
(PUNCT "]")
(NEWLINE)
(ID "last")
(PUNCT "[")
(ID "NEXT")
(PUNCT "]")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "PREV")
(PUNCT "]")
(PUNCT "=")
(ID "link")
(NEWLINE)
(ID "link")
(PUNCT "[")
(ID "PREV")
(PUNCT "]")
(PUNCT "=")
(ID "last")
(NEWLINE)
(ID "link")
(PUNCT "[")
(ID "NEXT")
(PUNCT "]")
(PUNCT "=")
(ID "root")
(NEWLINE)
(ID "hits")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "user_function")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(KEYWORD in)
(ID "cache")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "full")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "oldroot")
(PUNCT "=")
(ID "root")
(NEWLINE)
(ID "oldroot")
(PUNCT "[")
(ID "KEY")
(PUNCT "]")
(PUNCT "=")
(ID "key")
(NEWLINE)
(ID "oldroot")
(PUNCT "[")
(ID "RESULT")
(PUNCT "]")
(PUNCT "=")
(ID "result")
(NEWLINE)
(ID "root")
(PUNCT "=")
(ID "oldroot")
(PUNCT "[")
(ID "NEXT")
(PUNCT "]")
(NEWLINE)
(ID "oldkey")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "KEY")
(PUNCT "]")
(NEWLINE)
(ID "oldresult")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "RESULT")
(PUNCT "]")
(NEWLINE)
(ID "root")
(PUNCT "[")
(ID "KEY")
(PUNCT "]")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "RESULT")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD del)
(ID "cache")
(PUNCT "[")
(ID "oldkey")
(PUNCT "]")
(NEWLINE)
(ID "cache")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "oldroot")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "PREV")
(PUNCT "]")
(NEWLINE)
(ID "link")
(PUNCT "=")
(PUNCT "[")
(ID "last")
(PUNCT ",")
(ID "root")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "result")
(PUNCT "]")
(NEWLINE)
(ID "last")
(PUNCT "[")
(ID "NEXT")
(PUNCT "]")
(PUNCT "=")
(ID "root")
(PUNCT "[")
(ID "PREV")
(PUNCT "]")
(PUNCT "=")
(ID "cache")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "link")
(NEWLINE)
(ID "full")
(PUNCT "=")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "cache")
(PUNCT ")")
(PUNCT ">=")
(ID "maxsize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "misses")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "cache_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Report cache statistics")
(NEWLINE)
(KEYWORD with)
(ID "lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_CacheInfo")
(PUNCT "(")
(ID "hits")
(PUNCT ",")
(ID "misses")
(PUNCT ",")
(ID "maxsize")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "cache")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "cache_clear")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Clear the cache and cache statistics")
(NEWLINE)
(KEYWORD nonlocal)
(ID "hits")
(PUNCT ",")
(ID "misses")
(PUNCT ",")
(ID "full")
(NEWLINE)
(KEYWORD with)
(ID "lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cache")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "root")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(ID "root")
(PUNCT ",")
(ID "root")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT "]")
(NEWLINE)
(ID "hits")
(PUNCT "=")
(ID "misses")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "full")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "wrapper")
(PUNCT ".")
(ID "cache_info")
(PUNCT "=")
(ID "cache_info")
(NEWLINE)
(ID "wrapper")
(PUNCT ".")
(ID "cache_clear")
(PUNCT "=")
(ID "cache_clear")
(NEWLINE)
(KEYWORD return)
(ID "update_wrapper")
(PUNCT "(")
(ID "wrapper")
(PUNCT ",")
(ID "user_function")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "decorating_function")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_c3_merge")
(PUNCT "(")
(ID "sequences")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n\n    Adapted from http://www.python.org/download/releases/2.3/mro/.\n\n    ")
(NEWLINE)
(ID "result")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sequences")
(PUNCT "=")
(PUNCT "[")
(ID "s")
(KEYWORD for)
(ID "s")
(KEYWORD in)
(ID "sequences")
(KEYWORD if)
(ID "s")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "sequences")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "s1")
(KEYWORD in)
(ID "sequences")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "candidate")
(PUNCT "=")
(ID "s1")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "s2")
(KEYWORD in)
(ID "sequences")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "candidate")
(KEYWORD in)
(ID "s2")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "candidate")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "candidate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "Inconsistent hierarchy")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "candidate")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "seq")
(KEYWORD in)
(ID "sequences")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "seq")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(ID "candidate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "seq")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_c3_mro")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "abcs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Computes the method resolution order using extended C3 linearization.\n\n    If no *abcs* are given, the algorithm works exactly like the built-in C3\n    linearization used for method resolution.\n\n    If given, *abcs* is a list of abstract base classes that should be inserted\n    into the resulting MRO. Unrelated ABCs are ignored and don't end up in the\n    result. The algorithm inserts ABCs where their functionality is introduced,\n    i.e. issubclass(cls, abc) returns True for the class itself but returns\n    False for all its direct base classes. Implicit ABCs for a given class\n    (either registered or inferred from the presence of a special method like\n    __len__) are inserted directly after the last ABC explicitly listed in the\n    MRO of said class. If two implicit ABCs end up next to each other in the\n    resulting MRO, their ordering depends on the order of types in *abcs*.\n\n    ")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "base")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "reversed")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__bases__")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(LIT "__abstractmethods__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "boundary")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__bases__")
(PUNCT ")")
(PUNCT "-")
(ID "i")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "boundary")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "abcs")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "abcs")
(PUNCT ")")
(KEYWORD if)
(ID "abcs")
(KEYWORD else)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "explicit_bases")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__bases__")
(PUNCT "[")
(PUNCT ":")
(ID "boundary")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "abstract_bases")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "other_bases")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__bases__")
(PUNCT "[")
(ID "boundary")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "abcs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "issubclass")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "base")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "any")
(PUNCT "(")
(ID "issubclass")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "base")
(PUNCT ")")
(KEYWORD for)
(ID "b")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "__bases__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "abstract_bases")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "abstract_bases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "abcs")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "explicit_c3_mros")
(PUNCT "=")
(PUNCT "[")
(ID "_c3_mro")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "abcs")
(PUNCT "=")
(ID "abcs")
(PUNCT ")")
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "explicit_bases")
(PUNCT "]")
(NEWLINE)
(ID "abstract_c3_mros")
(PUNCT "=")
(PUNCT "[")
(ID "_c3_mro")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "abcs")
(PUNCT "=")
(ID "abcs")
(PUNCT ")")
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "abstract_bases")
(PUNCT "]")
(NEWLINE)
(ID "other_c3_mros")
(PUNCT "=")
(PUNCT "[")
(ID "_c3_mro")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "abcs")
(PUNCT "=")
(ID "abcs")
(PUNCT ")")
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "other_bases")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "_c3_merge")
(PUNCT "(")
(PUNCT "[")
(PUNCT "[")
(ID "cls")
(PUNCT "]")
(PUNCT "]")
(PUNCT "+")
(ID "explicit_c3_mros")
(PUNCT "+")
(ID "abstract_c3_mros")
(PUNCT "+")
(ID "other_c3_mros")
(PUNCT "+")
(PUNCT "[")
(ID "explicit_bases")
(PUNCT "]")
(PUNCT "+")
(PUNCT "[")
(ID "abstract_bases")
(PUNCT "]")
(PUNCT "+")
(PUNCT "[")
(ID "other_bases")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_compose_mro")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "types")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Calculates the method resolution order for a given class *cls*.\n\n    Includes relevant abstract base classes (with their respective bases) from\n    the *types* iterable. Uses a modified C3 linearization algorithm.\n\n    ")
(NEWLINE)
(ID "bases")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "is_related")
(PUNCT "(")
(ID "typ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "typ")
(KEYWORD not)
(KEYWORD in)
(ID "bases")
(KEYWORD and)
(ID "hasattr")
(PUNCT "(")
(ID "typ")
(PUNCT ",")
(LIT "__mro__")
(PUNCT ")")
(KEYWORD and)
(ID "issubclass")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "typ")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "types")
(PUNCT "=")
(PUNCT "[")
(ID "n")
(KEYWORD for)
(ID "n")
(KEYWORD in)
(ID "types")
(KEYWORD if)
(ID "is_related")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "is_strict_base")
(PUNCT "(")
(ID "typ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "other")
(KEYWORD in)
(ID "types")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "typ")
(PUNCT "!=")
(ID "other")
(KEYWORD and)
(ID "typ")
(KEYWORD in)
(ID "other")
(PUNCT ".")
(ID "__mro__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "types")
(PUNCT "=")
(PUNCT "[")
(ID "n")
(KEYWORD for)
(ID "n")
(KEYWORD in)
(ID "types")
(KEYWORD if)
(KEYWORD not)
(ID "is_strict_base")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "type_set")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "types")
(PUNCT ")")
(NEWLINE)
(ID "mro")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "typ")
(KEYWORD in)
(ID "types")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "sub")
(KEYWORD in)
(ID "typ")
(PUNCT ".")
(ID "__subclasses__")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sub")
(KEYWORD not)
(KEYWORD in)
(ID "bases")
(KEYWORD and)
(ID "issubclass")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "sub")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "[")
(ID "s")
(KEYWORD for)
(ID "s")
(KEYWORD in)
(ID "sub")
(PUNCT ".")
(ID "__mro__")
(KEYWORD if)
(ID "s")
(KEYWORD in)
(ID "type_set")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "found")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mro")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "typ")
(PUNCT ")")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "found")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(ID "key")
(PUNCT "=")
(ID "len")
(PUNCT ",")
(ID "reverse")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "sub")
(KEYWORD in)
(ID "found")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "subcls")
(KEYWORD in)
(ID "sub")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "subcls")
(KEYWORD not)
(KEYWORD in)
(ID "mro")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mro")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "subcls")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "_c3_mro")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "abcs")
(PUNCT "=")
(ID "mro")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_find_impl")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "registry")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the best matching implementation from *registry* for type *cls*.\n\n    Where there is no registered implementation for a specific type, its method\n    resolution order is used to find a more generic implementation.\n\n    Note: if *registry* does not contain an implementation for the base\n    *object* type, this function may return None.\n\n    ")
(NEWLINE)
(ID "mro")
(PUNCT "=")
(ID "_compose_mro")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "registry")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "match")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "t")
(KEYWORD in)
(ID "mro")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "match")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "t")
(KEYWORD in)
(ID "registry")
(KEYWORD and)
(ID "t")
(KEYWORD not)
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "__mro__")
(KEYWORD and)
(ID "match")
(KEYWORD not)
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "__mro__")
(KEYWORD and)
(KEYWORD not)
(ID "issubclass")
(PUNCT "(")
(ID "match")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "Ambiguous dispatch: {} or {}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "match")
(PUNCT ",")
(ID "t")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "t")
(KEYWORD in)
(ID "registry")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "match")
(PUNCT "=")
(ID "t")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "registry")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "match")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "singledispatch")
(PUNCT "(")
(ID "func")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Single-dispatch generic function decorator.\n\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the type of its first argument. The decorated\n    function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.\n\n    ")
(NEWLINE)
(ID "registry")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "dispatch_cache")
(PUNCT "=")
(ID "WeakKeyDictionary")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cache_token")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "dispatch")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "generic_func.dispatch(cls) -> <function implementation>\n\n        Runs the dispatch algorithm to return the best available implementation\n        for the given *cls* registered on *generic_func*.\n\n        ")
(NEWLINE)
(KEYWORD nonlocal)
(ID "cache_token")
(NEWLINE)
(KEYWORD if)
(ID "cache_token")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "current_token")
(PUNCT "=")
(ID "get_cache_token")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "cache_token")
(PUNCT "!=")
(ID "current_token")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dispatch_cache")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cache_token")
(PUNCT "=")
(ID "current_token")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "impl")
(PUNCT "=")
(ID "dispatch_cache")
(PUNCT "[")
(ID "cls")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "impl")
(PUNCT "=")
(ID "registry")
(PUNCT "[")
(ID "cls")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "impl")
(PUNCT "=")
(ID "_find_impl")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "registry")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "dispatch_cache")
(PUNCT "[")
(ID "cls")
(PUNCT "]")
(PUNCT "=")
(ID "impl")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "impl")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "register")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "func")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "generic_func.register(cls, func) -> func\n\n        Registers a new implementation for the given *cls* on a *generic_func*.\n\n        ")
(NEWLINE)
(KEYWORD nonlocal)
(ID "cache_token")
(NEWLINE)
(KEYWORD if)
(ID "func")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD lambda)
(ID "f")
(PUNCT ":")
(ID "register")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "registry")
(PUNCT "[")
(ID "cls")
(PUNCT "]")
(PUNCT "=")
(ID "func")
(NEWLINE)
(KEYWORD if)
(ID "cache_token")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "hasattr")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(LIT "__abstractmethods__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cache_token")
(PUNCT "=")
(ID "get_cache_token")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "dispatch_cache")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "func")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "wrapper")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "dispatch")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "__class__")
(PUNCT ")")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "registry")
(PUNCT "[")
(ID "object")
(PUNCT "]")
(PUNCT "=")
(ID "func")
(NEWLINE)
(ID "wrapper")
(PUNCT ".")
(ID "register")
(PUNCT "=")
(ID "register")
(NEWLINE)
(ID "wrapper")
(PUNCT ".")
(ID "dispatch")
(PUNCT "=")
(ID "dispatch")
(NEWLINE)
(ID "wrapper")
(PUNCT ".")
(ID "registry")
(PUNCT "=")
(ID "MappingProxyType")
(PUNCT "(")
(ID "registry")
(PUNCT ")")
(NEWLINE)
(ID "wrapper")
(PUNCT ".")
(ID "_clear_cache")
(PUNCT "=")
(ID "dispatch_cache")
(PUNCT ".")
(ID "clear")
(NEWLINE)
(ID "update_wrapper")
(PUNCT "(")
(ID "wrapper")
(PUNCT ",")
(ID "func")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "wrapper")
(NEWLINE)
(DEDENT)
(ENDMARKER)
