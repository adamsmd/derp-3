(LIT "Utility code for constructing importers, etc.")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "MAGIC_NUMBER")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "cache_from_source")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "decode_source")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "source_from_cache")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "spec_from_loader")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "spec_from_file_location")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "_resolve_name")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "_bootstrap")
(KEYWORD import)
(ID "_find_spec")
(NEWLINE)
(KEYWORD from)
(ID "contextlib")
(KEYWORD import)
(ID "contextmanager")
(NEWLINE)
(KEYWORD import)
(ID "functools")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(KEYWORD def)
(ID "resolve_name")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "package")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Resolve a relative module name to an absolute one.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "package")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "{!r} is not a relative name ")
(LIT "(no leading dot)")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "level")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "character")
(KEYWORD in)
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "character")
(PUNCT "!=")
(LIT ".")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "level")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_resolve_name")
(PUNCT "(")
(ID "name")
(PUNCT "[")
(ID "level")
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(ID "package")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_find_spec_from_path")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "path")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the spec for the specified module.\n\n    First, sys.modules is checked to see if the module was already imported. If\n    so, then sys.modules[name].__spec__ is returned. If that happens to be\n    set to None, then ValueError is raised. If the module is not in\n    sys.modules, then sys.meta_path is searched for a suitable spec with the\n    value of 'path' given to the finders. None is returned if no spec could\n    be found.\n\n    Dotted names do not have their parent packages implicitly imported. You will\n    most likely need to explicitly import all parent packages in the proper\n    order for a submodule to get the correct spec.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "name")
(KEYWORD not)
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_find_spec")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spec")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__spec__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "{}.__spec__ is not set")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "spec")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "{}.__spec__ is None")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "spec")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "find_spec")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "package")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the spec for the specified module.\n\n    First, sys.modules is checked to see if the module was already imported. If\n    so, then sys.modules[name].__spec__ is returned. If that happens to be\n    set to None, then ValueError is raised. If the module is not in\n    sys.modules, then sys.meta_path is searched for a suitable spec with the\n    value of 'path' given to the finders. None is returned if no spec could\n    be found.\n\n    If the name is for submodule (contains a dot), the parent module is\n    automatically imported.\n\n    The name and package arguments work the same as importlib.import_module().\n    In other words, relative module names (with leading dots) work.\n\n    ")
(NEWLINE)
(ID "fullname")
(PUNCT "=")
(ID "resolve_name")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "package")
(PUNCT ")")
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(KEYWORD else)
(ID "name")
(NEWLINE)
(KEYWORD if)
(ID "fullname")
(KEYWORD not)
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parent_name")
(PUNCT "=")
(ID "fullname")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "parent_name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parent")
(PUNCT "=")
(ID "__import__")
(PUNCT "(")
(ID "parent_name")
(PUNCT ",")
(ID "fromlist")
(PUNCT "=")
(PUNCT "[")
(LIT "__path__")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_find_spec")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(ID "parent")
(PUNCT ".")
(ID "__path__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_find_spec")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "fullname")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spec")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__spec__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "{}.__spec__ is not set")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "spec")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "{}.__spec__ is None")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "spec")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "contextmanager")
(NEWLINE)
(KEYWORD def)
(ID "_module_to_load")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "is_reload")
(PUNCT "=")
(ID "name")
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "modules")
(NEWLINE)
(ID "module")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "is_reload")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "sys")
(PUNCT ")")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "module")
(PUNCT ".")
(ID "__initializing__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "module")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "module")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "is_reload")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__initializing__")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_package")
(PUNCT "(")
(ID "fxn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set __package__ on the returned module.\n\n    This function is deprecated.\n\n    ")
(NEWLINE)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "wraps")
(PUNCT "(")
(ID "fxn")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "set_package_wrapper")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The import system now takes care of this automatically.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "module")
(PUNCT "=")
(ID "fxn")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__package__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__package__")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__path__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__package__")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__package__")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "module")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "set_package_wrapper")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_loader")
(PUNCT "(")
(ID "fxn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set __loader__ on the returned module.\n\n    This function is deprecated.\n\n    ")
(NEWLINE)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "wraps")
(PUNCT "(")
(ID "fxn")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "set_loader_wrapper")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The import system now takes care of this automatically.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "module")
(PUNCT "=")
(ID "fxn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__loader__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__loader__")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "module")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "set_loader_wrapper")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "module_for_loader")
(PUNCT "(")
(ID "fxn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decorator to handle selecting the proper module for loaders.\n\n    The decorated function is passed the module to use instead of the module\n    name. The module passed in to the function is either from sys.modules if\n    it already exists or is a new module. If the module is new, then __name__\n    is set the first argument to the method, __loader__ is set to self, and\n    __package__ is set accordingly (if self.is_package() is defined) will be set\n    before it is passed to the decorated function (if self.is_package() does\n    not work for the module it will be set post-load).\n\n    If an exception is raised and the decorator created the module it is\n    subsequently removed from sys.modules.\n\n    The decorator assumes that the decorated function takes the module name as\n    the second argument.\n\n    ")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The import system now takes care of this automatically.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "wraps")
(PUNCT "(")
(ID "fxn")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "module_for_loader_wrapper")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "_module_to_load")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(KEYWORD as)
(ID "module")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__loader__")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "is_package")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "is_package")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "ImportError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "is_package")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__package__")
(PUNCT "=")
(ID "fullname")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT ".")
(ID "__package__")
(PUNCT "=")
(ID "fullname")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "fxn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "module")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "module_for_loader_wrapper")
(NEWLINE)
(DEDENT)
(ENDMARKER)
