(LIT "Text wrapping and filling.\n")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "TextWrapper")
(PUNCT ",")
(LIT "wrap")
(PUNCT ",")
(LIT "fill")
(PUNCT ",")
(LIT "dedent")
(PUNCT ",")
(LIT "indent")
(PUNCT ",")
(LIT "shorten")
(PUNCT "]")
(NEWLINE)
(ID "_whitespace")
(PUNCT "=")
(LIT "\t\n\v\f\r ")
(NEWLINE)
(KEYWORD class)
(ID "TextWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Object for wrapping/filling text.  The public interface consists of\n    the wrap() and fill() methods; the other methods are just there for\n    subclasses to override in order to tweak the default behaviour.\n    If you want to completely replace the main wrapping algorithm,\n    you'll probably have to override _wrap_chunks().\n\n    Several instance attributes control various aspects of wrapping:\n      width (default: 70)\n        the maximum width of wrapped lines (unless break_long_words\n        is false)\n      initial_indent (default: \"\")\n        string that will be prepended to the first line of wrapped\n        output.  Counts towards the line's width.\n      subsequent_indent (default: \"\")\n        string that will be prepended to all lines save the first\n        of wrapped output; also counts towards each line's width.\n      expand_tabs (default: true)\n        Expand tabs in input text to spaces before further processing.\n        Each tab will become 0 .. 'tabsize' spaces, depending on its position\n        in its line.  If false, each tab is treated as a single character.\n      tabsize (default: 8)\n        Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n        'expand_tabs' is false.\n      replace_whitespace (default: true)\n        Replace all whitespace characters in the input text by spaces\n        after tab expansion.  Note that if expand_tabs is false and\n        replace_whitespace is true, every tab will be converted to a\n        single space!\n      fix_sentence_endings (default: false)\n        Ensure that sentence-ending punctuation is always followed\n        by two spaces.  Off by default because the algorithm is\n        (unavoidably) imperfect.\n      break_long_words (default: true)\n        Break words longer than 'width'.  If false, those words will not\n        be broken, and some lines might be longer than 'width'.\n      break_on_hyphens (default: true)\n        Allow breaking hyphenated words. If true, wrapping will occur\n        preferably on whitespaces and right after hyphens part of\n        compound words.\n      drop_whitespace (default: true)\n        Drop leading and trailing whitespace from lines.\n      max_lines (default: None)\n        Truncate wrapped lines.\n      placeholder (default: ' [...]')\n        Append to the last line of truncated text.\n    ")
(NEWLINE)
(ID "unicode_whitespace_trans")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "uspace")
(PUNCT "=")
(ID "ord")
(PUNCT "(")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "_whitespace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "unicode_whitespace_trans")
(PUNCT "[")
(ID "ord")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "uspace")
(NEWLINE)
(DEDENT)
(ID "wordsep_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "(\\s+|")
(LIT "[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W])|")
(LIT "(?<=[\\w\\!\\\"\\'\\&\\.\\,\\?])-{2,}(?=\\w))")
(PUNCT ")")
(NEWLINE)
(ID "wordsep_simple_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "(\\s+)")
(PUNCT ")")
(NEWLINE)
(ID "sentence_end_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "[a-z]")
(LIT "[\\.\\!\\?]")
(LIT "[\\\"\\']?")
(LIT "\\Z")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "width")
(PUNCT "=")
(LIT 70)
(PUNCT ",")
(ID "initial_indent")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "subsequent_indent")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "expand_tabs")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "replace_whitespace")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "fix_sentence_endings")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "break_long_words")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "drop_whitespace")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "break_on_hyphens")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "tabsize")
(PUNCT "=")
(LIT 8)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "max_lines")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "placeholder")
(PUNCT "=")
(LIT " [...]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "width")
(PUNCT "=")
(ID "width")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "initial_indent")
(PUNCT "=")
(ID "initial_indent")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "subsequent_indent")
(PUNCT "=")
(ID "subsequent_indent")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "expand_tabs")
(PUNCT "=")
(ID "expand_tabs")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "replace_whitespace")
(PUNCT "=")
(ID "replace_whitespace")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "fix_sentence_endings")
(PUNCT "=")
(ID "fix_sentence_endings")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "break_long_words")
(PUNCT "=")
(ID "break_long_words")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "drop_whitespace")
(PUNCT "=")
(ID "drop_whitespace")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "break_on_hyphens")
(PUNCT "=")
(ID "break_on_hyphens")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tabsize")
(PUNCT "=")
(ID "tabsize")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "max_lines")
(PUNCT "=")
(ID "max_lines")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "placeholder")
(PUNCT "=")
(ID "placeholder")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_munge_whitespace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "_munge_whitespace(text : string) -> string\n\n        Munge whitespace in text: expand tabs and convert all other\n        whitespace characters to spaces.  Eg. \" foo\tbar\n\nbaz\"\n        becomes \" foo    bar  baz\".\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "expand_tabs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "expandtabs")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "tabsize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "replace_whitespace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "unicode_whitespace_trans")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_split")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "_split(text : string) -> [string]\n\n        Split the text to wrap into indivisible chunks.  Chunks are\n        not quite the same as words; see _wrap_chunks() for full\n        details.  As an example, the text\n          Look, goof-ball -- use the -b option!\n        breaks into the following chunks:\n          'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n        if break_on_hyphens is True, or in:\n          'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', option!'\n        otherwise.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "break_on_hyphens")
(KEYWORD is)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunks")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "wordsep_re")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunks")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "wordsep_simple_re")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "chunks")
(PUNCT "=")
(PUNCT "[")
(ID "c")
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "chunks")
(KEYWORD if)
(ID "c")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "chunks")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fix_sentence_endings")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "chunks")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "_fix_sentence_endings(chunks : [string])\n\n        Correct for sentence endings buried in 'chunks'.  Eg. when the\n        original text contains \"... foo.\nBar ...\", munge_whitespace()\n        and split() will convert that to [..., \"foo.\", \" \", \"Bar\", ...]\n        which has one too few spaces; this method simply changes the one\n        space to two.\n        ")
(NEWLINE)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "patsearch")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "sentence_end_re")
(PUNCT ".")
(ID "search")
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "len")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "chunks")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT " ")
(KEYWORD and)
(ID "patsearch")
(PUNCT "(")
(ID "chunks")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunks")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(LIT "  ")
(NEWLINE)
(ID "i")
(PUNCT "+=")
(LIT 2)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_handle_long_word")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "reversed_chunks")
(PUNCT ",")
(ID "cur_line")
(PUNCT ",")
(ID "cur_len")
(PUNCT ",")
(ID "width")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "_handle_long_word(chunks : [string],\n                             cur_line : [string],\n                             cur_len : int, width : int)\n\n        Handle a chunk of text (most likely a word, not whitespace) that\n        is too long to fit in any line.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "width")
(PUNCT "<")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "space_left")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "space_left")
(PUNCT "=")
(ID "width")
(PUNCT "-")
(ID "cur_len")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "break_long_words")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cur_line")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "reversed_chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "[")
(PUNCT ":")
(ID "space_left")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "reversed_chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "reversed_chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "[")
(ID "space_left")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "cur_line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cur_line")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "reversed_chunks")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_wrap_chunks")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "chunks")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "_wrap_chunks(chunks : [string]) -> [string]\n\n        Wrap a sequence of text chunks and return a list of lines of\n        length 'self.width' or less.  (If 'break_long_words' is false,\n        some lines may be longer than this.)  Chunks correspond roughly\n        to words and the whitespace between them: each chunk is\n        indivisible (modulo 'break_long_words'), but a line break can\n        come between any two chunks.  Chunks should not have internal\n        whitespace; ie. a chunk is either all whitespace or a \"word\".\n        Whitespace chunks will be removed from the beginning and end of\n        lines, but apart from that whitespace is preserved.\n        ")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "width")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid width %r (must be > 0)")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "width")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "max_lines")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "max_lines")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "subsequent_indent")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "initial_indent")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "indent")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "placeholder")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "width")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "placeholder too large for max width")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "chunks")
(PUNCT ".")
(ID "reverse")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "chunks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cur_line")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "cur_len")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "subsequent_indent")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "initial_indent")
(NEWLINE)
(DEDENT)
(ID "width")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "width")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "indent")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "drop_whitespace")
(KEYWORD and)
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "")
(KEYWORD and)
(ID "lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "chunks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "l")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "cur_len")
(PUNCT "+")
(ID "l")
(PUNCT "<=")
(ID "width")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cur_line")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "chunks")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "cur_len")
(PUNCT "+=")
(ID "l")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "chunks")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ">")
(ID "width")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_handle_long_word")
(PUNCT "(")
(ID "chunks")
(PUNCT ",")
(ID "cur_line")
(PUNCT ",")
(ID "cur_len")
(PUNCT ",")
(ID "width")
(PUNCT ")")
(NEWLINE)
(ID "cur_len")
(PUNCT "=")
(ID "sum")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "len")
(PUNCT ",")
(ID "cur_line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "drop_whitespace")
(KEYWORD and)
(ID "cur_line")
(KEYWORD and)
(ID "cur_line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cur_len")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "cur_line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "cur_line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cur_line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "max_lines")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT "<")
(ID "self")
(PUNCT ".")
(ID "max_lines")
(KEYWORD or)
(PUNCT "(")
(KEYWORD not)
(ID "chunks")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "drop_whitespace")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(KEYWORD not)
(ID "chunks")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(KEYWORD and)
(ID "cur_len")
(PUNCT "<=")
(ID "width")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "indent")
(PUNCT "+")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "cur_line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "cur_line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "cur_line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "cur_len")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "placeholder")
(PUNCT ")")
(PUNCT "<=")
(ID "width")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cur_line")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "placeholder")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "indent")
(PUNCT "+")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "cur_line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "cur_len")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "cur_line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "cur_line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prev_line")
(PUNCT "=")
(ID "lines")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "prev_line")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "placeholder")
(PUNCT ")")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "width")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "prev_line")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "placeholder")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "indent")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "placeholder")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "lines")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_split_chunks")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_munge_whitespace")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_split")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "wrap")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "wrap(text : string) -> [string]\n\n        Reformat the single paragraph in 'text' so it fits in lines of\n        no more than 'self.width' columns, and return a list of wrapped\n        lines.  Tabs in 'text' are expanded with string.expandtabs(),\n        and all other whitespace characters (including newline) are\n        converted to space.\n        ")
(NEWLINE)
(ID "chunks")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_split_chunks")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "fix_sentence_endings")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_fix_sentence_endings")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_wrap_chunks")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fill")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "fill(text : string) -> string\n\n        Reformat the single paragraph in 'text' to fit in lines of no\n        more than 'self.width' columns, and return a new string\n        containing the entire wrapped paragraph.\n        ")
(NEWLINE)
(KEYWORD return)
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "wrap")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "wrap")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "width")
(PUNCT "=")
(LIT 70)
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wrap a single paragraph of text, returning a list of wrapped lines.\n\n    Reformat the single paragraph in 'text' so it fits in lines of no\n    more than 'width' columns, and return a list of wrapped lines.  By\n    default, tabs in 'text' are expanded with string.expandtabs(), and\n    all other whitespace characters (including newline) are converted to\n    space.  See TextWrapper class for available keyword args to customize\n    wrapping behaviour.\n    ")
(NEWLINE)
(ID "w")
(PUNCT "=")
(ID "TextWrapper")
(PUNCT "(")
(ID "width")
(PUNCT "=")
(ID "width")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "w")
(PUNCT ".")
(ID "wrap")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fill")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "width")
(PUNCT "=")
(LIT 70)
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Fill a single paragraph of text, returning a new string.\n\n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n    ")
(NEWLINE)
(ID "w")
(PUNCT "=")
(ID "TextWrapper")
(PUNCT "(")
(ID "width")
(PUNCT "=")
(ID "width")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "w")
(PUNCT ".")
(ID "fill")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shorten")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "width")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Collapse and truncate the given text to fit in the given width.\n\n    The text first has its whitespace collapsed.  If it then fits in\n    the *width*, it is returned as is.  Otherwise, as many words\n    as possible are joined and then the placeholder is appended::\n\n        >>> textwrap.shorten(\"Hello  world!\", width=12)\n        'Hello world!'\n        >>> textwrap.shorten(\"Hello  world!\", width=11)\n        'Hello [...]'\n    ")
(NEWLINE)
(ID "w")
(PUNCT "=")
(ID "TextWrapper")
(PUNCT "(")
(ID "width")
(PUNCT "=")
(ID "width")
(PUNCT ",")
(ID "max_lines")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "w")
(PUNCT ".")
(ID "fill")
(PUNCT "(")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "text")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_whitespace_only_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^[ \t]+$")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT ")")
(NEWLINE)
(ID "_leading_whitespace_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "(^[ \t]*)(?:[^ \t\n])")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "dedent")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove any common leading whitespace from every line in `text`.\n\n    This can be used to make triple-quoted strings line up with the left\n    edge of the display, while still presenting them in the source code\n    in indented form.\n\n    Note that tabs and spaces are both treated as whitespace, but they\n    are not equal: the lines \"  hello\" and \"\thello\" are\n    considered to have no common leading whitespace.  (This behaviour is\n    new in Python 2.5; older versions of this module incorrectly\n    expanded tabs before searching for common leading whitespace.)\n    ")
(NEWLINE)
(ID "margin")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "text")
(PUNCT "=")
(ID "_whitespace_only_re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(ID "indents")
(PUNCT "=")
(ID "_leading_whitespace_re")
(PUNCT ".")
(ID "findall")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "indent")
(KEYWORD in)
(ID "indents")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "margin")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "margin")
(PUNCT "=")
(ID "indent")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "indent")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "margin")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "margin")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "indent")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "margin")
(PUNCT "=")
(ID "indent")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "margin")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(LIT 0)
(KEYWORD and)
(ID "margin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "text")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "line")
(KEYWORD or)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "margin")
(PUNCT ")")
(PUNCT ",")
(LIT "line = %r, margin = %r")
(PUNCT "%")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(ID "margin")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "margin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "(?m)^")
(PUNCT "+")
(ID "margin")
(PUNCT ",")
(LIT "")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "indent")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "prefix")
(PUNCT ",")
(ID "predicate")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Adds 'prefix' to the beginning of selected lines in 'text'.\n\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "predicate")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "predicate")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "prefixed_lines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "text")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(PUNCT "(")
(ID "prefix")
(PUNCT "+")
(ID "line")
(KEYWORD if)
(ID "predicate")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(KEYWORD else)
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "prefixed_lines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "dedent")
(PUNCT "(")
(LIT "Hello there.\n  This is indented.")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
