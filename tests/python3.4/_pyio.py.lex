(LIT "\nPython implementation of the io module.\n")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "abc")
(NEWLINE)
(KEYWORD import)
(ID "codecs")
(NEWLINE)
(KEYWORD import)
(ID "errno")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_thread")
(KEYWORD import)
(ID "allocate_lock")
(KEYWORD as)
(ID "Lock")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_dummy_thread")
(KEYWORD import)
(ID "allocate_lock")
(KEYWORD as)
(ID "Lock")
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD from)
(ID "io")
(KEYWORD import)
(PUNCT "(")
(ID "__all__")
(PUNCT ",")
(ID "SEEK_SET")
(PUNCT ",")
(ID "SEEK_CUR")
(PUNCT ",")
(ID "SEEK_END")
(PUNCT ")")
(NEWLINE)
(ID "valid_seek_flags")
(PUNCT "=")
(PUNCT "{")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "SEEK_HOLE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "valid_seek_flags")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "SEEK_HOLE")
(PUNCT ")")
(NEWLINE)
(ID "valid_seek_flags")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "SEEK_DATA")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "DEFAULT_BUFFER_SIZE")
(PUNCT "=")
(LIT 8)
(PUNCT "*")
(LIT 1024)
(NEWLINE)
(ID "BlockingIOError")
(PUNCT "=")
(ID "BlockingIOError")
(NEWLINE)
(KEYWORD def)
(ID "open")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT "r")
(PUNCT ",")
(ID "buffering")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "closefd")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "opener")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Open file and return a stream.  Raise OSError upon failure.\n\n    file is either a text or byte string giving the name (and the path\n    if the file isn't in the current working directory) of the file to\n    be opened or an integer file descriptor of the file to be\n    wrapped. (If a file descriptor is given, it is closed when the\n    returned I/O object is closed, unless closefd is set to False.)\n\n    mode is an optional string that specifies the mode in which the file is\n    opened. It defaults to 'r' which means open for reading in text mode. Other\n    common values are 'w' for writing (truncating the file if it already\n    exists), 'x' for exclusive creation of a new file, and 'a' for appending\n    (which on some Unix systems, means that all writes append to the end of the\n    file regardless of the current seek position). In text mode, if encoding is\n    not specified the encoding used is platform dependent. (For reading and\n    writing raw bytes use binary mode and leave encoding unspecified.) The\n    available modes are:\n\n    ========= ===============================================================\n    Character Meaning\n    --------- ---------------------------------------------------------------\n    'r'       open for reading (default)\n    'w'       open for writing, truncating the file first\n    'x'       create a new file and open it for writing\n    'a'       open for writing, appending to the end of the file if it exists\n    'b'       binary mode\n    't'       text mode (default)\n    '+'       open a disk file for updating (reading and writing)\n    'U'       universal newline mode (deprecated)\n    ========= ===============================================================\n\n    The default mode is 'rt' (open for reading text). For binary random\n    access, the mode 'w+b' opens and truncates the file to 0 bytes, while\n    'r+b' opens the file without truncation. The 'x' mode implies 'w' and\n    raises an `FileExistsError` if the file already exists.\n\n    Python distinguishes between files opened in binary and text modes,\n    even when the underlying operating system doesn't. Files opened in\n    binary mode (appending 'b' to the mode argument) return contents as\n    bytes objects without any decoding. In text mode (the default, or when\n    't' is appended to the mode argument), the contents of the file are\n    returned as strings, the bytes having been first decoded using a\n    platform-dependent encoding or using the specified encoding if given.\n\n    'U' mode is deprecated and will raise an exception in future versions\n    of Python.  It has no effect in Python 3.  Use newline to control\n    universal newlines mode.\n\n    buffering is an optional integer used to set the buffering policy.\n    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select\n    line buffering (only usable in text mode), and an integer > 1 to indicate\n    the size of a fixed-size chunk buffer.  When no buffering argument is\n    given, the default buffering policy works as follows:\n\n    * Binary files are buffered in fixed-size chunks; the size of the buffer\n      is chosen using a heuristic trying to determine the underlying device's\n      \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n      On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n    * \"Interactive\" text files (files for which isatty() returns True)\n      use line buffering.  Other text files use the policy described above\n      for binary files.\n\n    encoding is the str name of the encoding used to decode or encode the\n    file. This should only be used in text mode. The default encoding is\n    platform dependent, but any encoding supported by Python can be\n    passed.  See the codecs module for the list of supported encodings.\n\n    errors is an optional string that specifies how encoding errors are to\n    be handled---this argument should not be used in binary mode. Pass\n    'strict' to raise a ValueError exception if there is an encoding error\n    (the default of None has the same effect), or pass 'ignore' to ignore\n    errors. (Note that ignoring encoding errors can lead to data loss.)\n    See the documentation for codecs.register for a list of the permitted\n    encoding error strings.\n\n    newline is a string controlling how universal newlines works (it only\n    applies to text mode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works\n    as follows:\n\n    * On input, if newline is None, universal newlines mode is\n      enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n      these are translated into '\\n' before being returned to the\n      caller. If it is '', universal newline mode is enabled, but line\n      endings are returned to the caller untranslated. If it has any of\n      the other legal values, input lines are only terminated by the given\n      string, and the line ending is returned to the caller untranslated.\n\n    * On output, if newline is None, any '\\n' characters written are\n      translated to the system default line separator, os.linesep. If\n      newline is '', no translation takes place. If newline is any of the\n      other legal values, any '\\n' characters written are translated to\n      the given string.\n\n    closedfd is a bool. If closefd is False, the underlying file descriptor will\n    be kept open when the file is closed. This does not work when a file name is\n    given and must be True in that case.\n\n    The newly created file is non-inheritable.\n\n    A custom opener can be used by passing a callable as *opener*. The\n    underlying file descriptor for the file object is then obtained by calling\n    *opener* with (*file*, *flags*). *opener* must return an open file\n    descriptor (passing os.open as *opener* results in functionality similar to\n    passing None).\n\n    open() returns a file object whose type depends on the mode, and\n    through which the standard file operations such as reading and writing\n    are performed. When open() is used to open a file in a text mode ('w',\n    'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\n    a file in a binary mode, the returned class varies: in read binary\n    mode, it returns a BufferedReader; in write binary and append binary\n    modes, it returns a BufferedWriter, and in read/write mode, it returns\n    a BufferedRandom.\n\n    It is also possible to use a string or bytearray as a file for both\n    reading and writing. For strings StringIO can be used like a file\n    opened in a text mode, and for bytes a BytesIO can be used like a file\n    opened in a binary mode.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "bytes")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid file: %r")
(PUNCT "%")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid mode: %r")
(PUNCT "%")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "buffering")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid buffering: %r")
(PUNCT "%")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid encoding: %r")
(PUNCT "%")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "errors")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "errors")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "invalid errors: %r")
(PUNCT "%")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "modes")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "modes")
(PUNCT "-")
(ID "set")
(PUNCT "(")
(LIT "axrwb+tU")
(PUNCT ")")
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "mode")
(PUNCT ")")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "modes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid mode: %r")
(PUNCT "%")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "creating")
(PUNCT "=")
(LIT "x")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(ID "reading")
(PUNCT "=")
(LIT "r")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(ID "writing")
(PUNCT "=")
(LIT "w")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(ID "appending")
(PUNCT "=")
(LIT "a")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(ID "updating")
(PUNCT "=")
(LIT "+")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(ID "text")
(PUNCT "=")
(LIT "t")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(ID "binary")
(PUNCT "=")
(LIT "b")
(KEYWORD in)
(ID "modes")
(NEWLINE)
(KEYWORD if)
(LIT "U")
(KEYWORD in)
(ID "modes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "creating")
(KEYWORD or)
(ID "writing")
(KEYWORD or)
(ID "appending")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "can't use U and writing mode at once")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "'U' mode is deprecated")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "reading")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "text")
(KEYWORD and)
(ID "binary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "can't have text and binary mode at once")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "creating")
(PUNCT "+")
(ID "reading")
(PUNCT "+")
(ID "writing")
(PUNCT "+")
(ID "appending")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "can't have read/write/append mode at once")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "creating")
(KEYWORD or)
(ID "reading")
(KEYWORD or)
(ID "writing")
(KEYWORD or)
(ID "appending")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "must have exactly one of read/write/append mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "binary")
(KEYWORD and)
(ID "encoding")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "binary mode doesn't take an encoding argument")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "binary")
(KEYWORD and)
(ID "errors")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "binary mode doesn't take an errors argument")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "binary")
(KEYWORD and)
(ID "newline")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "binary mode doesn't take a newline argument")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "raw")
(PUNCT "=")
(ID "FileIO")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(PUNCT "(")
(ID "creating")
(KEYWORD and)
(LIT "x")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "reading")
(KEYWORD and)
(LIT "r")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "writing")
(KEYWORD and)
(LIT "w")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "appending")
(KEYWORD and)
(LIT "a")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "updating")
(KEYWORD and)
(LIT "+")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT ",")
(ID "closefd")
(PUNCT ",")
(ID "opener")
(PUNCT "=")
(ID "opener")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "raw")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line_buffering")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(ID "buffering")
(PUNCT "==")
(LIT 1)
(KEYWORD or)
(ID "buffering")
(PUNCT "<")
(LIT 0)
(KEYWORD and)
(ID "raw")
(PUNCT ".")
(ID "isatty")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffering")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "line_buffering")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "buffering")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffering")
(PUNCT "=")
(ID "DEFAULT_BUFFER_SIZE")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bs")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fstat")
(PUNCT "(")
(ID "raw")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "st_blksize")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "OSError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "bs")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffering")
(PUNCT "=")
(ID "bs")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "buffering")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid buffering size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "buffering")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "binary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "can't have unbuffered text I/O")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "updating")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffer")
(PUNCT "=")
(ID "BufferedRandom")
(PUNCT "(")
(ID "raw")
(PUNCT ",")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "creating")
(KEYWORD or)
(ID "writing")
(KEYWORD or)
(ID "appending")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffer")
(PUNCT "=")
(ID "BufferedWriter")
(PUNCT "(")
(ID "raw")
(PUNCT ",")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "reading")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffer")
(PUNCT "=")
(ID "BufferedReader")
(PUNCT "(")
(ID "raw")
(PUNCT ",")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown mode: %r")
(PUNCT "%")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "buffer")
(NEWLINE)
(KEYWORD if)
(ID "binary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "TextIOWrapper")
(PUNCT "(")
(ID "buffer")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ",")
(ID "newline")
(PUNCT ",")
(ID "line_buffering")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "text")
(NEWLINE)
(ID "text")
(PUNCT ".")
(ID "mode")
(PUNCT "=")
(ID "mode")
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DocDescriptor")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper for builtins.open.__doc__\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__get__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "typ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(LIT "open(file, mode='r', buffering=-1, encoding=None, ")
(LIT "errors=None, newline=None, closefd=True)\n\n")
(PUNCT "+")
(ID "open")
(PUNCT ".")
(ID "__doc__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "OpenWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wrapper for builtins.open\n\n    Trick so that open won't become a bound method when stored\n    as a class variable (as dbm.dumb does).\n\n    See initstdio() in Python/pythonrun.c.\n    ")
(NEWLINE)
(ID "__doc__")
(PUNCT "=")
(ID "DocDescriptor")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "open")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "UnsupportedOperation")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "UnsupportedOperation")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD class)
(ID "UnsupportedOperation")
(PUNCT "(")
(ID "ValueError")
(PUNCT ",")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IOBase")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "abc")
(PUNCT ".")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The abstract base class for all I/O classes, acting on streams of\n    bytes. There is no public constructor.\n\n    This class provides dummy implementations for many methods that\n    derived classes can override selectively; the default implementations\n    represent a file that cannot be read, written or seeked.\n\n    Even though IOBase does not declare read, readinto, or write because\n    their signatures will vary, implementations and clients should\n    consider those methods part of the interface. Also, implementations\n    may raise UnsupportedOperation when operations they do not support are\n    called.\n\n    The basic type used for binary data read from or written to a file is\n    bytes. bytearrays are accepted too, and in some cases (such as\n    readinto) needed. Text I/O classes work with str data.\n\n    Note that calling any method (even inquiries) on a closed stream is\n    undefined. Implementations may raise OSError in this case.\n\n    IOBase (and its subclasses) support the iterator protocol, meaning\n    that an IOBase object can be iterated over yielding the lines in a\n    stream.\n\n    IOBase also supports the :keyword:`with` statement. In this example,\n    fp is closed after the suite of the with statement is complete:\n\n    with open('spam.txt', 'r') as fp:\n        fp.write('Spam and eggs!')\n    ")
(NEWLINE)
(KEYWORD def)
(ID "_unsupported")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: raise an OSError exception for unsupported operations.")
(NEWLINE)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "%s.%s() not supported")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Change stream position.\n\n        Change the stream position to byte offset pos. Argument pos is\n        interpreted relative to the position indicated by whence.  Values\n        for whence are ints:\n\n        * 0 -- start of stream (the default); offset should be zero or positive\n        * 1 -- current stream position; offset may be negative\n        * 2 -- end of stream; offset is usually negative\n        Some operating systems / file systems could provide additional values.\n\n        Return an int indicating the new absolute position.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "seek")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an int indicating the current stream position.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Truncate file to size bytes.\n\n        Size defaults to the current IO position as reported by tell().  Return\n        the new size.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "truncate")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Flush write buffers, if applicable.\n\n        This is not implemented for read-only and non-blocking streams.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__closed")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Flush and close the IO object.\n\n        This method has no effect if the file is already closed.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "__closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "__closed")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Destructor.  Calls close().")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "seekable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a bool indicating whether object supports random access.\n\n        If False, seek(), tell() and truncate() will raise UnsupportedOperation.\n        This method may need to do a test seek().\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_checkSeekable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: raise UnsupportedOperation if file is not seekable\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "seekable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "File or stream is not seekable.")
(KEYWORD if)
(ID "msg")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "readable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a bool indicating whether object was opened for reading.\n\n        If False, read() will raise UnsupportedOperation.\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_checkReadable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: raise UnsupportedOperation if file is not readable\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "readable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "File or stream is not readable.")
(KEYWORD if)
(ID "msg")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a bool indicating whether object was opened for writing.\n\n        If False, write() and truncate() will raise UnsupportedOperation.\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_checkWritable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: raise UnsupportedOperation if file is not writable\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "File or stream is not writable.")
(KEYWORD if)
(ID "msg")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "closed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "closed: bool.  True iff the file has been closed.\n\n        For backwards compatibility, this is a property, not a predicate.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__closed")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_checkClosed")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: raise an ValueError if file is closed\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file.")
(KEYWORD if)
(ID "msg")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Context management protocol.  Returns self (an instance of IOBase).")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Context management protocol.  Calls close()")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns underlying file descriptor (an int) if one exists.\n\n        An OSError is raised if the IO object does not use a file descriptor.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "fileno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isatty")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a bool indicating whether this is an 'interactive' stream.\n\n        Return False if it can't be determined.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readline")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read and return a line of bytes from the stream.\n\n        If size is specified, at most size bytes will be read.\n        Size should be an int.\n\n        The line terminator is always b'\\n' for binary files; for text\n        files, the newlines argument to open can be used to select the line\n        terminator(s) recognized.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "peek")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "nreadahead")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "readahead")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "peek")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "readahead")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "n")
(PUNCT "=")
(PUNCT "(")
(ID "readahead")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT #"\n")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "readahead")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "size")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "n")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "nreadahead")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "size")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "size must be an integer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "res")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "size")
(PUNCT "<")
(LIT 0)
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(PUNCT "<")
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "nreadahead")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "b")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "res")
(PUNCT "+=")
(ID "b")
(NEWLINE)
(KEYWORD if)
(ID "res")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__next__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readlines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "hint")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of lines from the stream.\n\n        hint can be specified to control the number of lines read: no more\n        lines will be read if the total size (in bytes/characters) of all\n        lines so far exceeds hint.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "hint")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "hint")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "n")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">=")
(ID "hint")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "lines")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writelines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "io")
(PUNCT ".")
(ID "IOBase")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "IOBase")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "RawIOBase")
(PUNCT "(")
(ID "IOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for raw binary I/O.")
(NEWLINE)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read and return up to size bytes, where size is an int.\n\n        Returns an empty bytes object on EOF, or None if the object is\n        set not to block and has no data to read.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "readall")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "b")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(ID "size")
(PUNCT ".")
(ID "__index__")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "readinto")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "b")
(PUNCT "[")
(ID "n")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readall")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read until EOF, using multiple read() call.")
(NEWLINE)
(ID "res")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "DEFAULT_BUFFER_SIZE")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "res")
(PUNCT "+=")
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "res")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "readinto")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read up to len(b) bytes into bytearray b.\n\n        Returns an int representing the number of bytes read (0 for EOF), or\n        None if the object is set not to block and has no data to read.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "readinto")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write the given buffer to the IO stream.\n\n        Returns the number of bytes written, which may be less than len(b).\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "write")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "io")
(PUNCT ".")
(ID "RawIOBase")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "RawIOBase")
(PUNCT ")")
(NEWLINE)
(KEYWORD from)
(ID "_io")
(KEYWORD import)
(ID "FileIO")
(NEWLINE)
(ID "RawIOBase")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "FileIO")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "BufferedIOBase")
(PUNCT "(")
(ID "IOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for buffered IO objects.\n\n    The main difference with RawIOBase is that the read() method\n    supports omitting the size argument, and does not have a default\n    implementation that defers to readinto().\n\n    In addition, read(), readinto() and write() may raise\n    BlockingIOError if the underlying raw stream is in non-blocking\n    mode and not ready; unlike their raw counterparts, they will never\n    return None.\n\n    A typical implementation should not inherit from a RawIOBase\n    implementation, but wrap one.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read and return up to size bytes, where size is an int.\n\n        If the argument is omitted, None, or negative, reads and\n        returns all data until EOF.\n\n        If the argument is positive, and the underlying raw stream is\n        not 'interactive', multiple raw reads may be issued to satisfy\n        the byte count (unless EOF is reached first).  But for\n        interactive raw streams (XXX and for pipes?), at most one raw\n        read will be issued, and a short result does not imply that\n        EOF is imminent.\n\n        Returns an empty bytes array on EOF.\n\n        Raises BlockingIOError if the underlying raw stream has no\n        data at the moment.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "read")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read up to size bytes with at most one read() system call,\n        where size is an int.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "read1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readinto")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read up to len(b) bytes into bytearray b.\n\n        Like read(), this may issue multiple reads to the underlying raw\n        stream, unless the latter is 'interactive'.\n\n        Returns an int representing the number of bytes read (0 for EOF).\n\n        Raises BlockingIOError if the underlying raw stream has no\n        data at the moment.\n        ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(PUNCT "=")
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "array")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "array")
(PUNCT ".")
(ID "array")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "err")
(NEWLINE)
(DEDENT)
(ID "b")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(PUNCT "=")
(ID "array")
(PUNCT ".")
(ID "array")
(PUNCT "(")
(LIT "b")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "n")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write the given bytes buffer to the IO stream.\n\n        Return the number of bytes written, which is never less than\n        len(b).\n\n        Raises BlockingIOError if the buffer is full and the\n        underlying raw stream cannot accept more data at the moment.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "write")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "detach")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Separate the underlying raw stream from the buffer and return it.\n\n        After the raw stream has been detached, the buffer is in an unusable\n        state.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "detach")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "io")
(PUNCT ".")
(ID "BufferedIOBase")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "BufferedIOBase")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "_BufferedIOMixin")
(PUNCT "(")
(ID "BufferedIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A mixin implementation of BufferedIOBase with an underlying raw stream.\n\n    This passes most requests on to the underlying raw stream.  It\n    does *not* provide implementations of read(), readinto() or\n    write().\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_raw")
(PUNCT "=")
(ID "raw")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_position")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new_position")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "seek() returned an invalid position")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "new_position")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "tell() returned an invalid position")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "truncate")
(PUNCT "(")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "flush of closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "raw")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "detach")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "raw")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "raw stream already detached")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "raw")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_raw")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_raw")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(ID "raw")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seekable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "seekable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "readable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "raw")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_raw")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "closed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "closed")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "mode")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "mode")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getstate__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "can not serialize a '{0}' object")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "clsname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<_pyio.{0}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "clsname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<_pyio.{0} name={1!r}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "clsname")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isatty")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "isatty")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BytesIO")
(PUNCT "(")
(ID "BufferedIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Buffered I/O implementation using an in-memory bytes buffer.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "initial_bytes")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "initial_bytes")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT "+=")
(ID "initial_bytes")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "=")
(ID "buf")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getstate__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "__getstate__ on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getvalue")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the bytes value (contents) of the buffer\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "getvalue on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getbuffer")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a readable and writable view of the buffer.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "getbuffer on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "memoryview")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "read from closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT #"")
(NEWLINE)
(DEDENT)
(ID "newpos")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "+")
(ID "size")
(PUNCT ")")
(NEWLINE)
(ID "b")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT ":")
(ID "newpos")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "=")
(ID "newpos")
(NEWLINE)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This is the same as read.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "write to closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "can't write str to binary stream")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_pos")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "padding")
(PUNCT "=")
(LIT #"\0")
(PUNCT "*")
(PUNCT "(")
(ID "pos")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "+=")
(ID "padding")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(ID "pos")
(PUNCT "+")
(ID "n")
(PUNCT "]")
(PUNCT "=")
(ID "b")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "+=")
(ID "n")
(NEWLINE)
(KEYWORD return)
(ID "n")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "seek on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT ".")
(ID "__index__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "an integer is required")
(PUNCT ")")
(KEYWORD from)
(ID "err")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "whence")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pos")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "negative seek position %r")
(PUNCT "%")
(PUNCT "(")
(ID "pos")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "=")
(ID "pos")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "whence")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "+")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "whence")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_pos")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ")")
(PUNCT "+")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unsupported whence value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "tell on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "truncate on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_pos")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT ".")
(ID "__index__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "an integer is required")
(PUNCT ")")
(KEYWORD from)
(ID "err")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pos")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "negative truncate position %r")
(PUNCT "%")
(PUNCT "(")
(ID "pos")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seekable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BufferedReader")
(PUNCT "(")
(ID "_BufferedIOMixin")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "BufferedReader(raw[, buffer_size])\n\n    A buffer for a readable, sequential BaseRawIO object.\n\n    The constructor creates a BufferedReader for the given readable raw\n    stream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE\n    is used.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ",")
(ID "buffer_size")
(PUNCT "=")
(ID "DEFAULT_BUFFER_SIZE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a new buffered reader using the given readable raw IO object.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "raw")
(PUNCT ".")
(ID "readable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "\"raw\" argument must be readable.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_BufferedIOMixin")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "buffer_size")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid buffer size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT "=")
(ID "buffer_size")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_reset_read_buf")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT "=")
(ID "Lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_reset_read_buf")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read size bytes.\n\n        Returns exactly size bytes of data unless the underlying raw IO\n        stream reaches EOF or if the call would block in non-blocking\n        mode. If size is negative, read until EOF or until read() would\n        block.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "size")
(PUNCT "<")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid number of bytes to read")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_read_unlocked")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_read_unlocked")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nodata_val")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "empty_values")
(PUNCT "=")
(PUNCT "(")
(LIT #"")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(NEWLINE)
(KEYWORD if)
(ID "n")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "n")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_reset_read_buf")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ",")
(LIT "readall")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "readall")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "chunk")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "buf")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(PUNCT "]")
(KEYWORD or)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "buf")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(PUNCT "]")
(PUNCT "+")
(ID "chunk")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "chunks")
(PUNCT "=")
(PUNCT "[")
(ID "buf")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "current_size")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "InterruptedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "chunk")
(KEYWORD in)
(ID "empty_values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nodata_val")
(PUNCT "=")
(ID "chunk")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "current_size")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(NEWLINE)
(ID "chunks")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(KEYWORD or)
(ID "nodata_val")
(NEWLINE)
(DEDENT)
(ID "avail")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "buf")
(PUNCT ")")
(PUNCT "-")
(ID "pos")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<=")
(ID "avail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT "+=")
(ID "n")
(NEWLINE)
(KEYWORD return)
(ID "buf")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(ID "pos")
(PUNCT "+")
(ID "n")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "chunks")
(PUNCT "=")
(PUNCT "[")
(ID "buf")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "wanted")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "avail")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "wanted")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "InterruptedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "chunk")
(KEYWORD in)
(ID "empty_values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nodata_val")
(PUNCT "=")
(ID "chunk")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "avail")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(NEWLINE)
(ID "chunks")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "n")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "avail")
(PUNCT ")")
(NEWLINE)
(ID "out")
(PUNCT "=")
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT "=")
(ID "out")
(PUNCT "[")
(ID "n")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD return)
(ID "out")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(KEYWORD if)
(ID "out")
(KEYWORD else)
(ID "nodata_val")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "peek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns buffered bytes without advancing the position.\n\n        The argument indicates a desired minimal number of bytes; we\n        do at most one raw read to satisfy it.  We never return more\n        than self.buffer_size.\n        ")
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_peek_unlocked")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_peek_unlocked")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "want")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT ")")
(NEWLINE)
(ID "have")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ")")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(NEWLINE)
(KEYWORD if)
(ID "have")
(PUNCT "<")
(ID "want")
(KEYWORD or)
(ID "have")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "to_read")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT "-")
(ID "have")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "current")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "to_read")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "InterruptedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "current")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT ":")
(PUNCT "]")
(PUNCT "+")
(ID "current")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Reads up to size bytes, with at most one read() system call.")
(NEWLINE)
(KEYWORD if)
(ID "size")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "number of bytes to read must be positive")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT #"")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_peek_unlocked")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_read_unlocked")
(PUNCT "(")
(ID "min")
(PUNCT "(")
(ID "size")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ")")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_BufferedIOMixin")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "whence")
(KEYWORD not)
(KEYWORD in)
(ID "valid_seek_flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid whence value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "whence")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ")")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(NEWLINE)
(DEDENT)
(ID "pos")
(PUNCT "=")
(ID "_BufferedIOMixin")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_reset_read_buf")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "pos")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BufferedWriter")
(PUNCT "(")
(ID "_BufferedIOMixin")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A buffer for a writeable sequential RawIO object.\n\n    The constructor creates a BufferedWriter for the given writeable raw\n    stream. If the buffer_size is not given, it defaults to\n    DEFAULT_BUFFER_SIZE.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ",")
(ID "buffer_size")
(PUNCT "=")
(ID "DEFAULT_BUFFER_SIZE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "raw")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "\"raw\" argument must be writable.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_BufferedIOMixin")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "buffer_size")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid buffer size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT "=")
(ID "buffer_size")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_write_lock")
(PUNCT "=")
(ID "Lock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "write to closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "can't write str to binary stream")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_write_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flush_unlocked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "before")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(ID "written")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(PUNCT "-")
(ID "before")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flush_unlocked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "BlockingIOError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "overage")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(NEWLINE)
(ID "written")
(PUNCT "-=")
(ID "overage")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT "[")
(PUNCT ":")
(ID "self")
(PUNCT ".")
(ID "buffer_size")
(PUNCT "]")
(NEWLINE)
(KEYWORD raise)
(ID "BlockingIOError")
(PUNCT "(")
(ID "e")
(PUNCT ".")
(ID "errno")
(PUNCT ",")
(ID "e")
(PUNCT ".")
(ID "strerror")
(PUNCT ",")
(ID "written")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "written")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_write_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flush_unlocked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "truncate")
(PUNCT "(")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_write_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flush_unlocked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_flush_unlocked")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "flush of closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "InterruptedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "BlockingIOError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "self.raw should implement RawIOBase: it ")
(LIT "should not raise BlockingIOError")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "n")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "BlockingIOError")
(PUNCT "(")
(ID "errno")
(PUNCT ".")
(ID "EAGAIN")
(PUNCT ",")
(LIT "write could not complete without blocking")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(KEYWORD or)
(ID "n")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "write() returned incorrect number of bytes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_BufferedIOMixin")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "whence")
(KEYWORD not)
(KEYWORD in)
(ID "valid_seek_flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid whence value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_write_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_flush_unlocked")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_BufferedIOMixin")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BufferedRWPair")
(PUNCT "(")
(ID "BufferedIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A buffered reader and writer object together.\n\n    A buffered reader object and buffered writer object put together to\n    form a sequential IO object that can read and write. This is typically\n    used with a socket or two-way pipe.\n\n    reader and writer are RawIOBase objects that are readable and\n    writeable respectively. If the buffer_size is omitted it defaults to\n    DEFAULT_BUFFER_SIZE.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "reader")
(PUNCT ",")
(ID "writer")
(PUNCT ",")
(ID "buffer_size")
(PUNCT "=")
(ID "DEFAULT_BUFFER_SIZE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor.\n\n        The arguments are two RawIO instances.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "reader")
(PUNCT ".")
(ID "readable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "\"reader\" argument must be readable.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "writer")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "\"writer\" argument must be writable.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT "=")
(ID "BufferedReader")
(PUNCT "(")
(ID "reader")
(PUNCT ",")
(ID "buffer_size")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT "=")
(ID "BufferedWriter")
(PUNCT "(")
(ID "writer")
(PUNCT ",")
(ID "buffer_size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readinto")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "readinto")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "peek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "peek")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "read1")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "readable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isatty")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT ".")
(ID "isatty")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT ".")
(ID "isatty")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "closed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT ".")
(ID "closed")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BufferedRandom")
(PUNCT "(")
(ID "BufferedWriter")
(PUNCT ",")
(ID "BufferedReader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A buffered interface to random access streams.\n\n    The constructor creates a reader and writer for a seekable stream,\n    raw, given in the first argument. If the buffer_size is omitted it\n    defaults to DEFAULT_BUFFER_SIZE.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ",")
(ID "buffer_size")
(PUNCT "=")
(ID "DEFAULT_BUFFER_SIZE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "raw")
(PUNCT ".")
(ID "_checkSeekable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "BufferedReader")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ",")
(ID "buffer_size")
(PUNCT ")")
(NEWLINE)
(ID "BufferedWriter")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "raw")
(PUNCT ",")
(ID "buffer_size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "whence")
(KEYWORD not)
(KEYWORD in)
(ID "valid_seek_flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid whence value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ")")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "pos")
(PUNCT ",")
(ID "whence")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_reset_read_buf")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pos")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "seek() returned invalid position")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "pos")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_write_buf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "BufferedWriter")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "BufferedReader")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "BufferedWriter")
(PUNCT ".")
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "BufferedReader")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readinto")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "BufferedReader")
(PUNCT ".")
(ID "readinto")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "peek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "BufferedReader")
(PUNCT ".")
(ID "peek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "BufferedReader")
(PUNCT ".")
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "self")
(PUNCT ".")
(ID "_read_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "raw")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_pos")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_read_buf")
(PUNCT ")")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_reset_read_buf")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "BufferedWriter")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "TextIOBase")
(PUNCT "(")
(ID "IOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for text I/O.\n\n    This class provides a character and line based interface to stream\n    I/O. There is no readinto method because Python's character strings\n    are immutable. There is no public constructor.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read at most size characters from stream, where size is an int.\n\n        Read from underlying buffer until we have size characters or we hit EOF.\n        If size is negative or omitted, read until EOF.\n\n        Returns a string.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "read")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write string s to stream and returning an int.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "write")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Truncate size to pos, where pos is an int.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "truncate")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readline")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read until newline or EOF.\n\n        Returns an empty string if EOF is hit immediately.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "readline")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "detach")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Separate the underlying buffer from the TextIOBase and return it.\n\n        After the underlying buffer has been detached, the TextIO is in an\n        unusable state.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "detach")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "encoding")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Subclasses should override.")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "newlines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Line endings translated so far.\n\n        Only line endings translated during reading are considered.\n\n        Subclasses should override.\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "errors")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Error setting of the decoder or encoder.\n\n        Subclasses should override.")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "io")
(PUNCT ".")
(ID "TextIOBase")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "TextIOBase")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "IncrementalNewlineDecoder")
(PUNCT "(")
(ID "codecs")
(PUNCT ".")
(ID "IncrementalDecoder")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Codec used when reading a file in universal newlines mode.  It wraps\n    another incremental decoder, translating \\r\\n and \\r into \\n.  It also\n    records the types of newlines encountered.  When used with\n    translate=False, it ensures that the newline sequence is returned in\n    one piece.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "decoder")
(PUNCT ",")
(ID "translate")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "strict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "codecs")
(PUNCT ".")
(ID "IncrementalDecoder")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "translate")
(PUNCT "=")
(ID "translate")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "decoder")
(PUNCT "=")
(ID "decoder")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "seennl")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "input")
(PUNCT ",")
(ID "final")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "decoder")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "=")
(ID "input")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(ID "final")
(PUNCT "=")
(ID "final")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(KEYWORD and)
(PUNCT "(")
(ID "output")
(KEYWORD or)
(ID "final")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "=")
(LIT "\r")
(PUNCT "+")
(ID "output")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "output")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "\r")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "final")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "=")
(ID "output")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(ID "crlf")
(PUNCT "=")
(ID "output")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\r\n")
(PUNCT ")")
(NEWLINE)
(ID "cr")
(PUNCT "=")
(ID "output")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\r")
(PUNCT ")")
(PUNCT "-")
(ID "crlf")
(NEWLINE)
(ID "lf")
(PUNCT "=")
(ID "output")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(PUNCT "-")
(ID "crlf")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "seennl")
(PUNCT "|=")
(PUNCT "(")
(ID "lf")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_LF")
(PUNCT ")")
(PUNCT "|")
(PUNCT "(")
(ID "cr")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_CR")
(PUNCT ")")
(PUNCT "|")
(PUNCT "(")
(ID "crlf")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_CRLF")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "translate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "crlf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "=")
(ID "output")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\r\n")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT "=")
(ID "output")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\r")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "output")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getstate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "decoder")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "flag")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT ",")
(ID "flag")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "decoder")
(PUNCT ".")
(ID "getstate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "flag")
(PUNCT "<<=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flag")
(PUNCT "|=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "buf")
(PUNCT ",")
(ID "flag")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setstate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "state")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT ",")
(ID "flag")
(PUNCT "=")
(ID "state")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(PUNCT "=")
(ID "bool")
(PUNCT "(")
(ID "flag")
(PUNCT "&")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "decoder")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "decoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(PUNCT "(")
(ID "buf")
(PUNCT ",")
(ID "flag")
(PUNCT ">>")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "reset")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "seennl")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pendingcr")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "decoder")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "decoder")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_LF")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "_CR")
(PUNCT "=")
(LIT 2)
(NEWLINE)
(ID "_CRLF")
(PUNCT "=")
(LIT 4)
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "newlines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(LIT "\n")
(PUNCT ",")
(LIT "\r")
(PUNCT ",")
(PUNCT "(")
(LIT "\r")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(PUNCT ",")
(LIT "\r\n")
(PUNCT ",")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(LIT "\r\n")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "\r")
(PUNCT ",")
(LIT "\r\n")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "\r")
(PUNCT ",")
(LIT "\n")
(PUNCT ",")
(LIT "\r\n")
(PUNCT ")")
(PUNCT ")")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "seennl")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "TextIOWrapper")
(PUNCT "(")
(ID "TextIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Character and line based layer over a BufferedIOBase object, buffer.\n\n    encoding gives the name of the encoding that the stream will be\n    decoded or encoded with. It defaults to locale.getpreferredencoding(False).\n\n    errors determines the strictness of encoding and decoding (see the\n    codecs.register) and defaults to \"strict\".\n\n    newline can be None, '', '\\n', '\\r', or '\\r\\n'.  It controls the\n    handling of line endings. If it is None, universal newlines is\n    enabled.  With this enabled, on input, the lines endings '\\n', '\\r',\n    or '\\r\\n' are translated to '\\n' before being returned to the\n    caller. Conversely, on output, '\\n' is translated to the system\n    default line separator, os.linesep. If newline is any other of its\n    legal values, that newline becomes the newline when the file is read\n    and it is returned untranslated. On output, '\\n' is converted to the\n    newline.\n\n    If line_buffering is True, a call to flush is implied when a call to\n    write contains a newline character.\n    ")
(NEWLINE)
(ID "_CHUNK_SIZE")
(PUNCT "=")
(LIT 2048)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "buffer")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "line_buffering")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "write_through")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "newline")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "newline")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "illegal newline type: %r")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "newline")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "newline")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(LIT "")
(PUNCT ",")
(LIT "\n")
(PUNCT ",")
(LIT "\r")
(PUNCT ",")
(LIT "\r\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "illegal newline value: %r")
(PUNCT "%")
(PUNCT "(")
(ID "newline")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "device_encoding")
(PUNCT "(")
(ID "buffer")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AttributeError")
(PUNCT ",")
(ID "UnsupportedOperation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "encoding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "locale")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(LIT "ascii")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "locale")
(PUNCT ".")
(ID "getpreferredencoding")
(PUNCT "(")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid encoding: %r")
(PUNCT "%")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "codecs")
(PUNCT ".")
(ID "lookup")
(PUNCT "(")
(ID "encoding")
(PUNCT ")")
(PUNCT ".")
(ID "_is_text_encoding")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "(")
(LIT "%r is not a text encoding; ")
(LIT "use codecs.open() to handle arbitrary codecs")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "LookupError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "errors")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT "=")
(LIT "strict")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "errors")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid errors: %r")
(PUNCT "%")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "=")
(ID "buffer")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_line_buffering")
(PUNCT "=")
(ID "line_buffering")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_encoding")
(PUNCT "=")
(ID "encoding")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_errors")
(PUNCT "=")
(ID "errors")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_readuniversal")
(PUNCT "=")
(KEYWORD not)
(ID "newline")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_readtranslate")
(PUNCT "=")
(ID "newline")
(KEYWORD is)
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_readnl")
(PUNCT "=")
(ID "newline")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_writetranslate")
(PUNCT "=")
(ID "newline")
(PUNCT "!=")
(LIT "")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_writenl")
(PUNCT "=")
(ID "newline")
(KEYWORD or)
(ID "os")
(PUNCT ".")
(ID "linesep")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_encoder")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_seekable")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "seekable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_has_read1")
(PUNCT "=")
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ",")
(LIT "read1")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_b2cratio")
(PUNCT "=")
(LIT 0.0)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_seekable")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "position")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "position")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_get_encoder")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "LookupError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(LIT "<_pyio.TextIOWrapper")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT " name={0!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "mode")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT " mode={0!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(PUNCT "+")
(LIT " encoding={0!r}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "encoding")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_encoding")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "errors")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_errors")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "line_buffering")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_line_buffering")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "buffer")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seekable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed file.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_seekable")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "readable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "writable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_seekable")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "buffer")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "closed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "closed")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isatty")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "isatty")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write data, where s is a str")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "write to closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "can't write %s to text stream")
(PUNCT "%")
(ID "s")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "length")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "haslf")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_writetranslate")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_line_buffering")
(PUNCT ")")
(KEYWORD and)
(LIT "\n")
(KEYWORD in)
(ID "s")
(NEWLINE)
(KEYWORD if)
(ID "haslf")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_writetranslate")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_writenl")
(PUNCT "!=")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_writenl")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "encoder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_encoder")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_get_encoder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "b")
(PUNCT "=")
(ID "encoder")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_line_buffering")
(KEYWORD and)
(PUNCT "(")
(ID "haslf")
(KEYWORD or)
(LIT "\r")
(KEYWORD in)
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "length")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_encoder")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "make_encoder")
(PUNCT "=")
(ID "codecs")
(PUNCT ".")
(ID "getincrementalencoder")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_encoding")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_encoder")
(PUNCT "=")
(ID "make_encoder")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_encoder")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_decoder")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "make_decoder")
(PUNCT "=")
(ID "codecs")
(PUNCT ".")
(ID "getincrementaldecoder")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_encoding")
(PUNCT ")")
(NEWLINE)
(ID "decoder")
(PUNCT "=")
(ID "make_decoder")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_readuniversal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoder")
(PUNCT "=")
(ID "IncrementalNewlineDecoder")
(PUNCT "(")
(ID "decoder")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_readtranslate")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT "=")
(ID "decoder")
(NEWLINE)
(KEYWORD return)
(ID "decoder")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_set_decoded_chars")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "chars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the _decoded_chars buffer.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT "=")
(ID "chars")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_decoded_chars")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Advance into the _decoded_chars buffer.")
(NEWLINE)
(ID "offset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(NEWLINE)
(KEYWORD if)
(ID "n")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chars")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT "[")
(ID "offset")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chars")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT "[")
(ID "offset")
(PUNCT ":")
(ID "offset")
(PUNCT "+")
(ID "n")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "chars")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "chars")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_rewind_decoded_chars")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rewind the _decoded_chars buffer.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "rewind decoded_chars out of bounds")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(PUNCT "-=")
(ID "n")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_read_chunk")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Read and decode the next chunk of data from the BufferedReader.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "no decoder")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dec_buffer")
(PUNCT ",")
(ID "dec_flags")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "getstate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_has_read1")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "input_chunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "read1")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_CHUNK_SIZE")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "input_chunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_CHUNK_SIZE")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "eof")
(PUNCT "=")
(KEYWORD not)
(ID "input_chunk")
(NEWLINE)
(ID "decoded_chars")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "input_chunk")
(PUNCT ",")
(ID "eof")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_decoded_chars")
(PUNCT "(")
(ID "decoded_chars")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "decoded_chars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_b2cratio")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "input_chunk")
(PUNCT ")")
(PUNCT "/")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_b2cratio")
(PUNCT "=")
(LIT 0.0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(PUNCT "(")
(ID "dec_flags")
(PUNCT ",")
(ID "dec_buffer")
(PUNCT "+")
(ID "input_chunk")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD not)
(ID "eof")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_pack_cookie")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "position")
(PUNCT ",")
(ID "dec_flags")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "bytes_to_feed")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "need_eof")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "chars_to_skip")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "position")
(PUNCT "|")
(PUNCT "(")
(ID "dec_flags")
(PUNCT "<<")
(LIT 64)
(PUNCT ")")
(PUNCT "|")
(PUNCT "(")
(ID "bytes_to_feed")
(PUNCT "<<")
(LIT 128)
(PUNCT ")")
(PUNCT "|")
(PUNCT "(")
(ID "chars_to_skip")
(PUNCT "<<")
(LIT 192)
(PUNCT ")")
(PUNCT "|")
(ID "bool")
(PUNCT "(")
(ID "need_eof")
(PUNCT ")")
(PUNCT "<<")
(LIT 256)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_unpack_cookie")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "bigint")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rest")
(PUNCT ",")
(ID "position")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "bigint")
(PUNCT ",")
(LIT 1)
(PUNCT "<<")
(LIT 64)
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT ",")
(ID "dec_flags")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(LIT 1)
(PUNCT "<<")
(LIT 64)
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT ",")
(ID "bytes_to_feed")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(LIT 1)
(PUNCT "<<")
(LIT 64)
(PUNCT ")")
(NEWLINE)
(ID "need_eof")
(PUNCT ",")
(ID "chars_to_skip")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(LIT 1)
(PUNCT "<<")
(LIT 64)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "position")
(PUNCT ",")
(ID "dec_flags")
(PUNCT ",")
(ID "bytes_to_feed")
(PUNCT ",")
(ID "need_eof")
(PUNCT ",")
(ID "chars_to_skip")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_seekable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "underlying stream is not seekable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "telling position disabled by next() call")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "position")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "decoder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(NEWLINE)
(KEYWORD if)
(ID "decoder")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "pending decoded text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "position")
(NEWLINE)
(DEDENT)
(ID "dec_flags")
(PUNCT ",")
(ID "next_input")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(NEWLINE)
(ID "position")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "next_input")
(PUNCT ")")
(NEWLINE)
(ID "chars_to_skip")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(NEWLINE)
(KEYWORD if)
(ID "chars_to_skip")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_pack_cookie")
(PUNCT "(")
(ID "position")
(PUNCT ",")
(ID "dec_flags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "saved_state")
(PUNCT "=")
(ID "decoder")
(PUNCT ".")
(ID "getstate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "skip_bytes")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_b2cratio")
(PUNCT "*")
(ID "chars_to_skip")
(PUNCT ")")
(NEWLINE)
(ID "skip_back")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD assert)
(ID "skip_bytes")
(PUNCT "<=")
(ID "len")
(PUNCT "(")
(ID "next_input")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "skip_bytes")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(PUNCT "(")
(LIT #"")
(PUNCT ",")
(ID "dec_flags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "next_input")
(PUNCT "[")
(PUNCT ":")
(ID "skip_bytes")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<=")
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT ",")
(ID "d")
(PUNCT "=")
(ID "decoder")
(PUNCT ".")
(ID "getstate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "b")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dec_flags")
(PUNCT "=")
(ID "d")
(NEWLINE)
(ID "chars_to_skip")
(PUNCT "-=")
(ID "n")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "skip_bytes")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(ID "skip_back")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "skip_bytes")
(PUNCT "-=")
(ID "skip_back")
(NEWLINE)
(ID "skip_back")
(PUNCT "=")
(ID "skip_back")
(PUNCT "*")
(LIT 2)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "skip_bytes")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "decoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(PUNCT "(")
(LIT #"")
(PUNCT ",")
(ID "dec_flags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "start_pos")
(PUNCT "=")
(ID "position")
(PUNCT "+")
(ID "skip_bytes")
(NEWLINE)
(ID "start_flags")
(PUNCT "=")
(ID "dec_flags")
(NEWLINE)
(KEYWORD if)
(ID "chars_to_skip")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_pack_cookie")
(PUNCT "(")
(ID "start_pos")
(PUNCT ",")
(ID "start_flags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bytes_fed")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "need_eof")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "chars_decoded")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "skip_bytes")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "next_input")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bytes_fed")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "chars_decoded")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "next_input")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dec_buffer")
(PUNCT ",")
(ID "dec_flags")
(PUNCT "=")
(ID "decoder")
(PUNCT ".")
(ID "getstate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dec_buffer")
(KEYWORD and)
(ID "chars_decoded")
(PUNCT "<=")
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start_pos")
(PUNCT "+=")
(ID "bytes_fed")
(NEWLINE)
(ID "chars_to_skip")
(PUNCT "-=")
(ID "chars_decoded")
(NEWLINE)
(ID "start_flags")
(PUNCT ",")
(ID "bytes_fed")
(PUNCT ",")
(ID "chars_decoded")
(PUNCT "=")
(ID "dec_flags")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "chars_decoded")
(PUNCT ">=")
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chars_decoded")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT #"")
(PUNCT ",")
(ID "final")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "need_eof")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "chars_decoded")
(PUNCT "<")
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "can't reconstruct logical file position")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_pack_cookie")
(PUNCT "(")
(ID "start_pos")
(PUNCT ",")
(ID "start_flags")
(PUNCT ",")
(ID "bytes_fed")
(PUNCT ",")
(ID "need_eof")
(PUNCT ",")
(ID "chars_to_skip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(ID "saved_state")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "truncate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pos")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "truncate")
(PUNCT "(")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "detach")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "buffer")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "buffer is already detached")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "buffer")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(ID "buffer")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seek")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "cookie")
(PUNCT ",")
(ID "whence")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "tell on closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_seekable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "underlying stream is not seekable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "whence")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cookie")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "can't do nonzero cur-relative seeks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "whence")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "cookie")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "whence")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cookie")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnsupportedOperation")
(PUNCT "(")
(LIT "can't do nonzero end-relative seeks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "position")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_decoded_chars")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "position")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "whence")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unsupported whence (%r)")
(PUNCT "%")
(PUNCT "(")
(ID "whence")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cookie")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "negative seek position %r")
(PUNCT "%")
(PUNCT "(")
(ID "cookie")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "start_pos")
(PUNCT ",")
(ID "dec_flags")
(PUNCT ",")
(ID "bytes_to_feed")
(PUNCT ",")
(ID "need_eof")
(PUNCT ",")
(ID "chars_to_skip")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_unpack_cookie")
(PUNCT "(")
(ID "cookie")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(ID "start_pos")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_decoded_chars")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "cookie")
(PUNCT "==")
(LIT 0)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(KEYWORD or)
(ID "dec_flags")
(KEYWORD or)
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_get_decoder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(PUNCT "(")
(LIT #"")
(PUNCT ",")
(ID "dec_flags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(PUNCT "(")
(ID "dec_flags")
(PUNCT ",")
(LIT #"")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "input_chunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "bytes_to_feed")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_decoded_chars")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "input_chunk")
(PUNCT ",")
(ID "need_eof")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(PUNCT "(")
(ID "dec_flags")
(PUNCT ",")
(ID "input_chunk")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT ")")
(PUNCT "<")
(ID "chars_to_skip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "can't restore logical file position")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars_used")
(PUNCT "=")
(ID "chars_to_skip")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_encoder")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_get_encoder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "LookupError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cookie")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoder")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "cookie")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_checkReadable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "decoder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_get_decoder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT ".")
(ID "__index__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "an integer is required")
(PUNCT ")")
(KEYWORD from)
(ID "err")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_get_decoded_chars")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "final")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_set_decoded_chars")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "eof")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_decoded_chars")
(PUNCT "(")
(ID "size")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "len")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(PUNCT "<")
(ID "size")
(KEYWORD and)
(KEYWORD not)
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "eof")
(PUNCT "=")
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_read_chunk")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "+=")
(ID "self")
(PUNCT ".")
(ID "_get_decoded_chars")
(PUNCT "(")
(ID "size")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__next__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_telling")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_seekable")
(NEWLINE)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readline")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "read from closed file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "size")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "size must be an integer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_decoded_chars")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "start")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_get_decoder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "pos")
(PUNCT "=")
(ID "endpos")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_readtranslate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(ID "start")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "pos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_readuniversal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nlpos")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(ID "start")
(PUNCT ")")
(NEWLINE)
(ID "crpos")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "\r")
(PUNCT ",")
(ID "start")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "crpos")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "nlpos")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "nlpos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "nlpos")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "crpos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "nlpos")
(PUNCT "<")
(ID "crpos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "nlpos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "nlpos")
(PUNCT "==")
(ID "crpos")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "crpos")
(PUNCT "+")
(LIT 2)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "crpos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_readnl")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pos")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "pos")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_readnl")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT ">=")
(LIT 0)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ">=")
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "size")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "_read_chunk")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoded_chars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "+=")
(ID "self")
(PUNCT ".")
(ID "_get_decoded_chars")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_set_decoded_chars")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_snapshot")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "size")
(PUNCT ">=")
(LIT 0)
(KEYWORD and)
(ID "endpos")
(PUNCT ">")
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "endpos")
(PUNCT "=")
(ID "size")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_rewind_decoded_chars")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT "-")
(ID "endpos")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "line")
(PUNCT "[")
(PUNCT ":")
(ID "endpos")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "newlines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(PUNCT ".")
(ID "newlines")
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_decoder")
(KEYWORD else)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "StringIO")
(PUNCT "(")
(ID "TextIOWrapper")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Text I/O implementation using an in-memory buffer.\n\n    The initial_value argument sets the value of object.  The newline\n    argument is like the one of TextIOWrapper's constructor.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "initial_value")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(ID "StringIO")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "surrogatepass")
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(ID "newline")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "newline")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_writetranslate")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "initial_value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "initial_value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "initial_value must be str or None, not {0}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "initial_value")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "initial_value")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getvalue")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "decoder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_decoder")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_get_decoder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "old_state")
(PUNCT "=")
(ID "decoder")
(PUNCT ".")
(ID "getstate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "decoder")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "buffer")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "final")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoder")
(PUNCT ".")
(ID "setstate")
(PUNCT "(")
(ID "old_state")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "errors")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "encoding")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "detach")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_unsupported")
(PUNCT "(")
(LIT "detach")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
