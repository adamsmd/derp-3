(LIT "JSON (JavaScript Object Notation) <http://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\n:mod:`json` exposes an API familiar to users of the standard library\n:mod:`marshal` and :mod:`pickle` modules.  It is derived from a\nversion of the externally maintained simplejson library.\n\nEncoding basic Python object hierarchies::\n\n    >>> import json\n    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n    '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n    >>> print(json.dumps(\"\\\"foo\\bar\"))\n    \"\\\"foo\\bar\"\n    >>> print(json.dumps('\\u1234'))\n    \"\\u1234\"\n    >>> print(json.dumps('\\\\'))\n    \"\\\\\"\n    >>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n    {\"a\": 0, \"b\": 0, \"c\": 0}\n    >>> from io import StringIO\n    >>> io = StringIO()\n    >>> json.dump(['streaming API'], io)\n    >>> io.getvalue()\n    '[\"streaming API\"]'\n\nCompact encoding::\n\n    >>> import json\n    >>> from collections import OrderedDict\n    >>> mydict = OrderedDict([('4', 5), ('6', 7)])\n    >>> json.dumps([1,2,3,mydict], separators=(',', ':'))\n    '[1,2,3,{\"4\":5,\"6\":7}]'\n\nPretty printing::\n\n    >>> import json\n    >>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))\n    {\n        \"4\": 5,\n        \"6\": 7\n    }\n\nDecoding JSON::\n\n    >>> import json\n    >>> obj = ['foo', {'bar': ['baz', None, 1.0, 2]}]\n    >>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]') == obj\n    True\n    >>> json.loads('\"\\\\\"foo\\\\bar\"') == '\"foo\\x08ar'\n    True\n    >>> from io import StringIO\n    >>> io = StringIO('[\"streaming API\"]')\n    >>> json.load(io)[0] == 'streaming API'\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import json\n    >>> def as_complex(dct):\n    ...     if '__complex__' in dct:\n    ...         return complex(dct['real'], dct['imag'])\n    ...     return dct\n    ...\n    >>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> json.loads('1.1', parse_float=Decimal) == Decimal('1.1')\n    True\n\nSpecializing JSON object encoding::\n\n    >>> import json\n    >>> def encode_complex(obj):\n    ...     if isinstance(obj, complex):\n    ...         return [obj.real, obj.imag]\n    ...     raise TypeError(repr(o) + \" is not JSON serializable\")\n    ...\n    >>> json.dumps(2 + 1j, default=encode_complex)\n    '[2.0, 1.0]'\n    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n    '[2.0, 1.0]'\n    >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n    '[2.0, 1.0]'\n\n\nUsing json.tool from the shell to validate and pretty-print::\n\n    $ echo '{\"json\":\"obj\"}' | python -m json.tool\n    {\n        \"json\": \"obj\"\n    }\n    $ echo '{ 1.2:3.4}' | python -m json.tool\n    Expecting property name enclosed in double quotes: line 1 column 3 (char 2)\n")
(NEWLINE)
(ID "__version__")
(PUNCT "=")
(LIT "2.0.9")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "dump")
(PUNCT ",")
(LIT "dumps")
(PUNCT ",")
(LIT "load")
(PUNCT ",")
(LIT "loads")
(PUNCT ",")
(LIT "JSONDecoder")
(PUNCT ",")
(LIT "JSONEncoder")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(ID "__author__")
(PUNCT "=")
(LIT "Bob Ippolito <bob@redivi.com>")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "decoder")
(KEYWORD import)
(ID "JSONDecoder")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "encoder")
(KEYWORD import)
(ID "JSONEncoder")
(NEWLINE)
(ID "_default_encoder")
(PUNCT "=")
(ID "JSONEncoder")
(PUNCT "(")
(ID "skipkeys")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "ensure_ascii")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "check_circular")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "allow_nan")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "separators")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "dump")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "fp")
(PUNCT ",")
(ID "skipkeys")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "ensure_ascii")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "check_circular")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "allow_nan")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "cls")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "separators")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "sort_keys")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n    ``.write()``-supporting file-like object).\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\n    instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the strings written to ``fp`` can\n    contain non-ASCII characters if they appear in strings contained in\n    ``obj``. Otherwise, all such characters are escaped in JSON strings.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n    in strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a non-negative integer, then JSON array elements and\n    object members will be pretty-printed with that indent level. An indent\n    level of 0 will only insert newlines. ``None`` is the most compact\n    representation.\n\n    If specified, ``separators`` should be an ``(item_separator, key_separator)``\n    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,\n    you should specify ``(',', ':')`` to eliminate whitespace.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *sort_keys* is ``True`` (default: ``False``), then the output of\n    dictionaries will be sorted by key.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.\n\n    ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "skipkeys")
(KEYWORD and)
(ID "ensure_ascii")
(KEYWORD and)
(ID "check_circular")
(KEYWORD and)
(ID "allow_nan")
(KEYWORD and)
(ID "cls")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "indent")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "separators")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "default")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "sort_keys")
(KEYWORD and)
(KEYWORD not)
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "iterable")
(PUNCT "=")
(ID "_default_encoder")
(PUNCT ".")
(ID "iterencode")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "JSONEncoder")
(NEWLINE)
(DEDENT)
(ID "iterable")
(PUNCT "=")
(ID "cls")
(PUNCT "(")
(ID "skipkeys")
(PUNCT "=")
(ID "skipkeys")
(PUNCT ",")
(ID "ensure_ascii")
(PUNCT "=")
(ID "ensure_ascii")
(PUNCT ",")
(ID "check_circular")
(PUNCT "=")
(ID "check_circular")
(PUNCT ",")
(ID "allow_nan")
(PUNCT "=")
(ID "allow_nan")
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(ID "indent")
(PUNCT ",")
(ID "separators")
(PUNCT "=")
(ID "separators")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(ID "default")
(PUNCT ",")
(ID "sort_keys")
(PUNCT "=")
(ID "sort_keys")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ".")
(ID "iterencode")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "chunk")
(KEYWORD in)
(ID "iterable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fp")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "dumps")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "skipkeys")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "ensure_ascii")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "check_circular")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "allow_nan")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "cls")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "separators")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "sort_keys")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Serialize ``obj`` to a JSON formatted ``str``.\n\n    If ``skipkeys`` is false then ``dict`` keys that are not basic types\n    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\n    instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the return value can contain non-ASCII\n    characters if they appear in strings contained in ``obj``. Otherwise, all\n    such characters are escaped in JSON strings.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\n    strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a non-negative integer, then JSON array elements and\n    object members will be pretty-printed with that indent level. An indent\n    level of 0 will only insert newlines. ``None`` is the most compact\n    representation.\n\n    If specified, ``separators`` should be an ``(item_separator, key_separator)``\n    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,\n    you should specify ``(',', ':')`` to eliminate whitespace.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *sort_keys* is ``True`` (default: ``False``), then the output of\n    dictionaries will be sorted by key.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.\n\n    ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "skipkeys")
(KEYWORD and)
(ID "ensure_ascii")
(KEYWORD and)
(ID "check_circular")
(KEYWORD and)
(ID "allow_nan")
(KEYWORD and)
(ID "cls")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "indent")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "separators")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "default")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "sort_keys")
(KEYWORD and)
(KEYWORD not)
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_default_encoder")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "JSONEncoder")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "skipkeys")
(PUNCT "=")
(ID "skipkeys")
(PUNCT ",")
(ID "ensure_ascii")
(PUNCT "=")
(ID "ensure_ascii")
(PUNCT ",")
(ID "check_circular")
(PUNCT "=")
(ID "check_circular")
(PUNCT ",")
(ID "allow_nan")
(PUNCT "=")
(ID "allow_nan")
(PUNCT ",")
(ID "indent")
(PUNCT "=")
(ID "indent")
(PUNCT ",")
(ID "separators")
(PUNCT "=")
(ID "separators")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(ID "default")
(PUNCT ",")
(ID "sort_keys")
(PUNCT "=")
(ID "sort_keys")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_default_decoder")
(PUNCT "=")
(ID "JSONDecoder")
(PUNCT "(")
(ID "object_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "object_pairs_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "load")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "cls")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "object_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_float")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_int")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_constant")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "object_pairs_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n    a JSON document) to a Python object.\n\n    ``object_hook`` is an optional function that will be called with the\n    result of any object literal decode (a ``dict``). The return value of\n    ``object_hook`` will be used instead of the ``dict``. This feature\n    can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n    ``object_pairs_hook`` is an optional function that will be called with the\n    result of any object literal decoded with an ordered list of pairs.  The\n    return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n    This feature can be used to implement custom decoders that rely on the\n    order that the key and value pairs are decoded (for example,\n    collections.OrderedDict will remember the order of insertion). If\n    ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg; otherwise ``JSONDecoder`` is used.\n\n    ")
(NEWLINE)
(KEYWORD return)
(ID "loads")
(PUNCT "(")
(ID "fp")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "cls")
(PUNCT "=")
(ID "cls")
(PUNCT ",")
(ID "object_hook")
(PUNCT "=")
(ID "object_hook")
(PUNCT ",")
(ID "parse_float")
(PUNCT "=")
(ID "parse_float")
(PUNCT ",")
(ID "parse_int")
(PUNCT "=")
(ID "parse_int")
(PUNCT ",")
(ID "parse_constant")
(PUNCT "=")
(ID "parse_constant")
(PUNCT ",")
(ID "object_pairs_hook")
(PUNCT "=")
(ID "object_pairs_hook")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "loads")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "cls")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "object_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_float")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_int")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_constant")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "object_pairs_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deserialize ``s`` (a ``str`` instance containing a JSON\n    document) to a Python object.\n\n    ``object_hook`` is an optional function that will be called with the\n    result of any object literal decode (a ``dict``). The return value of\n    ``object_hook`` will be used instead of the ``dict``. This feature\n    can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n    ``object_pairs_hook`` is an optional function that will be called with the\n    result of any object literal decoded with an ordered list of pairs.  The\n    return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n    This feature can be used to implement custom decoders that rely on the\n    order that the key and value pairs are decoded (for example,\n    collections.OrderedDict will remember the order of insertion). If\n    ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n\n    ``parse_float``, if specified, will be called with the string\n    of every JSON float to be decoded. By default this is equivalent to\n    float(num_str). This can be used to use another datatype or parser\n    for JSON floats (e.g. decimal.Decimal).\n\n    ``parse_int``, if specified, will be called with the string\n    of every JSON int to be decoded. By default this is equivalent to\n    int(num_str). This can be used to use another datatype or parser\n    for JSON integers (e.g. float).\n\n    ``parse_constant``, if specified, will be called with one of the\n    following strings: -Infinity, Infinity, NaN, null, true, false.\n    This can be used to raise an exception if invalid JSON numbers\n    are encountered.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg; otherwise ``JSONDecoder`` is used.\n\n    The ``encoding`` argument is ignored and deprecated.\n\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "the JSON object must be str, not {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "\uFEFF")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Unexpected UTF-8 BOM (decode using utf-8-sig)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(PUNCT "(")
(ID "cls")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "object_hook")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "parse_int")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "parse_float")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "parse_constant")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "object_pairs_hook")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_default_decoder")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "JSONDecoder")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "object_hook")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kw")
(PUNCT "[")
(LIT "object_hook")
(PUNCT "]")
(PUNCT "=")
(ID "object_hook")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "object_pairs_hook")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kw")
(PUNCT "[")
(LIT "object_pairs_hook")
(PUNCT "]")
(PUNCT "=")
(ID "object_pairs_hook")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "parse_float")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kw")
(PUNCT "[")
(LIT "parse_float")
(PUNCT "]")
(PUNCT "=")
(ID "parse_float")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "parse_int")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kw")
(PUNCT "[")
(LIT "parse_int")
(PUNCT "]")
(PUNCT "=")
(ID "parse_int")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "parse_constant")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kw")
(PUNCT "[")
(LIT "parse_constant")
(PUNCT "]")
(PUNCT "=")
(ID "parse_constant")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
