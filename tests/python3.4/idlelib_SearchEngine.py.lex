(LIT "Define SearchEngine for search dialogs.")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD from)
(ID "tkinter")
(KEYWORD import)
(ID "StringVar")
(PUNCT ",")
(ID "BooleanVar")
(PUNCT ",")
(ID "TclError")
(NEWLINE)
(KEYWORD import)
(ID "tkinter")
(PUNCT ".")
(ID "messagebox")
(KEYWORD as)
(ID "tkMessageBox")
(NEWLINE)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "root")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the singleton SearchEngine instance for the process.\n\n    The single SearchEngine saves settings between dialog instances.\n    If there is not a SearchEngine already, make one.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(LIT "_searchengine")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "root")
(PUNCT ".")
(ID "_searchengine")
(PUNCT "=")
(ID "SearchEngine")
(PUNCT "(")
(ID "root")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "root")
(PUNCT ".")
(ID "_searchengine")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "SearchEngine")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handles searching a text widget for Find, Replace, and Grep.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "root")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Initialize Variables that save search state.\n\n        The dialogs bind these to the UI elements present in the dialogs.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "root")
(PUNCT "=")
(ID "root")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "patvar")
(PUNCT "=")
(ID "StringVar")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "revar")
(PUNCT "=")
(ID "BooleanVar")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "casevar")
(PUNCT "=")
(ID "BooleanVar")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "wordvar")
(PUNCT "=")
(ID "BooleanVar")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "wrapvar")
(PUNCT "=")
(ID "BooleanVar")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "backvar")
(PUNCT "=")
(ID "BooleanVar")
(PUNCT "(")
(ID "root")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getpat")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "patvar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setpat")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "patvar")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isre")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "revar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iscase")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "casevar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isword")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "wordvar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iswrap")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "wrapvar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isback")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "backvar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setcookedpat")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set pattern after escaping if re.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isre")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pat")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "setpat")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getcookedpat")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pat")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "getpat")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "isre")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pat")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isword")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pat")
(PUNCT "=")
(LIT "\\b%s\\b")
(PUNCT "%")
(ID "pat")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "pat")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getprog")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return compiled cooked search pattern.")
(NEWLINE)
(ID "pat")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "getpat")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "pat")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "report_error")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(LIT "Empty regular expression")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "pat")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "getcookedpat")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "flags")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "iscase")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flags")
(PUNCT "=")
(ID "flags")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "IGNORECASE")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prog")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(ID "flags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "re")
(PUNCT ".")
(ID "error")
(KEYWORD as)
(ID "what")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(ID "what")
(PUNCT ".")
(ID "args")
(NEWLINE)
(ID "msg")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "col")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT ">=")
(LIT 2)
(KEYWORD else)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "report_error")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "col")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "prog")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "report_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pat")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "col")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Error: ")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pat")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "+")
(LIT "\nPattern: ")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "col")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "+")
(LIT "\nOffset: ")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "col")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "tkMessageBox")
(PUNCT ".")
(ID "showerror")
(PUNCT "(")
(LIT "Regular expression error")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "master")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "root")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "search_text")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "prog")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "ok")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return (lineno, matchobj) or None for forward/backward search.\n\n        This function calls the right function with the right arguments.\n        It directly return the result of that call.\n\n        Text is a text widget. Prog is a precompiled pattern.\n        The ok parameteris a bit complicated as it has two effects.\n\n        If there is a selection, the search begin at either end,\n        depending on the direction setting and ok, with ok meaning that\n        the search starts with the selection. Otherwise, search begins\n        at the insert mark.\n\n        To aid progress, the search functions do not return an empty\n        match at the starting position unless ok is True.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "prog")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prog")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "getprog")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "prog")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "wrap")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "wrapvar")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT "=")
(ID "get_selection")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isback")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ok")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "last")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "first")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT "=")
(ID "get_line_col")
(PUNCT "(")
(ID "start")
(PUNCT ")")
(NEWLINE)
(ID "res")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "search_backward")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "prog")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT ",")
(ID "wrap")
(PUNCT ",")
(ID "ok")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ok")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "first")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "last")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT "=")
(ID "get_line_col")
(PUNCT "(")
(ID "start")
(PUNCT ")")
(NEWLINE)
(ID "res")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "search_forward")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "prog")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT ",")
(ID "wrap")
(PUNCT ",")
(ID "ok")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "res")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "search_forward")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "prog")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT ",")
(ID "wrap")
(PUNCT ",")
(ID "ok")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wrapped")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "startline")
(PUNCT "=")
(ID "line")
(NEWLINE)
(ID "chars")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "%d.0")
(PUNCT "%")
(ID "line")
(PUNCT ",")
(LIT "%d.0")
(PUNCT "%")
(PUNCT "(")
(ID "line")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "chars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "prog")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "chars")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "col")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ok")
(KEYWORD or)
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">")
(ID "col")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "line")
(PUNCT ",")
(ID "m")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "wrapped")
(KEYWORD and)
(ID "line")
(PUNCT ">")
(ID "startline")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "col")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "ok")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "chars")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "%d.0")
(PUNCT "%")
(ID "line")
(PUNCT ",")
(LIT "%d.0")
(PUNCT "%")
(PUNCT "(")
(ID "line")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "chars")
(KEYWORD and)
(ID "wrap")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wrapped")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "wrap")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "line")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "chars")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "1.0")
(PUNCT ",")
(LIT "2.0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "search_backward")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "prog")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT ",")
(ID "wrap")
(PUNCT ",")
(ID "ok")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wrapped")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "startline")
(PUNCT "=")
(ID "line")
(NEWLINE)
(ID "chars")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "%d.0")
(PUNCT "%")
(ID "line")
(PUNCT ",")
(LIT "%d.0")
(PUNCT "%")
(PUNCT "(")
(ID "line")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "search_reverse")
(PUNCT "(")
(ID "prog")
(PUNCT ",")
(ID "chars")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "col")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ok")
(KEYWORD or)
(ID "m")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(PUNCT "<")
(ID "col")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "line")
(PUNCT ",")
(ID "m")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "wrapped")
(KEYWORD and)
(ID "line")
(PUNCT "<")
(ID "startline")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "ok")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "wrap")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "wrapped")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "wrap")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(LIT "end-1c")
(PUNCT ")")
(NEWLINE)
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT "=")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "pos")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "chars")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "%d.0")
(PUNCT "%")
(ID "line")
(PUNCT ",")
(LIT "%d.0")
(PUNCT "%")
(PUNCT "(")
(ID "line")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "col")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "chars")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "search_reverse")
(PUNCT "(")
(ID "prog")
(PUNCT ",")
(ID "chars")
(PUNCT ",")
(ID "col")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Search backwards and return an re match object or None.\n\n    This is done by searching forwards until there is no match.\n    Prog: compiled re object with a search method returning a match.\n    Chars: line of text, without \n.\n    Col: stop index for the search; the limit for match.end().\n    ")
(NEWLINE)
(ID "m")
(PUNCT "=")
(ID "prog")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "chars")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "found")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "i")
(PUNCT ",")
(ID "j")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "span")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "col")
(KEYWORD and)
(ID "j")
(PUNCT "<=")
(ID "col")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT "=")
(ID "m")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT "==")
(ID "j")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "j")
(PUNCT "=")
(ID "j")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "m")
(PUNCT "=")
(ID "prog")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "chars")
(PUNCT ",")
(ID "j")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT ",")
(ID "j")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "span")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "found")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_selection")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return tuple of 'line.col' indexes from selection or insert mark.\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(LIT "sel.first")
(PUNCT ")")
(NEWLINE)
(ID "last")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(LIT "sel.last")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TclError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "last")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "first")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(LIT "insert")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "last")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last")
(PUNCT "=")
(ID "first")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "first")
(PUNCT ",")
(ID "last")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_line_col")
(PUNCT "(")
(ID "index")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return (line, col) tuple of ints from 'line.col' string.")
(NEWLINE)
(ID "line")
(PUNCT ",")
(ID "col")
(PUNCT "=")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "index")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "line")
(PUNCT ",")
(ID "col")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "unittest")
(NEWLINE)
(ID "unittest")
(PUNCT ".")
(ID "main")
(PUNCT "(")
(LIT "idlelib.idle_test.test_searchengine")
(PUNCT ",")
(ID "verbosity")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "exit")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
