(LIT "\nThis is an implementation of decimal floating point arithmetic based on\nthe General Decimal Arithmetic Specification:\n\n    http://speleotrove.com/decimal/decarith.html\n\nand IEEE standard 854-1987:\n\n    http://en.wikipedia.org/wiki/IEEE_854-1987\n\nDecimal floating point has finite precision with arbitrarily large bounds.\n\nThe purpose of this module is to support arithmetic using familiar\n\"schoolhouse\" rules and to avoid some of the tricky representation\nissues associated with binary floating point.  The package is especially\nuseful for financial applications or for contexts where users have\nexpectations that are at odds with binary floating point (for instance,\nin binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead\nof 0.0; Decimal('1.00') % Decimal('0.1') returns the expected\nDecimal('0.00')).\n\nHere are some examples of using the decimal module:\n\n>>> from decimal import *\n>>> setcontext(ExtendedContext)\n>>> Decimal(0)\nDecimal('0')\n>>> Decimal('1')\nDecimal('1')\n>>> Decimal('-.0123')\nDecimal('-0.0123')\n>>> Decimal(123456)\nDecimal('123456')\n>>> Decimal('123.45e12345678')\nDecimal('1.2345E+12345680')\n>>> Decimal('1.33') + Decimal('1.27')\nDecimal('2.60')\n>>> Decimal('12.34') + Decimal('3.87') - Decimal('18.41')\nDecimal('-2.20')\n>>> dig = Decimal(1)\n>>> print(dig / Decimal(3))\n0.333333333\n>>> getcontext().prec = 18\n>>> print(dig / Decimal(3))\n0.333333333333333333\n>>> print(dig.sqrt())\n1\n>>> print(Decimal(3).sqrt())\n1.73205080756887729\n>>> print(Decimal(3) ** 123)\n4.85192780976896427E+58\n>>> inf = Decimal(1) / Decimal(0)\n>>> print(inf)\nInfinity\n>>> neginf = Decimal(-1) / Decimal(0)\n>>> print(neginf)\n-Infinity\n>>> print(neginf + inf)\nNaN\n>>> print(neginf * inf)\n-Infinity\n>>> print(dig / 0)\nInfinity\n>>> getcontext().traps[DivisionByZero] = 1\n>>> print(dig / 0)\nTraceback (most recent call last):\n  ...\n  ...\n  ...\ndecimal.DivisionByZero: x / 0\n>>> c = Context()\n>>> c.traps[InvalidOperation] = 0\n>>> print(c.flags[InvalidOperation])\n0\n>>> c.divide(Decimal(0), Decimal(0))\nDecimal('NaN')\n>>> c.traps[InvalidOperation] = 1\n>>> print(c.flags[InvalidOperation])\n1\n>>> c.flags[InvalidOperation] = 0\n>>> print(c.flags[InvalidOperation])\n0\n>>> print(c.divide(Decimal(0), Decimal(0)))\nTraceback (most recent call last):\n  ...\n  ...\n  ...\ndecimal.InvalidOperation: 0 / 0\n>>> print(c.flags[InvalidOperation])\n1\n>>> c.flags[InvalidOperation] = 0\n>>> c.traps[InvalidOperation] = 0\n>>> print(c.divide(Decimal(0), Decimal(0)))\nNaN\n>>> print(c.flags[InvalidOperation])\n1\n>>>\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Decimal")
(PUNCT ",")
(LIT "Context")
(PUNCT ",")
(LIT "DecimalTuple")
(PUNCT ",")
(LIT "DefaultContext")
(PUNCT ",")
(LIT "BasicContext")
(PUNCT ",")
(LIT "ExtendedContext")
(PUNCT ",")
(LIT "DecimalException")
(PUNCT ",")
(LIT "Clamped")
(PUNCT ",")
(LIT "InvalidOperation")
(PUNCT ",")
(LIT "DivisionByZero")
(PUNCT ",")
(LIT "Inexact")
(PUNCT ",")
(LIT "Rounded")
(PUNCT ",")
(LIT "Subnormal")
(PUNCT ",")
(LIT "Overflow")
(PUNCT ",")
(LIT "Underflow")
(PUNCT ",")
(LIT "FloatOperation")
(PUNCT ",")
(LIT "DivisionImpossible")
(PUNCT ",")
(LIT "InvalidContext")
(PUNCT ",")
(LIT "ConversionSyntax")
(PUNCT ",")
(LIT "DivisionUndefined")
(PUNCT ",")
(LIT "ROUND_DOWN")
(PUNCT ",")
(LIT "ROUND_HALF_UP")
(PUNCT ",")
(LIT "ROUND_HALF_EVEN")
(PUNCT ",")
(LIT "ROUND_CEILING")
(PUNCT ",")
(LIT "ROUND_FLOOR")
(PUNCT ",")
(LIT "ROUND_UP")
(PUNCT ",")
(LIT "ROUND_HALF_DOWN")
(PUNCT ",")
(LIT "ROUND_05UP")
(PUNCT ",")
(LIT "setcontext")
(PUNCT ",")
(LIT "getcontext")
(PUNCT ",")
(LIT "localcontext")
(PUNCT ",")
(LIT "MAX_PREC")
(PUNCT ",")
(LIT "MAX_EMAX")
(PUNCT ",")
(LIT "MIN_EMIN")
(PUNCT ",")
(LIT "MIN_ETINY")
(PUNCT ",")
(LIT "HAVE_THREADS")
(PUNCT "]")
(NEWLINE)
(ID "__version__")
(PUNCT "=")
(LIT "1.70")
(NEWLINE)
(ID "__libmpdec_version__")
(PUNCT "=")
(LIT "2.4.1")
(NEWLINE)
(KEYWORD import)
(ID "math")
(KEYWORD as)
(ID "_math")
(NEWLINE)
(KEYWORD import)
(ID "numbers")
(KEYWORD as)
(ID "_numbers")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "namedtuple")
(KEYWORD as)
(ID "_namedtuple")
(NEWLINE)
(ID "DecimalTuple")
(PUNCT "=")
(ID "_namedtuple")
(PUNCT "(")
(LIT "DecimalTuple")
(PUNCT ",")
(LIT "sign digits exponent")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "DecimalTuple")
(PUNCT "=")
(KEYWORD lambda)
(PUNCT "*")
(ID "args")
(PUNCT ":")
(ID "args")
(NEWLINE)
(DEDENT)
(ID "ROUND_DOWN")
(PUNCT "=")
(LIT "ROUND_DOWN")
(NEWLINE)
(ID "ROUND_HALF_UP")
(PUNCT "=")
(LIT "ROUND_HALF_UP")
(NEWLINE)
(ID "ROUND_HALF_EVEN")
(PUNCT "=")
(LIT "ROUND_HALF_EVEN")
(NEWLINE)
(ID "ROUND_CEILING")
(PUNCT "=")
(LIT "ROUND_CEILING")
(NEWLINE)
(ID "ROUND_FLOOR")
(PUNCT "=")
(LIT "ROUND_FLOOR")
(NEWLINE)
(ID "ROUND_UP")
(PUNCT "=")
(LIT "ROUND_UP")
(NEWLINE)
(ID "ROUND_HALF_DOWN")
(PUNCT "=")
(LIT "ROUND_HALF_DOWN")
(NEWLINE)
(ID "ROUND_05UP")
(PUNCT "=")
(LIT "ROUND_05UP")
(NEWLINE)
(ID "HAVE_THREADS")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT "==")
(LIT 2)
(PUNCT "**")
(LIT 63)
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "MAX_PREC")
(PUNCT "=")
(LIT 999999999999999999)
(NEWLINE)
(ID "MAX_EMAX")
(PUNCT "=")
(LIT 999999999999999999)
(NEWLINE)
(ID "MIN_EMIN")
(PUNCT "=")
(PUNCT "-")
(LIT 999999999999999999)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "MAX_PREC")
(PUNCT "=")
(LIT 425000000)
(NEWLINE)
(ID "MAX_EMAX")
(PUNCT "=")
(LIT 425000000)
(NEWLINE)
(ID "MIN_EMIN")
(PUNCT "=")
(PUNCT "-")
(LIT 425000000)
(NEWLINE)
(DEDENT)
(ID "MIN_ETINY")
(PUNCT "=")
(ID "MIN_EMIN")
(PUNCT "-")
(PUNCT "(")
(ID "MAX_PREC")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "DecimalException")
(PUNCT "(")
(ID "ArithmeticError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base exception class.\n\n    Used exceptions derive from this.\n    If an exception derives from another exception besides this (such as\n    Underflow (Inexact, Rounded, Subnormal) that indicates that it is only\n    called if the others are present.  This isn't actually used for\n    anything, though.\n\n    handle  -- Called when context._raise_error is called and the\n               trap_enabler is not set.  First argument is self, second is the\n               context.  More arguments can be given, those being after\n               the explanation in _raise_error (For example,\n               context._raise_error(NewError, '(-x)!', self._sign) would\n               call NewError().handle(context, self._sign).)\n\n    To define a new exception, it should be sufficient to have it derive\n    from DecimalException.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Clamped")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Exponent of a 0 changed to fit bounds.\n\n    This occurs and signals clamped if the exponent of a result has been\n    altered in order to fit the constraints of a specific concrete\n    representation.  This may occur when the exponent of a zero result would\n    be outside the bounds of a representation, or when a large normal\n    number would have an encoded exponent that cannot be represented.  In\n    this latter case, the exponent is reduced to fit and the corresponding\n    number of zero digits are appended to the coefficient (\"fold-down\").\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "InvalidOperation")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "An invalid operation was performed.\n\n    Various bad things cause this:\n\n    Something creates a signaling NaN\n    -INF + INF\n    0 * (+-)INF\n    (+-)INF / (+-)INF\n    x % 0\n    (+-)INF % x\n    x._rescale( non-integer )\n    sqrt(-x) , x > 0\n    0 ** 0\n    x ** (non-integer)\n    x ** (+-)INF\n    An operand is invalid\n\n    The result of the operation after these is a quiet positive NaN,\n    except when the cause is a signaling NaN, in which case the result is\n    also a quiet NaN, but with the original sign, and an optional\n    diagnostic information.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(LIT "n")
(PUNCT ",")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_NaN")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ConversionSyntax")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Trying to convert badly formed string.\n\n    This occurs and signals invalid-operation if an string is being\n    converted to a number and it does not conform to the numeric string\n    syntax.  The result is [0,qNaN].\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NaN")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DivisionByZero")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ",")
(ID "ZeroDivisionError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Division by 0.\n\n    This occurs and signals division-by-zero if division of a finite number\n    by zero was attempted (during a divide-integer or divide operation, or a\n    power operation with negative right-hand operand), and the dividend was\n    not zero.\n\n    The result of the operation is [sign,inf], where sign is the exclusive\n    or of the signs of the operands for divide, or is 1 for an odd power of\n    -0, for power.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(ID "sign")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DivisionImpossible")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Cannot perform the division adequately.\n\n    This occurs and signals invalid-operation if the integer result of a\n    divide-integer or remainder operation had too many digits (would be\n    longer than precision).  The result is [0,qNaN].\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NaN")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DivisionUndefined")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(ID "ZeroDivisionError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Undefined result of division.\n\n    This occurs and signals invalid-operation if division by zero was\n    attempted (during a divide-integer, divide, or remainder operation), and\n    the dividend is also zero.  The result is [0,qNaN].\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NaN")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Inexact")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Had to round, losing information.\n\n    This occurs and signals inexact whenever the result of an operation is\n    not exact (that is, it needed to be rounded and any discarded digits\n    were non-zero), or if an overflow or underflow condition occurs.  The\n    result in all cases is unchanged.\n\n    The inexact signal may be tested (or trapped) to determine if a given\n    operation (or sequence of operations) was inexact.\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "InvalidContext")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Invalid context.  Unknown rounding, for example.\n\n    This occurs and signals invalid-operation if an invalid context was\n    detected during an operation.  This can occur if contexts are not checked\n    on creation and either the precision exceeds the capability of the\n    underlying concrete representation or an unknown or unsupported rounding\n    was specified.  These aspects of the context need only be checked when\n    the values are required to be used.  The result is [0,qNaN].\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NaN")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Rounded")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Number got rounded (not  necessarily changed during rounding).\n\n    This occurs and signals rounded whenever the result of an operation is\n    rounded (that is, some zero or non-zero digits were discarded from the\n    coefficient), or if an overflow or underflow condition occurs.  The\n    result in all cases is unchanged.\n\n    The rounded signal may be tested (or trapped) to determine if a given\n    operation (or sequence of operations) caused a loss of precision.\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Subnormal")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Exponent < Emin before rounding.\n\n    This occurs and signals subnormal whenever the result of a conversion or\n    operation is subnormal (that is, its adjusted exponent is less than\n    Emin, before any rounding).  The result in all cases is unchanged.\n\n    The subnormal signal may be tested (or trapped) to determine if a given\n    or operation (or sequence of operations) yielded a subnormal result.\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Overflow")
(PUNCT "(")
(ID "Inexact")
(PUNCT ",")
(ID "Rounded")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Numerical overflow.\n\n    This occurs and signals overflow if the adjusted exponent of a result\n    (from a conversion or from an operation that is not an attempt to divide\n    by zero), after rounding, would be greater than the largest value that\n    can be handled by the implementation (the value Emax).\n\n    The result depends on the rounding mode:\n\n    For round-half-up and round-half-even (and for round-half-down and\n    round-up, if implemented), the result of the operation is [sign,inf],\n    where sign is the sign of the intermediate result.  For round-down, the\n    result is the largest finite number that can be represented in the\n    current precision, with the sign of the intermediate result.  For\n    round-ceiling, the result is the same as for round-down if the sign of\n    the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,\n    the result is the same as for round-down if the sign of the intermediate\n    result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded\n    will also be raised.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(ID "sign")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(PUNCT ".")
(ID "rounding")
(KEYWORD in)
(PUNCT "(")
(ID "ROUND_HALF_UP")
(PUNCT ",")
(ID "ROUND_HALF_EVEN")
(PUNCT ",")
(ID "ROUND_HALF_DOWN")
(PUNCT ",")
(ID "ROUND_UP")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "==")
(ID "ROUND_CEILING")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(LIT "9")
(PUNCT "*")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "==")
(ID "ROUND_FLOOR")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(LIT "9")
(PUNCT "*")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Underflow")
(PUNCT "(")
(ID "Inexact")
(PUNCT ",")
(ID "Rounded")
(PUNCT ",")
(ID "Subnormal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Numerical underflow with result rounded to 0.\n\n    This occurs and signals underflow if a result is inexact and the\n    adjusted exponent of the result would be smaller (more negative) than\n    the smallest value that can be handled by the implementation (the value\n    Emin).  That is, the result is both inexact and subnormal.\n\n    The result after an underflow will be a subnormal number rounded, if\n    necessary, so that its exponent is not less than Etiny.  This may result\n    in 0 with the sign of the intermediate result and an exponent of Etiny.\n\n    In all cases, Inexact, Rounded, and Subnormal will also be raised.\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "FloatOperation")
(PUNCT "(")
(ID "DecimalException")
(PUNCT ",")
(ID "TypeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Enable stricter semantics for mixing floats and Decimals.\n\n    If the signal is not trapped (default), mixing floats and Decimals is\n    permitted in the Decimal() constructor, context.create_decimal() and\n    all comparison operators. Both conversion and comparisons are exact.\n    Any occurrence of a mixed operation is silently recorded by setting\n    FloatOperation in the context flags.  Explicit conversions with\n    Decimal.from_float() or context.create_decimal_from_float() do not\n    set the flag.\n\n    Otherwise (the signal is trapped), only equality comparisons and explicit\n    conversions are silent. All other mixed operations raise FloatOperation.\n    ")
(NEWLINE)
(DEDENT)
(ID "_signals")
(PUNCT "=")
(PUNCT "[")
(ID "Clamped")
(PUNCT ",")
(ID "DivisionByZero")
(PUNCT ",")
(ID "Inexact")
(PUNCT ",")
(ID "Overflow")
(PUNCT ",")
(ID "Rounded")
(PUNCT ",")
(ID "Underflow")
(PUNCT ",")
(ID "InvalidOperation")
(PUNCT ",")
(ID "Subnormal")
(PUNCT ",")
(ID "FloatOperation")
(PUNCT "]")
(NEWLINE)
(ID "_condition_map")
(PUNCT "=")
(PUNCT "{")
(ID "ConversionSyntax")
(PUNCT ":")
(ID "InvalidOperation")
(PUNCT ",")
(ID "DivisionImpossible")
(PUNCT ":")
(ID "InvalidOperation")
(PUNCT ",")
(ID "DivisionUndefined")
(PUNCT ":")
(ID "InvalidOperation")
(PUNCT ",")
(ID "InvalidContext")
(PUNCT ":")
(ID "InvalidOperation")
(PUNCT "}")
(NEWLINE)
(ID "_rounding_modes")
(PUNCT "=")
(PUNCT "(")
(ID "ROUND_DOWN")
(PUNCT ",")
(ID "ROUND_HALF_UP")
(PUNCT ",")
(ID "ROUND_HALF_EVEN")
(PUNCT ",")
(ID "ROUND_CEILING")
(PUNCT ",")
(ID "ROUND_FLOOR")
(PUNCT ",")
(ID "ROUND_UP")
(PUNCT ",")
(ID "ROUND_HALF_DOWN")
(PUNCT ",")
(ID "ROUND_05UP")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "threading")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD class)
(ID "MockThreading")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "local")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sys")
(PUNCT "=")
(ID "sys")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "__name__")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "threading")
(PUNCT "=")
(ID "MockThreading")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "MockThreading")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "threading")
(PUNCT ".")
(ID "local")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "threading")
(PUNCT ".")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(LIT "__decimal_context__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "threading")
(PUNCT ".")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__decimal_context__")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setcontext")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set this thread's context to context.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD in)
(PUNCT "(")
(ID "DefaultContext")
(PUNCT ",")
(ID "BasicContext")
(PUNCT ",")
(ID "ExtendedContext")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "clear_flags")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "threading")
(PUNCT ".")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__decimal_context__")
(PUNCT "=")
(ID "context")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns this thread's context.\n\n        If this thread does not yet have a context, returns\n        a new context and sets this thread's context.\n        New contexts are copies of DefaultContext.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "threading")
(PUNCT ".")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__decimal_context__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "threading")
(PUNCT ".")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__decimal_context__")
(PUNCT "=")
(ID "context")
(NEWLINE)
(KEYWORD return)
(ID "context")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "local")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "local")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "local")
(PUNCT ",")
(LIT "__decimal_context__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "local")
(PUNCT ".")
(ID "__decimal_context__")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getcontext")
(PUNCT "(")
(ID "_local")
(PUNCT "=")
(ID "local")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns this thread's context.\n\n        If this thread does not yet have a context, returns\n        a new context and sets this thread's context.\n        New contexts are copies of DefaultContext.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_local")
(PUNCT ".")
(ID "__decimal_context__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_local")
(PUNCT ".")
(ID "__decimal_context__")
(PUNCT "=")
(ID "context")
(NEWLINE)
(KEYWORD return)
(ID "context")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "setcontext")
(PUNCT "(")
(ID "context")
(PUNCT ",")
(ID "_local")
(PUNCT "=")
(ID "local")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set this thread's context to context.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD in)
(PUNCT "(")
(ID "DefaultContext")
(PUNCT ",")
(ID "BasicContext")
(PUNCT ",")
(ID "ExtendedContext")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "clear_flags")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_local")
(PUNCT ".")
(ID "__decimal_context__")
(PUNCT "=")
(ID "context")
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "threading")
(PUNCT ",")
(ID "local")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "localcontext")
(PUNCT "(")
(ID "ctx")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a context manager for a copy of the supplied context\n\n    Uses a copy of the current context if no context is specified\n    The returned context manager creates a local decimal context\n    in a with statement:\n        def sin(x):\n             with localcontext() as ctx:\n                 ctx.prec += 2\n                 # Rest of sin calculation algorithm\n                 # uses a precision 2 greater than normal\n             return +s  # Convert result to normal precision\n\n         def sin(x):\n             with localcontext(ExtendedContext):\n                 # Rest of sin calculation algorithm\n                 # uses the Extended Context from the\n                 # General Decimal Arithmetic Specification\n             return +s  # Convert result to normal context\n\n    >>> setcontext(DefaultContext)\n    >>> print(getcontext().prec)\n    28\n    >>> with localcontext():\n    ...     ctx = getcontext()\n    ...     ctx.prec += 2\n    ...     print(ctx.prec)\n    ...\n    30\n    >>> with localcontext(ExtendedContext):\n    ...     print(getcontext().prec)\n    ...\n    9\n    >>> print(getcontext().prec)\n    28\n    ")
(NEWLINE)
(KEYWORD if)
(ID "ctx")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(ID "ctx")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_ContextManager")
(PUNCT "(")
(ID "ctx")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Decimal")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Floating point class for decimal arithmetic.")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "_exp")
(PUNCT ",")
(LIT "_int")
(PUNCT ",")
(LIT "_sign")
(PUNCT ",")
(LIT "_is_special")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(LIT "0")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a decimal point instance.\n\n        >>> Decimal('3.14')              # string input\n        Decimal('3.14')\n        >>> Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)\n        Decimal('3.14')\n        >>> Decimal(314)                 # int\n        Decimal('314')\n        >>> Decimal(Decimal(314))        # another decimal instance\n        Decimal('314')\n        >>> Decimal('  3.14  \\n')        # leading and trailing whitespace okay\n        Decimal('3.14')\n        ")
(NEWLINE)
(ID "self")
(PUNCT "=")
(ID "object")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "_parser")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "ConversionSyntax")
(PUNCT ",")
(LIT "Invalid literal for Decimal: %r")
(PUNCT "%")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "sign")
(PUNCT ")")
(PUNCT "==")
(LIT "-")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "intpart")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "int")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "intpart")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fracpart")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "frac")
(PUNCT ")")
(KEYWORD or)
(LIT "")
(NEWLINE)
(ID "exp")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "exp")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "intpart")
(PUNCT "+")
(ID "fracpart")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "exp")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "fracpart")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "diag")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "diag")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "diag")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "diag")
(KEYWORD or)
(LIT "0")
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "signal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(LIT "N")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(LIT "n")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(LIT "0")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(LIT "F")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_is_special")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "_WorkRep")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "sign")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT "!=")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid tuple size in creation of Decimal ")
(LIT "from list or tuple.  The list or tuple ")
(LIT "should have exactly three elements.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(KEYWORD and)
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD in)
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid sign.  The first value in the tuple ")
(LIT "should be an integer; either 0 for a ")
(LIT "positive number or 1 for a negative number.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(LIT "F")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(LIT "0")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "digits")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "digit")
(KEYWORD in)
(ID "value")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "digit")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(KEYWORD and)
(LIT 0)
(PUNCT "<=")
(ID "digit")
(PUNCT "<=")
(LIT 9)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "digits")
(KEYWORD or)
(ID "digit")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "digits")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "digit")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "The second value in the tuple must ")
(LIT "be composed of integers in the range ")
(LIT "0 through 9.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(KEYWORD in)
(PUNCT "(")
(LIT "n")
(PUNCT ",")
(LIT "N")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "digits")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "digits")
(KEYWORD or)
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "The third value in the tuple must ")
(LIT "be an integer, or one of the ")
(LIT "strings 'F', 'n', 'N'.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "FloatOperation")
(PUNCT ",")
(LIT "strict semantics for mixing floats and Decimals are ")
(LIT "enabled")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "Decimal")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_is_special")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Cannot convert %r to Decimal")
(PUNCT "%")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "from_float")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Converts a float to a decimal number, exactly.\n\n        Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').\n        Since 0.1 is not exactly representable in binary floating point, the\n        value is stored as the nearest representable value which is\n        0x1.999999999999ap-4.  The exact equivalent of the value in decimal\n        is 0.1000000000000000055511151231257827021181583404541015625.\n\n        >>> Decimal.from_float(0.1)\n        Decimal('0.1000000000000000055511151231257827021181583404541015625')\n        >>> Decimal.from_float(float('nan'))\n        Decimal('NaN')\n        >>> Decimal.from_float(float('inf'))\n        Decimal('Infinity')\n        >>> Decimal.from_float(-float('inf'))\n        Decimal('-Infinity')\n        >>> Decimal.from_float(-0.0)\n        Decimal('-0')\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "argument must be int or float.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_math")
(PUNCT ".")
(ID "isinf")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(KEYWORD or)
(ID "_math")
(PUNCT ".")
(ID "isnan")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "_math")
(PUNCT ".")
(ID "copysign")
(PUNCT "(")
(LIT 1.0)
(PUNCT ",")
(ID "f")
(PUNCT ")")
(PUNCT "==")
(LIT 1.0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "n")
(PUNCT ",")
(ID "d")
(PUNCT "=")
(ID "abs")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ".")
(ID "as_integer_ratio")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "k")
(PUNCT "=")
(ID "d")
(PUNCT ".")
(ID "bit_length")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "n")
(PUNCT "*")
(LIT 5)
(PUNCT "**")
(ID "k")
(PUNCT ")")
(PUNCT ",")
(PUNCT "-")
(ID "k")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Decimal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_isnan")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns whether the number is not actually one.\n\n        0 if a number\n        1 if NaN\n        2 if sNaN\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(KEYWORD if)
(ID "exp")
(PUNCT "==")
(LIT "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "exp")
(PUNCT "==")
(LIT "N")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 2)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_isinfinity")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns whether the number is infinite\n\n        0 if finite or not a number\n        1 if +INF\n        -1 if -INF\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "F")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_check_nans")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns whether the number is not actually one.\n\n        if self, other are sNaN, signal\n        if self, other are NaN return nan\n        return 0\n\n        Done before operations.\n        ")
(NEWLINE)
(ID "self_is_nan")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "other_is_nan")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "other_is_nan")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_is_nan")
(KEYWORD or)
(ID "other_is_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_is_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_is_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_is_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_compare_check_nans")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Version of _check_nans used for the signaling comparisons\n        compare_signal, __le__, __lt__, __ge__, __gt__.\n\n        Signal InvalidOperation if either self or other is a (quiet\n        or signaling) NaN.  Signaling NaNs take precedence over quiet\n        NaNs.\n\n        Return 0 if neither operand is a NaN.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_snan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "comparison involving sNaN")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "other")
(PUNCT ".")
(ID "is_snan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "comparison involving sNaN")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "is_qnan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "comparison involving NaN")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "other")
(PUNCT ".")
(ID "is_qnan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "comparison involving NaN")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bool__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is nonzero; otherwise return False.\n\n        NaNs and infinities are considered nonzero.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "!=")
(LIT "0")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_cmp")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compare the two non-NaN decimal instances self and other.\n\n        Returns -1 if self < other, 0 if self == other and 1\n        if self > other.  This routine is for internal use only.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self_inf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "other_inf")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self_inf")
(PUNCT "==")
(ID "other_inf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self_inf")
(PUNCT "<")
(ID "other_inf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(PUNCT "(")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "<")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "self_adjusted")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "other_adjusted")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self_adjusted")
(PUNCT "==")
(ID "other_adjusted")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self_padded")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(ID "other_padded")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self_padded")
(PUNCT "==")
(ID "other_padded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self_padded")
(PUNCT "<")
(ID "other_padded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "self_adjusted")
(PUNCT ">")
(ID "other_adjusted")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(PUNCT "(")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "equality_op")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ne__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "equality_op")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "!=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_compare_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "<")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__le__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_compare_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "<=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__gt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_compare_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ">")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ge__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT "=")
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_compare_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares one to another.\n\n        -1 => a < b\n        0  => a = b\n        1  => a > b\n        NaN => one is NaN\n        Like __cmp__, but returns Decimal instances.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "x.__hash__() <==> hash(x)")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_snan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Cannot hash a signaling NaN value.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_PyHASH_NAN")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(ID "_PyHASH_INF")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_PyHASH_INF")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp_hash")
(PUNCT "=")
(ID "pow")
(PUNCT "(")
(LIT 10)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "_PyHASH_MODULUS")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp_hash")
(PUNCT "=")
(ID "pow")
(PUNCT "(")
(ID "_PyHASH_10INV")
(PUNCT ",")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "_PyHASH_MODULUS")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "hash_")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "*")
(ID "exp_hash")
(PUNCT "%")
(ID "_PyHASH_MODULUS")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "hash_")
(KEYWORD if)
(ID "self")
(PUNCT ">=")
(LIT 0)
(KEYWORD else)
(PUNCT "-")
(ID "hash_")
(NEWLINE)
(KEYWORD return)
(PUNCT "-")
(LIT 2)
(KEYWORD if)
(ID "ans")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(KEYWORD else)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "as_tuple")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Represents the number as a triple tuple.\n\n        To show the internals exactly as they are.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "DecimalTuple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "tuple")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Represents the number as an instance of Decimal.")
(NEWLINE)
(KEYWORD return)
(LIT "Decimal('%s')")
(PUNCT "%")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "eng")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return string representation of the number in scientific notation.\n\n        Captures all of the information in the underlying representation.\n        ")
(NEWLINE)
(ID "sign")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT ",")
(LIT "-")
(PUNCT "]")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "F")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sign")
(PUNCT "+")
(LIT "Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sign")
(PUNCT "+")
(LIT "NaN")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sign")
(PUNCT "+")
(LIT "sNaN")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "leftdigits")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "<=")
(LIT 0)
(KEYWORD and)
(ID "leftdigits")
(PUNCT ">")
(PUNCT "-")
(LIT 6)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(ID "leftdigits")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "eng")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "==")
(LIT "0")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(PUNCT "(")
(ID "leftdigits")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT "%")
(LIT 3)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(PUNCT "(")
(ID "leftdigits")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "%")
(LIT 3)
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "dotplace")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "intpart")
(PUNCT "=")
(LIT "0")
(NEWLINE)
(ID "fracpart")
(PUNCT "=")
(LIT ".")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(PUNCT "-")
(ID "dotplace")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "dotplace")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "intpart")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "dotplace")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "fracpart")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "intpart")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT ":")
(ID "dotplace")
(PUNCT "]")
(NEWLINE)
(ID "fracpart")
(PUNCT "=")
(LIT ".")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "dotplace")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "leftdigits")
(PUNCT "==")
(ID "dotplace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exp")
(PUNCT "=")
(PUNCT "[")
(LIT "e")
(PUNCT ",")
(LIT "E")
(PUNCT "]")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "capitals")
(PUNCT "]")
(PUNCT "+")
(LIT "%+d")
(PUNCT "%")
(PUNCT "(")
(ID "leftdigits")
(PUNCT "-")
(ID "dotplace")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "sign")
(PUNCT "+")
(ID "intpart")
(PUNCT "+")
(ID "fracpart")
(PUNCT "+")
(ID "exp")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_eng_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert to engineering-type string.\n\n        Engineering notation has an exponent which is a multiple of 3, so there\n        are up to 3 digits left of the decimal place.\n\n        Same rules for when in exponential and when as a value as in __str__.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__str__")
(PUNCT "(")
(ID "eng")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__neg__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy with the sign switched.\n\n        Rounds, if it has reason.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD and)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "!=")
(ID "ROUND_FLOOR")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_negate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__pos__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy, unless it is a sNaN.\n\n        Rounds the number (if more then precision digits)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD and)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "!=")
(ID "ROUND_FLOOR")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__abs__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "round")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the absolute value of self.\n\n        If the keyword argument 'round' is false, do not round.  The\n        expression self.__abs__(round=False) is equivalent to\n        self.copy_abs().\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "round")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__neg__")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__pos__")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__add__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns self + other.\n\n        -INF + INF (or the reverse) cause InvalidOperation errors.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_sign")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "-INF + INF")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "exp")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(ID "negativezero")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "==")
(ID "ROUND_FLOOR")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "negativezero")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD and)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "negativezero")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "exp")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "exp")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "exp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "exp")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(ID "op1")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "op2")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "op1")
(PUNCT ",")
(ID "op2")
(PUNCT "=")
(ID "_normalize")
(PUNCT "(")
(ID "op1")
(PUNCT ",")
(ID "op2")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "sign")
(PUNCT "!=")
(ID "op2")
(PUNCT ".")
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "==")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "negativezero")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "<")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op1")
(PUNCT ",")
(ID "op2")
(PUNCT "=")
(ID "op2")
(PUNCT ",")
(ID "op1")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "op1")
(PUNCT ".")
(ID "sign")
(PUNCT ",")
(ID "op2")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(ID "op2")
(PUNCT ".")
(ID "sign")
(PUNCT ",")
(ID "op1")
(PUNCT ".")
(ID "sign")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "op1")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "op1")
(PUNCT ".")
(ID "sign")
(PUNCT ",")
(ID "op2")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "op2")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "int")
(PUNCT "=")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "+")
(ID "op2")
(PUNCT ".")
(ID "int")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "int")
(PUNCT "=")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "-")
(ID "op2")
(PUNCT ".")
(ID "int")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT ".")
(ID "exp")
(PUNCT "=")
(ID "op1")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(ID "__radd__")
(PUNCT "=")
(ID "__add__")
(NEWLINE)
(KEYWORD def)
(ID "__sub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return self - other")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__add__")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "copy_negate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rsub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return other - self")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "__sub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__mul__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return self * other.\n\n        (+-) INF * 0 (or its reverse) raise InvalidOperation.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "resultsign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "(+-)INF * 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "resultsign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "0 * (+-)INF")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "resultsign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "resultexp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "other")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD or)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "resultsign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "resultexp")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "==")
(LIT "1")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "resultsign")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "resultexp")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT "==")
(LIT "1")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "resultsign")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "resultexp")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(ID "op1")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "op2")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "resultsign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "*")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(PUNCT ",")
(ID "resultexp")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(ID "__rmul__")
(PUNCT "=")
(ID "__mul__")
(NEWLINE)
(KEYWORD def)
(ID "__truediv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return self / other.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "(+-)INF/(+-)INF")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Clamped")
(PUNCT ",")
(LIT "Division by infinity")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionUndefined")
(PUNCT ",")
(LIT "0 / 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionByZero")
(PUNCT ",")
(LIT "x / 0")
(PUNCT ",")
(ID "sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(ID "coeff")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "shift")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "+")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "exp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "shift")
(NEWLINE)
(ID "op1")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "op2")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "shift")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "remainder")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "shift")
(PUNCT ",")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "remainder")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "shift")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "remainder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "coeff")
(PUNCT "%")
(LIT 5)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ideal_exp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(KEYWORD while)
(ID "exp")
(PUNCT "<")
(ID "ideal_exp")
(KEYWORD and)
(ID "coeff")
(PUNCT "%")
(LIT 10)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "//=")
(LIT 10)
(NEWLINE)
(ID "exp")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_divide")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return (self // other, self % other), to context.prec precision.\n\n        Assumes that neither self nor other is a NaN, that self is not\n        infinite and that other is nonzero.\n        ")
(NEWLINE)
(ID "sign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ideal_exp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ideal_exp")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "expdiff")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(ID "expdiff")
(PUNCT "<=")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "ideal_exp")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "expdiff")
(PUNCT "<=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op1")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "op2")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT ">=")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT "-")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT "-")
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "q")
(PUNCT ",")
(ID "r")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "q")
(PUNCT "<")
(LIT 10)
(PUNCT "**")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "q")
(PUNCT ")")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "r")
(PUNCT ")")
(PUNCT ",")
(ID "ideal_exp")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionImpossible")
(PUNCT ",")
(LIT "quotient too large in //, % or divmod")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ",")
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rtruediv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Swaps self/other and returns __truediv__.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "__truediv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__divmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return (self // other, self % other)\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "ans")
(PUNCT ",")
(ID "ans")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "divmod(INF, INF)")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ",")
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "_SignedInfinity")
(PUNCT "[")
(ID "sign")
(PUNCT "]")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "INF % x")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionUndefined")
(PUNCT ",")
(LIT "divmod(0, 0)")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ",")
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionByZero")
(PUNCT ",")
(LIT "x // 0")
(PUNCT ",")
(ID "sign")
(PUNCT ")")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "x % 0")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "quotient")
(PUNCT ",")
(ID "remainder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_divide")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "remainder")
(PUNCT "=")
(ID "remainder")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "quotient")
(PUNCT ",")
(ID "remainder")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rdivmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Swaps self/other and returns __divmod__.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "__divmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__mod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        self % other\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "INF % x")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "x % 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionUndefined")
(PUNCT ",")
(LIT "0 % 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "remainder")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_divide")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "remainder")
(PUNCT "=")
(ID "remainder")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "remainder")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rmod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Swaps self/other and returns __mod__.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "__mod__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remainder_near")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Remainder nearest to 0-  abs(remainder-near) <= other/2\n        ")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "remainder_near(infinity, x)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "remainder_near(x, 0)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionUndefined")
(PUNCT ",")
(LIT "remainder_near(0, 0)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ideal_exponent")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "ideal_exponent")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "expdiff")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "expdiff")
(PUNCT ">=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionImpossible")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "expdiff")
(PUNCT "<=")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "ideal_exponent")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "op1")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "op2")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT ">=")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT "-")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT "-")
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "q")
(PUNCT ",")
(ID "r")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "op1")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT 2)
(PUNCT "*")
(ID "r")
(PUNCT "+")
(PUNCT "(")
(ID "q")
(PUNCT "&")
(LIT 1)
(PUNCT ")")
(PUNCT ">")
(ID "op2")
(PUNCT ".")
(ID "int")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "-=")
(ID "op2")
(PUNCT ".")
(ID "int")
(NEWLINE)
(ID "q")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "q")
(PUNCT ">=")
(LIT 10)
(PUNCT "**")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionImpossible")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(KEYWORD if)
(ID "r")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(LIT 1)
(PUNCT "-")
(ID "sign")
(NEWLINE)
(ID "r")
(PUNCT "=")
(PUNCT "-")
(ID "r")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "r")
(PUNCT ")")
(PUNCT ",")
(ID "ideal_exponent")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__floordiv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "self // other")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "INF // INF")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionByZero")
(PUNCT ",")
(LIT "x // 0")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionUndefined")
(PUNCT ",")
(LIT "0 // 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_divide")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rfloordiv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Swaps self/other and returns __floordiv__.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "__floordiv__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__float__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Float representation.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_snan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot convert signaling NaN to float")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "=")
(LIT "-nan")
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(KEYWORD else)
(LIT "nan")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "float")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__int__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Converts self to an int, truncating if necessary.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot convert NaN to integer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OverflowError")
(PUNCT "(")
(LIT "Cannot convert infinity to integer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "s")
(PUNCT "=")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "s")
(PUNCT "*")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "self")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "s")
(PUNCT "*")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT ":")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "]")
(KEYWORD or)
(LIT "0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "__trunc__")
(PUNCT "=")
(ID "__int__")
(NEWLINE)
(KEYWORD def)
(ID "real")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(ID "real")
(PUNCT "=")
(ID "property")
(PUNCT "(")
(ID "real")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "imag")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "imag")
(PUNCT "=")
(ID "property")
(PUNCT "(")
(ID "imag")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "conjugate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__complex__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "complex")
(PUNCT "(")
(ID "float")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fix_nan")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decapitate the payload of a NaN to fit the context")
(NEWLINE)
(ID "payload")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(ID "max_payload_len")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "clamp")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "payload")
(PUNCT ")")
(PUNCT ">")
(ID "max_payload_len")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "payload")
(PUNCT "=")
(ID "payload")
(PUNCT "[")
(ID "len")
(PUNCT "(")
(ID "payload")
(PUNCT ")")
(PUNCT "-")
(ID "max_payload_len")
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "payload")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fix")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Round if it is necessary to keep self within prec precision.\n\n        Rounds and fixes the exponent.  Does not raise on a sNaN.\n\n        Arguments:\n        self - Decimal instance\n        context - context used.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Etiny")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "Etop")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "Etop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp_max")
(PUNCT "=")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT ",")
(ID "Etop")
(PUNCT "]")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "clamp")
(PUNCT "]")
(NEWLINE)
(ID "new_exp")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "max")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "Etiny")
(PUNCT ")")
(PUNCT ",")
(ID "exp_max")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new_exp")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Clamped")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "new_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "exp_min")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(KEYWORD if)
(ID "exp_min")
(PUNCT ">")
(ID "Etop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Overflow")
(PUNCT ",")
(LIT "above Emax")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(ID "self_is_subnormal")
(PUNCT "=")
(ID "exp_min")
(PUNCT "<")
(ID "Etiny")
(NEWLINE)
(KEYWORD if)
(ID "self_is_subnormal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp_min")
(PUNCT "=")
(ID "Etiny")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "<")
(ID "exp_min")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "digits")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "exp_min")
(NEWLINE)
(KEYWORD if)
(ID "digits")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "exp_min")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "digits")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "rounding_method")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_pick_rounding_function")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "]")
(NEWLINE)
(ID "changed")
(PUNCT "=")
(ID "rounding_method")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "digits")
(PUNCT ")")
(NEWLINE)
(ID "coeff")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT ":")
(ID "digits")
(PUNCT "]")
(KEYWORD or)
(LIT "0")
(NEWLINE)
(KEYWORD if)
(ID "changed")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ">")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "=")
(ID "coeff")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "exp_min")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "exp_min")
(PUNCT ">")
(ID "Etop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Overflow")
(PUNCT ",")
(LIT "above Emax")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "coeff")
(PUNCT ",")
(ID "exp_min")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "changed")
(KEYWORD and)
(ID "self_is_subnormal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Underflow")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_is_subnormal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Subnormal")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "changed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Clamped")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_is_subnormal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Subnormal")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(PUNCT ".")
(ID "clamp")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">")
(ID "Etop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Clamped")
(PUNCT ")")
(NEWLINE)
(ID "self_padded")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "Etop")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "self_padded")
(PUNCT ",")
(ID "Etop")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_round_down")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Also known as round-towards-0, truncate.")
(NEWLINE)
(KEYWORD if)
(ID "_all_zeros")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_round_up")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds away from 0.")
(NEWLINE)
(KEYWORD return)
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_round_half_up")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds 5 up (away from 0)")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "prec")
(PUNCT "]")
(KEYWORD in)
(LIT "56789")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "_all_zeros")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_round_half_down")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Round 5 down")
(NEWLINE)
(KEYWORD if)
(ID "_exact_half")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_round_half_up")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_round_half_even")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Round 5 to even, rest to nearest.")
(NEWLINE)
(KEYWORD if)
(ID "_exact_half")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(KEYWORD and)
(PUNCT "(")
(ID "prec")
(PUNCT "==")
(LIT 0)
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "prec")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD in)
(LIT "02468")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_round_half_up")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_round_ceiling")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds up (not away from 0 if negative.)")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_round_floor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds down (not towards 0 if negative)")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_round_05up")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Round down unless digit prec-1 is 0 or 5.")
(NEWLINE)
(KEYWORD if)
(ID "prec")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "prec")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(LIT "05")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_round_down")
(PUNCT "(")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_pick_rounding_function")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "ROUND_DOWN")
(PUNCT "=")
(ID "_round_down")
(PUNCT ",")
(ID "ROUND_UP")
(PUNCT "=")
(ID "_round_up")
(PUNCT ",")
(ID "ROUND_HALF_UP")
(PUNCT "=")
(ID "_round_half_up")
(PUNCT ",")
(ID "ROUND_HALF_DOWN")
(PUNCT "=")
(ID "_round_half_down")
(PUNCT ",")
(ID "ROUND_HALF_EVEN")
(PUNCT "=")
(ID "_round_half_even")
(PUNCT ",")
(ID "ROUND_CEILING")
(PUNCT "=")
(ID "_round_ceiling")
(PUNCT ",")
(ID "ROUND_FLOOR")
(PUNCT "=")
(ID "_round_floor")
(PUNCT ",")
(ID "ROUND_05UP")
(PUNCT "=")
(ID "_round_05up")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__round__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Round self to the nearest integer, or to a given precision.\n\n        If only one argument is supplied, round a finite Decimal\n        instance self to the nearest integer.  If self is infinite or\n        a NaN then a Python exception is raised.  If self is finite\n        and lies exactly halfway between two integers then it is\n        rounded to the integer with even last digit.\n\n        >>> round(Decimal('123.456'))\n        123\n        >>> round(Decimal('-456.789'))\n        -457\n        >>> round(Decimal('-3.0'))\n        -3\n        >>> round(Decimal('2.5'))\n        2\n        >>> round(Decimal('3.5'))\n        4\n        >>> round(Decimal('Inf'))\n        Traceback (most recent call last):\n          ...\n        OverflowError: cannot round an infinity\n        >>> round(Decimal('NaN'))\n        Traceback (most recent call last):\n          ...\n        ValueError: cannot round a NaN\n\n        If a second argument n is supplied, self is rounded to n\n        decimal places using the rounding mode for the current\n        context.\n\n        For an integer n, round(self, -n) is exactly equivalent to\n        self.quantize(Decimal('1En')).\n\n        >>> round(Decimal('123.456'), 0)\n        Decimal('123')\n        >>> round(Decimal('123.456'), 2)\n        Decimal('123.46')\n        >>> round(Decimal('123.456'), -2)\n        Decimal('1E+2')\n        >>> round(Decimal('-Infinity'), 37)\n        Decimal('NaN')\n        >>> round(Decimal('sNaN123'), 0)\n        Decimal('NaN123')\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Second argument to round should be integral")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exp")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(PUNCT "-")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "quantize")
(PUNCT "(")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cannot round a NaN")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OverflowError")
(PUNCT "(")
(LIT "cannot round an infinity")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "ROUND_HALF_EVEN")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__floor__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the floor of self, as an integer.\n\n        For a finite Decimal instance self, return the greatest\n        integer n such that n <= self.  If self is infinite or a NaN\n        then a Python exception is raised.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cannot round a NaN")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OverflowError")
(PUNCT "(")
(LIT "cannot round an infinity")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "ROUND_FLOOR")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ceil__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the ceiling of self, as an integer.\n\n        For a finite Decimal instance self, return the least integer n\n        such that n >= self.  If self is infinite or a NaN then a\n        Python exception is raised.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cannot round a NaN")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OverflowError")
(PUNCT "(")
(LIT "cannot round an infinity")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "ROUND_CEILING")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fma")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "third")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Fused multiply-add.\n\n        Returns self*other+third with no rounding of the intermediate\n        product self*other.\n\n        self and other are multiplied together, with no rounding of\n        the result.  The third operand is then added to the result,\n        and a single final rounding is performed.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "third")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "third")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "N")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "N")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "product")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "product")
(PUNCT "=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "F")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "INF * 0 in fma")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "product")
(PUNCT "=")
(ID "_SignedInfinity")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "F")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "0 * INF in fma")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "product")
(PUNCT "=")
(ID "_SignedInfinity")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "product")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "^")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "*")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "product")
(PUNCT ".")
(ID "__add__")
(PUNCT "(")
(ID "third")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_power_modulo")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "modulo")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Three argument version of __pow__")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(ID "modulo")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "modulo")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "modulo")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "modulo")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self_is_nan")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "other_is_nan")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "modulo_is_nan")
(PUNCT "=")
(ID "modulo")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self_is_nan")
(KEYWORD or)
(ID "other_is_nan")
(KEYWORD or)
(ID "modulo_is_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self_is_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_is_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "modulo_is_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sNaN")
(PUNCT ",")
(ID "modulo")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_is_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_is_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "modulo")
(PUNCT ".")
(ID "_fix_nan")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "modulo")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "pow() 3rd argument not allowed ")
(LIT "unless all arguments are integers")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "pow() 2nd argument cannot be ")
(LIT "negative when 3rd argument specified")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "modulo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "pow() 3rd argument cannot be 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "modulo")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "insufficient precision: pow() 3rd ")
(LIT "argument must not have more than ")
(LIT "precision digits")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "at least one of pow() 1st argument ")
(LIT "and 2nd argument must be nonzero ;")
(LIT "0**0 is not defined")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_iseven")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(DEDENT)
(ID "modulo")
(PUNCT "=")
(ID "abs")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "modulo")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "base")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "to_integral_value")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "exponent")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "to_integral_value")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "base")
(PUNCT "=")
(PUNCT "(")
(ID "base")
(PUNCT ".")
(ID "int")
(PUNCT "%")
(ID "modulo")
(PUNCT "*")
(ID "pow")
(PUNCT "(")
(LIT 10)
(PUNCT ",")
(ID "base")
(PUNCT ".")
(ID "exp")
(PUNCT ",")
(ID "modulo")
(PUNCT ")")
(PUNCT ")")
(PUNCT "%")
(ID "modulo")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "exponent")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "base")
(PUNCT "=")
(ID "pow")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(LIT 10)
(PUNCT ",")
(ID "modulo")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "base")
(PUNCT "=")
(ID "pow")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "exponent")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "modulo")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_power_exact")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Attempt to compute self**other exactly.\n\n        Given Decimals self and other and an integer p, attempt to\n        compute an exact result for the power self**other, with p\n        digits of precision.  Return None if self**other is not\n        exactly representable in p digits.\n\n        Assumes that elimination of special cases has already been\n        performed: self and other must both be nonspecial; self must\n        be positive and not numerically equal to 1; other must be\n        nonzero.  For efficiency, other._exp should not be too large,\n        so that 10**abs(other._exp) is a feasible calculation.")
(NEWLINE)
(ID "x")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "xc")
(PUNCT ",")
(ID "xe")
(PUNCT "=")
(ID "x")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "x")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD while)
(ID "xc")
(PUNCT "%")
(LIT 10)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "xc")
(PUNCT "//=")
(LIT 10)
(NEWLINE)
(ID "xe")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "y")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT "=")
(ID "y")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "y")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD while)
(ID "yc")
(PUNCT "%")
(LIT 10)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yc")
(PUNCT "//=")
(LIT 10)
(NEWLINE)
(ID "ye")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "xc")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "xe")
(PUNCT "*=")
(ID "yc")
(NEWLINE)
(KEYWORD while)
(ID "xe")
(PUNCT "%")
(LIT 10)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "xe")
(PUNCT "//=")
(LIT 10)
(NEWLINE)
(ID "ye")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ye")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "exponent")
(PUNCT "=")
(ID "xe")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "ye")
(NEWLINE)
(KEYWORD if)
(ID "y")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exponent")
(PUNCT "=")
(PUNCT "-")
(ID "exponent")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ideal_exponent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "*")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "zeros")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "exponent")
(PUNCT "-")
(ID "ideal_exponent")
(PUNCT ",")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zeros")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(ID "zeros")
(PUNCT ",")
(ID "exponent")
(PUNCT "-")
(ID "zeros")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "y")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last_digit")
(PUNCT "=")
(ID "xc")
(PUNCT "%")
(LIT 10)
(NEWLINE)
(KEYWORD if)
(ID "last_digit")
(KEYWORD in)
(PUNCT "(")
(LIT 2)
(PUNCT ",")
(LIT 4)
(PUNCT ",")
(LIT 6)
(PUNCT ",")
(LIT 8)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "xc")
(PUNCT "&")
(PUNCT "-")
(ID "xc")
(PUNCT "!=")
(ID "xc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "e")
(PUNCT "=")
(ID "_nbits")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "emax")
(PUNCT "=")
(ID "p")
(PUNCT "*")
(LIT 93)
(PUNCT "//")
(LIT 65)
(NEWLINE)
(KEYWORD if)
(ID "ye")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "emax")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "e")
(PUNCT "=")
(ID "_decimal_lshift_exact")
(PUNCT "(")
(ID "e")
(PUNCT "*")
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT ")")
(NEWLINE)
(ID "xe")
(PUNCT "=")
(ID "_decimal_lshift_exact")
(PUNCT "(")
(ID "xe")
(PUNCT "*")
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "e")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "xe")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "e")
(PUNCT ">")
(ID "emax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xc")
(PUNCT "=")
(LIT 5)
(PUNCT "**")
(ID "e")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "last_digit")
(PUNCT "==")
(LIT 5)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "e")
(PUNCT "=")
(ID "_nbits")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(PUNCT "*")
(LIT 28)
(PUNCT "//")
(LIT 65)
(NEWLINE)
(ID "xc")
(PUNCT ",")
(ID "remainder")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(LIT 5)
(PUNCT "**")
(ID "e")
(PUNCT ",")
(ID "xc")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "remainder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "xc")
(PUNCT "%")
(LIT 5)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "xc")
(PUNCT "//=")
(LIT 5)
(NEWLINE)
(ID "e")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "emax")
(PUNCT "=")
(ID "p")
(PUNCT "*")
(LIT 10)
(PUNCT "//")
(LIT 3)
(NEWLINE)
(KEYWORD if)
(ID "ye")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "emax")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "e")
(PUNCT "=")
(ID "_decimal_lshift_exact")
(PUNCT "(")
(ID "e")
(PUNCT "*")
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT ")")
(NEWLINE)
(ID "xe")
(PUNCT "=")
(ID "_decimal_lshift_exact")
(PUNCT "(")
(ID "xe")
(PUNCT "*")
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "e")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "xe")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "e")
(PUNCT ">")
(ID "emax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xc")
(PUNCT "=")
(LIT 2)
(PUNCT "**")
(ID "e")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "xc")
(PUNCT ">=")
(LIT 10)
(PUNCT "**")
(ID "p")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xe")
(PUNCT "=")
(PUNCT "-")
(ID "e")
(PUNCT "-")
(ID "xe")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(PUNCT ",")
(ID "xe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ye")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "yc")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "ye")
(PUNCT ",")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "xe")
(PUNCT "!=")
(LIT 0)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "yc")
(PUNCT "*")
(ID "xe")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT "<=")
(PUNCT "-")
(ID "ye")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xc_bits")
(PUNCT "=")
(ID "_nbits")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "xc")
(PUNCT "!=")
(LIT 1)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "yc")
(PUNCT ")")
(PUNCT "*")
(ID "xc_bits")
(PUNCT ")")
(PUNCT ")")
(PUNCT "<=")
(PUNCT "-")
(ID "ye")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "m")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "yc")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(PUNCT "-")
(ID "ye")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "m")
(PUNCT "%")
(LIT 2)
(PUNCT "==")
(ID "n")
(PUNCT "%")
(LIT 2)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "//=")
(LIT 2)
(NEWLINE)
(ID "n")
(PUNCT "//=")
(LIT 2)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "m")
(PUNCT "%")
(LIT 5)
(PUNCT "==")
(ID "n")
(PUNCT "%")
(LIT 5)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "//=")
(LIT 5)
(NEWLINE)
(ID "n")
(PUNCT "//=")
(LIT 5)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "xc")
(PUNCT "!=")
(LIT 1)
(KEYWORD and)
(ID "xc_bits")
(PUNCT "<=")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xe")
(PUNCT ",")
(ID "rem")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "xe")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "rem")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "a")
(PUNCT "=")
(LIT 1)
(PUNCT "<<")
(PUNCT "-")
(PUNCT "(")
(PUNCT "-")
(ID "_nbits")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(PUNCT "//")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "q")
(PUNCT ",")
(ID "r")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "xc")
(PUNCT ",")
(ID "a")
(PUNCT "**")
(PUNCT "(")
(ID "n")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "a")
(PUNCT "<=")
(ID "q")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "a")
(PUNCT "=")
(PUNCT "(")
(ID "a")
(PUNCT "*")
(PUNCT "(")
(ID "n")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "+")
(ID "q")
(PUNCT ")")
(PUNCT "//")
(ID "n")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "a")
(PUNCT "==")
(ID "q")
(KEYWORD and)
(ID "r")
(PUNCT "==")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xc")
(PUNCT "=")
(ID "a")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "xc")
(PUNCT ">")
(LIT 1)
(KEYWORD and)
(ID "m")
(PUNCT ">")
(ID "p")
(PUNCT "*")
(LIT 100)
(PUNCT "//")
(ID "_log10_lb")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "xc")
(PUNCT "=")
(ID "xc")
(PUNCT "**")
(ID "m")
(NEWLINE)
(ID "xe")
(PUNCT "*=")
(ID "m")
(NEWLINE)
(KEYWORD if)
(ID "xc")
(PUNCT ">")
(LIT 10)
(PUNCT "**")
(ID "p")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "str_xc")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ideal_exponent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "*")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "zeros")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "xe")
(PUNCT "-")
(ID "ideal_exponent")
(PUNCT ",")
(ID "p")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "str_xc")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zeros")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "str_xc")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(ID "zeros")
(PUNCT ",")
(ID "xe")
(PUNCT "-")
(ID "zeros")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__pow__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "modulo")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return self ** other [ % modulo].\n\n        With two arguments, compute self**other.\n\n        With three arguments, compute (self**other) % modulo.  For the\n        three argument form, the following restrictions on the\n        arguments hold:\n\n         - all three arguments must be integral\n         - other must be nonnegative\n         - either self or other (or both) must be nonzero\n         - modulo must be nonzero and must have at most p digits,\n           where p is the context precision.\n\n        If any of these restrictions is violated the InvalidOperation\n        flag is raised.\n\n        The result of pow(self, other, modulo) is identical to the\n        result that would be obtained by computing (self**other) %\n        modulo with unbounded precision, but is computed more\n        efficiently.  It is always exact.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "modulo")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_power_modulo")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "modulo")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "0 ** 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "result_sign")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "_iseven")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result_sign")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "x ** y with x negative and y not an integer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_negate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "result_sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "result_sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT "==")
(ID "_One")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "multiplier")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "other")
(PUNCT ">")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "multiplier")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "multiplier")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "*")
(ID "multiplier")
(NEWLINE)
(KEYWORD if)
(ID "exp")
(PUNCT "<")
(LIT 1)
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(LIT 1)
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(ID "exp")
(PUNCT "=")
(LIT 1)
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(LIT "1")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "-")
(ID "exp")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self_adj")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(ID "self_adj")
(PUNCT "<")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_SignedInfinity")
(PUNCT "[")
(ID "result_sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "ans")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "exact")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "bound")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_log10_exp_bound")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "other")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self_adj")
(PUNCT ">=")
(LIT 0)
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "bound")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Etiny")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "bound")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(PUNCT "-")
(ID "Etiny")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "Etiny")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "ans")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_power_exact")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "result_sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "ans")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "ans")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exact")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "ans")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "p")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(ID "x")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "xc")
(PUNCT ",")
(ID "xe")
(PUNCT "=")
(ID "x")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "x")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(ID "y")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT "=")
(ID "y")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "y")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD if)
(ID "y")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yc")
(PUNCT "=")
(PUNCT "-")
(ID "yc")
(NEWLINE)
(DEDENT)
(ID "extra")
(PUNCT "=")
(LIT 3)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "exp")
(PUNCT "=")
(ID "_dpower")
(PUNCT "(")
(ID "xc")
(PUNCT ",")
(ID "xe")
(PUNCT ",")
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT ",")
(ID "p")
(PUNCT "+")
(ID "extra")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "coeff")
(PUNCT "%")
(PUNCT "(")
(LIT 5)
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "extra")
(PUNCT "+=")
(LIT 3)
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "result_sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "exact")
(KEYWORD and)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "_isinteger")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "ans")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "<=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "expdiff")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "ans")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "ans")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "ans")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(ID "expdiff")
(PUNCT ",")
(ID "ans")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "expdiff")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "newcontext")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "newcontext")
(PUNCT ".")
(ID "clear_flags")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "exception")
(KEYWORD in)
(ID "_signals")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newcontext")
(PUNCT ".")
(ID "traps")
(PUNCT "[")
(ID "exception")
(PUNCT "]")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "newcontext")
(PUNCT ")")
(NEWLINE)
(ID "newcontext")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "newcontext")
(PUNCT ".")
(ID "flags")
(PUNCT "[")
(ID "Subnormal")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newcontext")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Underflow")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "newcontext")
(PUNCT ".")
(ID "flags")
(PUNCT "[")
(ID "Overflow")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Overflow")
(PUNCT ",")
(LIT "above Emax")
(PUNCT ",")
(ID "ans")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "exception")
(KEYWORD in)
(ID "Underflow")
(PUNCT ",")
(ID "Subnormal")
(PUNCT ",")
(ID "Inexact")
(PUNCT ",")
(ID "Rounded")
(PUNCT ",")
(ID "Clamped")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "newcontext")
(PUNCT ".")
(ID "flags")
(PUNCT "[")
(ID "exception")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "exception")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rpow__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Swaps self/other and returns __pow__.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "__pow__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "normalize")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Normalize- strip trailing 0s, change anything equal to 0 to 0e0")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "dup")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "dup")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "dup")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "dup")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "dup")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exp_max")
(PUNCT "=")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etop")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "clamp")
(PUNCT "]")
(NEWLINE)
(ID "end")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "dup")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(ID "exp")
(PUNCT "=")
(ID "dup")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(KEYWORD while)
(ID "dup")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "end")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "0")
(KEYWORD and)
(ID "exp")
(PUNCT "<")
(ID "exp_max")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "end")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "dup")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "dup")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "quantize")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exp")
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "watchexp")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Quantize self so its exponent is the same as that of exp.\n\n        Similar to self._rescale(exp._exp) but with error checking.\n        ")
(NEWLINE)
(ID "exp")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "exp")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "rounding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "rounding")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "exp")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "exp")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "exp")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "exp")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "quantize with one INF")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "watchexp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "exp")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ".")
(ID "_exp")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT "!=")
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(PUNCT "<=")
(ID "exp")
(PUNCT ".")
(ID "_exp")
(PUNCT "<=")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "target exponent out of bounds in quantize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "exp")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self_adjusted")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self_adjusted")
(PUNCT ">")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "exponent of quantize result too large for current context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_adjusted")
(PUNCT "-")
(ID "exp")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(LIT 1)
(PUNCT ">")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "quantize result has too many digits for current context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "exp")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "exponent of quantize result too large for current context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "ans")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ">")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "quantize result has too many digits for current context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ans")
(KEYWORD and)
(ID "ans")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "<")
(ID "context")
(PUNCT ".")
(ID "Emin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Subnormal")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ans")
(PUNCT ".")
(ID "_exp")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ans")
(PUNCT "!=")
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "same_quantum")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self and other have the same exponent; otherwise\n        return False.\n\n        If either operand is a special value, the following rules are used:\n           * return True if both operands are infinities\n           * return True if both operands are NaNs\n           * otherwise, return False.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "is_infinite")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "is_infinite")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_rescale")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exp")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rescale self so that the exponent is exp, either by padding with zeros\n        or by truncating digits, using the given rounding mode.\n\n        Specials are returned without change.  This operation is\n        quiet: it raises no flags, and uses no information from the\n        context.\n\n        exp = exp to scale to (an integer)\n        rounding = rounding mode\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">=")
(ID "exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "exp")
(PUNCT ")")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "digits")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "-")
(ID "exp")
(NEWLINE)
(KEYWORD if)
(ID "digits")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "exp")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "digits")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "this_function")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_pick_rounding_function")
(PUNCT "[")
(ID "rounding")
(PUNCT "]")
(NEWLINE)
(ID "changed")
(PUNCT "=")
(ID "this_function")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "digits")
(PUNCT ")")
(NEWLINE)
(ID "coeff")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT ":")
(ID "digits")
(PUNCT "]")
(KEYWORD or)
(LIT "0")
(NEWLINE)
(KEYWORD if)
(ID "changed")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "coeff")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_round")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "places")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Round a nonzero, nonspecial Decimal to a fixed number of\n        significant figures, using the given rounding mode.\n\n        Infinities, NaNs and zeros are returned unaltered.\n\n        This operation is quiet: it raises no flags, and uses no\n        information from the context.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "places")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "argument should be at least 1 in _round")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT "-")
(ID "places")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(ID "ans")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT "-")
(ID "places")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_integral_exact")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds to a nearby integer.\n\n        If no rounding mode is specified, take the rounding mode from\n        the context.  This method raises the Rounded and Inexact flags\n        when appropriate.\n\n        See also: to_integral_value, which does exactly the same as\n        this method except that it doesn't raise Inexact or Rounded.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "rounding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "rounding")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT "!=")
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_integral_value")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds to the nearest integer, without raising inexact, rounded.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "rounding")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "rounding")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "to_integral")
(PUNCT "=")
(ID "to_integral_value")
(NEWLINE)
(KEYWORD def)
(ID "sqrt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the square root of self.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(LIT "0")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "//")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "sqrt(-x), x > 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "prec")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "op")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "e")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "exp")
(PUNCT ">>")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "op")
(PUNCT ".")
(ID "exp")
(PUNCT "&")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(PUNCT "*")
(LIT 10)
(NEWLINE)
(ID "l")
(PUNCT "=")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ">>")
(LIT 1)
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(NEWLINE)
(ID "l")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ">>")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "shift")
(PUNCT "=")
(ID "prec")
(PUNCT "-")
(ID "l")
(NEWLINE)
(KEYWORD if)
(ID "shift")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "*=")
(LIT 100)
(PUNCT "**")
(ID "shift")
(NEWLINE)
(ID "exact")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT ",")
(ID "remainder")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(LIT 100)
(PUNCT "**")
(PUNCT "-")
(ID "shift")
(PUNCT ")")
(NEWLINE)
(ID "exact")
(PUNCT "=")
(KEYWORD not)
(ID "remainder")
(NEWLINE)
(DEDENT)
(ID "e")
(PUNCT "-=")
(ID "shift")
(NEWLINE)
(ID "n")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(ID "prec")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "q")
(PUNCT "=")
(ID "c")
(PUNCT "//")
(ID "n")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<=")
(ID "q")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "=")
(ID "n")
(PUNCT "+")
(ID "q")
(PUNCT ">>")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "exact")
(PUNCT "=")
(ID "exact")
(KEYWORD and)
(ID "n")
(PUNCT "*")
(ID "n")
(PUNCT "==")
(ID "c")
(NEWLINE)
(KEYWORD if)
(ID "exact")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "shift")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "//=")
(LIT 10)
(PUNCT "**")
(ID "shift")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "shift")
(NEWLINE)
(DEDENT)
(ID "e")
(PUNCT "+=")
(ID "shift")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "n")
(PUNCT "%")
(LIT 5)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT ",")
(ID "e")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_shallow_copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_set_rounding")
(PUNCT "(")
(ID "ROUND_HALF_EVEN")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "=")
(ID "rounding")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "max")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the larger value.\n\n        Like max(self, other) except if one is not a number, returns\n        NaN (and signals if one is sNaN).  Also rounds.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sn")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "on")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sn")
(KEYWORD or)
(ID "on")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "on")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "sn")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sn")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "on")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "compare_total")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "min")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the smaller value.\n\n        Like min(self, other) except if one is not a number, returns\n        NaN (and signals if one is sNaN).  Also rounds.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sn")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "on")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sn")
(KEYWORD or)
(ID "on")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "on")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "sn")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sn")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "on")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "compare_total")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_isinteger")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns whether self is an integer")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(ID "rest")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "rest")
(PUNCT "==")
(LIT "0")
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_iseven")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns True if self is even.  Assumes self is an integer.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "]")
(KEYWORD in)
(LIT "02468")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "adjusted")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the adjusted exponent of self")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "canonical")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the same Decimal object.\n\n        As we do not have different encodings for the same number, the\n        received object already is in its canonical form.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare_signal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares self to the other operand numerically.\n\n        It's pretty much like compare(), but all NaNs signal, with signaling\n        NaNs taking precedence over quiet NaNs.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_compare_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "compare")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare_total")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares self to other using the abstract representations.\n\n        This is not like the standard compare, which use their numerical\n        value. Note that a total ordering is defined for all possible abstract\n        representations.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(KEYWORD and)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_sign")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(ID "sign")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(ID "self_nan")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "other_nan")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self_nan")
(KEYWORD or)
(ID "other_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self_nan")
(PUNCT "==")
(ID "other_nan")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self_key")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(ID "other_key")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(KEYWORD if)
(ID "self_key")
(PUNCT "<")
(ID "other_key")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self_key")
(PUNCT ">")
(ID "other_key")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "_Zero")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self_nan")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_nan")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self_nan")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_nan")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other_nan")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT "<")
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ">")
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">")
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeOne")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "_Zero")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare_total_mag")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares self to other using abstract repr., ignoring sign.\n\n        Like compare_total, but with operand's sign ignored and assumed to be 0.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "o")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "s")
(PUNCT ".")
(ID "compare_total")
(PUNCT "(")
(ID "o")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy_abs")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy with the sign set to 0. ")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy_negate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy with the sign inverted.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "copy_sign")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns self with the sign of other.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "exp")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns e ** self.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_Zero")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_One")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "p")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(ID "adj")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(KEYWORD and)
(ID "adj")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(PUNCT "(")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT "*")
(LIT 3)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "adj")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(PUNCT "(")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT "*")
(LIT 3)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 0)
(KEYWORD and)
(ID "adj")
(PUNCT "<")
(PUNCT "-")
(ID "p")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "+")
(LIT "1")
(PUNCT ",")
(PUNCT "-")
(ID "p")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "adj")
(PUNCT "<")
(PUNCT "-")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "9")
(PUNCT "*")
(PUNCT "(")
(ID "p")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(PUNCT "-")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD if)
(ID "op")
(PUNCT ".")
(ID "sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(PUNCT "-")
(ID "c")
(NEWLINE)
(DEDENT)
(ID "extra")
(PUNCT "=")
(LIT 3)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "exp")
(PUNCT "=")
(ID "_dexp")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "p")
(PUNCT "+")
(ID "extra")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "coeff")
(PUNCT "%")
(PUNCT "(")
(LIT 5)
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "extra")
(PUNCT "+=")
(LIT 3)
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_shallow_copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_set_rounding")
(PUNCT "(")
(ID "ROUND_HALF_EVEN")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "=")
(ID "rounding")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_canonical")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is canonical; otherwise return False.\n\n        Currently, the encoding of a Decimal instance is always\n        canonical, so this method returns True for any Decimal.\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_finite")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is finite; otherwise return False.\n\n        A Decimal instance is considered finite if it is neither\n        infinite nor a NaN.\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_infinite")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is infinite; otherwise return False.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "F")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_nan")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is a qNaN or sNaN; otherwise return False.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exp")
(KEYWORD in)
(PUNCT "(")
(LIT "n")
(PUNCT ",")
(LIT "N")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_normal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is a normal number; otherwise return False.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "Emin")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_qnan")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is a quiet NaN; otherwise return False.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "n")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_signed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is negative; otherwise return False.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_snan")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is a signaling NaN; otherwise return False.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "==")
(LIT "N")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_subnormal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is subnormal; otherwise return False.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "<")
(ID "context")
(PUNCT ".")
(ID "Emin")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_zero")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is a zero; otherwise return False.")
(NEWLINE)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "==")
(LIT "0")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ln_exp_bound")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute a lower bound for the adjusted exponent of self.ln().\n        In other words, compute r such that self.ln() >= 10**r.  Assumes\n        that self is finite and positive and that self != 1.\n        ")
(NEWLINE)
(ID "adj")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "adj")
(PUNCT ">=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "adj")
(PUNCT "*")
(LIT 23)
(PUNCT "//")
(LIT 10)
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "adj")
(PUNCT "<=")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT "-")
(ID "adj")
(PUNCT ")")
(PUNCT "*")
(LIT 23)
(PUNCT "//")
(LIT 10)
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "op")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD if)
(ID "adj")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT "-")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "e")
(PUNCT ")")
(NEWLINE)
(ID "den")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "num")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "den")
(PUNCT ")")
(PUNCT "-")
(PUNCT "(")
(ID "num")
(PUNCT "<")
(ID "den")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "e")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "e")
(PUNCT "-")
(ID "c")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ln")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the natural (base e) logarithm of self.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeInfinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT "==")
(ID "_One")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_Zero")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "ln of a negative value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "op")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(ID "p")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(ID "places")
(PUNCT "=")
(ID "p")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_ln_exp_bound")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT 2)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "=")
(ID "_dlog")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "places")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "coeff")
(PUNCT "%")
(PUNCT "(")
(LIT 5)
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "places")
(PUNCT "+=")
(LIT 3)
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "coeff")
(PUNCT "<")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(PUNCT "-")
(ID "places")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_shallow_copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_set_rounding")
(PUNCT "(")
(ID "ROUND_HALF_EVEN")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "=")
(ID "rounding")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_log10_exp_bound")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute a lower bound for the adjusted exponent of self.log10().\n        In other words, find r such that self.log10() >= 10**r.\n        Assumes that self is finite and positive and that self != 1.\n        ")
(NEWLINE)
(ID "adj")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "adj")
(PUNCT ">=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "adj")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "adj")
(PUNCT "<=")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT "-")
(ID "adj")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "op")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD if)
(ID "adj")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT "-")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "e")
(PUNCT ")")
(NEWLINE)
(ID "den")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(LIT 231)
(PUNCT "*")
(ID "c")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "num")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "den")
(PUNCT ")")
(PUNCT "-")
(PUNCT "(")
(ID "num")
(PUNCT "<")
(ID "den")
(PUNCT ")")
(PUNCT "+")
(LIT 2)
(NEWLINE)
(DEDENT)
(ID "num")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "e")
(PUNCT "-")
(ID "c")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "num")
(PUNCT ")")
(PUNCT "+")
(ID "e")
(PUNCT "-")
(PUNCT "(")
(ID "num")
(PUNCT "<")
(LIT "231")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log10")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the base 10 logarithm of self.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeInfinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ",")
(LIT "log10 of a negative value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "1")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op")
(PUNCT "=")
(ID "_WorkRep")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT "=")
(ID "op")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "op")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(ID "p")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(ID "places")
(PUNCT "=")
(ID "p")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_log10_exp_bound")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT 2)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT "=")
(ID "_dlog10")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "places")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "coeff")
(PUNCT "%")
(PUNCT "(")
(LIT 5)
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "places")
(PUNCT "+=")
(LIT 3)
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "coeff")
(PUNCT "<")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "coeff")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(PUNCT "-")
(ID "places")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_shallow_copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "_set_rounding")
(PUNCT "(")
(ID "ROUND_HALF_EVEN")
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "rounding")
(PUNCT "=")
(ID "rounding")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logb")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Returns the exponent of the magnitude of self's MSD.\n\n        The result is the integer which is the exponent of the magnitude\n        of the most significant digit of self (as though it were truncated\n        to a single digit while maintaining the value of that digit and\n        without limiting the resulting exponent).\n        ")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "DivisionByZero")
(PUNCT ",")
(LIT "logb(0)")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_islogical")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if self is a logical operand.\n\n        For being logical, it must be a finite number with a sign of 0,\n        an exponent of 0, and a coefficient whose digits must all be\n        either 0 or 1.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "!=")
(LIT 0)
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "dig")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "dig")
(KEYWORD not)
(KEYWORD in)
(LIT "01")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fill_logical")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dif")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "opa")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "dif")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opa")
(PUNCT "=")
(LIT "0")
(PUNCT "*")
(ID "dif")
(PUNCT "+")
(ID "opa")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "dif")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opa")
(PUNCT "=")
(ID "opa")
(PUNCT "[")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "dif")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "opb")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "dif")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opb")
(PUNCT "=")
(LIT "0")
(PUNCT "*")
(ID "dif")
(PUNCT "+")
(ID "opb")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "dif")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opb")
(PUNCT "=")
(ID "opb")
(PUNCT "[")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "opa")
(PUNCT ",")
(ID "opb")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_and")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Applies an 'and' operation between self and other's digits.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_islogical")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "_islogical")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fill_logical")
(PUNCT "(")
(ID "context")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT "&")
(ID "int")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "a")
(PUNCT ",")
(ID "b")
(KEYWORD in)
(ID "zip")
(PUNCT "(")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "result")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_invert")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Invert all its digits.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "logical_xor")
(PUNCT "(")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT "*")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_or")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Applies an 'or' operation between self and other's digits.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_islogical")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "_islogical")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fill_logical")
(PUNCT "(")
(ID "context")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT "|")
(ID "int")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "a")
(PUNCT ",")
(ID "b")
(KEYWORD in)
(ID "zip")
(PUNCT "(")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "result")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_xor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Applies an 'xor' operation between self and other's digits.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_islogical")
(PUNCT "(")
(PUNCT ")")
(KEYWORD or)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "_islogical")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fill_logical")
(PUNCT "(")
(ID "context")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT "^")
(ID "int")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "a")
(PUNCT ",")
(ID "b")
(KEYWORD in)
(ID "zip")
(PUNCT "(")
(ID "opa")
(PUNCT ",")
(ID "opb")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "result")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "max_mag")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares the values numerically with their sign ignored.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sn")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "on")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sn")
(KEYWORD or)
(ID "on")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "on")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "sn")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sn")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "on")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "compare_total")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "min_mag")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares the values numerically with their sign ignored.")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(KEYWORD or)
(ID "other")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sn")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "on")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sn")
(KEYWORD or)
(ID "on")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "on")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "sn")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sn")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "on")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "compare_total")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ans")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "next_minus")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the largest representable number smaller than itself.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_NegativeInfinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "9")
(PUNCT "*")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etop")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_set_rounding")
(PUNCT "(")
(ID "ROUND_FLOOR")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_ignore_all_flags")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "new_self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new_self")
(PUNCT "!=")
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "new_self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__sub__")
(PUNCT "(")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "next_plus")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the smallest representable number larger than itself.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT "9")
(PUNCT "*")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etop")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_set_rounding")
(PUNCT "(")
(ID "ROUND_CEILING")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_ignore_all_flags")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "new_self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new_self")
(PUNCT "!=")
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "new_self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__add__")
(PUNCT "(")
(ID "_dec_from_triple")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "1")
(PUNCT ",")
(ID "context")
(PUNCT ".")
(ID "Etiny")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "next_toward")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the number closest to self, in the direction towards other.\n\n        The result is the closest representable number to self\n        (excluding self) that is in the direction towards other,\n        unless both have the same value.  If the two operands are\n        numerically equal, then the result is a copy of self with the\n        sign set to be the same as the sign of other.\n        ")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(ID "comparison")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cmp")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "comparison")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "copy_sign")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "comparison")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "next_plus")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "next_minus")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ans")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Overflow")
(PUNCT ",")
(LIT "Infinite result from next_toward")
(PUNCT ",")
(ID "ans")
(PUNCT ".")
(ID "_sign")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "ans")
(PUNCT ".")
(ID "adjusted")
(PUNCT "(")
(PUNCT ")")
(PUNCT "<")
(ID "context")
(PUNCT ".")
(ID "Emin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Underflow")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Subnormal")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Inexact")
(PUNCT ")")
(NEWLINE)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Rounded")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "Clamped")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "number_class")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns an indication of the class of self.\n\n        The class is one of the following strings:\n          sNaN\n          NaN\n          -Infinity\n          -Normal\n          -Subnormal\n          -Zero\n          +Zero\n          +Subnormal\n          +Normal\n          +Infinity\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_snan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "sNaN")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_qnan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "NaN")
(NEWLINE)
(DEDENT)
(ID "inf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "inf")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "+Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "inf")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "-Infinity")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_zero")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "-Zero")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "+Zero")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_subnormal")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "-Subnormal")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "+Subnormal")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "-Normal")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "+Normal")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "radix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Just returns 10, as this is Decimal, :)")
(NEWLINE)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(LIT 10)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "rotate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a rotated copy of self, value-of-other times.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "<=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "<=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "torot")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "rotdig")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(ID "topad")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "rotdig")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "topad")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rotdig")
(PUNCT "=")
(LIT "0")
(PUNCT "*")
(ID "topad")
(PUNCT "+")
(ID "rotdig")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "topad")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rotdig")
(PUNCT "=")
(ID "rotdig")
(PUNCT "[")
(PUNCT "-")
(ID "topad")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "rotated")
(PUNCT "=")
(ID "rotdig")
(PUNCT "[")
(ID "torot")
(PUNCT ":")
(PUNCT "]")
(PUNCT "+")
(ID "rotdig")
(PUNCT "[")
(PUNCT ":")
(ID "torot")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "rotated")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "scaleb")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns self operand after adding the second value to its exp.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "liminf")
(PUNCT "=")
(PUNCT "-")
(LIT 2)
(PUNCT "*")
(PUNCT "(")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "+")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(ID "limsup")
(PUNCT "=")
(LIT 2)
(PUNCT "*")
(PUNCT "(")
(ID "context")
(PUNCT ".")
(ID "Emax")
(PUNCT "+")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "liminf")
(PUNCT "<=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "<=")
(ID "limsup")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "d")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "d")
(PUNCT "=")
(ID "d")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "d")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shift")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a shifted copy of self, value-of-other times.")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "ans")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_check_nans")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "context")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ans")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "ans")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT ".")
(ID "_exp")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "<=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "<=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "InvalidOperation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_isinfinity")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "torot")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(ID "rotdig")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(ID "topad")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "rotdig")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "topad")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rotdig")
(PUNCT "=")
(LIT "0")
(PUNCT "*")
(ID "topad")
(PUNCT "+")
(ID "rotdig")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "topad")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rotdig")
(PUNCT "=")
(ID "rotdig")
(PUNCT "[")
(PUNCT "-")
(ID "topad")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "torot")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "shifted")
(PUNCT "=")
(ID "rotdig")
(PUNCT "[")
(PUNCT ":")
(ID "torot")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "shifted")
(PUNCT "=")
(ID "rotdig")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(ID "torot")
(NEWLINE)
(ID "shifted")
(PUNCT "=")
(ID "shifted")
(PUNCT "[")
(PUNCT "-")
(ID "context")
(PUNCT ".")
(ID "prec")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "shifted")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reduce__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ",")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__copy__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(KEYWORD is)
(ID "Decimal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__deepcopy__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "memo")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(KEYWORD is)
(ID "Decimal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__format__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "specifier")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "_localeconv")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Format a Decimal instance according to the given specifier.\n\n        The specifier should be a standard format specifier, with the\n        form described in PEP 3101.  Formatting types 'e', 'E', 'f',\n        'F', 'g', 'G', 'n' and '%' are supported.  If the formatting\n        type is omitted it defaults to 'g' or 'G', depending on the\n        value of context.capitals.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "spec")
(PUNCT "=")
(ID "_parse_format_specifier")
(PUNCT "(")
(ID "specifier")
(PUNCT ",")
(ID "_localeconv")
(PUNCT "=")
(ID "_localeconv")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sign")
(PUNCT "=")
(ID "_format_sign")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(NEWLINE)
(ID "body")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "==")
(LIT "%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "body")
(PUNCT "+=")
(LIT "%")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_format_align")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "body")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(LIT "g")
(PUNCT ",")
(LIT "G")
(PUNCT "]")
(PUNCT "[")
(ID "context")
(PUNCT ".")
(ID "capitals")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "==")
(LIT "%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rounding")
(PUNCT "=")
(ID "context")
(PUNCT ".")
(ID "rounding")
(NEWLINE)
(ID "precision")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "precision")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "precision")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "eE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_round")
(PUNCT "(")
(ID "precision")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "fF%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(PUNCT "-")
(ID "precision")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "gG")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ">")
(ID "precision")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_round")
(PUNCT "(")
(ID "precision")
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "fF%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_rescale")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "rounding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "leftdigits")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "eE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(KEYWORD and)
(ID "precision")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(LIT 1)
(PUNCT "-")
(ID "precision")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "fF%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(ID "leftdigits")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "gG")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "<=")
(LIT 0)
(KEYWORD and)
(ID "leftdigits")
(PUNCT ">")
(PUNCT "-")
(LIT 6)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(ID "leftdigits")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotplace")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "dotplace")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "intpart")
(PUNCT "=")
(LIT "0")
(NEWLINE)
(ID "fracpart")
(PUNCT "=")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(PUNCT "-")
(ID "dotplace")
(PUNCT ")")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_int")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "dotplace")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "intpart")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "+")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "dotplace")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "fracpart")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "intpart")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(PUNCT ":")
(ID "dotplace")
(PUNCT "]")
(KEYWORD or)
(LIT "0")
(NEWLINE)
(ID "fracpart")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "[")
(ID "dotplace")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "exp")
(PUNCT "=")
(ID "leftdigits")
(PUNCT "-")
(ID "dotplace")
(NEWLINE)
(KEYWORD return)
(ID "_format_number")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "intpart")
(PUNCT ",")
(ID "fracpart")
(PUNCT ",")
(ID "exp")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_dec_from_triple")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "coefficient")
(PUNCT ",")
(ID "exponent")
(PUNCT ",")
(ID "special")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a decimal instance directly, without any validation,\n    normalization (e.g. removal of leading zeros) or argument\n    conversion.\n\n    This function is for *internal use only*.\n    ")
(NEWLINE)
(ID "self")
(PUNCT "=")
(ID "object")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "Decimal")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT "=")
(ID "sign")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT "=")
(ID "coefficient")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT "=")
(ID "exponent")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT "=")
(ID "special")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(ID "_numbers")
(PUNCT ".")
(ID "Number")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "Decimal")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "_ContextManager")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Context manager class to support localcontext().\n\n      Sets a copy of the supplied context in __enter__() and restores\n      the previous decimal context in __exit__()\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "new_context")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "new_context")
(PUNCT "=")
(ID "new_context")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "saved_context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "setcontext")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "new_context")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "new_context")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setcontext")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "saved_context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Context")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Contains the context for a Decimal instance.\n\n    Contains:\n    prec - precision (for use in rounding, division, square roots..)\n    rounding - rounding type (how you round)\n    traps - If traps[exception] = 1, then the exception is\n                    raised when it is caused.  Otherwise, a value is\n                    substituted in.\n    flags  - When an exception is caused, flags[exception] is set.\n             (Whether or not the trap_enabler is set)\n             Should be reset by user of Decimal instance.\n    Emin -   Minimum exponent\n    Emax -   Maximum exponent\n    capitals -      If 1, 1*10^1 is printed as 1E+1.\n                    If 0, printed as 1e1\n    clamp -  If 1, change exponents if too high (Default 0)\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prec")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "Emin")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "Emax")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "capitals")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "clamp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "flags")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "traps")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "_ignored_flags")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dc")
(PUNCT "=")
(ID "DefaultContext")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NameError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT "=")
(ID "prec")
(KEYWORD if)
(ID "prec")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "dc")
(PUNCT ".")
(ID "prec")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rounding")
(PUNCT "=")
(ID "rounding")
(KEYWORD if)
(ID "rounding")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "dc")
(PUNCT ".")
(ID "rounding")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "Emin")
(PUNCT "=")
(ID "Emin")
(KEYWORD if)
(ID "Emin")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "dc")
(PUNCT ".")
(ID "Emin")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "Emax")
(PUNCT "=")
(ID "Emax")
(KEYWORD if)
(ID "Emax")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "dc")
(PUNCT ".")
(ID "Emax")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "capitals")
(PUNCT "=")
(ID "capitals")
(KEYWORD if)
(ID "capitals")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "dc")
(PUNCT ".")
(ID "capitals")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "clamp")
(PUNCT "=")
(ID "clamp")
(KEYWORD if)
(ID "clamp")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(ID "dc")
(PUNCT ".")
(ID "clamp")
(NEWLINE)
(KEYWORD if)
(ID "_ignored_flags")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT "=")
(ID "_ignored_flags")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "traps")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT "=")
(ID "dc")
(PUNCT ".")
(ID "traps")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "traps")
(PUNCT ",")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "int")
(PUNCT "(")
(ID "s")
(KEYWORD in)
(ID "traps")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "s")
(KEYWORD in)
(ID "_signals")
(PUNCT "+")
(ID "traps")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT "=")
(ID "traps")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "flags")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT "=")
(ID "dict")
(PUNCT ".")
(ID "fromkeys")
(PUNCT "(")
(ID "_signals")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "flags")
(PUNCT ",")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "int")
(PUNCT "(")
(ID "s")
(KEYWORD in)
(ID "flags")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "s")
(KEYWORD in)
(ID "_signals")
(PUNCT "+")
(ID "flags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT "=")
(ID "flags")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_set_integer_check")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "vmin")
(PUNCT ",")
(ID "vmax")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s must be an integer")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "vmin")
(PUNCT "==")
(LIT "-inf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(PUNCT ">")
(ID "vmax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s must be in [%s, %d]. got: %s")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "vmin")
(PUNCT ",")
(ID "vmax")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "vmax")
(PUNCT "==")
(LIT "inf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(PUNCT "<")
(ID "vmin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s must be in [%d, %s]. got: %s")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "vmin")
(PUNCT ",")
(ID "vmax")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(PUNCT "<")
(ID "vmin")
(KEYWORD or)
(ID "value")
(PUNCT ">")
(ID "vmax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s must be in [%d, %d]. got %s")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "vmin")
(PUNCT ",")
(ID "vmax")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__setattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_set_signal_dict")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "d")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "d")
(PUNCT ",")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s must be a signal dict")
(PUNCT "%")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "d")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "key")
(KEYWORD in)
(ID "_signals")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(LIT "%s is not a valid signal dict")
(PUNCT "%")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "_signals")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "key")
(KEYWORD in)
(ID "d")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(LIT "%s is not a valid signal dict")
(PUNCT "%")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__setattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT "==")
(LIT "prec")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_set_integer_check")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT "inf")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "Emin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_set_integer_check")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(LIT "-inf")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "Emax")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_set_integer_check")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT "inf")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "capitals")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_set_integer_check")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "clamp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_set_integer_check")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "rounding")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "value")
(KEYWORD in)
(ID "_rounding_modes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s: invalid rounding mode")
(PUNCT "%")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__setattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "flags")
(KEYWORD or)
(ID "name")
(PUNCT "==")
(LIT "traps")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_set_signal_dict")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "name")
(PUNCT "==")
(LIT "_ignored_flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__setattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(LIT "'decimal.Context' object has no attribute '%s'")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__delattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(LIT "%s cannot be deleted")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reduce__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flags")
(PUNCT "=")
(PUNCT "[")
(ID "sig")
(KEYWORD for)
(ID "sig")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "v")
(PUNCT "]")
(NEWLINE)
(ID "traps")
(PUNCT "=")
(PUNCT "[")
(ID "sig")
(KEYWORD for)
(ID "sig")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "v")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "rounding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "Emin")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "Emax")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "capitals")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "clamp")
(PUNCT ",")
(ID "flags")
(PUNCT ",")
(ID "traps")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Show the current context.")
(NEWLINE)
(ID "s")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "s")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Context(prec=%(prec)d, rounding=%(rounding)s, ")
(LIT "Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d, ")
(LIT "clamp=%(clamp)d")
(PUNCT "%")
(ID "vars")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "names")
(PUNCT "=")
(PUNCT "[")
(ID "f")
(PUNCT ".")
(ID "__name__")
(KEYWORD for)
(ID "f")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "v")
(PUNCT "]")
(NEWLINE)
(ID "s")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "flags=[")
(PUNCT "+")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "names")
(PUNCT ")")
(PUNCT "+")
(LIT "]")
(PUNCT ")")
(NEWLINE)
(ID "names")
(PUNCT "=")
(PUNCT "[")
(ID "t")
(PUNCT ".")
(ID "__name__")
(KEYWORD for)
(ID "t")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "v")
(PUNCT "]")
(NEWLINE)
(ID "s")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "traps=[")
(PUNCT "+")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "names")
(PUNCT ")")
(PUNCT "+")
(LIT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "+")
(LIT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear_flags")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Reset all flags to zero")
(NEWLINE)
(KEYWORD for)
(ID "flag")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT "[")
(ID "flag")
(PUNCT "]")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "clear_traps")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Reset all traps to zero")
(NEWLINE)
(KEYWORD for)
(ID "flag")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT "[")
(ID "flag")
(PUNCT "]")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_shallow_copy")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a shallow copy from self.")
(NEWLINE)
(ID "nc")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "rounding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "Emin")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "Emax")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "capitals")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "clamp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "nc")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a deep copy from self.")
(NEWLINE)
(ID "nc")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "rounding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "Emin")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "Emax")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "capitals")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "clamp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "nc")
(NEWLINE)
(DEDENT)
(ID "__copy__")
(PUNCT "=")
(ID "copy")
(NEWLINE)
(KEYWORD def)
(ID "_raise_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "condition")
(PUNCT ",")
(ID "explanation")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handles an error\n\n        If the flag is in _ignored_flags, returns the default response.\n        Otherwise, it sets the flag, then, if the corresponding\n        trap_enabler is set, it reraises the exception.  Otherwise, it returns\n        the default value after setting the flag.\n        ")
(NEWLINE)
(ID "error")
(PUNCT "=")
(ID "_condition_map")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "condition")
(PUNCT ",")
(ID "condition")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "error")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "error")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "flags")
(PUNCT "[")
(ID "error")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "traps")
(PUNCT "[")
(ID "error")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "condition")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "error")
(PUNCT "(")
(ID "explanation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ignore_all_flags")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Ignore all flags, if they are raised")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ignore_flags")
(PUNCT "(")
(PUNCT "*")
(ID "_signals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ignore_flags")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "flags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Ignore the flags, if they are raised")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT "+")
(ID "list")
(PUNCT "(")
(ID "flags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "flags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_regard_flags")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "flags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Stop ignoring the flags, if they are raised")
(NEWLINE)
(KEYWORD if)
(ID "flags")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "flags")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(PUNCT "(")
(ID "tuple")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flags")
(PUNCT "=")
(ID "flags")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "flag")
(KEYWORD in)
(ID "flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_ignored_flags")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "flag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "__hash__")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "Etiny")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns Etiny (= Emin - prec + 1)")
(NEWLINE)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "Emin")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "Etop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns maximum exponent (= Emax - prec + 1)")
(NEWLINE)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "Emax")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_set_rounding")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Sets the rounding type.\n\n        Sets the rounding type, and returns the current (previous)\n        rounding type.  Often used like:\n\n        context = context.copy()\n        # so you don't change the calling context\n        # if an error occurs in the middle.\n        rounding = context._set_rounding(ROUND_UP)\n        val = self.__sub__(other, context=context)\n        context._set_rounding(rounding)\n\n        This will make it round up for that operation.\n        ")
(NEWLINE)
(ID "rounding")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "rounding")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rounding")
(PUNCT "=")
(ID "type")
(NEWLINE)
(KEYWORD return)
(ID "rounding")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "create_decimal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "num")
(PUNCT "=")
(LIT "0")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Creates a new Decimal instance but using self as context.\n\n        This method implements the to-number operation of the\n        IBM Decimal specification.")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "num")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(KEYWORD and)
(ID "num")
(PUNCT "!=")
(ID "num")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "ConversionSyntax")
(PUNCT ",")
(LIT "no trailing or leading whitespace is ")
(LIT "permitted.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "d")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "num")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "d")
(PUNCT ".")
(ID "_isnan")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "d")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "prec")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "clamp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "ConversionSyntax")
(PUNCT ",")
(LIT "diagnostic info too long in NaN")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "d")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "create_decimal_from_float")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Creates a new Decimal instance from a float but rounding using self\n        as the context.\n\n        >>> context = Context(prec=5, rounding=ROUND_DOWN)\n        >>> context.create_decimal_from_float(3.1415926535897932)\n        Decimal('3.1415')\n        >>> context = Context(prec=5, traps=[Inexact])\n        >>> context.create_decimal_from_float(3.1415926535897932)\n        Traceback (most recent call last):\n            ...\n        decimal.Inexact: None\n\n        ")
(NEWLINE)
(ID "d")
(PUNCT "=")
(ID "Decimal")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "d")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "abs")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the absolute value of the operand.\n\n        If the operand is negative, the result is the same as using the minus\n        operation on the operand.  Otherwise, the result is the same as using\n        the plus operation on the operand.\n\n        >>> ExtendedContext.abs(Decimal('2.1'))\n        Decimal('2.1')\n        >>> ExtendedContext.abs(Decimal('-100'))\n        Decimal('100')\n        >>> ExtendedContext.abs(Decimal('101.5'))\n        Decimal('101.5')\n        >>> ExtendedContext.abs(Decimal('-101.5'))\n        Decimal('101.5')\n        >>> ExtendedContext.abs(-1)\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "__abs__")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the sum of the two operands.\n\n        >>> ExtendedContext.add(Decimal('12'), Decimal('7.00'))\n        Decimal('19.00')\n        >>> ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))\n        Decimal('1.02E+4')\n        >>> ExtendedContext.add(1, Decimal(2))\n        Decimal('3')\n        >>> ExtendedContext.add(Decimal(8), 5)\n        Decimal('13')\n        >>> ExtendedContext.add(5, 5)\n        Decimal('10')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__add__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_apply")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "_fix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "canonical")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the same Decimal object.\n\n        As we do not have different encodings for the same number, the\n        received object already is in its canonical form.\n\n        >>> ExtendedContext.canonical(Decimal('2.50'))\n        Decimal('2.50')\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "canonical requires a Decimal as an argument.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "canonical")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares values numerically.\n\n        If the signs of the operands differ, a value representing each operand\n        ('-1' if the operand is less than zero, '0' if the operand is zero or\n        negative zero, or '1' if the operand is greater than zero) is used in\n        place of that operand for the comparison instead of the actual\n        operand.\n\n        The comparison is then effected by subtracting the second operand from\n        the first and then returning a value according to the result of the\n        subtraction: '-1' if the result is less than zero, '0' if the result is\n        zero or negative zero, or '1' if the result is greater than zero.\n\n        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('3'))\n        Decimal('-1')\n        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))\n        Decimal('0')\n        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))\n        Decimal('0')\n        >>> ExtendedContext.compare(Decimal('3'), Decimal('2.1'))\n        Decimal('1')\n        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))\n        Decimal('1')\n        >>> ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))\n        Decimal('-1')\n        >>> ExtendedContext.compare(1, 2)\n        Decimal('-1')\n        >>> ExtendedContext.compare(Decimal(1), 2)\n        Decimal('-1')\n        >>> ExtendedContext.compare(1, Decimal(2))\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "compare")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare_signal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares the values of the two operands numerically.\n\n        It's pretty much like compare(), but all NaNs signal, with signaling\n        NaNs taking precedence over quiet NaNs.\n\n        >>> c = ExtendedContext\n        >>> c.compare_signal(Decimal('2.1'), Decimal('3'))\n        Decimal('-1')\n        >>> c.compare_signal(Decimal('2.1'), Decimal('2.1'))\n        Decimal('0')\n        >>> c.flags[InvalidOperation] = 0\n        >>> print(c.flags[InvalidOperation])\n        0\n        >>> c.compare_signal(Decimal('NaN'), Decimal('2.1'))\n        Decimal('NaN')\n        >>> print(c.flags[InvalidOperation])\n        1\n        >>> c.flags[InvalidOperation] = 0\n        >>> print(c.flags[InvalidOperation])\n        0\n        >>> c.compare_signal(Decimal('sNaN'), Decimal('2.1'))\n        Decimal('NaN')\n        >>> print(c.flags[InvalidOperation])\n        1\n        >>> c.compare_signal(-1, 2)\n        Decimal('-1')\n        >>> c.compare_signal(Decimal(-1), 2)\n        Decimal('-1')\n        >>> c.compare_signal(-1, Decimal(2))\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "compare_signal")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare_total")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares two operands using their abstract representation.\n\n        This is not like the standard compare, which use their numerical\n        value. Note that a total ordering is defined for all possible abstract\n        representations.\n\n        >>> ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))\n        Decimal('-1')\n        >>> ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))\n        Decimal('-1')\n        >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))\n        Decimal('-1')\n        >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))\n        Decimal('0')\n        >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))\n        Decimal('1')\n        >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))\n        Decimal('-1')\n        >>> ExtendedContext.compare_total(1, 2)\n        Decimal('-1')\n        >>> ExtendedContext.compare_total(Decimal(1), 2)\n        Decimal('-1')\n        >>> ExtendedContext.compare_total(1, Decimal(2))\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "compare_total")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare_total_mag")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares two operands using their abstract representation ignoring sign.\n\n        Like compare_total, but with operand's sign ignored and assumed to be 0.\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "compare_total_mag")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy_abs")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy of the operand with the sign set to 0.\n\n        >>> ExtendedContext.copy_abs(Decimal('2.1'))\n        Decimal('2.1')\n        >>> ExtendedContext.copy_abs(Decimal('-100'))\n        Decimal('100')\n        >>> ExtendedContext.copy_abs(-1)\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "copy_abs")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy_decimal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy of the decimal object.\n\n        >>> ExtendedContext.copy_decimal(Decimal('2.1'))\n        Decimal('2.1')\n        >>> ExtendedContext.copy_decimal(Decimal('-1.00'))\n        Decimal('-1.00')\n        >>> ExtendedContext.copy_decimal(1)\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy_negate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a copy of the operand with the sign inverted.\n\n        >>> ExtendedContext.copy_negate(Decimal('101.5'))\n        Decimal('-101.5')\n        >>> ExtendedContext.copy_negate(Decimal('-101.5'))\n        Decimal('101.5')\n        >>> ExtendedContext.copy_negate(1)\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "copy_negate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy_sign")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copies the second operand's sign to the first one.\n\n        In detail, it returns a copy of the first operand with the sign\n        equal to the sign of the second operand.\n\n        >>> ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))\n        Decimal('1.50')\n        >>> ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))\n        Decimal('1.50')\n        >>> ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))\n        Decimal('-1.50')\n        >>> ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))\n        Decimal('-1.50')\n        >>> ExtendedContext.copy_sign(1, -2)\n        Decimal('-1')\n        >>> ExtendedContext.copy_sign(Decimal(1), -2)\n        Decimal('-1')\n        >>> ExtendedContext.copy_sign(1, Decimal(-2))\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "copy_sign")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "divide")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decimal division in a specified context.\n\n        >>> ExtendedContext.divide(Decimal('1'), Decimal('3'))\n        Decimal('0.333333333')\n        >>> ExtendedContext.divide(Decimal('2'), Decimal('3'))\n        Decimal('0.666666667')\n        >>> ExtendedContext.divide(Decimal('5'), Decimal('2'))\n        Decimal('2.5')\n        >>> ExtendedContext.divide(Decimal('1'), Decimal('10'))\n        Decimal('0.1')\n        >>> ExtendedContext.divide(Decimal('12'), Decimal('12'))\n        Decimal('1')\n        >>> ExtendedContext.divide(Decimal('8.00'), Decimal('2'))\n        Decimal('4.00')\n        >>> ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))\n        Decimal('1.20')\n        >>> ExtendedContext.divide(Decimal('1000'), Decimal('100'))\n        Decimal('10')\n        >>> ExtendedContext.divide(Decimal('1000'), Decimal('1'))\n        Decimal('1000')\n        >>> ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))\n        Decimal('1.20E+6')\n        >>> ExtendedContext.divide(5, 5)\n        Decimal('1')\n        >>> ExtendedContext.divide(Decimal(5), 5)\n        Decimal('1')\n        >>> ExtendedContext.divide(5, Decimal(5))\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__truediv__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "divide_int")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Divides two numbers and returns the integer part of the result.\n\n        >>> ExtendedContext.divide_int(Decimal('2'), Decimal('3'))\n        Decimal('0')\n        >>> ExtendedContext.divide_int(Decimal('10'), Decimal('3'))\n        Decimal('3')\n        >>> ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))\n        Decimal('3')\n        >>> ExtendedContext.divide_int(10, 3)\n        Decimal('3')\n        >>> ExtendedContext.divide_int(Decimal(10), 3)\n        Decimal('3')\n        >>> ExtendedContext.divide_int(10, Decimal(3))\n        Decimal('3')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__floordiv__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "divmod")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return (a // b, a % b).\n\n        >>> ExtendedContext.divmod(Decimal(8), Decimal(3))\n        (Decimal('2'), Decimal('2'))\n        >>> ExtendedContext.divmod(Decimal(8), Decimal(4))\n        (Decimal('2'), Decimal('0'))\n        >>> ExtendedContext.divmod(8, 4)\n        (Decimal('2'), Decimal('0'))\n        >>> ExtendedContext.divmod(Decimal(8), 4)\n        (Decimal('2'), Decimal('0'))\n        >>> ExtendedContext.divmod(8, Decimal(4))\n        (Decimal('2'), Decimal('0'))\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__divmod__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "exp")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns e ** a.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.exp(Decimal('-Infinity'))\n        Decimal('0')\n        >>> c.exp(Decimal('-1'))\n        Decimal('0.367879441')\n        >>> c.exp(Decimal('0'))\n        Decimal('1')\n        >>> c.exp(Decimal('1'))\n        Decimal('2.71828183')\n        >>> c.exp(Decimal('0.693147181'))\n        Decimal('2.00000000')\n        >>> c.exp(Decimal('+Infinity'))\n        Decimal('Infinity')\n        >>> c.exp(10)\n        Decimal('22026.4658')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "exp")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fma")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "c")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a multiplied by b, plus c.\n\n        The first two operands are multiplied together, using multiply,\n        the third operand is then added to the result of that\n        multiplication, using add, all with only one final rounding.\n\n        >>> ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))\n        Decimal('22')\n        >>> ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))\n        Decimal('-8')\n        >>> ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))\n        Decimal('1.38435736E+12')\n        >>> ExtendedContext.fma(1, 3, 4)\n        Decimal('7')\n        >>> ExtendedContext.fma(1, Decimal(3), 4)\n        Decimal('7')\n        >>> ExtendedContext.fma(1, 3, Decimal(4))\n        Decimal('7')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "fma")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "c")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_canonical")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is canonical; otherwise return False.\n\n        Currently, the encoding of a Decimal instance is always\n        canonical, so this method returns True for any Decimal.\n\n        >>> ExtendedContext.is_canonical(Decimal('2.50'))\n        True\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "is_canonical requires a Decimal as an argument.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_canonical")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_finite")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is finite; otherwise return False.\n\n        A Decimal instance is considered finite if it is neither\n        infinite nor a NaN.\n\n        >>> ExtendedContext.is_finite(Decimal('2.50'))\n        True\n        >>> ExtendedContext.is_finite(Decimal('-0.3'))\n        True\n        >>> ExtendedContext.is_finite(Decimal('0'))\n        True\n        >>> ExtendedContext.is_finite(Decimal('Inf'))\n        False\n        >>> ExtendedContext.is_finite(Decimal('NaN'))\n        False\n        >>> ExtendedContext.is_finite(1)\n        True\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_finite")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_infinite")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is infinite; otherwise return False.\n\n        >>> ExtendedContext.is_infinite(Decimal('2.50'))\n        False\n        >>> ExtendedContext.is_infinite(Decimal('-Inf'))\n        True\n        >>> ExtendedContext.is_infinite(Decimal('NaN'))\n        False\n        >>> ExtendedContext.is_infinite(1)\n        False\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_infinite")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_nan")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is a qNaN or sNaN;\n        otherwise return False.\n\n        >>> ExtendedContext.is_nan(Decimal('2.50'))\n        False\n        >>> ExtendedContext.is_nan(Decimal('NaN'))\n        True\n        >>> ExtendedContext.is_nan(Decimal('-sNaN'))\n        True\n        >>> ExtendedContext.is_nan(1)\n        False\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_normal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is a normal number;\n        otherwise return False.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.is_normal(Decimal('2.50'))\n        True\n        >>> c.is_normal(Decimal('0.1E-999'))\n        False\n        >>> c.is_normal(Decimal('0.00'))\n        False\n        >>> c.is_normal(Decimal('-Inf'))\n        False\n        >>> c.is_normal(Decimal('NaN'))\n        False\n        >>> c.is_normal(1)\n        True\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_normal")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_qnan")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is a quiet NaN; otherwise return False.\n\n        >>> ExtendedContext.is_qnan(Decimal('2.50'))\n        False\n        >>> ExtendedContext.is_qnan(Decimal('NaN'))\n        True\n        >>> ExtendedContext.is_qnan(Decimal('sNaN'))\n        False\n        >>> ExtendedContext.is_qnan(1)\n        False\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_qnan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_signed")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is negative; otherwise return False.\n\n        >>> ExtendedContext.is_signed(Decimal('2.50'))\n        False\n        >>> ExtendedContext.is_signed(Decimal('-12'))\n        True\n        >>> ExtendedContext.is_signed(Decimal('-0'))\n        True\n        >>> ExtendedContext.is_signed(8)\n        False\n        >>> ExtendedContext.is_signed(-8)\n        True\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_signed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_snan")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is a signaling NaN;\n        otherwise return False.\n\n        >>> ExtendedContext.is_snan(Decimal('2.50'))\n        False\n        >>> ExtendedContext.is_snan(Decimal('NaN'))\n        False\n        >>> ExtendedContext.is_snan(Decimal('sNaN'))\n        True\n        >>> ExtendedContext.is_snan(1)\n        False\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_snan")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_subnormal")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is subnormal; otherwise return False.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.is_subnormal(Decimal('2.50'))\n        False\n        >>> c.is_subnormal(Decimal('0.1E-999'))\n        True\n        >>> c.is_subnormal(Decimal('0.00'))\n        False\n        >>> c.is_subnormal(Decimal('-Inf'))\n        False\n        >>> c.is_subnormal(Decimal('NaN'))\n        False\n        >>> c.is_subnormal(1)\n        False\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_subnormal")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_zero")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the operand is a zero; otherwise return False.\n\n        >>> ExtendedContext.is_zero(Decimal('0'))\n        True\n        >>> ExtendedContext.is_zero(Decimal('2.50'))\n        False\n        >>> ExtendedContext.is_zero(Decimal('-0E+2'))\n        True\n        >>> ExtendedContext.is_zero(1)\n        False\n        >>> ExtendedContext.is_zero(0)\n        True\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "is_zero")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ln")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the natural (base e) logarithm of the operand.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.ln(Decimal('0'))\n        Decimal('-Infinity')\n        >>> c.ln(Decimal('1.000'))\n        Decimal('0')\n        >>> c.ln(Decimal('2.71828183'))\n        Decimal('1.00000000')\n        >>> c.ln(Decimal('10'))\n        Decimal('2.30258509')\n        >>> c.ln(Decimal('+Infinity'))\n        Decimal('Infinity')\n        >>> c.ln(1)\n        Decimal('0')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "ln")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log10")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the base 10 logarithm of the operand.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.log10(Decimal('0'))\n        Decimal('-Infinity')\n        >>> c.log10(Decimal('0.001'))\n        Decimal('-3')\n        >>> c.log10(Decimal('1.000'))\n        Decimal('0')\n        >>> c.log10(Decimal('2'))\n        Decimal('0.301029996')\n        >>> c.log10(Decimal('10'))\n        Decimal('1')\n        >>> c.log10(Decimal('70'))\n        Decimal('1.84509804')\n        >>> c.log10(Decimal('+Infinity'))\n        Decimal('Infinity')\n        >>> c.log10(0)\n        Decimal('-Infinity')\n        >>> c.log10(1)\n        Decimal('0')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "log10")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logb")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Returns the exponent of the magnitude of the operand's MSD.\n\n        The result is the integer which is the exponent of the magnitude\n        of the most significant digit of the operand (as though the\n        operand were truncated to a single digit while maintaining the\n        value of that digit and without limiting the resulting exponent).\n\n        >>> ExtendedContext.logb(Decimal('250'))\n        Decimal('2')\n        >>> ExtendedContext.logb(Decimal('2.50'))\n        Decimal('0')\n        >>> ExtendedContext.logb(Decimal('0.03'))\n        Decimal('-2')\n        >>> ExtendedContext.logb(Decimal('0'))\n        Decimal('-Infinity')\n        >>> ExtendedContext.logb(1)\n        Decimal('0')\n        >>> ExtendedContext.logb(10)\n        Decimal('1')\n        >>> ExtendedContext.logb(100)\n        Decimal('2')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "logb")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_and")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Applies the logical operation 'and' between each operand's digits.\n\n        The operands must be both logical numbers.\n\n        >>> ExtendedContext.logical_and(Decimal('0'), Decimal('0'))\n        Decimal('0')\n        >>> ExtendedContext.logical_and(Decimal('0'), Decimal('1'))\n        Decimal('0')\n        >>> ExtendedContext.logical_and(Decimal('1'), Decimal('0'))\n        Decimal('0')\n        >>> ExtendedContext.logical_and(Decimal('1'), Decimal('1'))\n        Decimal('1')\n        >>> ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))\n        Decimal('1000')\n        >>> ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))\n        Decimal('10')\n        >>> ExtendedContext.logical_and(110, 1101)\n        Decimal('100')\n        >>> ExtendedContext.logical_and(Decimal(110), 1101)\n        Decimal('100')\n        >>> ExtendedContext.logical_and(110, Decimal(1101))\n        Decimal('100')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "logical_and")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_invert")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Invert all the digits in the operand.\n\n        The operand must be a logical number.\n\n        >>> ExtendedContext.logical_invert(Decimal('0'))\n        Decimal('111111111')\n        >>> ExtendedContext.logical_invert(Decimal('1'))\n        Decimal('111111110')\n        >>> ExtendedContext.logical_invert(Decimal('111111111'))\n        Decimal('0')\n        >>> ExtendedContext.logical_invert(Decimal('101010101'))\n        Decimal('10101010')\n        >>> ExtendedContext.logical_invert(1101)\n        Decimal('111110010')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "logical_invert")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_or")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Applies the logical operation 'or' between each operand's digits.\n\n        The operands must be both logical numbers.\n\n        >>> ExtendedContext.logical_or(Decimal('0'), Decimal('0'))\n        Decimal('0')\n        >>> ExtendedContext.logical_or(Decimal('0'), Decimal('1'))\n        Decimal('1')\n        >>> ExtendedContext.logical_or(Decimal('1'), Decimal('0'))\n        Decimal('1')\n        >>> ExtendedContext.logical_or(Decimal('1'), Decimal('1'))\n        Decimal('1')\n        >>> ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))\n        Decimal('1110')\n        >>> ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))\n        Decimal('1110')\n        >>> ExtendedContext.logical_or(110, 1101)\n        Decimal('1111')\n        >>> ExtendedContext.logical_or(Decimal(110), 1101)\n        Decimal('1111')\n        >>> ExtendedContext.logical_or(110, Decimal(1101))\n        Decimal('1111')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "logical_or")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "logical_xor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Applies the logical operation 'xor' between each operand's digits.\n\n        The operands must be both logical numbers.\n\n        >>> ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))\n        Decimal('0')\n        >>> ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))\n        Decimal('1')\n        >>> ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))\n        Decimal('1')\n        >>> ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))\n        Decimal('0')\n        >>> ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))\n        Decimal('110')\n        >>> ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))\n        Decimal('1101')\n        >>> ExtendedContext.logical_xor(110, 1101)\n        Decimal('1011')\n        >>> ExtendedContext.logical_xor(Decimal(110), 1101)\n        Decimal('1011')\n        >>> ExtendedContext.logical_xor(110, Decimal(1101))\n        Decimal('1011')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "logical_xor")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "max")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "max compares two values numerically and returns the maximum.\n\n        If either operand is a NaN then the general rules apply.\n        Otherwise, the operands are compared as though by the compare\n        operation.  If they are numerically equal then the left-hand operand\n        is chosen as the result.  Otherwise the maximum (closer to positive\n        infinity) of the two operands is chosen as the result.\n\n        >>> ExtendedContext.max(Decimal('3'), Decimal('2'))\n        Decimal('3')\n        >>> ExtendedContext.max(Decimal('-10'), Decimal('3'))\n        Decimal('3')\n        >>> ExtendedContext.max(Decimal('1.0'), Decimal('1'))\n        Decimal('1')\n        >>> ExtendedContext.max(Decimal('7'), Decimal('NaN'))\n        Decimal('7')\n        >>> ExtendedContext.max(1, 2)\n        Decimal('2')\n        >>> ExtendedContext.max(Decimal(1), 2)\n        Decimal('2')\n        >>> ExtendedContext.max(1, Decimal(2))\n        Decimal('2')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "max")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "max_mag")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares the values numerically with their sign ignored.\n\n        >>> ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))\n        Decimal('7')\n        >>> ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))\n        Decimal('-10')\n        >>> ExtendedContext.max_mag(1, -2)\n        Decimal('-2')\n        >>> ExtendedContext.max_mag(Decimal(1), -2)\n        Decimal('-2')\n        >>> ExtendedContext.max_mag(1, Decimal(-2))\n        Decimal('-2')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "max_mag")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "min")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "min compares two values numerically and returns the minimum.\n\n        If either operand is a NaN then the general rules apply.\n        Otherwise, the operands are compared as though by the compare\n        operation.  If they are numerically equal then the left-hand operand\n        is chosen as the result.  Otherwise the minimum (closer to negative\n        infinity) of the two operands is chosen as the result.\n\n        >>> ExtendedContext.min(Decimal('3'), Decimal('2'))\n        Decimal('2')\n        >>> ExtendedContext.min(Decimal('-10'), Decimal('3'))\n        Decimal('-10')\n        >>> ExtendedContext.min(Decimal('1.0'), Decimal('1'))\n        Decimal('1.0')\n        >>> ExtendedContext.min(Decimal('7'), Decimal('NaN'))\n        Decimal('7')\n        >>> ExtendedContext.min(1, 2)\n        Decimal('1')\n        >>> ExtendedContext.min(Decimal(1), 2)\n        Decimal('1')\n        >>> ExtendedContext.min(1, Decimal(29))\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "min")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "min_mag")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compares the values numerically with their sign ignored.\n\n        >>> ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))\n        Decimal('-2')\n        >>> ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))\n        Decimal('-3')\n        >>> ExtendedContext.min_mag(1, -2)\n        Decimal('1')\n        >>> ExtendedContext.min_mag(Decimal(1), -2)\n        Decimal('1')\n        >>> ExtendedContext.min_mag(1, Decimal(-2))\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "min_mag")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "minus")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Minus corresponds to unary prefix minus in Python.\n\n        The operation is evaluated using the same rules as subtract; the\n        operation minus(a) is calculated as subtract('0', a) where the '0'\n        has the same exponent as the operand.\n\n        >>> ExtendedContext.minus(Decimal('1.3'))\n        Decimal('-1.3')\n        >>> ExtendedContext.minus(Decimal('-1.3'))\n        Decimal('1.3')\n        >>> ExtendedContext.minus(1)\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "__neg__")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "multiply")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "multiply multiplies two operands.\n\n        If either operand is a special value then the general rules apply.\n        Otherwise, the operands are multiplied together\n        ('long multiplication'), resulting in a number which may be as long as\n        the sum of the lengths of the two operands.\n\n        >>> ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))\n        Decimal('3.60')\n        >>> ExtendedContext.multiply(Decimal('7'), Decimal('3'))\n        Decimal('21')\n        >>> ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))\n        Decimal('0.72')\n        >>> ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))\n        Decimal('-0.0')\n        >>> ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))\n        Decimal('4.28135971E+11')\n        >>> ExtendedContext.multiply(7, 7)\n        Decimal('49')\n        >>> ExtendedContext.multiply(Decimal(7), 7)\n        Decimal('49')\n        >>> ExtendedContext.multiply(7, Decimal(7))\n        Decimal('49')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__mul__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "next_minus")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the largest representable number smaller than a.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> ExtendedContext.next_minus(Decimal('1'))\n        Decimal('0.999999999')\n        >>> c.next_minus(Decimal('1E-1007'))\n        Decimal('0E-1007')\n        >>> ExtendedContext.next_minus(Decimal('-1.00000003'))\n        Decimal('-1.00000004')\n        >>> c.next_minus(Decimal('Infinity'))\n        Decimal('9.99999999E+999')\n        >>> c.next_minus(1)\n        Decimal('0.999999999')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "next_minus")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "next_plus")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the smallest representable number larger than a.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> ExtendedContext.next_plus(Decimal('1'))\n        Decimal('1.00000001')\n        >>> c.next_plus(Decimal('-1E-1007'))\n        Decimal('-0E-1007')\n        >>> ExtendedContext.next_plus(Decimal('-1.00000003'))\n        Decimal('-1.00000002')\n        >>> c.next_plus(Decimal('-Infinity'))\n        Decimal('-9.99999999E+999')\n        >>> c.next_plus(1)\n        Decimal('1.00000001')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "next_plus")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "next_toward")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the number closest to a, in direction towards b.\n\n        The result is the closest representable number from the first\n        operand (but not the first operand) that is in the direction\n        towards the second operand, unless the operands have the same\n        value.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.next_toward(Decimal('1'), Decimal('2'))\n        Decimal('1.00000001')\n        >>> c.next_toward(Decimal('-1E-1007'), Decimal('1'))\n        Decimal('-0E-1007')\n        >>> c.next_toward(Decimal('-1.00000003'), Decimal('0'))\n        Decimal('-1.00000002')\n        >>> c.next_toward(Decimal('1'), Decimal('0'))\n        Decimal('0.999999999')\n        >>> c.next_toward(Decimal('1E-1007'), Decimal('-100'))\n        Decimal('0E-1007')\n        >>> c.next_toward(Decimal('-1.00000003'), Decimal('-10'))\n        Decimal('-1.00000004')\n        >>> c.next_toward(Decimal('0.00'), Decimal('-0.0000'))\n        Decimal('-0.00')\n        >>> c.next_toward(0, 1)\n        Decimal('1E-1007')\n        >>> c.next_toward(Decimal(0), 1)\n        Decimal('1E-1007')\n        >>> c.next_toward(0, Decimal(1))\n        Decimal('1E-1007')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "next_toward")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "normalize")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "normalize reduces an operand to its simplest form.\n\n        Essentially a plus operation with all trailing zeros removed from the\n        result.\n\n        >>> ExtendedContext.normalize(Decimal('2.1'))\n        Decimal('2.1')\n        >>> ExtendedContext.normalize(Decimal('-2.0'))\n        Decimal('-2')\n        >>> ExtendedContext.normalize(Decimal('1.200'))\n        Decimal('1.2')\n        >>> ExtendedContext.normalize(Decimal('-120'))\n        Decimal('-1.2E+2')\n        >>> ExtendedContext.normalize(Decimal('120.00'))\n        Decimal('1.2E+2')\n        >>> ExtendedContext.normalize(Decimal('0.00'))\n        Decimal('0')\n        >>> ExtendedContext.normalize(6)\n        Decimal('6')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "normalize")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "number_class")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns an indication of the class of the operand.\n\n        The class is one of the following strings:\n          -sNaN\n          -NaN\n          -Infinity\n          -Normal\n          -Subnormal\n          -Zero\n          +Zero\n          +Subnormal\n          +Normal\n          +Infinity\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.number_class(Decimal('Infinity'))\n        '+Infinity'\n        >>> c.number_class(Decimal('1E-10'))\n        '+Normal'\n        >>> c.number_class(Decimal('2.50'))\n        '+Normal'\n        >>> c.number_class(Decimal('0.1E-999'))\n        '+Subnormal'\n        >>> c.number_class(Decimal('0'))\n        '+Zero'\n        >>> c.number_class(Decimal('-0'))\n        '-Zero'\n        >>> c.number_class(Decimal('-0.1E-999'))\n        '-Subnormal'\n        >>> c.number_class(Decimal('-1E-10'))\n        '-Normal'\n        >>> c.number_class(Decimal('-2.50'))\n        '-Normal'\n        >>> c.number_class(Decimal('-Infinity'))\n        '-Infinity'\n        >>> c.number_class(Decimal('NaN'))\n        'NaN'\n        >>> c.number_class(Decimal('-NaN'))\n        'NaN'\n        >>> c.number_class(Decimal('sNaN'))\n        'sNaN'\n        >>> c.number_class(123)\n        '+Normal'\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "number_class")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "plus")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Plus corresponds to unary prefix plus in Python.\n\n        The operation is evaluated using the same rules as add; the\n        operation plus(a) is calculated as add('0', a) where the '0'\n        has the same exponent as the operand.\n\n        >>> ExtendedContext.plus(Decimal('1.3'))\n        Decimal('1.3')\n        >>> ExtendedContext.plus(Decimal('-1.3'))\n        Decimal('-1.3')\n        >>> ExtendedContext.plus(-1)\n        Decimal('-1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "__pos__")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "power")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "modulo")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raises a to the power of b, to modulo if given.\n\n        With two arguments, compute a**b.  If a is negative then b\n        must be integral.  The result will be inexact unless b is\n        integral and the result is finite and can be expressed exactly\n        in 'precision' digits.\n\n        With three arguments, compute (a**b) % modulo.  For the\n        three argument form, the following restrictions on the\n        arguments hold:\n\n         - all three arguments must be integral\n         - b must be nonnegative\n         - at least one of a or b must be nonzero\n         - modulo must be nonzero and have at most 'precision' digits\n\n        The result of pow(a, b, modulo) is identical to the result\n        that would be obtained by computing (a**b) % modulo with\n        unbounded precision, but is computed more efficiently.  It is\n        always exact.\n\n        >>> c = ExtendedContext.copy()\n        >>> c.Emin = -999\n        >>> c.Emax = 999\n        >>> c.power(Decimal('2'), Decimal('3'))\n        Decimal('8')\n        >>> c.power(Decimal('-2'), Decimal('3'))\n        Decimal('-8')\n        >>> c.power(Decimal('2'), Decimal('-3'))\n        Decimal('0.125')\n        >>> c.power(Decimal('1.7'), Decimal('8'))\n        Decimal('69.7575744')\n        >>> c.power(Decimal('10'), Decimal('0.301029996'))\n        Decimal('2.00000000')\n        >>> c.power(Decimal('Infinity'), Decimal('-1'))\n        Decimal('0')\n        >>> c.power(Decimal('Infinity'), Decimal('0'))\n        Decimal('1')\n        >>> c.power(Decimal('Infinity'), Decimal('1'))\n        Decimal('Infinity')\n        >>> c.power(Decimal('-Infinity'), Decimal('-1'))\n        Decimal('-0')\n        >>> c.power(Decimal('-Infinity'), Decimal('0'))\n        Decimal('1')\n        >>> c.power(Decimal('-Infinity'), Decimal('1'))\n        Decimal('-Infinity')\n        >>> c.power(Decimal('-Infinity'), Decimal('2'))\n        Decimal('Infinity')\n        >>> c.power(Decimal('0'), Decimal('0'))\n        Decimal('NaN')\n\n        >>> c.power(Decimal('3'), Decimal('7'), Decimal('16'))\n        Decimal('11')\n        >>> c.power(Decimal('-3'), Decimal('7'), Decimal('16'))\n        Decimal('-11')\n        >>> c.power(Decimal('-3'), Decimal('8'), Decimal('16'))\n        Decimal('1')\n        >>> c.power(Decimal('3'), Decimal('7'), Decimal('-16'))\n        Decimal('11')\n        >>> c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))\n        Decimal('11729830')\n        >>> c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))\n        Decimal('-0')\n        >>> c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))\n        Decimal('1')\n        >>> ExtendedContext.power(7, 7)\n        Decimal('823543')\n        >>> ExtendedContext.power(Decimal(7), 7)\n        Decimal('823543')\n        >>> ExtendedContext.power(7, Decimal(7), 2)\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__pow__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "modulo")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "quantize")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a value equal to 'a' (rounded), having the exponent of 'b'.\n\n        The coefficient of the result is derived from that of the left-hand\n        operand.  It may be rounded using the current rounding setting (if the\n        exponent is being increased), multiplied by a positive power of ten (if\n        the exponent is being decreased), or is unchanged (if the exponent is\n        already equal to that of the right-hand operand).\n\n        Unlike other operations, if the length of the coefficient after the\n        quantize operation would be greater than precision then an Invalid\n        operation condition is raised.  This guarantees that, unless there is\n        an error condition, the exponent of the result of a quantize is always\n        equal to that of the right-hand operand.\n\n        Also unlike other operations, quantize will never raise Underflow, even\n        if the result is subnormal and inexact.\n\n        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))\n        Decimal('2.170')\n        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))\n        Decimal('2.17')\n        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))\n        Decimal('2.2')\n        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))\n        Decimal('2')\n        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))\n        Decimal('0E+1')\n        >>> ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))\n        Decimal('-Infinity')\n        >>> ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))\n        Decimal('NaN')\n        >>> ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))\n        Decimal('-0')\n        >>> ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))\n        Decimal('-0E+5')\n        >>> ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))\n        Decimal('NaN')\n        >>> ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))\n        Decimal('NaN')\n        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))\n        Decimal('217.0')\n        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))\n        Decimal('217')\n        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))\n        Decimal('2.2E+2')\n        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))\n        Decimal('2E+2')\n        >>> ExtendedContext.quantize(1, 2)\n        Decimal('1')\n        >>> ExtendedContext.quantize(Decimal(1), 2)\n        Decimal('1')\n        >>> ExtendedContext.quantize(1, Decimal(2))\n        Decimal('1')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "quantize")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "radix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Just returns 10, as this is Decimal, :)\n\n        >>> ExtendedContext.radix()\n        Decimal('10')\n        ")
(NEWLINE)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(LIT 10)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remainder")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the remainder from integer division.\n\n        The result is the residue of the dividend after the operation of\n        calculating integer division as described for divide-integer, rounded\n        to precision digits if necessary.  The sign of the result, if\n        non-zero, is the same as that of the original dividend.\n\n        This operation will fail under the same conditions as integer division\n        (that is, if integer division on the same two operands would fail, the\n        remainder cannot be calculated).\n\n        >>> ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))\n        Decimal('2.1')\n        >>> ExtendedContext.remainder(Decimal('10'), Decimal('3'))\n        Decimal('1')\n        >>> ExtendedContext.remainder(Decimal('-10'), Decimal('3'))\n        Decimal('-1')\n        >>> ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))\n        Decimal('0.2')\n        >>> ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))\n        Decimal('0.1')\n        >>> ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))\n        Decimal('1.0')\n        >>> ExtendedContext.remainder(22, 6)\n        Decimal('4')\n        >>> ExtendedContext.remainder(Decimal(22), 6)\n        Decimal('4')\n        >>> ExtendedContext.remainder(22, Decimal(6))\n        Decimal('4')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__mod__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "remainder_near")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns to be \"a - b * n\", where n is the integer nearest the exact\n        value of \"x / b\" (if two integers are equally near then the even one\n        is chosen).  If the result is equal to 0 then its sign will be the\n        sign of a.\n\n        This operation will fail under the same conditions as integer division\n        (that is, if integer division on the same two operands would fail, the\n        remainder cannot be calculated).\n\n        >>> ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))\n        Decimal('-0.9')\n        >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))\n        Decimal('-2')\n        >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))\n        Decimal('1')\n        >>> ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))\n        Decimal('-1')\n        >>> ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))\n        Decimal('0.2')\n        >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))\n        Decimal('0.1')\n        >>> ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))\n        Decimal('-0.3')\n        >>> ExtendedContext.remainder_near(3, 11)\n        Decimal('3')\n        >>> ExtendedContext.remainder_near(Decimal(3), 11)\n        Decimal('3')\n        >>> ExtendedContext.remainder_near(3, Decimal(11))\n        Decimal('3')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "remainder_near")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "rotate")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a rotated copy of a, b times.\n\n        The coefficient of the result is a rotated copy of the digits in\n        the coefficient of the first operand.  The number of places of\n        rotation is taken from the absolute value of the second operand,\n        with the rotation being to the left if the second operand is\n        positive or to the right otherwise.\n\n        >>> ExtendedContext.rotate(Decimal('34'), Decimal('8'))\n        Decimal('400000003')\n        >>> ExtendedContext.rotate(Decimal('12'), Decimal('9'))\n        Decimal('12')\n        >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))\n        Decimal('891234567')\n        >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))\n        Decimal('123456789')\n        >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))\n        Decimal('345678912')\n        >>> ExtendedContext.rotate(1333333, 1)\n        Decimal('13333330')\n        >>> ExtendedContext.rotate(Decimal(1333333), 1)\n        Decimal('13333330')\n        >>> ExtendedContext.rotate(1333333, Decimal(1))\n        Decimal('13333330')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "rotate")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "same_quantum")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns True if the two operands have the same exponent.\n\n        The result is never affected by either the sign or the coefficient of\n        either operand.\n\n        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))\n        False\n        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))\n        True\n        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))\n        False\n        >>> ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))\n        True\n        >>> ExtendedContext.same_quantum(10000, -1)\n        True\n        >>> ExtendedContext.same_quantum(Decimal(10000), -1)\n        True\n        >>> ExtendedContext.same_quantum(10000, Decimal(-1))\n        True\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "same_quantum")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "scaleb")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the first operand after adding the second value its exp.\n\n        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))\n        Decimal('0.0750')\n        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))\n        Decimal('7.50')\n        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))\n        Decimal('7.50E+3')\n        >>> ExtendedContext.scaleb(1, 4)\n        Decimal('1E+4')\n        >>> ExtendedContext.scaleb(Decimal(1), 4)\n        Decimal('1E+4')\n        >>> ExtendedContext.scaleb(1, Decimal(4))\n        Decimal('1E+4')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "scaleb")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shift")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a shifted copy of a, b times.\n\n        The coefficient of the result is a shifted copy of the digits\n        in the coefficient of the first operand.  The number of places\n        to shift is taken from the absolute value of the second operand,\n        with the shift being to the left if the second operand is\n        positive or to the right otherwise.  Digits shifted into the\n        coefficient are zeros.\n\n        >>> ExtendedContext.shift(Decimal('34'), Decimal('8'))\n        Decimal('400000000')\n        >>> ExtendedContext.shift(Decimal('12'), Decimal('9'))\n        Decimal('0')\n        >>> ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))\n        Decimal('1234567')\n        >>> ExtendedContext.shift(Decimal('123456789'), Decimal('0'))\n        Decimal('123456789')\n        >>> ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))\n        Decimal('345678900')\n        >>> ExtendedContext.shift(88888888, 2)\n        Decimal('888888800')\n        >>> ExtendedContext.shift(Decimal(88888888), 2)\n        Decimal('888888800')\n        >>> ExtendedContext.shift(88888888, Decimal(2))\n        Decimal('888888800')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "shift")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "sqrt")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Square root of a non-negative number to context precision.\n\n        If the result must be inexact, it is rounded using the round-half-even\n        algorithm.\n\n        >>> ExtendedContext.sqrt(Decimal('0'))\n        Decimal('0')\n        >>> ExtendedContext.sqrt(Decimal('-0'))\n        Decimal('-0')\n        >>> ExtendedContext.sqrt(Decimal('0.39'))\n        Decimal('0.624499800')\n        >>> ExtendedContext.sqrt(Decimal('100'))\n        Decimal('10')\n        >>> ExtendedContext.sqrt(Decimal('1'))\n        Decimal('1')\n        >>> ExtendedContext.sqrt(Decimal('1.0'))\n        Decimal('1.0')\n        >>> ExtendedContext.sqrt(Decimal('1.00'))\n        Decimal('1.0')\n        >>> ExtendedContext.sqrt(Decimal('7'))\n        Decimal('2.64575131')\n        >>> ExtendedContext.sqrt(Decimal('10'))\n        Decimal('3.16227766')\n        >>> ExtendedContext.sqrt(2)\n        Decimal('1.41421356')\n        >>> ExtendedContext.prec\n        9\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "sqrt")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "subtract")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the difference between the two operands.\n\n        >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))\n        Decimal('0.23')\n        >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))\n        Decimal('0.00')\n        >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))\n        Decimal('-0.77')\n        >>> ExtendedContext.subtract(8, 5)\n        Decimal('3')\n        >>> ExtendedContext.subtract(Decimal(8), 5)\n        Decimal('3')\n        >>> ExtendedContext.subtract(8, Decimal(5))\n        Decimal('3')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT "=")
(ID "a")
(PUNCT ".")
(ID "__sub__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "r")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "to_eng_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Converts a number to a string, using scientific notation.\n\n        The operation is not affected by the context.\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "to_eng_string")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_sci_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Converts a number to a string, using scientific notation.\n\n        The operation is not affected by the context.\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "__str__")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_integral_exact")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds to an integer.\n\n        When the operand has a negative exponent, the result is the same\n        as using the quantize() operation using the given operand as the\n        left-hand-operand, 1E+0 as the right-hand-operand, and the precision\n        of the operand as the precision setting; Inexact and Rounded flags\n        are allowed in this operation.  The rounding mode is taken from the\n        context.\n\n        >>> ExtendedContext.to_integral_exact(Decimal('2.1'))\n        Decimal('2')\n        >>> ExtendedContext.to_integral_exact(Decimal('100'))\n        Decimal('100')\n        >>> ExtendedContext.to_integral_exact(Decimal('100.0'))\n        Decimal('100')\n        >>> ExtendedContext.to_integral_exact(Decimal('101.5'))\n        Decimal('102')\n        >>> ExtendedContext.to_integral_exact(Decimal('-101.5'))\n        Decimal('-102')\n        >>> ExtendedContext.to_integral_exact(Decimal('10E+5'))\n        Decimal('1.0E+6')\n        >>> ExtendedContext.to_integral_exact(Decimal('7.89E+77'))\n        Decimal('7.89E+77')\n        >>> ExtendedContext.to_integral_exact(Decimal('-Inf'))\n        Decimal('-Infinity')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "to_integral_exact")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "to_integral_value")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Rounds to an integer.\n\n        When the operand has a negative exponent, the result is the same\n        as using the quantize() operation using the given operand as the\n        left-hand-operand, 1E+0 as the right-hand-operand, and the precision\n        of the operand as the precision setting, except that no flags will\n        be set.  The rounding mode is taken from the context.\n\n        >>> ExtendedContext.to_integral_value(Decimal('2.1'))\n        Decimal('2')\n        >>> ExtendedContext.to_integral_value(Decimal('100'))\n        Decimal('100')\n        >>> ExtendedContext.to_integral_value(Decimal('100.0'))\n        Decimal('100')\n        >>> ExtendedContext.to_integral_value(Decimal('101.5'))\n        Decimal('102')\n        >>> ExtendedContext.to_integral_value(Decimal('-101.5'))\n        Decimal('-102')\n        >>> ExtendedContext.to_integral_value(Decimal('10E+5'))\n        Decimal('1.0E+6')\n        >>> ExtendedContext.to_integral_value(Decimal('7.89E+77'))\n        Decimal('7.89E+77')\n        >>> ExtendedContext.to_integral_value(Decimal('-Inf'))\n        Decimal('-Infinity')\n        ")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "_convert_other")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "to_integral_value")
(PUNCT "(")
(ID "context")
(PUNCT "=")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "to_integral")
(PUNCT "=")
(ID "to_integral_value")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_WorkRep")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "sign")
(PUNCT ",")
(LIT "int")
(PUNCT ",")
(LIT "exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "int")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exp")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_sign")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "int")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exp")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_exp")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sign")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "int")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exp")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "(%r, %r, %r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "sign")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__str__")
(PUNCT "=")
(ID "__repr__")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_normalize")
(PUNCT "(")
(ID "op1")
(PUNCT ",")
(ID "op2")
(PUNCT ",")
(ID "prec")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Normalizes op1, op2 to have the same exp and length of coefficient.\n\n    Done during addition.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "op1")
(PUNCT ".")
(ID "exp")
(PUNCT "<")
(ID "op2")
(PUNCT ".")
(ID "exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tmp")
(PUNCT "=")
(ID "op2")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "op1")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tmp")
(PUNCT "=")
(ID "op1")
(NEWLINE)
(ID "other")
(PUNCT "=")
(ID "op2")
(NEWLINE)
(DEDENT)
(ID "tmp_len")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "tmp")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "other_len")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "int")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "exp")
(PUNCT "=")
(ID "tmp")
(PUNCT ".")
(ID "exp")
(PUNCT "+")
(ID "min")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "tmp_len")
(PUNCT "-")
(ID "prec")
(PUNCT "-")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "other_len")
(PUNCT "+")
(ID "other")
(PUNCT ".")
(ID "exp")
(PUNCT "-")
(LIT 1)
(PUNCT "<")
(ID "exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "other")
(PUNCT ".")
(ID "int")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "other")
(PUNCT ".")
(ID "exp")
(PUNCT "=")
(ID "exp")
(NEWLINE)
(DEDENT)
(ID "tmp")
(PUNCT ".")
(ID "int")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "tmp")
(PUNCT ".")
(ID "exp")
(PUNCT "-")
(ID "other")
(PUNCT ".")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(ID "tmp")
(PUNCT ".")
(ID "exp")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "exp")
(NEWLINE)
(KEYWORD return)
(ID "op1")
(PUNCT ",")
(ID "op2")
(NEWLINE)
(DEDENT)
(ID "_nbits")
(PUNCT "=")
(ID "int")
(PUNCT ".")
(ID "bit_length")
(NEWLINE)
(KEYWORD def)
(ID "_decimal_lshift_exact")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "e")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Given integers n and e, return n * 10**e if it's an integer, else None.\n\n    The computation is designed to avoid computing large powers of 10\n    unnecessarily.\n\n    >>> _decimal_lshift_exact(3, 4)\n    30000\n    >>> _decimal_lshift_exact(300, -999999999)  # returns None\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "e")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "n")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "e")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "str_n")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "val_n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str_n")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "str_n")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD None)
(KEYWORD if)
(ID "val_n")
(PUNCT "<")
(PUNCT "-")
(ID "e")
(KEYWORD else)
(ID "n")
(PUNCT "//")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "e")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_sqrt_nearest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Closest integer to the square root of the positive integer n.  a is\n    an initial approximation to the square root.  Any positive integer\n    will do for a, but the closer a is to the square root of n the\n    faster convergence will be.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<=")
(LIT 0)
(KEYWORD or)
(ID "a")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Both arguments to _sqrt_nearest should be positive.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "b")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(ID "a")
(PUNCT "!=")
(ID "b")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT ",")
(ID "a")
(PUNCT "=")
(ID "a")
(PUNCT ",")
(ID "a")
(PUNCT "-")
(PUNCT "-")
(ID "n")
(PUNCT "//")
(ID "a")
(PUNCT ">>")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "a")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_rshift_nearest")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "shift")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given an integer x and a nonnegative integer shift, return closest\n    integer to x / 2**shift; use round-to-even in case of a tie.\n\n    ")
(NEWLINE)
(ID "b")
(PUNCT ",")
(ID "q")
(PUNCT "=")
(LIT 1)
(PUNCT "<<")
(ID "shift")
(PUNCT ",")
(ID "x")
(PUNCT ">>")
(ID "shift")
(NEWLINE)
(KEYWORD return)
(ID "q")
(PUNCT "+")
(PUNCT "(")
(LIT 2)
(PUNCT "*")
(PUNCT "(")
(ID "x")
(PUNCT "&")
(PUNCT "(")
(ID "b")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "q")
(PUNCT "&")
(LIT 1)
(PUNCT ")")
(PUNCT ">")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_div_nearest")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Closest integer to a/b, a and b positive integers; rounds to even\n    in the case of a tie.\n\n    ")
(NEWLINE)
(ID "q")
(PUNCT ",")
(ID "r")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "q")
(PUNCT "+")
(PUNCT "(")
(LIT 2)
(PUNCT "*")
(ID "r")
(PUNCT "+")
(PUNCT "(")
(ID "q")
(PUNCT "&")
(LIT 1)
(PUNCT ")")
(PUNCT ">")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ilog")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "M")
(PUNCT ",")
(ID "L")
(PUNCT "=")
(LIT 8)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Integer approximation to M*log(x/M), with absolute error boundable\n    in terms only of x/M.\n\n    Given positive integers x and M, return an integer approximation to\n    M * log(x/M).  For L = 8 and 0.1 <= x/M <= 10 the difference\n    between the approximation and the exact result is at most 22.  For\n    L = 8 and 1.0 <= x/M <= 10.0 the difference is at most 15.  In\n    both cases these are upper bounds on the error; it will usually be\n    much smaller.")
(NEWLINE)
(ID "y")
(PUNCT "=")
(ID "x")
(PUNCT "-")
(ID "M")
(NEWLINE)
(ID "R")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(PUNCT "(")
(ID "R")
(PUNCT "<=")
(ID "L")
(KEYWORD and)
(ID "abs")
(PUNCT "(")
(ID "y")
(PUNCT ")")
(PUNCT "<<")
(ID "L")
(PUNCT "-")
(ID "R")
(PUNCT ">=")
(ID "M")
(KEYWORD or)
(ID "R")
(PUNCT ">")
(ID "L")
(KEYWORD and)
(ID "abs")
(PUNCT "(")
(ID "y")
(PUNCT ")")
(PUNCT ">>")
(ID "R")
(PUNCT "-")
(ID "L")
(PUNCT ">=")
(ID "M")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "y")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(PUNCT "(")
(ID "M")
(PUNCT "*")
(ID "y")
(PUNCT ")")
(PUNCT "<<")
(LIT 1)
(PUNCT ",")
(ID "M")
(PUNCT "+")
(ID "_sqrt_nearest")
(PUNCT "(")
(ID "M")
(PUNCT "*")
(PUNCT "(")
(ID "M")
(PUNCT "+")
(ID "_rshift_nearest")
(PUNCT "(")
(ID "y")
(PUNCT ",")
(ID "R")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "M")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "R")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "T")
(PUNCT "=")
(PUNCT "-")
(ID "int")
(PUNCT "(")
(PUNCT "-")
(LIT 10)
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "M")
(PUNCT ")")
(PUNCT ")")
(PUNCT "//")
(PUNCT "(")
(LIT 3)
(PUNCT "*")
(ID "L")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "yshift")
(PUNCT "=")
(ID "_rshift_nearest")
(PUNCT "(")
(ID "y")
(PUNCT ",")
(ID "R")
(PUNCT ")")
(NEWLINE)
(ID "w")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "M")
(PUNCT ",")
(ID "T")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "k")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "T")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "w")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "M")
(PUNCT ",")
(ID "k")
(PUNCT ")")
(PUNCT "-")
(ID "_div_nearest")
(PUNCT "(")
(ID "yshift")
(PUNCT "*")
(ID "w")
(PUNCT ",")
(ID "M")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_div_nearest")
(PUNCT "(")
(ID "w")
(PUNCT "*")
(ID "y")
(PUNCT ",")
(ID "M")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_dlog10")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given integers c, e and p with c > 0, p >= 0, compute an integer\n    approximation to 10**p * log10(c*10**e), with an absolute error of\n    at most 1.  Assumes that c*10**e is not exactly 1.")
(NEWLINE)
(ID "p")
(PUNCT "+=")
(LIT 2)
(NEWLINE)
(ID "l")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "e")
(PUNCT "+")
(ID "l")
(PUNCT "-")
(PUNCT "(")
(ID "e")
(PUNCT "+")
(ID "l")
(PUNCT ">=")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "p")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "M")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(ID "p")
(NEWLINE)
(ID "k")
(PUNCT "=")
(ID "e")
(PUNCT "+")
(ID "p")
(PUNCT "-")
(ID "f")
(NEWLINE)
(KEYWORD if)
(ID "k")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(ID "k")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "k")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "log_d")
(PUNCT "=")
(ID "_ilog")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "M")
(PUNCT ")")
(NEWLINE)
(ID "log_10")
(PUNCT "=")
(ID "_log10_digits")
(PUNCT "(")
(ID "p")
(PUNCT ")")
(NEWLINE)
(ID "log_d")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "log_d")
(PUNCT "*")
(ID "M")
(PUNCT ",")
(ID "log_10")
(PUNCT ")")
(NEWLINE)
(ID "log_tenpower")
(PUNCT "=")
(ID "f")
(PUNCT "*")
(ID "M")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log_d")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "log_tenpower")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "p")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_div_nearest")
(PUNCT "(")
(ID "log_tenpower")
(PUNCT "+")
(ID "log_d")
(PUNCT ",")
(LIT 100)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_dlog")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given integers c, e and p with c > 0, compute an integer\n    approximation to 10**p * log(c*10**e), with an absolute error of\n    at most 1.  Assumes that c*10**e is not exactly 1.")
(NEWLINE)
(ID "p")
(PUNCT "+=")
(LIT 2)
(NEWLINE)
(ID "l")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "e")
(PUNCT "+")
(ID "l")
(PUNCT "-")
(PUNCT "(")
(ID "e")
(PUNCT "+")
(ID "l")
(PUNCT ">=")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "p")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "e")
(PUNCT "+")
(ID "p")
(PUNCT "-")
(ID "f")
(NEWLINE)
(KEYWORD if)
(ID "k")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(ID "k")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "k")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "log_d")
(PUNCT "=")
(ID "_ilog")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(ID "p")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log_d")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extra")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "p")
(PUNCT "+")
(ID "extra")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f_log_ten")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "f")
(PUNCT "*")
(ID "_log10_digits")
(PUNCT "(")
(ID "p")
(PUNCT "+")
(ID "extra")
(PUNCT ")")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(ID "extra")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f_log_ten")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f_log_ten")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_div_nearest")
(PUNCT "(")
(ID "f_log_ten")
(PUNCT "+")
(ID "log_d")
(PUNCT ",")
(LIT 100)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_Log10Memoize")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Class to compute, store, and allow retrieval of, digits of the\n    constant log(10) = 2.302585....  This constant is needed by\n    Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "digits")
(PUNCT "=")
(LIT "23025850929940456840179914546843642076011014886")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getdigits")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given an integer p >= 0, return floor(10**p)*log(10).\n\n        For example, self.getdigits(3) returns 2302.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "p")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "p should be nonnegative")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "p")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "digits")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extra")
(PUNCT "=")
(LIT 3)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "M")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "p")
(PUNCT "+")
(ID "extra")
(PUNCT "+")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "digits")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "_div_nearest")
(PUNCT "(")
(ID "_ilog")
(PUNCT "(")
(LIT 10)
(PUNCT "*")
(ID "M")
(PUNCT ",")
(ID "M")
(PUNCT ")")
(PUNCT ",")
(LIT 100)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "digits")
(PUNCT "[")
(PUNCT "-")
(ID "extra")
(PUNCT ":")
(PUNCT "]")
(PUNCT "!=")
(LIT "0")
(PUNCT "*")
(ID "extra")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "extra")
(PUNCT "+=")
(LIT 3)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "digits")
(PUNCT "=")
(ID "digits")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT "0")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "digits")
(PUNCT "[")
(PUNCT ":")
(ID "p")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_log10_digits")
(PUNCT "=")
(ID "_Log10Memoize")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "getdigits")
(NEWLINE)
(KEYWORD def)
(ID "_iexp")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "M")
(PUNCT ",")
(ID "L")
(PUNCT "=")
(LIT 8)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given integers x and M, M > 0, such that x/M is small in absolute\n    value, compute an integer approximation to M*exp(x/M).  For 0 <=\n    x/M <= 2.4, the absolute error in the result is bounded by 60 (and\n    is usually much smaller).")
(NEWLINE)
(ID "R")
(PUNCT "=")
(ID "_nbits")
(PUNCT "(")
(PUNCT "(")
(ID "x")
(PUNCT "<<")
(ID "L")
(PUNCT ")")
(PUNCT "//")
(ID "M")
(PUNCT ")")
(NEWLINE)
(ID "T")
(PUNCT "=")
(PUNCT "-")
(ID "int")
(PUNCT "(")
(PUNCT "-")
(LIT 10)
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "M")
(PUNCT ")")
(PUNCT ")")
(PUNCT "//")
(PUNCT "(")
(LIT 3)
(PUNCT "*")
(ID "L")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "y")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "T")
(PUNCT ")")
(NEWLINE)
(ID "Mshift")
(PUNCT "=")
(ID "M")
(PUNCT "<<")
(ID "R")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "T")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "y")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "x")
(PUNCT "*")
(PUNCT "(")
(ID "Mshift")
(PUNCT "+")
(ID "y")
(PUNCT ")")
(PUNCT ",")
(ID "Mshift")
(PUNCT "*")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "k")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "R")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Mshift")
(PUNCT "=")
(ID "M")
(PUNCT "<<")
(PUNCT "(")
(ID "k")
(PUNCT "+")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "y")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "y")
(PUNCT "*")
(PUNCT "(")
(ID "y")
(PUNCT "+")
(ID "Mshift")
(PUNCT ")")
(PUNCT ",")
(ID "Mshift")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "M")
(PUNCT "+")
(ID "y")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_dexp")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute an approximation to exp(c*10**e), with p decimal places of\n    precision.\n\n    Returns integers d, f such that:\n\n      10**(p-1) <= d <= 10**p, and\n      (d-1)*10**f < exp(c*10**e) < (d+1)*10**f\n\n    In other words, d*10**f is an approximation to exp(c*10**e) with p\n    digits of precision, and with an error in d of at most 1.  This is\n    almost, but not quite, the same as the error being < 1ulp: when d\n    = 10**(p-1) the error could be up to 10 ulp.")
(NEWLINE)
(ID "p")
(PUNCT "+=")
(LIT 2)
(NEWLINE)
(ID "extra")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "e")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "q")
(PUNCT "=")
(ID "p")
(PUNCT "+")
(ID "extra")
(NEWLINE)
(ID "shift")
(PUNCT "=")
(ID "e")
(PUNCT "+")
(ID "q")
(NEWLINE)
(KEYWORD if)
(ID "shift")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cshift")
(PUNCT "=")
(ID "c")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "shift")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cshift")
(PUNCT "=")
(ID "c")
(PUNCT "//")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "shift")
(NEWLINE)
(DEDENT)
(ID "quot")
(PUNCT ",")
(ID "rem")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "cshift")
(PUNCT ",")
(ID "_log10_digits")
(PUNCT "(")
(ID "q")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "rem")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "rem")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(ID "extra")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_div_nearest")
(PUNCT "(")
(ID "_iexp")
(PUNCT "(")
(ID "rem")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(ID "p")
(PUNCT ")")
(PUNCT ",")
(LIT 1000)
(PUNCT ")")
(PUNCT ",")
(ID "quot")
(PUNCT "-")
(ID "p")
(PUNCT "+")
(LIT 3)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_dpower")
(PUNCT "(")
(ID "xc")
(PUNCT ",")
(ID "xe")
(PUNCT ",")
(ID "yc")
(PUNCT ",")
(ID "ye")
(PUNCT ",")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and\n    y = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:\n\n      10**(p-1) <= c <= 10**p, and\n      (c-1)*10**e < x**y < (c+1)*10**e\n\n    in other words, c*10**e is an approximation to x**y with p digits\n    of precision, and with an error in c of at most 1.  (This is\n    almost, but not quite, the same as the error being < 1ulp: when c\n    == 10**(p-1) we can only guarantee error < 10ulp.)\n\n    We assume that: x is positive and not equal to 1, and y is nonzero.\n    ")
(NEWLINE)
(ID "b")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "yc")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(ID "ye")
(NEWLINE)
(ID "lxc")
(PUNCT "=")
(ID "_dlog")
(PUNCT "(")
(ID "xc")
(PUNCT ",")
(ID "xe")
(PUNCT ",")
(ID "p")
(PUNCT "+")
(ID "b")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "shift")
(PUNCT "=")
(ID "ye")
(PUNCT "-")
(ID "b")
(NEWLINE)
(KEYWORD if)
(ID "shift")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pc")
(PUNCT "=")
(ID "lxc")
(PUNCT "*")
(ID "yc")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "shift")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pc")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "lxc")
(PUNCT "*")
(ID "yc")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "shift")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pc")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "xc")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(ID "xe")
(PUNCT ">=")
(LIT 1)
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(ID "yc")
(PUNCT ">")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "exp")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(PUNCT "(")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(LIT 1)
(PUNCT "-")
(ID "p")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "exp")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(ID "p")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(PUNCT "-")
(ID "p")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "coeff")
(PUNCT ",")
(ID "exp")
(PUNCT "=")
(ID "_dexp")
(PUNCT "(")
(ID "pc")
(PUNCT ",")
(PUNCT "-")
(PUNCT "(")
(ID "p")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "p")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "coeff")
(PUNCT "=")
(ID "_div_nearest")
(PUNCT "(")
(ID "coeff")
(PUNCT ",")
(LIT 10)
(PUNCT ")")
(NEWLINE)
(ID "exp")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "coeff")
(PUNCT ",")
(ID "exp")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_log10_lb")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "correction")
(PUNCT "=")
(PUNCT "{")
(LIT "1")
(PUNCT ":")
(LIT 100)
(PUNCT ",")
(LIT "2")
(PUNCT ":")
(LIT 70)
(PUNCT ",")
(LIT "3")
(PUNCT ":")
(LIT 53)
(PUNCT ",")
(LIT "4")
(PUNCT ":")
(LIT 40)
(PUNCT ",")
(LIT "5")
(PUNCT ":")
(LIT 31)
(PUNCT ",")
(LIT "6")
(PUNCT ":")
(LIT 23)
(PUNCT ",")
(LIT "7")
(PUNCT ":")
(LIT 16)
(PUNCT ",")
(LIT "8")
(PUNCT ":")
(LIT 10)
(PUNCT ",")
(LIT "9")
(PUNCT ":")
(LIT 5)
(PUNCT "}")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute a lower bound for 100*log10(c) for a positive integer c.")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "The argument to _log10_lb should be nonnegative.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "str_c")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 100)
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "str_c")
(PUNCT ")")
(PUNCT "-")
(ID "correction")
(PUNCT "[")
(ID "str_c")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_convert_other")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "raiseit")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "allow_float")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert other to Decimal.\n\n    Verifies that it's ok to use in an implicit construction.\n    If allow_float is true, allow conversion from float;  this\n    is used in the comparison methods (__eq__ and friends).\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "allow_float")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Decimal")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "raiseit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Unable to convert %s to Decimal")
(PUNCT "%")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_convert_for_comparison")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "equality_op")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given a Decimal instance self and a Python object other, return\n    a pair (s, o) of Decimal instances such that \"s op o\" is\n    equivalent to \"self op other\" for any of the 6 comparison\n    operators \"op\".\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ",")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "_numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_is_special")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "=")
(ID "_dec_from_triple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sign")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_int")
(PUNCT ")")
(PUNCT "*")
(ID "other")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ",")
(ID "Decimal")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "equality_op")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "_numbers")
(PUNCT ".")
(ID "Complex")
(PUNCT ")")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "imag")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "other")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "real")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "=")
(ID "getcontext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "equality_op")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "flags")
(PUNCT "[")
(ID "FloatOperation")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT ".")
(ID "_raise_error")
(PUNCT "(")
(ID "FloatOperation")
(PUNCT ",")
(LIT "strict semantics for mixing floats and Decimals are enabled")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ",")
(ID "Decimal")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(PUNCT ",")
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(ID "DefaultContext")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(ID "prec")
(PUNCT "=")
(LIT 28)
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(ID "ROUND_HALF_EVEN")
(PUNCT ",")
(ID "traps")
(PUNCT "=")
(PUNCT "[")
(ID "DivisionByZero")
(PUNCT ",")
(ID "Overflow")
(PUNCT ",")
(ID "InvalidOperation")
(PUNCT "]")
(PUNCT ",")
(ID "flags")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "Emax")
(PUNCT "=")
(LIT 999999)
(PUNCT ",")
(ID "Emin")
(PUNCT "=")
(PUNCT "-")
(LIT 999999)
(PUNCT ",")
(ID "capitals")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "clamp")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "BasicContext")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(ID "prec")
(PUNCT "=")
(LIT 9)
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(ID "ROUND_HALF_UP")
(PUNCT ",")
(ID "traps")
(PUNCT "=")
(PUNCT "[")
(ID "DivisionByZero")
(PUNCT ",")
(ID "Overflow")
(PUNCT ",")
(ID "InvalidOperation")
(PUNCT ",")
(ID "Clamped")
(PUNCT ",")
(ID "Underflow")
(PUNCT "]")
(PUNCT ",")
(ID "flags")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(ID "ExtendedContext")
(PUNCT "=")
(ID "Context")
(PUNCT "(")
(ID "prec")
(PUNCT "=")
(LIT 9)
(PUNCT ",")
(ID "rounding")
(PUNCT "=")
(ID "ROUND_HALF_EVEN")
(PUNCT ",")
(ID "traps")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "flags")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(ID "_parser")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "        # A numeric string consists of:\n#    \\s*\n    (?P<sign>[-+])?              # an optional sign, followed by either...\n    (\n        (?=\\d|\\.\\d)              # ...a number (with at least one digit)\n        (?P<int>\\d*)             # having a (possibly empty) integer part\n        (\\.(?P<frac>\\d*))?       # followed by an optional fractional part\n        (E(?P<exp>[-+]?\\d+))?    # followed by an optional exponent, or...\n    |\n        Inf(inity)?              # ...an infinity, or...\n    |\n        (?P<signal>s)?           # ...an (optionally signaling)\n        NaN                      # NaN\n        (?P<diag>\\d*)            # with (possibly empty) diagnostic info.\n    )\n#    \\s*\n    \\Z\n")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "IGNORECASE")
(PUNCT ")")
(PUNCT ".")
(ID "match")
(NEWLINE)
(ID "_all_zeros")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "0*$")
(PUNCT ")")
(PUNCT ".")
(ID "match")
(NEWLINE)
(ID "_exact_half")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "50*$")
(PUNCT ")")
(PUNCT ".")
(ID "match")
(NEWLINE)
(ID "_parse_format_specifier_regex")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\\A\n(?:\n   (?P<fill>.)?\n   (?P<align>[<>=^])\n)?\n(?P<sign>[-+ ])?\n(?P<alt>\\#)?\n(?P<zeropad>0)?\n(?P<minimumwidth>(?!0)\\d+)?\n(?P<thousands_sep>,)?\n(?:\\.(?P<precision>0|(?!0)\\d+))?\n(?P<type>[eEfFgGn%])?\n\\Z\n")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "DOTALL")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "re")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "locale")
(KEYWORD as)
(ID "_locale")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_parse_format_specifier")
(PUNCT "(")
(ID "format_spec")
(PUNCT ",")
(ID "_localeconv")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse and validate a format specifier.\n\n    Turns a standard numeric format specifier into a dict, with the\n    following entries:\n\n      fill: fill character to pad field to minimum width\n      align: alignment type, either '<', '>', '=' or '^'\n      sign: either '+', '-' or ' '\n      minimumwidth: nonnegative integer giving minimum width\n      zeropad: boolean, indicating whether to pad with zeros\n      thousands_sep: string to use as thousands separator, or ''\n      grouping: grouping for thousands separators, in format\n        used by localeconv\n      decimal_point: string to use for decimal point\n      precision: nonnegative integer giving precision, or None\n      type: one of the characters 'eEfFgG%', or None\n\n    ")
(NEWLINE)
(ID "m")
(PUNCT "=")
(ID "_parse_format_specifier_regex")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "format_spec")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid format specifier: ")
(PUNCT "+")
(ID "format_spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "format_dict")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "groupdict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "fill")
(PUNCT "=")
(ID "format_dict")
(PUNCT "[")
(LIT "fill")
(PUNCT "]")
(NEWLINE)
(ID "align")
(PUNCT "=")
(ID "format_dict")
(PUNCT "[")
(LIT "align")
(PUNCT "]")
(NEWLINE)
(ID "format_dict")
(PUNCT "[")
(LIT "zeropad")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "format_dict")
(PUNCT "[")
(LIT "zeropad")
(PUNCT "]")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "zeropad")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fill")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Fill character conflicts with '0'")
(LIT " in format specifier: ")
(PUNCT "+")
(ID "format_spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "align")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Alignment conflicts with '0' in ")
(LIT "format specifier: ")
(PUNCT "+")
(ID "format_spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "fill")
(PUNCT "]")
(PUNCT "=")
(ID "fill")
(KEYWORD or)
(LIT " ")
(NEWLINE)
(ID "format_dict")
(PUNCT "[")
(LIT "align")
(PUNCT "]")
(PUNCT "=")
(ID "align")
(KEYWORD or)
(LIT ">")
(NEWLINE)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "sign")
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "sign")
(PUNCT "]")
(PUNCT "=")
(LIT "-")
(NEWLINE)
(DEDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "minimumwidth")
(PUNCT "]")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "format_dict")
(PUNCT "[")
(LIT "minimumwidth")
(PUNCT "]")
(KEYWORD or)
(LIT "0")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "precision")
(PUNCT "]")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "precision")
(PUNCT "]")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "format_dict")
(PUNCT "[")
(LIT "precision")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "precision")
(PUNCT "]")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "format_dict")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "gGn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "precision")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "==")
(LIT "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "=")
(LIT "g")
(NEWLINE)
(KEYWORD if)
(ID "_localeconv")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_localeconv")
(PUNCT "=")
(ID "_locale")
(PUNCT ".")
(ID "localeconv")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "thousands_sep")
(PUNCT "]")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Explicit thousands separator conflicts with ")
(LIT "'n' type in format specifier: ")
(PUNCT "+")
(ID "format_spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "thousands_sep")
(PUNCT "]")
(PUNCT "=")
(ID "_localeconv")
(PUNCT "[")
(LIT "thousands_sep")
(PUNCT "]")
(NEWLINE)
(ID "format_dict")
(PUNCT "[")
(LIT "grouping")
(PUNCT "]")
(PUNCT "=")
(ID "_localeconv")
(PUNCT "[")
(LIT "grouping")
(PUNCT "]")
(NEWLINE)
(ID "format_dict")
(PUNCT "[")
(LIT "decimal_point")
(PUNCT "]")
(PUNCT "=")
(ID "_localeconv")
(PUNCT "[")
(LIT "decimal_point")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "format_dict")
(PUNCT "[")
(LIT "thousands_sep")
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "thousands_sep")
(PUNCT "]")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "format_dict")
(PUNCT "[")
(LIT "grouping")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(LIT 3)
(PUNCT ",")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "format_dict")
(PUNCT "[")
(LIT "decimal_point")
(PUNCT "]")
(PUNCT "=")
(LIT ".")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "format_dict")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format_align")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "body")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given an unpadded, non-aligned numeric string 'body' and sign\n    string 'sign', add padding and alignment conforming to the given\n    format specifier dictionary 'spec' (as produced by\n    parse_format_specifier).\n\n    ")
(NEWLINE)
(ID "minimumwidth")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "minimumwidth")
(PUNCT "]")
(NEWLINE)
(ID "fill")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "fill")
(PUNCT "]")
(NEWLINE)
(ID "padding")
(PUNCT "=")
(ID "fill")
(PUNCT "*")
(PUNCT "(")
(ID "minimumwidth")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "sign")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "body")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "align")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "align")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "align")
(PUNCT "==")
(LIT "<")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "sign")
(PUNCT "+")
(ID "body")
(PUNCT "+")
(ID "padding")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "align")
(PUNCT "==")
(LIT ">")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "padding")
(PUNCT "+")
(ID "sign")
(PUNCT "+")
(ID "body")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "align")
(PUNCT "==")
(LIT "=")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "sign")
(PUNCT "+")
(ID "padding")
(PUNCT "+")
(ID "body")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "align")
(PUNCT "==")
(LIT "^")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "half")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "padding")
(PUNCT ")")
(PUNCT "//")
(LIT 2)
(NEWLINE)
(ID "result")
(PUNCT "=")
(ID "padding")
(PUNCT "[")
(PUNCT ":")
(ID "half")
(PUNCT "]")
(PUNCT "+")
(ID "sign")
(PUNCT "+")
(ID "body")
(PUNCT "+")
(ID "padding")
(PUNCT "[")
(ID "half")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Unrecognised alignment field")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_group_lengths")
(PUNCT "(")
(ID "grouping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert a localeconv-style grouping into a (possibly infinite)\n    iterable of integers representing group lengths.\n\n    ")
(NEWLINE)
(KEYWORD from)
(ID "itertools")
(KEYWORD import)
(ID "chain")
(PUNCT ",")
(ID "repeat")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "grouping")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "grouping")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT 0)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "grouping")
(PUNCT ")")
(PUNCT ">=")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "chain")
(PUNCT "(")
(ID "grouping")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "repeat")
(PUNCT "(")
(ID "grouping")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "grouping")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(ID "_locale")
(PUNCT ".")
(ID "CHAR_MAX")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "grouping")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unrecognised format for grouping")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_insert_thousands_sep")
(PUNCT "(")
(ID "digits")
(PUNCT ",")
(ID "spec")
(PUNCT ",")
(ID "min_width")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Insert thousands separators into a digit string.\n\n    spec is a dictionary whose keys should include 'thousands_sep' and\n    'grouping'; typically it's the result of parsing the format\n    specifier using _parse_format_specifier.\n\n    The min_width keyword argument gives the minimum length of the\n    result, which will be padded on the left with zeros if necessary.\n\n    If necessary, the zero padding adds an extra '0' on the left to\n    avoid a leading thousands separator.  For example, inserting\n    commas every three digits in '123456', with min_width=8, gives\n    '0,123,456', even though that has length 9.\n\n    ")
(NEWLINE)
(ID "sep")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "thousands_sep")
(PUNCT "]")
(NEWLINE)
(ID "grouping")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "grouping")
(PUNCT "]")
(NEWLINE)
(ID "groups")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "l")
(KEYWORD in)
(ID "_group_lengths")
(PUNCT "(")
(ID "grouping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "l")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "group length should be positive")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "l")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "max")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "digits")
(PUNCT ")")
(PUNCT ",")
(ID "min_width")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(ID "l")
(PUNCT ")")
(NEWLINE)
(ID "groups")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "l")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "digits")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(ID "digits")
(PUNCT "[")
(PUNCT "-")
(ID "l")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "digits")
(PUNCT "=")
(ID "digits")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(ID "l")
(PUNCT "]")
(NEWLINE)
(ID "min_width")
(PUNCT "-=")
(ID "l")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "digits")
(KEYWORD and)
(ID "min_width")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "min_width")
(PUNCT "-=")
(ID "len")
(PUNCT "(")
(ID "sep")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "l")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "digits")
(PUNCT ")")
(PUNCT ",")
(ID "min_width")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "groups")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "0")
(PUNCT "*")
(PUNCT "(")
(ID "l")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "digits")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(ID "digits")
(PUNCT "[")
(PUNCT "-")
(ID "l")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "sep")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "reversed")
(PUNCT "(")
(ID "groups")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format_sign")
(PUNCT "(")
(ID "is_negative")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Determine sign character.")
(NEWLINE)
(KEYWORD if)
(ID "is_negative")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "-")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "spec")
(PUNCT "[")
(LIT "sign")
(PUNCT "]")
(KEYWORD in)
(LIT " +")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "spec")
(PUNCT "[")
(LIT "sign")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_format_number")
(PUNCT "(")
(ID "is_negative")
(PUNCT ",")
(ID "intpart")
(PUNCT ",")
(ID "fracpart")
(PUNCT ",")
(ID "exp")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Format a number, given the following data:\n\n    is_negative: true if the number is negative, else false\n    intpart: string of digits that must appear before the decimal point\n    fracpart: string of digits that must come after the point\n    exp: exponent, as an integer\n    spec: dictionary resulting from parsing the format specifier\n\n    This function uses the information in spec to:\n      insert separators (decimal separator and thousands separators)\n      format the sign\n      format the exponent\n      add trailing '%' for the '%' type\n      zero-pad if necessary\n      fill and align if necessary\n    ")
(NEWLINE)
(ID "sign")
(PUNCT "=")
(ID "_format_sign")
(PUNCT "(")
(ID "is_negative")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "fracpart")
(KEYWORD or)
(ID "spec")
(PUNCT "[")
(LIT "alt")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fracpart")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "decimal_point")
(PUNCT "]")
(PUNCT "+")
(ID "fracpart")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "exp")
(PUNCT "!=")
(LIT 0)
(KEYWORD or)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(KEYWORD in)
(LIT "eE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "echar")
(PUNCT "=")
(PUNCT "{")
(LIT "E")
(PUNCT ":")
(LIT "E")
(PUNCT ",")
(LIT "e")
(PUNCT ":")
(LIT "e")
(PUNCT ",")
(LIT "G")
(PUNCT ":")
(LIT "E")
(PUNCT ",")
(LIT "g")
(PUNCT ":")
(LIT "e")
(PUNCT "}")
(PUNCT "[")
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "fracpart")
(PUNCT "+=")
(LIT "{0}{1:+}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "echar")
(PUNCT ",")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "type")
(PUNCT "]")
(PUNCT "==")
(LIT "%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fracpart")
(PUNCT "+=")
(LIT "%")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "spec")
(PUNCT "[")
(LIT "zeropad")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "min_width")
(PUNCT "=")
(ID "spec")
(PUNCT "[")
(LIT "minimumwidth")
(PUNCT "]")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "fracpart")
(PUNCT ")")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "sign")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "min_width")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "intpart")
(PUNCT "=")
(ID "_insert_thousands_sep")
(PUNCT "(")
(ID "intpart")
(PUNCT ",")
(ID "spec")
(PUNCT ",")
(ID "min_width")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_format_align")
(PUNCT "(")
(ID "sign")
(PUNCT ",")
(ID "intpart")
(PUNCT "+")
(ID "fracpart")
(PUNCT ",")
(ID "spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_Infinity")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(LIT "Inf")
(PUNCT ")")
(NEWLINE)
(ID "_NegativeInfinity")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(LIT "-Inf")
(PUNCT ")")
(NEWLINE)
(ID "_NaN")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(LIT "NaN")
(PUNCT ")")
(NEWLINE)
(ID "_Zero")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "_One")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "_NegativeOne")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "_SignedInfinity")
(PUNCT "=")
(PUNCT "(")
(ID "_Infinity")
(PUNCT ",")
(ID "_NegativeInfinity")
(PUNCT ")")
(NEWLINE)
(ID "_PyHASH_MODULUS")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "hash_info")
(PUNCT ".")
(ID "modulus")
(NEWLINE)
(ID "_PyHASH_INF")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "hash_info")
(PUNCT ".")
(ID "inf")
(NEWLINE)
(ID "_PyHASH_NAN")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "hash_info")
(PUNCT ".")
(ID "nan")
(NEWLINE)
(ID "_PyHASH_10INV")
(PUNCT "=")
(ID "pow")
(PUNCT "(")
(LIT 10)
(PUNCT ",")
(ID "_PyHASH_MODULUS")
(PUNCT "-")
(LIT 2)
(PUNCT ",")
(ID "_PyHASH_MODULUS")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "sys")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "_decimal")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s1")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "dir")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "s2")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "dir")
(PUNCT "(")
(ID "_decimal")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "s1")
(PUNCT "-")
(ID "s2")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "s1")
(PUNCT ",")
(ID "s2")
(PUNCT ",")
(ID "name")
(NEWLINE)
(KEYWORD from)
(ID "_decimal")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "doctest")
(PUNCT ",")
(ID "decimal")
(NEWLINE)
(ID "doctest")
(PUNCT ".")
(ID "testmod")
(PUNCT "(")
(ID "decimal")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
