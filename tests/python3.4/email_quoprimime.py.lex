(LIT "Quoted-printable content transfer encoding per RFCs 2045-2047.\n\nThis module handles the content transfer encoding method defined in RFC 2045\nto encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to\nsafely encode text that is in a character set similar to the 7-bit US ASCII\ncharacter set, but that includes some 8-bit characters that are normally not\nallowed in email bodies or headers.\n\nQuoted-printable is very space-inefficient for encoding binary files; use the\nemail.base64mime module for that instead.\n\nThis module provides an interface to encode and decode both headers and bodies\nwith quoted-printable encoding.\n\nRFC 2045 defines a method for including character set information in an\n`encoded-word' in a header.  This method is commonly used for 8-bit real names\nin To:/From:/Cc: etc. fields, as well as Subject: lines.\n\nThis module does not do the line wrapping or end-of-line character\nconversion necessary for proper internationalized headers; it only\ndoes dumb encoding and decoding.  To deal with the various line\nwrapping issues, use the email.header module.\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "body_decode")
(PUNCT ",")
(LIT "body_encode")
(PUNCT ",")
(LIT "body_length")
(PUNCT ",")
(LIT "decode")
(PUNCT ",")
(LIT "decodestring")
(PUNCT ",")
(LIT "header_decode")
(PUNCT ",")
(LIT "header_encode")
(PUNCT ",")
(LIT "header_length")
(PUNCT ",")
(LIT "quote")
(PUNCT ",")
(LIT "unquote")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD from)
(ID "string")
(KEYWORD import)
(ID "ascii_letters")
(PUNCT ",")
(ID "digits")
(PUNCT ",")
(ID "hexdigits")
(NEWLINE)
(ID "CRLF")
(PUNCT "=")
(LIT "\r\n")
(NEWLINE)
(ID "NL")
(PUNCT "=")
(LIT "\n")
(NEWLINE)
(ID "EMPTYSTRING")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "_QUOPRI_MAP")
(PUNCT "=")
(PUNCT "[")
(LIT "=%02X")
(PUNCT "%")
(ID "c")
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 256)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "_QUOPRI_HEADER_MAP")
(PUNCT "=")
(ID "_QUOPRI_MAP")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "_QUOPRI_BODY_MAP")
(PUNCT "=")
(ID "_QUOPRI_MAP")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(LIT #"-!*+/")
(PUNCT "+")
(ID "ascii_letters")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(PUNCT "+")
(ID "digits")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_QUOPRI_HEADER_MAP")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_QUOPRI_HEADER_MAP")
(PUNCT "[")
(ID "ord")
(PUNCT "(")
(LIT " ")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(LIT "_")
(NEWLINE)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(PUNCT "(")
(LIT #" !\"#$%&'()*+,-./0123456789:;<>")
(LIT #"?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`")
(LIT #"abcdefghijklmnopqrstuvwxyz{|}~\t")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_QUOPRI_BODY_MAP")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_check")
(PUNCT "(")
(ID "octet")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the octet should be escaped with header quopri.")
(NEWLINE)
(KEYWORD return)
(ID "chr")
(PUNCT "(")
(ID "octet")
(PUNCT ")")
(PUNCT "!=")
(ID "_QUOPRI_HEADER_MAP")
(PUNCT "[")
(ID "octet")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "body_check")
(PUNCT "(")
(ID "octet")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the octet should be escaped with body quopri.")
(NEWLINE)
(KEYWORD return)
(ID "chr")
(PUNCT "(")
(ID "octet")
(PUNCT ")")
(PUNCT "!=")
(ID "_QUOPRI_BODY_MAP")
(PUNCT "[")
(ID "octet")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_length")
(PUNCT "(")
(ID "bytearray")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a header quoted-printable encoding length.\n\n    Note that this does not include any RFC 2047 chrome added by\n    `header_encode()`.\n\n    :param bytearray: An array of bytes (a.k.a. octets).\n    :return: The length in bytes of the byte array when it is encoded with\n        quoted-printable for headers.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "sum")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "_QUOPRI_HEADER_MAP")
(PUNCT "[")
(ID "octet")
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "octet")
(KEYWORD in)
(ID "bytearray")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "body_length")
(PUNCT "(")
(ID "bytearray")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a body quoted-printable encoding length.\n\n    :param bytearray: An array of bytes (a.k.a. octets).\n    :return: The length in bytes of the byte array when it is encoded with\n        quoted-printable for bodies.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "sum")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "_QUOPRI_BODY_MAP")
(PUNCT "[")
(ID "octet")
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "octet")
(KEYWORD in)
(ID "bytearray")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_max_append")
(PUNCT "(")
(ID "L")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "maxlen")
(PUNCT ",")
(ID "extra")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "L")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "L")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "L")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "<=")
(ID "maxlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "L")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "+=")
(ID "extra")
(PUNCT "+")
(ID "s")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "L")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "unquote")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn a string in the form =AB to the ASCII character with value 0xab")
(NEWLINE)
(KEYWORD return)
(ID "chr")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "s")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(LIT 3)
(PUNCT "]")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "quote")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_QUOPRI_MAP")
(PUNCT "[")
(ID "ord")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_encode")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ",")
(ID "charset")
(PUNCT "=")
(LIT "iso-8859-1")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a single header line with quoted-printable (like) encoding.\n\n    Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but\n    used specifically for email header fields to allow charsets with mostly 7\n    bit characters (and some 8 bit) to remain more or less readable in non-RFC\n    2045 aware mail clients.\n\n    charset names the character set to use in the RFC 2046 header.  It\n    defaults to iso-8859-1.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "header_bytes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(ID "encoded")
(PUNCT "=")
(ID "header_bytes")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "latin1")
(PUNCT ")")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "_QUOPRI_HEADER_MAP")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "=?%s?q?%s?=")
(PUNCT "%")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "encoded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_QUOPRI_BODY_ENCODE_MAP")
(PUNCT "=")
(ID "_QUOPRI_BODY_MAP")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(LIT #"\r\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_QUOPRI_BODY_ENCODE_MAP")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "body_encode")
(PUNCT "(")
(ID "body")
(PUNCT ",")
(ID "maxlinelen")
(PUNCT "=")
(LIT 76)
(PUNCT ",")
(ID "eol")
(PUNCT "=")
(ID "NL")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode with quoted-printable, wrapping at maxlinelen characters.\n\n    Each line of encoded text will end with eol, which defaults to \"\\n\".  Set\n    this to \"\\r\\n\" if you will be using the result of this function directly\n    in an email.\n\n    Each line will be wrapped at, at most, maxlinelen characters before the\n    eol string (maxlinelen defaults to 76 characters, the maximum value\n    permitted by RFC 2045).  Long lines will have the 'soft line break'\n    quoted-printable character \"=\" appended to them, so the decoded text will\n    be identical to the original text.\n\n    The minimum maxlinelen is 4 to have room for a quoted character (\"=XX\")\n    followed by a soft line break.  Smaller values will generate a\n    ValueError.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "maxlinelen")
(PUNCT "<")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "maxlinelen must be at least 4")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "body")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "body")
(NEWLINE)
(DEDENT)
(ID "body")
(PUNCT "=")
(ID "body")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "_QUOPRI_BODY_ENCODE_MAP")
(PUNCT ")")
(NEWLINE)
(ID "soft_break")
(PUNCT "=")
(LIT "=")
(PUNCT "+")
(ID "eol")
(NEWLINE)
(ID "maxlinelen1")
(PUNCT "=")
(ID "maxlinelen")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "encoded_body")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "append")
(PUNCT "=")
(ID "encoded_body")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "body")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "laststart")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT "-")
(ID "maxlinelen")
(NEWLINE)
(KEYWORD while)
(ID "start")
(PUNCT "<=")
(ID "laststart")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stop")
(PUNCT "=")
(ID "start")
(PUNCT "+")
(ID "maxlinelen1")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(ID "stop")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(LIT "=")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(ID "stop")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "start")
(PUNCT "=")
(ID "stop")
(PUNCT "-")
(LIT 2)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "line")
(PUNCT "[")
(ID "stop")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "=")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(ID "stop")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "start")
(PUNCT "=")
(ID "stop")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(ID "stop")
(PUNCT "]")
(PUNCT "+")
(LIT "=")
(PUNCT ")")
(NEWLINE)
(ID "start")
(PUNCT "=")
(ID "stop")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "line")
(KEYWORD and)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD in)
(LIT " \t")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "room")
(PUNCT "=")
(ID "start")
(PUNCT "-")
(ID "laststart")
(NEWLINE)
(KEYWORD if)
(ID "room")
(PUNCT ">=")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "q")
(PUNCT "=")
(ID "quote")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "room")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "q")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "+")
(ID "soft_break")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "q")
(PUNCT "=")
(ID "soft_break")
(PUNCT "+")
(ID "quote")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "+")
(ID "q")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(ID "start")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "body")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD in)
(ID "CRLF")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "eol")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "encoded_body")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "encoded")
(PUNCT ",")
(ID "eol")
(PUNCT "=")
(ID "NL")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a quoted-printable string.\n\n    Lines are separated with eol, which defaults to \\n.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "encoded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "encoded")
(NEWLINE)
(DEDENT)
(ID "decoded")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "encoded")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "+=")
(ID "eol")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "!=")
(LIT "=")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "+=")
(ID "c")
(NEWLINE)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "i")
(PUNCT "+")
(LIT 2)
(PUNCT "<")
(ID "n")
(KEYWORD and)
(ID "line")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(KEYWORD in)
(ID "hexdigits")
(KEYWORD and)
(ID "line")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 2)
(PUNCT "]")
(KEYWORD in)
(ID "hexdigits")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "+=")
(ID "unquote")
(PUNCT "(")
(ID "line")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(LIT 3)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "+=")
(LIT 3)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "+=")
(ID "c")
(NEWLINE)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "i")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "+=")
(ID "eol")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "encoded")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(LIT "\r\n")
(KEYWORD and)
(ID "decoded")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "eol")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "=")
(ID "decoded")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "decoded")
(NEWLINE)
(DEDENT)
(ID "body_decode")
(PUNCT "=")
(ID "decode")
(NEWLINE)
(ID "decodestring")
(PUNCT "=")
(ID "decode")
(NEWLINE)
(KEYWORD def)
(ID "_unquote_match")
(PUNCT "(")
(ID "match")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn a match in the form =AB to the ASCII character with value 0xab")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "unquote")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a string encoded with RFC 2045 MIME header `Q' encoding.\n\n    This function does not parse a full MIME header value encoded with\n    quoted-printable (like =?iso-8895-1?q?Hello_World?=) -- please use\n    the high level email.header class for that functionality.\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "_")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "=[a-fA-F0-9]{2}")
(PUNCT ",")
(ID "_unquote_match")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "flags")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "ASCII")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
