(LIT "Basic message object for the email package object model.")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Message")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "uu")
(NEWLINE)
(KEYWORD import)
(ID "quopri")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(KEYWORD from)
(ID "io")
(KEYWORD import)
(ID "BytesIO")
(PUNCT ",")
(ID "StringIO")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "utils")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "errors")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "_policybase")
(KEYWORD import)
(ID "compat32")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "charset")
(KEYWORD as)
(ID "_charset")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "_encoded_words")
(KEYWORD import)
(ID "decode_b")
(NEWLINE)
(ID "Charset")
(PUNCT "=")
(ID "_charset")
(PUNCT ".")
(ID "Charset")
(NEWLINE)
(ID "SEMISPACE")
(PUNCT "=")
(LIT "; ")
(NEWLINE)
(ID "tspecials")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "[ \\(\\)<>@,;:\\\\\"/\\[\\]\\?=]")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_splitparam")
(PUNCT "(")
(ID "param")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "a")
(PUNCT ",")
(ID "sep")
(PUNCT ",")
(ID "b")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "param")
(PUNCT ")")
(PUNCT ".")
(ID "partition")
(PUNCT "(")
(LIT ";")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "sep")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "b")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_formatparam")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "quote")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convenience function to format and return a key=value pair.\n\n    This will quote the value if needed or if quote is true.  If value is a\n    three tuple (charset, language, value), it will be encoded according\n    to RFC2231 rules.  If it contains non-ascii characters it will likewise\n    be encoded according to RFC2231 rules, using the utf-8 charset and\n    a null language.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "param")
(PUNCT "+=")
(LIT "*")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "encode_rfc2231")
(PUNCT "(")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ",")
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "value")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "%s=%s")
(PUNCT "%")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeEncodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "param")
(PUNCT "+=")
(LIT "*")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "encode_rfc2231")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "utf-8")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "%s=%s")
(PUNCT "%")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "quote")
(KEYWORD or)
(ID "tspecials")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s=\"%s\"")
(PUNCT "%")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "utils")
(PUNCT ".")
(ID "quote")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s=%s")
(PUNCT "%")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "param")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_parseparam")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(LIT ";")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "plist")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "s")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT ";")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "end")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "end")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\"")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT "-")
(ID "s")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\\\"")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ")")
(PUNCT "%")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "end")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "f")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(LIT "=")
(KEYWORD in)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(LIT "=")
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "f")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT "=")
(PUNCT "+")
(ID "f")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "plist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "f")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "plist")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_unquotevalue")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "value")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "utils")
(PUNCT ".")
(ID "unquote")
(PUNCT "(")
(ID "value")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "utils")
(PUNCT ".")
(ID "unquote")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Message")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Basic message object.\n\n    A message object is defined as something that has a bunch of RFC 2822\n    headers and a payload.  It may optionally have an envelope header\n    (a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a\n    multipart or a message/rfc822), then the payload is a list of Message\n    objects, otherwise it is a string.\n\n    Message objects implement part of the `mapping' interface, which assumes\n    there is exactly one occurrence of the header per message.  Some headers\n    do in fact appear multiple times (e.g. Received) and for those headers,\n    you must use the explicit API to set or get all the headers.  Not all of\n    the mapping methods are implemented.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "policy")
(PUNCT "=")
(ID "compat32")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT "=")
(ID "policy")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unixfrom")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_charset")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "preamble")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "epilogue")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "defects")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_default_type")
(PUNCT "=")
(LIT "text/plain")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the entire formatted message as a string.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "as_string")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "as_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "unixfrom")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "maxheaderlen")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "policy")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the entire formatted message as a string.\n\n        Optional 'unixfrom', when true, means include the Unix From_ envelope\n        header.  For backward compatibility reasons, if maxheaderlen is\n        not specified it defaults to 0, so you must override it explicitly\n        if you want a different maxheaderlen.  'policy' is passed to the\n        Generator instance used to serialize the mesasge; if it is not\n        specified the policy associated with the message instance is used.\n\n        If the message object contains binary data that is not encoded\n        according to RFC standards, the non-compliant data will be replaced by\n        unicode \"unknown character\" code points.\n        ")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "generator")
(KEYWORD import)
(ID "Generator")
(NEWLINE)
(ID "policy")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(KEYWORD if)
(ID "policy")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "policy")
(NEWLINE)
(ID "fp")
(PUNCT "=")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "g")
(PUNCT "=")
(ID "Generator")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "mangle_from_")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "maxheaderlen")
(PUNCT "=")
(ID "maxheaderlen")
(PUNCT ",")
(ID "policy")
(PUNCT "=")
(ID "policy")
(PUNCT ")")
(NEWLINE)
(ID "g")
(PUNCT ".")
(ID "flatten")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "unixfrom")
(PUNCT "=")
(ID "unixfrom")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "fp")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bytes__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the entire formatted message as a bytes object.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "as_bytes")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "as_bytes")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "unixfrom")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "policy")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the entire formatted message as a bytes object.\n\n        Optional 'unixfrom', when true, means include the Unix From_ envelope\n        header.  'policy' is passed to the BytesGenerator instance used to\n        serialize the message; if not specified the policy associated with\n        the message instance is used.\n        ")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "generator")
(KEYWORD import)
(ID "BytesGenerator")
(NEWLINE)
(ID "policy")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(KEYWORD if)
(ID "policy")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "policy")
(NEWLINE)
(ID "fp")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "g")
(PUNCT "=")
(ID "BytesGenerator")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "mangle_from_")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "policy")
(PUNCT "=")
(ID "policy")
(PUNCT ")")
(NEWLINE)
(ID "g")
(PUNCT ".")
(ID "flatten")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "unixfrom")
(PUNCT "=")
(ID "unixfrom")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "fp")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_multipart")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the message consists of multiple parts.")
(NEWLINE)
(KEYWORD return)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_unixfrom")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "unixfrom")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_unixfrom")
(PUNCT "=")
(ID "unixfrom")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_unixfrom")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_unixfrom")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "attach")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "payload")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add the given payload to the current payload.\n\n        The current payload will always be a list of objects after this method\n        is called.  If you want to set the payload to a scalar object, use\n        set_payload() instead.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_payload")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(PUNCT "[")
(ID "payload")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "payload")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Attach is not valid on a message with a")
(LIT " non-multipart payload")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_payload")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "i")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "decode")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a reference to the payload.\n\n        The payload will either be a list object or a string.  If you mutate\n        the list object, you modify the message's payload in place.  Optional\n        i returns that index into the payload.\n\n        Optional decode is a flag indicating whether the payload should be\n        decoded or not, according to the Content-Transfer-Encoding header\n        (default is False).\n\n        When True and the message is not a multipart, the payload will be\n        decoded if this header's value is `quoted-printable' or `base64'.  If\n        some other encoding is used, or the header is missing, or if the\n        payload has bogus data (i.e. bogus base64 or uuencoded data), the\n        payload is returned as-is.\n\n        If the message is a multipart and the decode flag is True, then None\n        is returned.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_multipart")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "decode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "i")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_payload")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "i")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Expected list, got %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "payload")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_payload")
(NEWLINE)
(ID "cte")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "content-transfer-encoding")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "payload")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "utils")
(PUNCT ".")
(ID "_has_surrogates")
(PUNCT "(")
(ID "payload")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bpayload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "decode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "payload")
(PUNCT "=")
(ID "bpayload")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "charset")
(PUNCT ",")
(LIT "ascii")
(PUNCT ")")
(PUNCT ",")
(LIT "replace")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "LookupError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "payload")
(PUNCT "=")
(ID "bpayload")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "replace")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "decode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bpayload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bpayload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "raw-unicode-escape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "decode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "payload")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cte")
(PUNCT "==")
(LIT "quoted-printable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "quopri")
(PUNCT ".")
(ID "decodestring")
(PUNCT "(")
(ID "bpayload")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "cte")
(PUNCT "==")
(LIT "base64")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT ",")
(ID "defects")
(PUNCT "=")
(ID "decode_b")
(PUNCT "(")
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "bpayload")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "defect")
(KEYWORD in)
(ID "defects")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "handle_defect")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "defect")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "cte")
(KEYWORD in)
(PUNCT "(")
(LIT "x-uuencode")
(PUNCT ",")
(LIT "uuencode")
(PUNCT ",")
(LIT "uue")
(PUNCT ",")
(LIT "x-uue")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "in_file")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(ID "bpayload")
(PUNCT ")")
(NEWLINE)
(ID "out_file")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "uu")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "in_file")
(PUNCT ",")
(ID "out_file")
(PUNCT ",")
(ID "quiet")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "out_file")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "uu")
(PUNCT ".")
(ID "Error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bpayload")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "payload")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bpayload")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "payload")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_payload")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "payload")
(PUNCT ",")
(ID "charset")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the payload to the given value.\n\n        Optional charset sets the message's default character set.  See\n        set_charset() for details.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "payload")
(PUNCT ",")
(LIT "encode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "charset")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(ID "payload")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "Charset")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "charset")
(PUNCT "=")
(ID "Charset")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "payload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "charset")
(PUNCT ".")
(ID "output_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "payload")
(PUNCT ",")
(LIT "decode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(ID "payload")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "charset")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_charset")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_charset")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "charset")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the charset of the payload to a given character set.\n\n        charset can be a Charset instance, a string naming a character set, or\n        None.  If it is a string it will be converted to a Charset instance.\n        If charset is None, the charset parameter will be removed from the\n        Content-Type field.  Anything else will generate a TypeError.\n\n        The message will be assumed to be of type text/* encoded with\n        charset.input_charset.  It will be converted to charset.output_charset\n        and encoded properly, if needed, when generating the plain text\n        representation of the message.  MIME headers (MIME-Version,\n        Content-Type, Content-Transfer-Encoding) will be added as needed.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "charset")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "del_param")
(PUNCT "(")
(LIT "charset")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_charset")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "Charset")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "charset")
(PUNCT "=")
(ID "Charset")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_charset")
(PUNCT "=")
(ID "charset")
(NEWLINE)
(KEYWORD if)
(LIT "MIME-Version")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "add_header")
(PUNCT "(")
(LIT "MIME-Version")
(PUNCT ",")
(LIT "1.0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "Content-Type")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "add_header")
(PUNCT "(")
(LIT "Content-Type")
(PUNCT ",")
(LIT "text/plain")
(PUNCT ",")
(ID "charset")
(PUNCT "=")
(ID "charset")
(PUNCT ".")
(ID "get_output_charset")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_param")
(PUNCT "(")
(LIT "charset")
(PUNCT ",")
(ID "charset")
(PUNCT ".")
(ID "get_output_charset")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "charset")
(PUNCT "!=")
(ID "charset")
(PUNCT ".")
(ID "get_output_charset")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(ID "charset")
(PUNCT ".")
(ID "body_encode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "Content-Transfer-Encoding")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cte")
(PUNCT "=")
(ID "charset")
(PUNCT ".")
(ID "get_body_encoding")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cte")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "payload")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_payload")
(NEWLINE)
(KEYWORD if)
(ID "payload")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "payload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "payload")
(PUNCT "=")
(ID "payload")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "charset")
(PUNCT ".")
(ID "output_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(ID "charset")
(PUNCT ".")
(ID "body_encode")
(PUNCT "(")
(ID "payload")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "add_header")
(PUNCT "(")
(LIT "Content-Transfer-Encoding")
(PUNCT ",")
(ID "cte")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_charset")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the Charset instance associated with the message's payload.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_charset")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the total number of headers, including duplicates.")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get a header value.\n\n        Return None if the header is missing instead of raising an exception.\n\n        Note that if the header appeared multiple times, exactly which\n        occurrence gets returned is undefined.  Use get_all() to get all\n        the values matching a header field name.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the value of a header.\n\n        Note: this does not overwrite an existing header with the same field\n        name.  Use __delitem__() first to delete any existing headers.\n        ")
(NEWLINE)
(ID "max_count")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_max_count")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "max_count")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lname")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "found")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "lname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "found")
(PUNCT ">=")
(ID "max_count")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "There may be at most {} {} headers ")
(LIT "in a message")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "max_count")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_store_parse")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Delete all occurrences of a header, if present.\n\n        Does not raise an exception if the header is missing.\n        ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "newheaders")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newheaders")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(ID "newheaders")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(KEYWORD in)
(PUNCT "[")
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "field")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "field")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "keys")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of all the message's header field names.\n\n        These will be sorted in the order they appeared in the original\n        message, or were added to the message, and may contain duplicates.\n        Any fields deleted and re-inserted are always appended to the header\n        list.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "k")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "values")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of all the message's header values.\n\n        These will be sorted in the order they appeared in the original\n        message, or were added to the message, and may contain duplicates.\n        Any fields deleted and re-inserted are always appended to the header\n        list.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_fetch_parse")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "items")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get all the message's header fields and values.\n\n        These will be sorted in the order they appeared in the original\n        message, or were added to the message, and may contain duplicates.\n        Any fields deleted and re-inserted are always appended to the header\n        list.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_fetch_parse")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get a header value.\n\n        Like __getitem__() but return failobj instead of None when the field\n        is missing.\n        ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_fetch_parse")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_raw")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Store name and value in the model without modification.\n\n        This is an \"internal\" API, intended only for use by a parser.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "raw_items")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the (name, value) header pairs without modification.\n\n        This is an \"internal\" API, intended only for use by a generator.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_all")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of all the values for the named field.\n\n        These will be sorted in the order they appeared in the original\n        message, and may contain duplicates.  Any fields deleted and\n        re-inserted are always appended to the header list.\n\n        If no such fields exist, failobj is returned (defaults to None).\n        ")
(NEWLINE)
(ID "values")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "values")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_fetch_parse")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "values")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_header")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "_name")
(PUNCT ",")
(ID "_value")
(PUNCT ",")
(PUNCT "**")
(ID "_params")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Extended header setting.\n\n        name is the header field to add.  keyword arguments can be used to set\n        additional parameters for the header field, with underscores converted\n        to dashes.  Normally the parameter will be added as key=\"value\" unless\n        value is None, in which case only the key will be added.  If a\n        parameter value contains non-ASCII characters it can be specified as a\n        three-tuple of (charset, language, value), in which case it will be\n        encoded according to RFC2231 rules.  Otherwise it will be encoded using\n        the utf-8 charset and a language of ''.\n\n        Examples:\n\n        msg.add_header('content-disposition', 'attachment', filename='bud.gif')\n        msg.add_header('content-disposition', 'attachment',\n                       filename=('utf-8', '', Fußballer.ppt'))\n        msg.add_header('content-disposition', 'attachment',\n                       filename='Fußballer.ppt'))\n        ")
(NEWLINE)
(ID "parts")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "_params")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "v")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "_")
(PUNCT ",")
(LIT "-")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "_formatparam")
(PUNCT "(")
(ID "k")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "_")
(PUNCT ",")
(LIT "-")
(PUNCT ")")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "_value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "_value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT "[")
(ID "_name")
(PUNCT "]")
(PUNCT "=")
(ID "SEMISPACE")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "replace_header")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "_name")
(PUNCT ",")
(ID "_value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Replace a header.\n\n        Replace the first matching header found in the message, retaining\n        header order and case.  If no matching header was found, a KeyError is\n        raised.\n        ")
(NEWLINE)
(ID "_name")
(PUNCT "=")
(ID "_name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(KEYWORD in)
(ID "zip")
(PUNCT "(")
(ID "range")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "_name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_store_parse")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "_value")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_content_type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the message's content type.\n\n        The returned string is coerced to lower case of the form\n        `maintype/subtype'.  If there was no Content-Type header in the\n        message, the default type as given by get_default_type() will be\n        returned.  Since according to RFC 2045, messages always have a default\n        type this will always return a value.\n\n        RFC 2045 defines a message's default type to be text/plain unless it\n        appears inside a multipart/digest container, in which case it would be\n        message/rfc822.\n        ")
(NEWLINE)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "content-type")
(PUNCT ",")
(ID "missing")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "get_default_type")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ctype")
(PUNCT "=")
(ID "_splitparam")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ctype")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "text/plain")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ctype")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_content_maintype")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the message's main content type.\n\n        This is the `maintype' part of the string returned by\n        get_content_type().\n        ")
(NEWLINE)
(ID "ctype")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_content_type")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ctype")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_content_subtype")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the message's sub-content type.\n\n        This is the `subtype' part of the string returned by\n        get_content_type().\n        ")
(NEWLINE)
(ID "ctype")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_content_type")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "ctype")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_default_type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the `default' content type.\n\n        Most messages have a default content type of text/plain, except for\n        messages that are subparts of multipart/digest containers.  Such\n        subparts have a default content type of message/rfc822.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_default_type")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_default_type")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ctype")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the `default' content type.\n\n        ctype should be either \"text/plain\" or \"message/rfc822\", although this\n        is not enforced.  The default content type is not stored in the\n        Content-Type header.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_default_type")
(PUNCT "=")
(ID "ctype")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_params_preserve")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "failobj")
(PUNCT ",")
(ID "header")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "header")
(PUNCT ",")
(ID "missing")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(ID "params")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "_parseparam")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT ",")
(ID "val")
(PUNCT "=")
(ID "p")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "=")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "val")
(PUNCT "=")
(ID "val")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "p")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "val")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "params")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "params")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "decode_params")
(PUNCT "(")
(ID "params")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "params")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_params")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "header")
(PUNCT "=")
(LIT "content-type")
(PUNCT ",")
(ID "unquote")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the message's Content-Type parameters, as a list.\n\n        The elements of the returned list are 2-tuples of key/value pairs, as\n        split on the `=' sign.  The left hand side of the `=' is the key,\n        while the right hand side is the value.  If there is no `=' sign in\n        the parameter the value is the empty string.  The value is as\n        described in the get_param() method.\n\n        Optional failobj is the object to return if there is no Content-Type\n        header.  Optional header is the header to search instead of\n        Content-Type.  If unquote is True, the value is unquoted.\n        ")
(NEWLINE)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "params")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_params_preserve")
(PUNCT "(")
(ID "missing")
(PUNCT ",")
(ID "header")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "params")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "unquote")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "_unquotevalue")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "params")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "params")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_param")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "param")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "header")
(PUNCT "=")
(LIT "content-type")
(PUNCT ",")
(ID "unquote")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the parameter value if found in the Content-Type header.\n\n        Optional failobj is the object to return if there is no Content-Type\n        header, or the Content-Type header has no such parameter.  Optional\n        header is the header to search instead of Content-Type.\n\n        Parameter keys are always compared case insensitively.  The return\n        value can either be a string, or a 3-tuple if the parameter was RFC\n        2231 encoded.  When it's a 3-tuple, the elements of the value are of\n        the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and\n        LANGUAGE can be None, in which case you should consider VALUE to be\n        encoded in the us-ascii charset.  You can usually ignore LANGUAGE.\n        The parameter value (either the returned string, or the VALUE item in\n        the 3-tuple) is always unquoted, unless unquote is set to False.\n\n        If your application doesn't care whether the parameter was RFC 2231\n        encoded, it can turn the return value into a string as follows:\n\n            rawparam = msg.get_param('foo')\n            param = email.utils.collapse_rfc2231_value(rawparam)\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "header")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_get_params_preserve")
(PUNCT "(")
(ID "failobj")
(PUNCT ",")
(ID "header")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "param")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "unquote")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_unquotevalue")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "v")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_param")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "header")
(PUNCT "=")
(LIT "Content-Type")
(PUNCT ",")
(ID "requote")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "charset")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "language")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "replace")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set a parameter in the Content-Type header.\n\n        If the parameter already exists in the header, its value will be\n        replaced with the new value.\n\n        If header is Content-Type and has not yet been defined for this\n        message, it will be set to \"text/plain\" and the new parameter and\n        value will be appended as per RFC 2045.\n\n        An alternate header can specified in the header argument, and all\n        parameters will be quoted as necessary unless requote is False.\n\n        If charset is specified, the parameter will be encoded according to RFC\n        2231.  Optional language specifies the RFC 2231 language, defaulting\n        to the empty string.  Both charset and language should be strings.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(KEYWORD and)
(ID "charset")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "language")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "header")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(KEYWORD and)
(ID "header")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "content-type")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(LIT "text/plain")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "header")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "header")
(PUNCT "=")
(ID "header")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "ctype")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(ID "_formatparam")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(ID "SEMISPACE")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "ctype")
(PUNCT ",")
(ID "_formatparam")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD for)
(ID "old_param")
(PUNCT ",")
(ID "old_value")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "get_params")
(PUNCT "(")
(ID "header")
(PUNCT "=")
(ID "header")
(PUNCT ",")
(ID "unquote")
(PUNCT "=")
(ID "requote")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append_param")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD if)
(ID "old_param")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(ID "param")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append_param")
(PUNCT "=")
(ID "_formatparam")
(PUNCT "(")
(ID "param")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append_param")
(PUNCT "=")
(ID "_formatparam")
(PUNCT "(")
(ID "old_param")
(PUNCT ",")
(ID "old_value")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "ctype")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(ID "append_param")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT "=")
(ID "SEMISPACE")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "ctype")
(PUNCT ",")
(ID "append_param")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "ctype")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "header")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "replace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "replace_header")
(PUNCT "(")
(ID "header")
(PUNCT ",")
(ID "ctype")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(PUNCT "=")
(ID "ctype")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "del_param")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "param")
(PUNCT ",")
(ID "header")
(PUNCT "=")
(LIT "content-type")
(PUNCT ",")
(ID "requote")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove the given parameter completely from the Content-Type header.\n\n        The header will be re-written in place without the parameter or its\n        value. All values will be quoted as necessary unless requote is\n        False.  Optional header specifies an alternative to the Content-Type\n        header.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "header")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "new_ctype")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD for)
(ID "p")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "get_params")
(PUNCT "(")
(ID "header")
(PUNCT "=")
(ID "header")
(PUNCT ",")
(ID "unquote")
(PUNCT "=")
(ID "requote")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "p")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(ID "param")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "new_ctype")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_ctype")
(PUNCT "=")
(ID "_formatparam")
(PUNCT "(")
(ID "p")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_ctype")
(PUNCT "=")
(ID "SEMISPACE")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "new_ctype")
(PUNCT ",")
(ID "_formatparam")
(PUNCT "(")
(ID "p")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "new_ctype")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "header")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(PUNCT "=")
(ID "new_ctype")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_type")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "header")
(PUNCT "=")
(LIT "Content-Type")
(PUNCT ",")
(ID "requote")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the main type and subtype for the Content-Type header.\n\n        type must be a string in the form \"maintype/subtype\", otherwise a\n        ValueError is raised.\n\n        This method replaces the Content-Type header, keeping all the\n        parameters in place.  If requote is False, this leaves the existing\n        header's quoting as is.  Otherwise, the parameters will be quoted (the\n        default).\n\n        An alternative header can be specified in the header argument.  When\n        the Content-Type header is set, we'll always also add a MIME-Version\n        header.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "type")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "header")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "content-type")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(LIT "mime-version")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT "[")
(LIT "MIME-Version")
(PUNCT "]")
(PUNCT "=")
(LIT "1.0")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "header")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(PUNCT "=")
(ID "type")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "params")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_params")
(PUNCT "(")
(ID "header")
(PUNCT "=")
(ID "header")
(PUNCT ",")
(ID "unquote")
(PUNCT "=")
(ID "requote")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT "[")
(ID "header")
(PUNCT "]")
(PUNCT "=")
(ID "type")
(NEWLINE)
(KEYWORD for)
(ID "p")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "params")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_param")
(PUNCT "(")
(ID "p")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "header")
(PUNCT ",")
(ID "requote")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the filename associated with the payload if present.\n\n        The filename is extracted from the Content-Disposition header's\n        `filename' parameter, and it is unquoted.  If that header is missing\n        the `filename' parameter, this method falls back to looking for the\n        `name' parameter.\n        ")
(NEWLINE)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "filename")
(PUNCT ",")
(ID "missing")
(PUNCT ",")
(LIT "content-disposition")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "name")
(PUNCT ",")
(ID "missing")
(PUNCT ",")
(LIT "content-type")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "filename")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "utils")
(PUNCT ".")
(ID "collapse_rfc2231_value")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_boundary")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the boundary associated with the payload if present.\n\n        The boundary is extracted from the Content-Type header's `boundary'\n        parameter, and it is unquoted.\n        ")
(NEWLINE)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "boundary")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "boundary")
(PUNCT ",")
(ID "missing")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "boundary")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "utils")
(PUNCT ".")
(ID "collapse_rfc2231_value")
(PUNCT "(")
(ID "boundary")
(PUNCT ")")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_boundary")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "boundary")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the boundary parameter in Content-Type to 'boundary'.\n\n        This is subtly different than deleting the Content-Type header and\n        adding a new one with a new boundary parameter via add_header().  The\n        main difference is that using the set_boundary() method preserves the\n        order of the Content-Type header in the original message.\n\n        HeaderParseError is raised if the message has no Content-Type header.\n        ")
(NEWLINE)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "params")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_params_preserve")
(PUNCT "(")
(ID "missing")
(PUNCT ",")
(LIT "content-type")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "params")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "errors")
(PUNCT ".")
(ID "HeaderParseError")
(PUNCT "(")
(LIT "No Content-Type header found")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "newparams")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "foundp")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD for)
(ID "pk")
(PUNCT ",")
(ID "pv")
(KEYWORD in)
(ID "params")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pk")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "boundary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newparams")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(LIT "boundary")
(PUNCT ",")
(LIT "\"%s\"")
(PUNCT "%")
(ID "boundary")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "foundp")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newparams")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "pk")
(PUNCT ",")
(ID "pv")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "foundp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newparams")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(LIT "boundary")
(PUNCT ",")
(LIT "\"%s\"")
(PUNCT "%")
(ID "boundary")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "newheaders")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "h")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "h")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "content-type")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "newparams")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "v")
(PUNCT "==")
(LIT "")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "k")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%s=%s")
(PUNCT "%")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "val")
(PUNCT "=")
(ID "SEMISPACE")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(NEWLINE)
(ID "newheaders")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "header_store_parse")
(PUNCT "(")
(ID "h")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newheaders")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "h")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(ID "newheaders")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_content_charset")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the charset parameter of the Content-Type header.\n\n        The returned string is always coerced to lower case.  If there is no\n        Content-Type header, or if that header has no charset parameter,\n        failobj is returned.\n        ")
(NEWLINE)
(ID "missing")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "charset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "charset")
(PUNCT ",")
(ID "missing")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "charset")
(KEYWORD is)
(ID "missing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pcharset")
(PUNCT "=")
(ID "charset")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD or)
(LIT "us-ascii")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "as_bytes")
(PUNCT "=")
(ID "charset")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "raw-unicode-escape")
(PUNCT ")")
(NEWLINE)
(ID "charset")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "as_bytes")
(PUNCT ",")
(ID "pcharset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "LookupError")
(PUNCT ",")
(ID "UnicodeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "charset")
(PUNCT "=")
(ID "charset")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "charset")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "us-ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failobj")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "charset")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_charsets")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "failobj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list containing the charset(s) used in this message.\n\n        The returned list of items describes the Content-Type headers'\n        charset parameter for this message and all the subparts in its\n        payload.\n\n        Each item will either be a string (the value of the charset parameter\n        in the Content-Type header of that part) or the value of the\n        'failobj' parameter (defaults to None), if the part does not have a\n        main MIME type of \"text\", or the charset is not defined.\n\n        The list will contain one string for each part of the message, plus\n        one for the container message (i.e. self), so that a non-multipart\n        message will still return a list of length 1.\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "part")
(PUNCT ".")
(ID "get_content_charset")
(PUNCT "(")
(ID "failobj")
(PUNCT ")")
(KEYWORD for)
(ID "part")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "walk")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "iterators")
(KEYWORD import)
(ID "walk")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_IsAttachment")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__call__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bool__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "is_attachment will be a method, not a property, in 3.5")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "MIMEPart")
(PUNCT "(")
(ID "Message")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "policy")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "policy")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "policy")
(KEYWORD import)
(ID "default")
(NEWLINE)
(ID "policy")
(PUNCT "=")
(ID "default")
(NEWLINE)
(DEDENT)
(ID "Message")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "policy")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_attachment")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c_d")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "content-disposition")
(PUNCT ")")
(NEWLINE)
(ID "result")
(PUNCT "=")
(KEYWORD False)
(KEYWORD if)
(ID "c_d")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "c_d")
(PUNCT ".")
(ID "content_disposition")
(PUNCT "==")
(LIT "attachment")
(NEWLINE)
(KEYWORD return)
(ID "_IsAttachment")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_find_body")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "part")
(PUNCT ",")
(ID "preferencelist")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "part")
(PUNCT ".")
(ID "is_attachment")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "maintype")
(PUNCT ",")
(ID "subtype")
(PUNCT "=")
(ID "part")
(PUNCT ".")
(ID "get_content_type")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "maintype")
(PUNCT "==")
(LIT "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "subtype")
(KEYWORD in)
(ID "preferencelist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(PUNCT "(")
(ID "preferencelist")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(ID "subtype")
(PUNCT ")")
(PUNCT ",")
(ID "part")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "maintype")
(PUNCT "!=")
(LIT "multipart")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "subtype")
(PUNCT "!=")
(LIT "related")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "subpart")
(KEYWORD in)
(ID "part")
(PUNCT ".")
(ID "iter_parts")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_find_body")
(PUNCT "(")
(ID "subpart")
(PUNCT ",")
(ID "preferencelist")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "related")
(KEYWORD in)
(ID "preferencelist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(PUNCT "(")
(ID "preferencelist")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(LIT "related")
(PUNCT ")")
(PUNCT ",")
(ID "part")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "candidate")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "start")
(PUNCT "=")
(ID "part")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "start")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "start")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "subpart")
(KEYWORD in)
(ID "part")
(PUNCT ".")
(ID "iter_parts")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "subpart")
(PUNCT "[")
(LIT "content-id")
(PUNCT "]")
(PUNCT "==")
(ID "start")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "candidate")
(PUNCT "=")
(ID "subpart")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "candidate")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "subparts")
(PUNCT "=")
(ID "part")
(PUNCT ".")
(ID "get_payload")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "candidate")
(PUNCT "=")
(ID "subparts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD if)
(ID "subparts")
(KEYWORD else)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "candidate")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_find_body")
(PUNCT "(")
(ID "candidate")
(PUNCT ",")
(ID "preferencelist")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_body")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "preferencelist")
(PUNCT "=")
(PUNCT "(")
(LIT "related")
(PUNCT ",")
(LIT "html")
(PUNCT ",")
(LIT "plain")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return best candidate mime part for display as 'body' of message.\n\n        Do a depth first search, starting with self, looking for the first part\n        matching each of the items in preferencelist, and return the part\n        corresponding to the first item that has a match, or None if no items\n        have a match.  If 'related' is not included in preferencelist, consider\n        the root part of any multipart/related encountered as a candidate\n        match.  Ignore parts with 'Content-Disposition: attachment'.\n        ")
(NEWLINE)
(ID "best_prio")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "preferencelist")
(PUNCT ")")
(NEWLINE)
(ID "body")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "prio")
(PUNCT ",")
(ID "part")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_find_body")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "preferencelist")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "prio")
(PUNCT "<")
(ID "best_prio")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "best_prio")
(PUNCT "=")
(ID "prio")
(NEWLINE)
(ID "body")
(PUNCT "=")
(ID "part")
(NEWLINE)
(KEYWORD if)
(ID "prio")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "body")
(NEWLINE)
(DEDENT)
(ID "_body_types")
(PUNCT "=")
(PUNCT "{")
(PUNCT "(")
(LIT "text")
(PUNCT ",")
(LIT "plain")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "text")
(PUNCT ",")
(LIT "html")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "multipart")
(PUNCT ",")
(LIT "related")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "multipart")
(PUNCT ",")
(LIT "alternative")
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "iter_attachments")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an iterator over the non-main parts of a multipart.\n\n        Skip the first of each occurrence of text/plain, text/html,\n        multipart/related, or multipart/alternative in the multipart (unless\n        they have a 'Content-Disposition: attachment' header) and include all\n        remaining subparts in the returned iterator.  When applied to a\n        multipart/related, return all parts except the root part.  Return an\n        empty iterator when applied to a multipart/alternative or a\n        non-multipart.\n        ")
(NEWLINE)
(ID "maintype")
(PUNCT ",")
(ID "subtype")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_content_type")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "maintype")
(PUNCT "!=")
(LIT "multipart")
(KEYWORD or)
(ID "subtype")
(PUNCT "==")
(LIT "alternative")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "parts")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_payload")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "maintype")
(PUNCT "==")
(LIT "multipart")
(KEYWORD and)
(ID "subtype")
(PUNCT "==")
(LIT "related")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "start")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_param")
(PUNCT "(")
(LIT "start")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "start")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "attachments")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "part")
(KEYWORD in)
(ID "parts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "part")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "content-id")
(PUNCT ")")
(PUNCT "==")
(ID "start")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "attachments")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "part")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "found")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "attachments")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "parts")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(KEYWORD from)
(ID "parts")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "seen")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "part")
(KEYWORD in)
(ID "parts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "maintype")
(PUNCT ",")
(ID "subtype")
(PUNCT "=")
(ID "part")
(PUNCT ".")
(ID "get_content_type")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(PUNCT "(")
(ID "maintype")
(PUNCT ",")
(ID "subtype")
(PUNCT ")")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_body_types")
(KEYWORD and)
(KEYWORD not)
(ID "part")
(PUNCT ".")
(ID "is_attachment")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "subtype")
(KEYWORD not)
(KEYWORD in)
(ID "seen")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "seen")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "subtype")
(PUNCT ")")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "part")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "iter_parts")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an iterator over all immediate subparts of a multipart.\n\n        Return an empty iterator for a non-multipart.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "get_content_maintype")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "multipart")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "get_payload")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_content")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(ID "content_manager")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "content_manager")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "content_manager")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "content_manager")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "content_manager")
(PUNCT ".")
(ID "get_content")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_content")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(ID "content_manager")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "content_manager")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "content_manager")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ".")
(ID "content_manager")
(NEWLINE)
(DEDENT)
(ID "content_manager")
(PUNCT ".")
(ID "set_content")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_make_multipart")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "subtype")
(PUNCT ",")
(ID "disallowed_subtypes")
(PUNCT ",")
(ID "boundary")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "get_content_maintype")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "multipart")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "existing_subtype")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_content_subtype")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "disallowed_subtypes")
(PUNCT "=")
(ID "disallowed_subtypes")
(PUNCT "+")
(PUNCT "(")
(ID "subtype")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "existing_subtype")
(KEYWORD in)
(ID "disallowed_subtypes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot convert {} to {}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "existing_subtype")
(PUNCT ",")
(ID "subtype")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "keep_headers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "part_headers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "content-")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "part_headers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "keep_headers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "part_headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "part")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "(")
(ID "policy")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ")")
(NEWLINE)
(ID "part")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(ID "part_headers")
(NEWLINE)
(ID "part")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_payload")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(PUNCT "[")
(ID "part")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(ID "keep_headers")
(NEWLINE)
(ID "self")
(PUNCT "[")
(LIT "Content-Type")
(PUNCT "]")
(PUNCT "=")
(LIT "multipart/")
(PUNCT "+")
(ID "subtype")
(NEWLINE)
(KEYWORD if)
(ID "boundary")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_param")
(PUNCT "(")
(LIT "boundary")
(PUNCT ",")
(ID "boundary")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "make_related")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "boundary")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_make_multipart")
(PUNCT "(")
(LIT "related")
(PUNCT ",")
(PUNCT "(")
(LIT "alternative")
(PUNCT ",")
(LIT "mixed")
(PUNCT ")")
(PUNCT ",")
(ID "boundary")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "make_alternative")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "boundary")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_make_multipart")
(PUNCT "(")
(LIT "alternative")
(PUNCT ",")
(PUNCT "(")
(LIT "mixed")
(PUNCT ",")
(PUNCT ")")
(PUNCT ",")
(ID "boundary")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "make_mixed")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "boundary")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_make_multipart")
(PUNCT "(")
(LIT "mixed")
(PUNCT ",")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "boundary")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_add_multipart")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "_subtype")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(ID "_disp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "get_content_maintype")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(LIT "multipart")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "get_content_subtype")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(ID "_subtype")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "make_")
(PUNCT "+")
(ID "_subtype")
(PUNCT ")")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "part")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "(")
(ID "policy")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "policy")
(PUNCT ")")
(NEWLINE)
(ID "part")
(PUNCT ".")
(ID "set_content")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_disp")
(KEYWORD and)
(LIT "content-disposition")
(KEYWORD not)
(KEYWORD in)
(ID "part")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "part")
(PUNCT "[")
(LIT "Content-Disposition")
(PUNCT "]")
(PUNCT "=")
(ID "_disp")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "attach")
(PUNCT "(")
(ID "part")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_related")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_add_multipart")
(PUNCT "(")
(LIT "related")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(ID "_disp")
(PUNCT "=")
(LIT "inline")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_alternative")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_add_multipart")
(PUNCT "(")
(LIT "alternative")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_attachment")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_add_multipart")
(PUNCT "(")
(LIT "mixed")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(ID "_disp")
(PUNCT "=")
(LIT "attachment")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear_content")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_headers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(KEYWORD for)
(ID "n")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_headers")
(KEYWORD if)
(KEYWORD not)
(ID "n")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "content-")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_payload")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "EmailMessage")
(PUNCT "(")
(ID "MIMEPart")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "set_content")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "set_content")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "MIME-Version")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(LIT "MIME-Version")
(PUNCT "]")
(PUNCT "=")
(LIT "1.0")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
