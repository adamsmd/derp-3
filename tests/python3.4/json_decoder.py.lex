(LIT "Implementation of JSONDecoder\n")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD from)
(ID "json")
(KEYWORD import)
(ID "scanner")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "_json")
(KEYWORD import)
(ID "scanstring")
(KEYWORD as)
(ID "c_scanstring")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c_scanstring")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "JSONDecoder")
(PUNCT "]")
(NEWLINE)
(ID "FLAGS")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "MULTILINE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "DOTALL")
(NEWLINE)
(ID "NaN")
(PUNCT "=")
(ID "float")
(PUNCT "(")
(LIT "nan")
(PUNCT ")")
(NEWLINE)
(ID "PosInf")
(PUNCT "=")
(ID "float")
(PUNCT "(")
(LIT "inf")
(PUNCT ")")
(NEWLINE)
(ID "NegInf")
(PUNCT "=")
(ID "float")
(PUNCT "(")
(LIT "-inf")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "linecol")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newline")
(PUNCT "=")
(LIT #"\n")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newline")
(PUNCT "=")
(LIT "\n")
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT "=")
(ID "doc")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(ID "newline")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "lineno")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "colno")
(PUNCT "=")
(ID "pos")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "colno")
(PUNCT "=")
(ID "pos")
(PUNCT "-")
(ID "doc")
(PUNCT ".")
(ID "rindex")
(PUNCT "(")
(ID "newline")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "lineno")
(PUNCT ",")
(ID "colno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "errmsg")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "doc")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT ",")
(ID "colno")
(PUNCT "=")
(ID "linecol")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "end")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fmt")
(PUNCT "=")
(LIT "{0}: line {1} column {2} (char {3})")
(NEWLINE)
(KEYWORD return)
(ID "fmt")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "colno")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "endlineno")
(PUNCT ",")
(ID "endcolno")
(PUNCT "=")
(ID "linecol")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(ID "fmt")
(PUNCT "=")
(LIT "{0}: line {1} column {2} - line {3} column {4} (char {5} - {6})")
(NEWLINE)
(KEYWORD return)
(ID "fmt")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "colno")
(PUNCT ",")
(ID "endlineno")
(PUNCT ",")
(ID "endcolno")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_CONSTANTS")
(PUNCT "=")
(PUNCT "{")
(LIT "-Infinity")
(PUNCT ":")
(ID "NegInf")
(PUNCT ",")
(LIT "Infinity")
(PUNCT ":")
(ID "PosInf")
(PUNCT ",")
(LIT "NaN")
(PUNCT ":")
(ID "NaN")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "STRINGCHUNK")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "(.*?)([\"\\\\\\x00-\\x1f])")
(PUNCT ",")
(ID "FLAGS")
(PUNCT ")")
(NEWLINE)
(ID "BACKSLASH")
(PUNCT "=")
(PUNCT "{")
(LIT "\"")
(PUNCT ":")
(LIT "\"")
(PUNCT ",")
(LIT "\\")
(PUNCT ":")
(LIT "\\")
(PUNCT ",")
(LIT "/")
(PUNCT ":")
(LIT "/")
(PUNCT ",")
(LIT "b")
(PUNCT ":")
(LIT "\b")
(PUNCT ",")
(LIT "f")
(PUNCT ":")
(LIT "\f")
(PUNCT ",")
(LIT "n")
(PUNCT ":")
(LIT "\n")
(PUNCT ",")
(LIT "r")
(PUNCT ":")
(LIT "\r")
(PUNCT ",")
(LIT "t")
(PUNCT ":")
(LIT "\t")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "_decode_uXXXX")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "esc")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "pos")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(ID "pos")
(PUNCT "+")
(LIT 5)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "esc")
(PUNCT ")")
(PUNCT "==")
(LIT 4)
(KEYWORD and)
(ID "esc")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(LIT "xX")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "esc")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "msg")
(PUNCT "=")
(LIT "Invalid \\uXXXX escape")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "py_scanstring")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "_b")
(PUNCT "=")
(ID "BACKSLASH")
(PUNCT ",")
(ID "_m")
(PUNCT "=")
(ID "STRINGCHUNK")
(PUNCT ".")
(ID "match")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Scan the string s for a JSON string. End is the index of the\n    character in s after the quote that started the JSON string.\n    Unescapes all valid JSON string escape sequences and raises ValueError\n    on attempt to decode an invalid string. If strict is False then literal\n    control characters are allowed in the string.\n\n    Returns a tuple of the decoded string and the index of the character in s\n    after the end quote.")
(NEWLINE)
(ID "chunks")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "_append")
(PUNCT "=")
(ID "chunks")
(PUNCT ".")
(ID "append")
(NEWLINE)
(ID "begin")
(PUNCT "=")
(ID "end")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunk")
(PUNCT "=")
(ID "_m")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "chunk")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Unterminated string starting at")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "begin")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "end")
(PUNCT "=")
(ID "chunk")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "content")
(PUNCT ",")
(ID "terminator")
(PUNCT "=")
(ID "chunk")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_append")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "terminator")
(PUNCT "==")
(LIT "\"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "terminator")
(PUNCT "!=")
(LIT "\\")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "strict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Invalid control character {0!r} at")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "terminator")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_append")
(PUNCT "(")
(ID "terminator")
(PUNCT ")")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "esc")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Unterminated string starting at")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "begin")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "esc")
(PUNCT "!=")
(LIT "u")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "char")
(PUNCT "=")
(ID "_b")
(PUNCT "[")
(ID "esc")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Invalid \\escape: {0!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "esc")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "uni")
(PUNCT "=")
(ID "_decode_uXXXX")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(ID "end")
(PUNCT "+=")
(LIT 5)
(NEWLINE)
(KEYWORD if)
(LIT 55296)
(PUNCT "<=")
(ID "uni")
(PUNCT "<=")
(LIT 56319)
(KEYWORD and)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(LIT "\\u")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "uni2")
(PUNCT "=")
(ID "_decode_uXXXX")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT 56320)
(PUNCT "<=")
(ID "uni2")
(PUNCT "<=")
(LIT 57343)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "uni")
(PUNCT "=")
(LIT 65536)
(PUNCT "+")
(PUNCT "(")
(PUNCT "(")
(PUNCT "(")
(ID "uni")
(PUNCT "-")
(LIT 55296)
(PUNCT ")")
(PUNCT "<<")
(LIT 10)
(PUNCT ")")
(PUNCT "|")
(PUNCT "(")
(ID "uni2")
(PUNCT "-")
(LIT 56320)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "end")
(PUNCT "+=")
(LIT 6)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "char")
(PUNCT "=")
(ID "chr")
(PUNCT "(")
(ID "uni")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_append")
(PUNCT "(")
(ID "char")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(PUNCT ",")
(ID "end")
(NEWLINE)
(DEDENT)
(ID "scanstring")
(PUNCT "=")
(ID "c_scanstring")
(KEYWORD or)
(ID "py_scanstring")
(NEWLINE)
(ID "WHITESPACE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "[ \\t\\n\\r]*")
(PUNCT ",")
(ID "FLAGS")
(PUNCT ")")
(NEWLINE)
(ID "WHITESPACE_STR")
(PUNCT "=")
(LIT " \t\n\r")
(NEWLINE)
(KEYWORD def)
(ID "JSONObject")
(PUNCT "(")
(ID "s_and_end")
(PUNCT ",")
(ID "strict")
(PUNCT ",")
(ID "scan_once")
(PUNCT ",")
(ID "object_hook")
(PUNCT ",")
(ID "object_pairs_hook")
(PUNCT ",")
(ID "memo")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "_w")
(PUNCT "=")
(ID "WHITESPACE")
(PUNCT ".")
(ID "match")
(PUNCT ",")
(ID "_ws")
(PUNCT "=")
(ID "WHITESPACE_STR")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "s_and_end")
(NEWLINE)
(ID "pairs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "pairs_append")
(PUNCT "=")
(ID "pairs")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD if)
(ID "memo")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "memo")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(ID "memo_get")
(PUNCT "=")
(ID "memo")
(PUNCT ".")
(ID "setdefault")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(PUNCT "!=")
(LIT "\"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "nextchar")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "nextchar")
(PUNCT "==")
(LIT "}")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "object_pairs_hook")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "object_pairs_hook")
(PUNCT "(")
(ID "pairs")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "result")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "pairs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "object_hook")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pairs")
(PUNCT "=")
(ID "object_hook")
(PUNCT "(")
(ID "pairs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "pairs")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "nextchar")
(PUNCT "!=")
(LIT "\"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting property name enclosed in double quotes")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "scanstring")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ",")
(ID "strict")
(PUNCT ")")
(NEWLINE)
(ID "key")
(PUNCT "=")
(ID "memo_get")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT "!=")
(LIT ":")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT "!=")
(LIT ":")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting ':' delimiter")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "scan_once")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting value")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "err")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "pairs_append")
(PUNCT "(")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nextchar")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(PUNCT "==")
(LIT "}")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "nextchar")
(PUNCT "!=")
(LIT ",")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting ',' delimiter")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(PUNCT "!=")
(LIT "\"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting property name enclosed in double quotes")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "object_pairs_hook")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "object_pairs_hook")
(PUNCT "(")
(ID "pairs")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "result")
(PUNCT ",")
(ID "end")
(NEWLINE)
(DEDENT)
(ID "pairs")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "pairs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "object_hook")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pairs")
(PUNCT "=")
(ID "object_hook")
(PUNCT "(")
(ID "pairs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "pairs")
(PUNCT ",")
(ID "end")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "JSONArray")
(PUNCT "(")
(ID "s_and_end")
(PUNCT ",")
(ID "scan_once")
(PUNCT ",")
(ID "_w")
(PUNCT "=")
(ID "WHITESPACE")
(PUNCT ".")
(ID "match")
(PUNCT ",")
(ID "_ws")
(PUNCT "=")
(ID "WHITESPACE_STR")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "s_and_end")
(NEWLINE)
(ID "values")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "nextchar")
(PUNCT "==")
(LIT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "values")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "_append")
(PUNCT "=")
(ID "values")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "scan_once")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting value")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "err")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "_append")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "nextchar")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "nextchar")
(PUNCT "==")
(LIT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "nextchar")
(PUNCT "!=")
(LIT ",")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting ',' delimiter")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(KEYWORD in)
(ID "_ws")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "values")
(PUNCT ",")
(ID "end")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "JSONDecoder")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | str               |\n    +---------------+-------------------+\n    | number (int)  | int               |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "object_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_float")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_int")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parse_constant")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "object_pairs_hook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "``object_hook``, if specified, will be called with the result\n        of every JSON object decoded and its return value will be used in\n        place of the given ``dict``.  This can be used to provide custom\n        deserializations (e.g. to support JSON-RPC class hinting).\n\n        ``object_pairs_hook``, if specified will be called with the result of\n        every JSON object decoded with an ordered list of pairs.  The return\n        value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders that rely on the\n        order that the key and value pairs are decoded (for example,\n        collections.OrderedDict will remember the order of insertion). If\n        ``object_hook`` is also defined, the ``object_pairs_hook`` takes\n        priority.\n\n        ``parse_float``, if specified, will be called with the string\n        of every JSON float to be decoded. By default this is equivalent to\n        float(num_str). This can be used to use another datatype or parser\n        for JSON floats (e.g. decimal.Decimal).\n\n        ``parse_int``, if specified, will be called with the string\n        of every JSON int to be decoded. By default this is equivalent to\n        int(num_str). This can be used to use another datatype or parser\n        for JSON integers (e.g. float).\n\n        ``parse_constant``, if specified, will be called with one of the\n        following strings: -Infinity, Infinity, NaN.\n        This can be used to raise an exception if invalid JSON numbers\n        are encountered.\n\n        If ``strict`` is false (true is the default), then control\n        characters will be allowed inside strings.  Control characters in\n        this context are those with character codes in the 0-31 range,\n        including ``'\\t'`` (tab), ``'\\n'``, ``'\\r'`` and ``'\\0'``.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "object_hook")
(PUNCT "=")
(ID "object_hook")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_float")
(PUNCT "=")
(ID "parse_float")
(KEYWORD or)
(ID "float")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_int")
(PUNCT "=")
(ID "parse_int")
(KEYWORD or)
(ID "int")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_constant")
(PUNCT "=")
(ID "parse_constant")
(KEYWORD or)
(ID "_CONSTANTS")
(PUNCT ".")
(ID "__getitem__")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "strict")
(PUNCT "=")
(ID "strict")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "object_pairs_hook")
(PUNCT "=")
(ID "object_pairs_hook")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_object")
(PUNCT "=")
(ID "JSONObject")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_array")
(PUNCT "=")
(ID "JSONArray")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_string")
(PUNCT "=")
(ID "scanstring")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "memo")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "scan_once")
(PUNCT "=")
(ID "scanner")
(PUNCT ".")
(ID "make_scanner")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "_w")
(PUNCT "=")
(ID "WHITESPACE")
(PUNCT ".")
(ID "match")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the Python representation of ``s`` (a ``str`` instance\n        containing a JSON document).\n\n        ")
(NEWLINE)
(ID "obj")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "raw_decode")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "idx")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "end")
(PUNCT "=")
(ID "_w")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "end")
(PUNCT "!=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Extra data")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "obj")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "raw_decode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "idx")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n\n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "scan_once")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "idx")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errmsg")
(PUNCT "(")
(LIT "Expecting value")
(PUNCT ",")
(ID "s")
(PUNCT ",")
(ID "err")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "obj")
(PUNCT ",")
(ID "end")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
