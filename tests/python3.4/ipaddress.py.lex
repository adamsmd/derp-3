(LIT "A fast, lightweight IPv4/IPv6 manipulation library in Python.\n\nThis library is used to create/poke/manipulate IPv4 and IPv6 addresses\nand networks.\n\n")
(NEWLINE)
(ID "__version__")
(PUNCT "=")
(LIT "1.0")
(NEWLINE)
(KEYWORD import)
(ID "functools")
(NEWLINE)
(ID "IPV4LENGTH")
(PUNCT "=")
(LIT 32)
(NEWLINE)
(ID "IPV6LENGTH")
(PUNCT "=")
(LIT 128)
(NEWLINE)
(KEYWORD class)
(ID "AddressValueError")
(PUNCT "(")
(ID "ValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A Value Error related to the address.")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "NetmaskValueError")
(PUNCT "(")
(ID "ValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A Value Error related to the netmask.")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ip_address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Take an IP string/int and return an object of the correct type.\n\n    Args:\n        address: A string or integer, the IP address.  Either IPv4 or\n          IPv6 addresses may be supplied; integers less than 2**32 will\n          be considered to be IPv4 by default.\n\n    Returns:\n        An IPv4Address or IPv6Address object.\n\n    Raises:\n        ValueError: if the *address* passed isn't either a v4 or a v6\n          address\n\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv4Address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AddressValueError")
(PUNCT ",")
(ID "NetmaskValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv6Address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AddressValueError")
(PUNCT ",")
(ID "NetmaskValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%r does not appear to be an IPv4 or IPv6 address")
(PUNCT "%")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ip_network")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Take an IP string/int and return an object of the correct type.\n\n    Args:\n        address: A string or integer, the IP network.  Either IPv4 or\n          IPv6 networks may be supplied; integers less than 2**32 will\n          be considered to be IPv4 by default.\n\n    Returns:\n        An IPv4Network or IPv6Network object.\n\n    Raises:\n        ValueError: if the string passed isn't either a v4 or a v6\n          address. Or if the network has host bits set.\n\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv4Network")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AddressValueError")
(PUNCT ",")
(ID "NetmaskValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv6Network")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AddressValueError")
(PUNCT ",")
(ID "NetmaskValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%r does not appear to be an IPv4 or IPv6 network")
(PUNCT "%")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ip_interface")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Take an IP string/int and return an object of the correct type.\n\n    Args:\n        address: A string or integer, the IP address.  Either IPv4 or\n          IPv6 addresses may be supplied; integers less than 2**32 will\n          be considered to be IPv4 by default.\n\n    Returns:\n        An IPv4Interface or IPv6Interface object.\n\n    Raises:\n        ValueError: if the string passed isn't either a v4 or a v6\n          address.\n\n    Notes:\n        The IPv?Interface classes describe an Address on a particular\n        Network, so they're basically a combination of both the Address\n        and Network classes.\n\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv4Interface")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AddressValueError")
(PUNCT ",")
(ID "NetmaskValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv6Interface")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AddressValueError")
(PUNCT ",")
(ID "NetmaskValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%r does not appear to be an IPv4 or IPv6 interface")
(PUNCT "%")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "v4_int_to_packed")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Represent an address as 4 packed bytes in network (big-endian) order.\n\n    Args:\n        address: An integer representation of an IPv4 IP address.\n\n    Returns:\n        The integer address packed as 4 bytes in network (big-endian) order.\n\n    Raises:\n        ValueError: If the integer is negative or too large to be an\n          IPv4 IP address.\n\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "address")
(PUNCT ".")
(ID "to_bytes")
(PUNCT "(")
(LIT 4)
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Address negative or too large for IPv4")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "v6_int_to_packed")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Represent an address as 16 packed bytes in network (big-endian) order.\n\n    Args:\n        address: An integer representation of an IPv6 IP address.\n\n    Returns:\n        The integer address packed as 16 bytes in network (big-endian) order.\n\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "address")
(PUNCT ".")
(ID "to_bytes")
(PUNCT "(")
(LIT 16)
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Address negative or too large for IPv6")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_split_optional_netmask")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to split the netmask and raise AddressValueError if needed")
(NEWLINE)
(ID "addr")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "addr")
(PUNCT ")")
(PUNCT ">")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "Only one '/' permitted in %r")
(PUNCT "%")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "addr")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_find_address_range")
(PUNCT "(")
(ID "addresses")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find a sequence of IPv#Address.\n\n    Args:\n        addresses: a list of IPv#Address objects.\n\n    Returns:\n        A tuple containing the first and last IP addresses in the sequence.\n\n    ")
(NEWLINE)
(ID "first")
(PUNCT "=")
(ID "last")
(PUNCT "=")
(ID "addresses")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "ip")
(KEYWORD in)
(ID "addresses")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ip")
(PUNCT ".")
(ID "_ip")
(PUNCT "==")
(ID "last")
(PUNCT ".")
(ID "_ip")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last")
(PUNCT "=")
(ID "ip")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_count_righthand_zero_bits")
(PUNCT "(")
(ID "number")
(PUNCT ",")
(ID "bits")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Count the number of zero bits on the right hand side.\n\n    Args:\n        number: an integer.\n        bits: maximum number of bits to count.\n\n    Returns:\n        The number of zero bits on the right hand side of the number.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "number")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bits")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "bits")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "number")
(PUNCT ">>")
(ID "i")
(PUNCT ")")
(PUNCT "&")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "i")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "bits")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "summarize_address_range")
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Summarize a network range given the first and last IP addresses.\n\n    Example:\n        >>> list(summarize_address_range(IPv4Address('192.0.2.0'),\n        ...                              IPv4Address('192.0.2.130')))\n        ...                                #doctest: +NORMALIZE_WHITESPACE\n        [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'),\n         IPv4Network('192.0.2.130/32')]\n\n    Args:\n        first: the first IPv4Address or IPv6Address in the range.\n        last: the last IPv4Address or IPv6Address in the range.\n\n    Returns:\n        An iterator of the summarized IPv(4|6) network objects.\n\n    Raise:\n        TypeError:\n            If the first and last objects are not IP addresses.\n            If the first and last objects are not the same version.\n        ValueError:\n            If the last object is not greater than the first.\n            If the version of the first address is not 4 or 6.\n\n    ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "last")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "first and last must be IP addresses, not networks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "first")
(PUNCT ".")
(ID "version")
(PUNCT "!=")
(ID "last")
(PUNCT ".")
(ID "version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "first")
(PUNCT ">")
(ID "last")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "last IP address must be greater than first")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "first")
(PUNCT ".")
(ID "version")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip")
(PUNCT "=")
(ID "IPv4Network")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "first")
(PUNCT ".")
(ID "version")
(PUNCT "==")
(LIT 6)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip")
(PUNCT "=")
(ID "IPv6Network")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown IP version")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ip_bits")
(PUNCT "=")
(ID "first")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(ID "first_int")
(PUNCT "=")
(ID "first")
(PUNCT ".")
(ID "_ip")
(NEWLINE)
(ID "last_int")
(PUNCT "=")
(ID "last")
(PUNCT ".")
(ID "_ip")
(NEWLINE)
(KEYWORD while)
(ID "first_int")
(PUNCT "<=")
(ID "last_int")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nbits")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "_count_righthand_zero_bits")
(PUNCT "(")
(ID "first_int")
(PUNCT ",")
(ID "ip_bits")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "last_int")
(PUNCT "-")
(ID "first_int")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "bit_length")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "net")
(PUNCT "=")
(ID "ip")
(PUNCT "(")
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "ip_bits")
(PUNCT "-")
(ID "nbits")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "net")
(NEWLINE)
(ID "first_int")
(PUNCT "+=")
(LIT 1)
(PUNCT "<<")
(ID "nbits")
(NEWLINE)
(KEYWORD if)
(ID "first_int")
(PUNCT "-")
(LIT 1)
(PUNCT "==")
(ID "ip")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "first")
(PUNCT "=")
(ID "first")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "first_int")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_collapse_addresses_recursive")
(PUNCT "(")
(ID "addresses")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Loops through the addresses, collapsing concurrent netblocks.\n\n    Example:\n\n        ip1 = IPv4Network('192.0.2.0/26')\n        ip2 = IPv4Network('192.0.2.64/26')\n        ip3 = IPv4Network('192.0.2.128/26')\n        ip4 = IPv4Network('192.0.2.192/26')\n\n        _collapse_addresses_recursive([ip1, ip2, ip3, ip4]) ->\n          [IPv4Network('192.0.2.0/24')]\n\n        This shouldn't be called directly; it is called via\n          collapse_addresses([]).\n\n    Args:\n        addresses: A list of IPv4Network's or IPv6Network's\n\n    Returns:\n        A list of IPv4Network's or IPv6Network's depending on what we were\n        passed.\n\n    ")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last_addr")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "ret_array")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "optimized")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD for)
(ID "cur_addr")
(KEYWORD in)
(ID "addresses")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "ret_array")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last_addr")
(PUNCT "=")
(ID "cur_addr")
(NEWLINE)
(ID "ret_array")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "cur_addr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(PUNCT "(")
(ID "cur_addr")
(PUNCT ".")
(ID "network_address")
(PUNCT ">=")
(ID "last_addr")
(PUNCT ".")
(ID "network_address")
(KEYWORD and)
(ID "cur_addr")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT "<=")
(ID "last_addr")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "optimized")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "cur_addr")
(PUNCT "==")
(ID "list")
(PUNCT "(")
(ID "last_addr")
(PUNCT ".")
(ID "supernet")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "subnets")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret_array")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "last_addr")
(PUNCT "=")
(ID "last_addr")
(PUNCT ".")
(ID "supernet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "optimized")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last_addr")
(PUNCT "=")
(ID "cur_addr")
(NEWLINE)
(ID "ret_array")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "cur_addr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "addresses")
(PUNCT "=")
(ID "ret_array")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "optimized")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "addresses")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "collapse_addresses")
(PUNCT "(")
(ID "addresses")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Collapse a list of IP objects.\n\n    Example:\n        collapse_addresses([IPv4Network('192.0.2.0/25'),\n                            IPv4Network('192.0.2.128/25')]) ->\n                           [IPv4Network('192.0.2.0/24')]\n\n    Args:\n        addresses: An iterator of IPv4Network or IPv6Network objects.\n\n    Returns:\n        An iterator of the collapsed IPv(4|6)Network objects.\n\n    Raises:\n        TypeError: If passed a list of mixed version objects.\n\n    ")
(NEWLINE)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "addrs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "ips")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "nets")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "ip")
(KEYWORD in)
(ID "addresses")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "ip")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ips")
(KEYWORD and)
(ID "ips")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "ip")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "ip")
(PUNCT ",")
(ID "ips")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ips")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "ip")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "==")
(ID "ip")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ips")
(KEYWORD and)
(ID "ips")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "ip")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "ip")
(PUNCT ",")
(ID "ips")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ips")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "ip")
(PUNCT ".")
(ID "ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ips")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "ip")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "nets")
(KEYWORD and)
(ID "nets")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "ip")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "ip")
(PUNCT ",")
(ID "nets")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "nets")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "ips")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "set")
(PUNCT "(")
(ID "ips")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "nets")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "set")
(PUNCT "(")
(ID "nets")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "len")
(PUNCT "(")
(ID "ips")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT ")")
(PUNCT "=")
(ID "_find_address_range")
(PUNCT "(")
(ID "ips")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "ips")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(ID "last")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "addrs")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "summarize_address_range")
(PUNCT "(")
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "iter")
(PUNCT "(")
(ID "_collapse_addresses_recursive")
(PUNCT "(")
(ID "sorted")
(PUNCT "(")
(ID "addrs")
(PUNCT "+")
(ID "nets")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(ID "_BaseNetwork")
(PUNCT ".")
(ID "_get_networks_key")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_mixed_type_key")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a key suitable for sorting between networks and addresses.\n\n    Address and Network objects are not sortable by default; they're\n    fundamentally different so the expression\n\n        IPv4Address('192.0.2.0') <= IPv4Network('192.0.2.0/24')\n\n    doesn't make any sense.  There are some times however, where you may wish\n    to have ipaddress sort these for you anyway. If you need to do this, you\n    can use this function as the key= argument to sorted().\n\n    Args:\n      obj: either a Network or Address object.\n    Returns:\n      appropriate key.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "_BaseNetwork")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "obj")
(PUNCT ".")
(ID "_get_networks_key")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "obj")
(PUNCT ".")
(ID "_get_address_key")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_IPAddressBase")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The mother class.")
(NEWLINE)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "exploded")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the longhand version of the IP address as a string.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_explode_shorthand_ip_string")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "compressed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the shorthand version of the IP address as a string.")
(NEWLINE)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "version")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%200s has no version specified")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_check_int_address")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "address")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%d (< 0) is not permitted as an IPv%d address")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "address")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%d (>= 2**%d) is not permitted as an IPv%d address")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_check_packed_address")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ",")
(ID "expected_len")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_len")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "address_len")
(PUNCT "!=")
(ID "expected_len")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%r (len %d != %d) is not permitted as an IPv%d address")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "address_len")
(PUNCT ",")
(ID "expected_len")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_ip_int_from_prefix")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefixlen")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn the prefix length into a bitwise netmask\n\n        Args:\n            prefixlen: An integer, the prefix length.\n\n        Returns:\n            An integer.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT "^")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ">>")
(ID "prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prefix_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return prefix length from the bitwise netmask.\n\n        Args:\n            ip_int: An integer, the netmask in expanded bitwise format\n\n        Returns:\n            An integer, the prefix length.\n\n        Raises:\n            ValueError: If the input intermingles zeroes & ones\n        ")
(NEWLINE)
(ID "trailing_zeroes")
(PUNCT "=")
(ID "_count_righthand_zero_bits")
(PUNCT "(")
(ID "ip_int")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT ")")
(NEWLINE)
(ID "prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT "-")
(ID "trailing_zeroes")
(NEWLINE)
(ID "leading_ones")
(PUNCT "=")
(ID "ip_int")
(PUNCT ">>")
(ID "trailing_zeroes")
(NEWLINE)
(ID "all_ones")
(PUNCT "=")
(PUNCT "(")
(LIT 1)
(PUNCT "<<")
(ID "prefixlen")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "leading_ones")
(PUNCT "!=")
(ID "all_ones")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "byteslen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT "//")
(LIT 8)
(NEWLINE)
(ID "details")
(PUNCT "=")
(ID "ip_int")
(PUNCT ".")
(ID "to_bytes")
(PUNCT "(")
(ID "byteslen")
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(ID "msg")
(PUNCT "=")
(LIT "Netmask pattern %r mixes zeroes & ones")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "details")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "prefixlen")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_report_invalid_netmask")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "netmask_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%r is not a valid netmask")
(PUNCT "%")
(ID "netmask_str")
(NEWLINE)
(KEYWORD raise)
(ID "NetmaskValueError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prefix_from_prefix_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefixlen_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return prefix length from a numeric string\n\n        Args:\n            prefixlen_str: The string to be converted\n\n        Returns:\n            An integer, the prefix length.\n\n        Raises:\n            NetmaskValueError: If the input is not a valid netmask\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_BaseV4")
(PUNCT ".")
(ID "_DECIMAL_DIGITS")
(PUNCT ".")
(ID "issuperset")
(PUNCT "(")
(ID "prefixlen_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_report_invalid_netmask")
(PUNCT "(")
(ID "prefixlen_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefixlen")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "prefixlen_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_report_invalid_netmask")
(PUNCT "(")
(ID "prefixlen_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(LIT 0)
(PUNCT "<=")
(ID "prefixlen")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_report_invalid_netmask")
(PUNCT "(")
(ID "prefixlen_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "prefixlen")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prefix_from_ip_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn a netmask/hostmask string into a prefix length\n\n        Args:\n            ip_str: The netmask/hostmask to be converted\n\n        Returns:\n            An integer, the prefix length.\n\n        Raises:\n            NetmaskValueError: If the input is not a valid netmask/hostmask\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_int")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AddressValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_report_invalid_netmask")
(PUNCT "(")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_prefix_from_ip_int")
(PUNCT "(")
(ID "ip_int")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "ip_int")
(PUNCT "^=")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_prefix_from_ip_int")
(PUNCT "(")
(ID "ip_int")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_report_invalid_netmask")
(PUNCT "(")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "total_ordering")
(NEWLINE)
(KEYWORD class)
(ID "_BaseAddress")
(PUNCT "(")
(ID "_IPAddressBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A generic IP object.\n\n    This IP class contains the version independent methods which are\n    used by single IP addresses.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(KEYWORD and)
(LIT "/")
(KEYWORD in)
(ID "str")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "Unexpected '/' in %r")
(PUNCT "%")
(ID "address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__int__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_ip")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_version")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_ip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "_ip")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__add__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "+")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__sub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "-")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s(%r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(ID "hex")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_address_key")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "total_ordering")
(NEWLINE)
(KEYWORD class)
(ID "_BaseNetwork")
(PUNCT "(")
(ID "_IPAddressBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A generic IP network object.\n\n    This IP class contains the version independent methods which are\n    used by networks.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cache")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s(%r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "hosts")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate Iterator over usable hosts in a network.\n\n        This is like __iter__ except it doesn't return the network\n        or broadcast addresses.\n\n        ")
(NEWLINE)
(ID "network")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(ID "broadcast")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "network")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "broadcast")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "network")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(ID "broadcast")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "network")
(PUNCT ",")
(ID "broadcast")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "network")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(ID "broadcast")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "network")
(PUNCT "+")
(ID "n")
(PUNCT ">")
(ID "broadcast")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "IndexError")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "network")
(PUNCT "+")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "n")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "broadcast")
(PUNCT "+")
(ID "n")
(PUNCT "<")
(ID "network")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "IndexError")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "broadcast")
(PUNCT "+")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "_BaseNetwork")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "network_address")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "netmask")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "netmask")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_version")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "network_address")
(KEYWORD and)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT "==")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "^")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "_BaseNetwork")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "<=")
(ID "int")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT "<=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "overlaps")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Tell if self is partly contained in other.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "network_address")
(KEYWORD in)
(ID "other")
(KEYWORD or)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(KEYWORD in)
(ID "other")
(KEYWORD or)
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "network_address")
(KEYWORD in)
(ID "self")
(KEYWORD or)
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "broadcast_address")
(KEYWORD in)
(ID "self")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "broadcast_address")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cache")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "broadcast_address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "x")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "|")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "hostmask")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cache")
(PUNCT "[")
(LIT "broadcast_address")
(PUNCT "]")
(PUNCT "=")
(ID "x")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "x")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "hostmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cache")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "hostmask")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "x")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT "^")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cache")
(PUNCT "[")
(LIT "hostmask")
(PUNCT "]")
(PUNCT "=")
(ID "x")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "x")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_prefixlen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_netmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_hostmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "hostmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "num_addresses")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Number of hosts in the current subnet.")
(NEWLINE)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(PUNCT "-")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "_address_class")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%200s has no associated address class")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "prefixlen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "address_exclude")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove an address from a larger block.\n\n        For example:\n\n            addr1 = ip_network('192.0.2.0/28')\n            addr2 = ip_network('192.0.2.1/32')\n            addr1.address_exclude(addr2) =\n                [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),\n                IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]\n\n        or IPv6:\n\n            addr1 = ip_network('2001:db8::1/32')\n            addr2 = ip_network('2001:db8::1/128')\n            addr1.address_exclude(addr2) =\n                [ip_network('2001:db8::1/128'),\n                ip_network('2001:db8::2/127'),\n                ip_network('2001:db8::4/126'),\n                ip_network('2001:db8::8/125'),\n                ...\n                ip_network('2001:db8:8000::/33')]\n\n        Args:\n            other: An IPv4Network or IPv6Network object of the same type.\n\n        Returns:\n            An iterator of the IPv(4|6)Network objects which is self\n            minus other.\n\n        Raises:\n            TypeError: If self and other are of differing address\n              versions, or if other is not a network object.\n            ValueError: If other is not completely contained by self.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same version")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "_BaseNetwork")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s is not a network object")
(PUNCT "%")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "network_address")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s not contained in %s")
(PUNCT "%")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "other")
(PUNCT "==")
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "other")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "prefixlen")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "s1")
(PUNCT ",")
(ID "s2")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "subnets")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "s1")
(PUNCT "!=")
(ID "other")
(KEYWORD and)
(ID "s2")
(PUNCT "!=")
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ">=")
(ID "s1")
(PUNCT ".")
(ID "network_address")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT "<=")
(ID "s1")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "s2")
(NEWLINE)
(ID "s1")
(PUNCT ",")
(ID "s2")
(PUNCT "=")
(ID "s1")
(PUNCT ".")
(ID "subnets")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ">=")
(ID "s2")
(PUNCT ".")
(ID "network_address")
(KEYWORD and)
(ID "other")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT "<=")
(ID "s2")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "s1")
(NEWLINE)
(ID "s1")
(PUNCT ",")
(ID "s2")
(PUNCT "=")
(ID "s2")
(PUNCT ".")
(ID "subnets")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "Error performing exclusion: ")
(LIT "s1: %s s2: %s other: %s")
(PUNCT "%")
(PUNCT "(")
(ID "s1")
(PUNCT ",")
(ID "s2")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "s1")
(PUNCT "==")
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "s2")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s2")
(PUNCT "==")
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "s1")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "Error performing exclusion: ")
(LIT "s1: %s s2: %s other: %s")
(PUNCT "%")
(PUNCT "(")
(ID "s1")
(PUNCT ",")
(ID "s2")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "compare_networks")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compare two IP objects.\n\n        This is only concerned about the comparison of the integer\n        representation of the network addresses.  This means that the\n        host bits aren't considered at all in this method.  If you want\n        to compare host bits, you can easily enough do a\n        'HostA._ip < HostB._ip'\n\n        Args:\n            other: An IP object.\n\n        Returns:\n            If the IP versions of self and other are the same, returns:\n\n            -1 if self < other:\n              eg: IPv4Network('192.0.2.0/25') < IPv4Network('192.0.2.128/25')\n              IPv6Network('2001:db8::1000/124') <\n                  IPv6Network('2001:db8::2000/124')\n            0 if self == other\n              eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')\n              IPv6Network('2001:db8::1000/124') ==\n                  IPv6Network('2001:db8::1000/124')\n            1 if self > other\n              eg: IPv4Network('192.0.2.128/25') > IPv4Network('192.0.2.0/25')\n                  IPv6Network('2001:db8::2000/124') >\n                      IPv6Network('2001:db8::1000/124')\n\n          Raises:\n              TypeError if the IP versions are different.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "_version")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s and %s are not of the same type")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ">")
(ID "other")
(PUNCT ".")
(ID "network_address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "netmask")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ">")
(ID "other")
(PUNCT ".")
(ID "netmask")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_networks_key")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Network-only key function.\n\n        Returns an object that identifies this address' network and\n        netmask. This function is a suitable \"key\" argument for sorted()\n        and list.sort().\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "subnets")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefixlen_diff")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "new_prefix")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The subnets which join to make the current subnet.\n\n        In the case that self contains only one IP\n        (self._prefixlen == 32 for IPv4 or self._prefixlen == 128\n        for IPv6), yield an iterator with just ourself.\n\n        Args:\n            prefixlen_diff: An integer, the amount the prefix length\n              should be increased by. This should not be set if\n              new_prefix is also set.\n            new_prefix: The desired new prefix length. This must be a\n              larger number (smaller prefix) than the existing prefix.\n              This should not be set if prefixlen_diff is also set.\n\n        Returns:\n            An iterator of IPv(4|6) objects.\n\n        Raises:\n            ValueError: The prefixlen_diff is too small or too large.\n                OR\n            prefixlen_diff and new_prefix are both set or new_prefix\n              is a smaller number than the current prefix (smaller\n              number means a larger network)\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "new_prefix")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "new_prefix")
(PUNCT "<")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "new prefix must be longer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "prefixlen_diff")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cannot set prefixlen_diff and new_prefix")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "prefixlen_diff")
(PUNCT "=")
(ID "new_prefix")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "prefixlen_diff")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "prefix length diff must be > 0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "new_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "+")
(ID "prefixlen_diff")
(NEWLINE)
(KEYWORD if)
(ID "new_prefixlen")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "prefix length diff %d is invalid for netblock %s")
(PUNCT "%")
(PUNCT "(")
(ID "new_prefixlen")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "first")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "+")
(ID "prefixlen_diff")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "first")
(NEWLINE)
(ID "current")
(PUNCT "=")
(ID "first")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "broadcast")
(PUNCT "=")
(ID "current")
(PUNCT ".")
(ID "broadcast_address")
(NEWLINE)
(KEYWORD if)
(ID "broadcast")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "new_addr")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "broadcast")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "current")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "new_addr")
(PUNCT ",")
(ID "new_prefixlen")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "current")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "supernet")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefixlen_diff")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "new_prefix")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The supernet containing the current network.\n\n        Args:\n            prefixlen_diff: An integer, the amount the prefix length of\n              the network should be decreased by.  For example, given a\n              /24 network and a prefixlen_diff of 3, a supernet with a\n              /21 netmask is returned.\n\n        Returns:\n            An IPv4 network object.\n\n        Raises:\n            ValueError: If self.prefixlen - prefixlen_diff < 0. I.e., you have\n              a negative prefix length.\n                OR\n            If prefixlen_diff and new_prefix are both set or new_prefix is a\n              larger number than the current prefix (larger number means a\n              smaller network)\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "new_prefix")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "new_prefix")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "new prefix must be shorter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "prefixlen_diff")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cannot set prefixlen_diff and new_prefix")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "prefixlen_diff")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "-")
(ID "new_prefix")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "prefixlen")
(PUNCT "-")
(ID "prefixlen_diff")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "current prefixlen is %d, cannot have a prefixlen_diff of %d")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "prefixlen")
(PUNCT ",")
(ID "prefixlen_diff")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "t")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "prefixlen")
(PUNCT "-")
(ID "prefixlen_diff")
(PUNCT ")")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "t")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "t")
(PUNCT ".")
(ID "network_address")
(PUNCT ",")
(ID "t")
(PUNCT ".")
(ID "prefixlen")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_multicast")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for multicast use.\n\n        Returns:\n            A boolean, True if the address is a multicast address.\n            See RFC 2373 2.7 for details.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_multicast")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_multicast")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_reserved")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is otherwise IETF reserved.\n\n        Returns:\n            A boolean, True if the address is within one of the\n            reserved IPv6 Network ranges.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_reserved")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_reserved")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_link_local")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for link-local.\n\n        Returns:\n            A boolean, True if the address is reserved per RFC 4291.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_link_local")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_link_local")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_private")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if this address is allocated for private networks.\n\n        Returns:\n            A boolean, True if the address is reserved per\n            iana-ipv4-special-registry or iana-ipv6-special-registry.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_private")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_private")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_global")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if this address is allocated for public networks.\n\n        Returns:\n            A boolean, True if the address is not reserved per\n            iana-ipv4-special-registry or iana-ipv6-special-registry.\n\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "is_private")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_unspecified")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is unspecified.\n\n        Returns:\n            A boolean, True if this is the unspecified address as defined in\n            RFC 2373 2.5.2.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_unspecified")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_unspecified")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_loopback")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is a loopback address.\n\n        Returns:\n            A boolean, True if the address is a loopback address as defined in\n            RFC 2373 2.5.3.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_loopback")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_loopback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_BaseV4")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base IPv4 object.\n\n    The following methods are used by IPv4 objects in both single IP\n    addresses and networks.\n\n    ")
(NEWLINE)
(ID "_ALL_ONES")
(PUNCT "=")
(PUNCT "(")
(LIT 2)
(PUNCT "**")
(ID "IPV4LENGTH")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "_DECIMAL_DIGITS")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(LIT "0123456789")
(PUNCT ")")
(NEWLINE)
(ID "_valid_mask_octets")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(PUNCT "(")
(LIT 255)
(PUNCT ",")
(LIT 254)
(PUNCT ",")
(LIT 252)
(PUNCT ",")
(LIT 248)
(PUNCT ",")
(LIT 240)
(PUNCT ",")
(LIT 224)
(PUNCT ",")
(LIT 192)
(PUNCT ",")
(LIT 128)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "=")
(LIT 4)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT "=")
(ID "IPV4LENGTH")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_explode_shorthand_ip_string")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn the given IP string into an integer for comparison.\n\n        Args:\n            ip_str: A string, the IP ip_str.\n\n        Returns:\n            The IP ip_str as an integer.\n\n        Raises:\n            AddressValueError: if ip_str isn't a valid IPv4 Address.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ip_str")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "Address cannot be empty")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "octets")
(PUNCT "=")
(ID "ip_str")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "octets")
(PUNCT ")")
(PUNCT "!=")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "Expected 4 octets in %r")
(PUNCT "%")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "int")
(PUNCT ".")
(ID "from_bytes")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_parse_octet")
(PUNCT ",")
(ID "octets")
(PUNCT ")")
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "%s in %r")
(PUNCT "%")
(PUNCT "(")
(ID "exc")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_parse_octet")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "octet_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert a decimal octet into an integer.\n\n        Args:\n            octet_str: A string, the number to parse.\n\n        Returns:\n            The octet as an integer.\n\n        Raises:\n            ValueError: if the octet isn't strictly a decimal from [0..255].\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "octet_str")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Empty octet not permitted")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_DECIMAL_DIGITS")
(PUNCT ".")
(ID "issuperset")
(PUNCT "(")
(ID "octet_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Only decimal digits permitted in %r")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "octet_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "octet_str")
(PUNCT ")")
(PUNCT ">")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "At most 3 characters permitted in %r")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "octet_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "octet_int")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "octet_str")
(PUNCT ",")
(LIT 10)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "octet_int")
(PUNCT ">")
(LIT 7)
(KEYWORD and)
(ID "octet_str")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "0")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Ambiguous (octal/decimal) value in %r not permitted")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "octet_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "octet_int")
(PUNCT ">")
(LIT 255)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Octet %d (> 255) not permitted")
(PUNCT "%")
(ID "octet_int")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "octet_int")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turns a 32-bit integer into dotted decimal notation.\n\n        Args:\n            ip_int: An integer, the IP address.\n\n        Returns:\n            The IP address as a string in dotted decimal notation.\n\n        ")
(NEWLINE)
(KEYWORD return)
(LIT ".")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "ip_int")
(PUNCT ".")
(ID "to_bytes")
(PUNCT "(")
(LIT 4)
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_is_valid_netmask")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "netmask")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Verify that the netmask is valid.\n\n        Args:\n            netmask: A string, either a prefix or dotted decimal\n              netmask.\n\n        Returns:\n            A boolean, True if the prefix represents a valid IPv4\n            netmask.\n\n        ")
(NEWLINE)
(ID "mask")
(PUNCT "=")
(ID "netmask")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "mask")
(PUNCT ")")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "mask")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "int")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_valid_mask_octets")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "idx")
(PUNCT ",")
(ID "y")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "mask")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "idx")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(ID "y")
(PUNCT ">")
(ID "mask")
(PUNCT "[")
(ID "idx")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "netmask")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "netmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 0)
(PUNCT "<=")
(ID "netmask")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_is_hostmask")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the IP string is a hostmask (rather than a netmask).\n\n        Args:\n            ip_str: A string, the potential hostmask.\n\n        Returns:\n            A boolean, True if the IP string is a hostmask.\n\n        ")
(NEWLINE)
(ID "bits")
(PUNCT "=")
(ID "ip_str")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts")
(PUNCT "=")
(PUNCT "[")
(ID "x")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "bits")
(PUNCT ")")
(KEYWORD if)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_valid_mask_octets")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "!=")
(ID "len")
(PUNCT "(")
(ID "bits")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "<")
(ID "parts")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "max_prefixlen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "version")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_version")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IPv4Address")
(PUNCT "(")
(ID "_BaseV4")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Represent and manipulate single IPv4 Addresses.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Args:\n            address: A string or integer representing the IP\n\n              Additionally, an integer can be passed, so\n              IPv4Address('192.0.2.1') == IPv4Address(3221225985).\n              or, more generally\n              IPv4Address(int(IPv4Address('192.0.2.1'))) ==\n                IPv4Address('192.0.2.1')\n\n        Raises:\n            AddressValueError: If ipaddress isn't a valid IPv4 address.\n\n        ")
(NEWLINE)
(ID "_BaseAddress")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "_BaseV4")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_check_int_address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "=")
(ID "address")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_check_packed_address")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "=")
(ID "int")
(PUNCT ".")
(ID "from_bytes")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "addr_str")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "addr_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "packed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The binary representation of this address.")
(NEWLINE)
(KEYWORD return)
(ID "v4_int_to_packed")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_reserved")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is otherwise IETF reserved.\n\n         Returns:\n             A boolean, True if the address is within the\n             reserved IPv4 Network range.\n\n        ")
(NEWLINE)
(ID "reserved_network")
(PUNCT "=")
(ID "IPv4Network")
(PUNCT "(")
(LIT "240.0.0.0/4")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "reserved_network")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "lru_cache")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "is_private")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if this address is allocated for private networks.\n\n        Returns:\n            A boolean, True if the address is reserved per\n            iana-ipv4-special-registry.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "0.0.0.0/8")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "10.0.0.0/8")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "127.0.0.0/8")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "169.254.0.0/16")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "172.16.0.0/12")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "192.0.0.0/29")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "192.0.0.170/31")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "192.0.2.0/24")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "192.168.0.0/16")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "198.18.0.0/15")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "198.51.100.0/24")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "203.0.113.0/24")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "240.0.0.0/4")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "255.255.255.255/32")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_multicast")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for multicast use.\n\n        Returns:\n            A boolean, True if the address is multicast.\n            See RFC 3171 for details.\n\n        ")
(NEWLINE)
(ID "multicast_network")
(PUNCT "=")
(ID "IPv4Network")
(PUNCT "(")
(LIT "224.0.0.0/4")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "multicast_network")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_unspecified")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is unspecified.\n\n        Returns:\n            A boolean, True if this is the unspecified address as defined in\n            RFC 5735 3.\n\n        ")
(NEWLINE)
(ID "unspecified_address")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(LIT "0.0.0.0")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT "==")
(ID "unspecified_address")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_loopback")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is a loopback address.\n\n        Returns:\n            A boolean, True if the address is a loopback per RFC 3330.\n\n        ")
(NEWLINE)
(ID "loopback_network")
(PUNCT "=")
(ID "IPv4Network")
(PUNCT "(")
(LIT "127.0.0.0/8")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "loopback_network")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_link_local")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for link-local.\n\n        Returns:\n            A boolean, True if the address is link-local per RFC 3927.\n\n        ")
(NEWLINE)
(ID "linklocal_network")
(PUNCT "=")
(ID "IPv4Network")
(PUNCT "(")
(LIT "169.254.0.0/16")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "linklocal_network")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IPv4Interface")
(PUNCT "(")
(ID "IPv4Address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(PUNCT "(")
(ID "bytes")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "IPv4Address")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "=")
(ID "IPv4Network")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "addr")
(PUNCT "=")
(ID "_split_optional_netmask")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "IPv4Address")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "addr")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "=")
(ID "IPv4Network")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "_prefixlen")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "netmask")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "hostmask")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "hostmask")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_equal")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT ".")
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "address_equal")
(KEYWORD or)
(ID "address_equal")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "address_equal")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "network")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_less")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT ".")
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "address_less")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "network")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "^")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "^")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "ip")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv4Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_prefixlen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_netmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_hostmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "hostmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IPv4Network")
(PUNCT "(")
(ID "_BaseV4")
(PUNCT ",")
(ID "_BaseNetwork")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This class represents and manipulates 32-bit IPv4 network + addresses..\n\n    Attributes: [examples for IPv4Network('192.0.2.0/27')]\n        .network_address: IPv4Address('192.0.2.0')\n        .hostmask: IPv4Address('0.0.0.31')\n        .broadcast_address: IPv4Address('192.0.2.32')\n        .netmask: IPv4Address('255.255.255.224')\n        .prefixlen: 27\n\n    ")
(NEWLINE)
(ID "_address_class")
(PUNCT "=")
(ID "IPv4Address")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Instantiate a new IPv4 network object.\n\n        Args:\n            address: A string or integer representing the IP [& network].\n              '192.0.2.0/24'\n              '192.0.2.0/255.255.255.0'\n              '192.0.0.2/0.0.0.255'\n              are all functionally the same in IPv4. Similarly,\n              '192.0.2.1'\n              '192.0.2.1/255.255.255.255'\n              '192.0.2.1/32'\n              are also functionally equivalent. That is to say, failing to\n              provide a subnetmask will create an object with a mask of /32.\n\n              If the mask (portion after the / in the argument) is given in\n              dotted quad form, it is treated as a netmask if it starts with a\n              non-zero field (e.g. /255.0.0.0 == /8) and as a hostmask if it\n              starts with a zero field (e.g. 0.255.255.255 == /8), with the\n              single exception of an all-zero mask which is treated as a\n              netmask == /0. If no mask is given, a default of /32 is used.\n\n              Additionally, an integer can be passed, so\n              IPv4Network('192.0.2.1') == IPv4Network(3221225985)\n              or, more generally\n              IPv4Interface(int(IPv4Interface('192.0.2.1'))) ==\n                IPv4Interface('192.0.2.1')\n\n        Raises:\n            AddressValueError: If ipaddress isn't a valid IPv4 address.\n            NetmaskValueError: If the netmask isn't valid for\n              an IPv4 address.\n            ValueError: If strict is True and a network address is not\n              supplied.\n\n        ")
(NEWLINE)
(ID "_BaseV4")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "_BaseNetwork")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "addr")
(PUNCT "=")
(ID "_split_optional_netmask")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "addr")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "addr")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefix_from_prefix_string")
(PUNCT "(")
(ID "addr")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NetmaskValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefix_from_ip_string")
(PUNCT "(")
(ID "addr")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_prefix")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "strict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "IPv4Address")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "&")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT ")")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s has host bits set")
(PUNCT "%")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "&")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "==")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "hosts")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__iter__")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "lru_cache")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "is_global")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if this address is allocated for public networks.\n\n        Returns:\n            A boolean, True if the address is not reserved per\n            iana-ipv4-special-registry.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(KEYWORD not)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "100.64.0.0/10")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(KEYWORD in)
(ID "IPv4Network")
(PUNCT "(")
(LIT "100.64.0.0/10")
(PUNCT ")")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "is_private")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_BaseV6")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base IPv6 object.\n\n    The following methods are used by IPv6 objects in both single IP\n    addresses and networks.\n\n    ")
(NEWLINE)
(ID "_ALL_ONES")
(PUNCT "=")
(PUNCT "(")
(LIT 2)
(PUNCT "**")
(ID "IPV6LENGTH")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "_HEXTET_COUNT")
(PUNCT "=")
(LIT 8)
(NEWLINE)
(ID "_HEX_DIGITS")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(LIT "0123456789ABCDEFabcdef")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "=")
(LIT 6)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT "=")
(ID "IPV6LENGTH")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turn an IPv6 ip_str into an integer.\n\n        Args:\n            ip_str: A string, the IPv6 ip_str.\n\n        Returns:\n            An int, the IPv6 address\n\n        Raises:\n            AddressValueError: if ip_str isn't a valid IPv6 Address.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ip_str")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "Address cannot be empty")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parts")
(PUNCT "=")
(ID "ip_str")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(ID "_min_parts")
(PUNCT "=")
(LIT 3)
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "<")
(ID "_min_parts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "At least %d parts expected in %r")
(PUNCT "%")
(PUNCT "(")
(ID "_min_parts")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT ".")
(KEYWORD in)
(ID "parts")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ipv4_int")
(PUNCT "=")
(ID "IPv4Address")
(PUNCT "(")
(ID "parts")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "_ip")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AddressValueError")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "%s in %r")
(PUNCT "%")
(PUNCT "(")
(ID "exc")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "parts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%x")
(PUNCT "%")
(PUNCT "(")
(PUNCT "(")
(ID "ipv4_int")
(PUNCT ">>")
(LIT 16)
(PUNCT ")")
(PUNCT "&")
(LIT 65535)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "parts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%x")
(PUNCT "%")
(PUNCT "(")
(ID "ipv4_int")
(PUNCT "&")
(LIT 65535)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_max_parts")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_HEXTET_COUNT")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT ">")
(ID "_max_parts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "At most %d colons permitted in %r")
(PUNCT "%")
(PUNCT "(")
(ID "_max_parts")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "skip_index")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "parts")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "skip_index")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "At most one '::' permitted in %r")
(PUNCT "%")
(ID "ip_str")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "skip_index")
(PUNCT "=")
(ID "i")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "skip_index")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts_hi")
(PUNCT "=")
(ID "skip_index")
(NEWLINE)
(ID "parts_lo")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "-")
(ID "skip_index")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts_hi")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "parts_hi")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Leading ':' only permitted as part of '::' in %r")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "parts")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parts_lo")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "parts_lo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Trailing ':' only permitted as part of '::' in %r")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "parts_skipped")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_HEXTET_COUNT")
(PUNCT "-")
(PUNCT "(")
(ID "parts_hi")
(PUNCT "+")
(ID "parts_lo")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "parts_skipped")
(PUNCT "<")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Expected at most %d other parts with '::' in %r")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_HEXTET_COUNT")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "_HEXTET_COUNT")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Exactly %d parts expected without '::' in %r")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_HEXTET_COUNT")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Leading ':' only permitted as part of '::' in %r")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "parts")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Trailing ':' only permitted as part of '::' in %r")
(NEWLINE)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parts_hi")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(NEWLINE)
(ID "parts_lo")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "parts_skipped")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_int")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "parts_hi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_int")
(PUNCT "<<=")
(LIT 16)
(NEWLINE)
(ID "ip_int")
(PUNCT "|=")
(ID "self")
(PUNCT ".")
(ID "_parse_hextet")
(PUNCT "(")
(ID "parts")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ip_int")
(PUNCT "<<=")
(LIT 16)
(PUNCT "*")
(ID "parts_skipped")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(PUNCT "-")
(ID "parts_lo")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_int")
(PUNCT "<<=")
(LIT 16)
(NEWLINE)
(ID "ip_int")
(PUNCT "|=")
(ID "self")
(PUNCT ".")
(ID "_parse_hextet")
(PUNCT "(")
(ID "parts")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ip_int")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AddressValueError")
(PUNCT "(")
(LIT "%s in %r")
(PUNCT "%")
(PUNCT "(")
(ID "exc")
(PUNCT ",")
(ID "ip_str")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_parse_hextet")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "hextet_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert an IPv6 hextet string into an integer.\n\n        Args:\n            hextet_str: A string, the number to parse.\n\n        Returns:\n            The hextet as an integer.\n\n        Raises:\n            ValueError: if the input isn't strictly a hex number from\n              [0..FFFF].\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_HEX_DIGITS")
(PUNCT ".")
(ID "issuperset")
(PUNCT "(")
(ID "hextet_str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Only hex digits permitted in %r")
(PUNCT "%")
(ID "hextet_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "hextet_str")
(PUNCT ")")
(PUNCT ">")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "At most 4 characters permitted in %r")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "hextet_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "hextet_str")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_compress_hextets")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "hextets")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compresses a list of hextets.\n\n        Compresses a list of strings, replacing the longest continuous\n        sequence of \"0\" in the list with \"\" and adding empty strings at\n        the beginning or at the end of the string such that subsequently\n        calling \":\".join(hextets) will produce the compressed version of\n        the IPv6 address.\n\n        Args:\n            hextets: A list of strings, the hextets to compress.\n\n        Returns:\n            A list of strings.\n\n        ")
(NEWLINE)
(ID "best_doublecolon_start")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "best_doublecolon_len")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "doublecolon_start")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "doublecolon_len")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "index")
(PUNCT ",")
(ID "hextet")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "hextets")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hextet")
(PUNCT "==")
(LIT "0")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "doublecolon_len")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "doublecolon_start")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "doublecolon_start")
(PUNCT "=")
(ID "index")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "doublecolon_len")
(PUNCT ">")
(ID "best_doublecolon_len")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "best_doublecolon_len")
(PUNCT "=")
(ID "doublecolon_len")
(NEWLINE)
(ID "best_doublecolon_start")
(PUNCT "=")
(ID "doublecolon_start")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "doublecolon_len")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "doublecolon_start")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "best_doublecolon_len")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "best_doublecolon_end")
(PUNCT "=")
(PUNCT "(")
(ID "best_doublecolon_start")
(PUNCT "+")
(ID "best_doublecolon_len")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "best_doublecolon_end")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "hextets")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hextets")
(PUNCT "+=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "hextets")
(PUNCT "[")
(ID "best_doublecolon_start")
(PUNCT ":")
(ID "best_doublecolon_end")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "best_doublecolon_start")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hextets")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(PUNCT "+")
(ID "hextets")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "hextets")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ip_int")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Turns a 128-bit integer into hexadecimal notation.\n\n        Args:\n            ip_int: An integer, the IP address.\n\n        Returns:\n            A string, the hexadecimal representation of the address.\n\n        Raises:\n            ValueError: The address is bigger than 128 bits of all ones.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "ip_int")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_int")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ip_int")
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "IPv6 address is too large")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "hex_str")
(PUNCT "=")
(LIT "%032x")
(PUNCT "%")
(ID "ip_int")
(NEWLINE)
(ID "hextets")
(PUNCT "=")
(PUNCT "[")
(LIT "%x")
(PUNCT "%")
(ID "int")
(PUNCT "(")
(ID "hex_str")
(PUNCT "[")
(ID "x")
(PUNCT ":")
(ID "x")
(PUNCT "+")
(LIT 4)
(PUNCT "]")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 32)
(PUNCT ",")
(LIT 4)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "hextets")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_compress_hextets")
(PUNCT "(")
(ID "hextets")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT ":")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "hextets")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_explode_shorthand_ip_string")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Expand a shortened IPv6 address.\n\n        Args:\n            ip_str: A string, the IPv6 address.\n\n        Returns:\n            A string, the expanded IPv6 address.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_str")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "IPv6Interface")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_str")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ip_str")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ip_int")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "ip_str")
(PUNCT ")")
(NEWLINE)
(ID "hex_str")
(PUNCT "=")
(LIT "%032x")
(PUNCT "%")
(ID "ip_int")
(NEWLINE)
(ID "parts")
(PUNCT "=")
(PUNCT "[")
(ID "hex_str")
(PUNCT "[")
(ID "x")
(PUNCT ":")
(ID "x")
(PUNCT "+")
(LIT 4)
(PUNCT "]")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 32)
(PUNCT ",")
(LIT 4)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "(")
(ID "_BaseNetwork")
(PUNCT ",")
(ID "IPv6Interface")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(LIT ":")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT ":")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "max_prefixlen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "version")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_version")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IPv6Address")
(PUNCT "(")
(ID "_BaseV6")
(PUNCT ",")
(ID "_BaseAddress")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Represent and manipulate single IPv6 Addresses.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Instantiate a new IPv6 address object.\n\n        Args:\n            address: A string or integer representing the IP\n\n              Additionally, an integer can be passed, so\n              IPv6Address('2001:db8::') ==\n                IPv6Address(42540766411282592856903984951653826560)\n              or, more generally\n              IPv6Address(int(IPv6Address('2001:db8::'))) ==\n                IPv6Address('2001:db8::')\n\n        Raises:\n            AddressValueError: If address isn't a valid IPv6 address.\n\n        ")
(NEWLINE)
(ID "_BaseAddress")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "_BaseV6")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_check_int_address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "=")
(ID "address")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_check_packed_address")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(LIT 16)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "=")
(ID "int")
(PUNCT ".")
(ID "from_bytes")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "addr_str")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "addr_str")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "packed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The binary representation of this address.")
(NEWLINE)
(KEYWORD return)
(ID "v6_int_to_packed")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_multicast")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for multicast use.\n\n        Returns:\n            A boolean, True if the address is a multicast address.\n            See RFC 2373 2.7 for details.\n\n        ")
(NEWLINE)
(ID "multicast_network")
(PUNCT "=")
(ID "IPv6Network")
(PUNCT "(")
(LIT "ff00::/8")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "multicast_network")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_reserved")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is otherwise IETF reserved.\n\n        Returns:\n            A boolean, True if the address is within one of the\n            reserved IPv6 Network ranges.\n\n        ")
(NEWLINE)
(ID "reserved_networks")
(PUNCT "=")
(PUNCT "[")
(ID "IPv6Network")
(PUNCT "(")
(LIT "::/8")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "100::/8")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "200::/7")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "400::/6")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "800::/5")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "1000::/4")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "4000::/3")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "6000::/3")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "8000::/3")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "A000::/3")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "C000::/3")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "E000::/4")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "F000::/5")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "F800::/6")
(PUNCT ")")
(PUNCT ",")
(ID "IPv6Network")
(PUNCT "(")
(LIT "FE00::/9")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "any")
(PUNCT "(")
(ID "self")
(KEYWORD in)
(ID "x")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "reserved_networks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_link_local")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for link-local.\n\n        Returns:\n            A boolean, True if the address is reserved per RFC 4291.\n\n        ")
(NEWLINE)
(ID "linklocal_network")
(PUNCT "=")
(ID "IPv6Network")
(PUNCT "(")
(LIT "fe80::/10")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "linklocal_network")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_site_local")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for site-local.\n\n        Note that the site-local address space has been deprecated by RFC 3879.\n        Use is_private to test if this address is in the space of unique local\n        addresses as defined by RFC 4193.\n\n        Returns:\n            A boolean, True if the address is reserved per RFC 3513 2.5.6.\n\n        ")
(NEWLINE)
(ID "sitelocal_network")
(PUNCT "=")
(ID "IPv6Network")
(PUNCT "(")
(LIT "fec0::/10")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(KEYWORD in)
(ID "sitelocal_network")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "lru_cache")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "is_private")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if this address is allocated for private networks.\n\n        Returns:\n            A boolean, True if the address is reserved per\n            iana-ipv6-special-registry.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "::1/128")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "::/128")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "::ffff:0:0/96")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "100::/64")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "2001::/23")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "2001:2::/48")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "2001:db8::/32")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "2001:10::/28")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "fc00::/7")
(PUNCT ")")
(KEYWORD or)
(ID "self")
(KEYWORD in)
(ID "IPv6Network")
(PUNCT "(")
(LIT "fe80::/10")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_global")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if this address is allocated for public networks.\n\n        Returns:\n            A boolean, true if the address is not reserved per\n            iana-ipv6-special-registry.\n\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "is_private")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_unspecified")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is unspecified.\n\n        Returns:\n            A boolean, True if this is the unspecified address as defined in\n            RFC 2373 2.5.2.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "==")
(LIT 0)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_loopback")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is a loopback address.\n\n        Returns:\n            A boolean, True if the address is a loopback address as defined in\n            RFC 2373 2.5.3.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "ipv4_mapped")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the IPv4 mapped address.\n\n        Returns:\n            If the IPv6 address is a v4 mapped address, return the\n            IPv4 mapped address. Return None otherwise.\n\n        ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ">>")
(LIT 32)
(PUNCT ")")
(PUNCT "!=")
(LIT 65535)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "IPv4Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "&")
(LIT 4294967295)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "teredo")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Tuple of embedded teredo IPs.\n\n        Returns:\n            Tuple of the (server, client) IPs or None if the address\n            doesn't appear to be a teredo address (doesn't start with\n            2001::/32)\n\n        ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ">>")
(LIT 96)
(PUNCT ")")
(PUNCT "!=")
(LIT 536936448)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "IPv4Address")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ">>")
(LIT 64)
(PUNCT ")")
(PUNCT "&")
(LIT 4294967295)
(PUNCT ")")
(PUNCT ",")
(ID "IPv4Address")
(PUNCT "(")
(PUNCT "~")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "&")
(LIT 4294967295)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "sixtofour")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the IPv4 6to4 embedded address.\n\n        Returns:\n            The IPv4 6to4-embedded address if present or None if the\n            address doesn't appear to contain a 6to4 embedded address.\n\n        ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ">>")
(LIT 112)
(PUNCT ")")
(PUNCT "!=")
(LIT 8194)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "IPv4Address")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ">>")
(LIT 80)
(PUNCT ")")
(PUNCT "&")
(LIT 4294967295)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IPv6Interface")
(PUNCT "(")
(ID "IPv6Address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(PUNCT "(")
(ID "bytes")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "IPv6Address")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "=")
(ID "IPv6Network")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "addr")
(PUNCT "=")
(ID "_split_optional_netmask")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "IPv6Address")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "addr")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "=")
(ID "IPv6Network")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "netmask")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "_prefixlen")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "hostmask")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "hostmask")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%d")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_equal")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT ".")
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "address_equal")
(KEYWORD or)
(ID "address_equal")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "address_equal")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "network")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_less")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT ".")
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "address_less")
(KEYWORD is)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "network")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "^")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "^")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "ip")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IPv6Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_prefixlen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_netmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "with_hostmask")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_string_from_ip_int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "hostmask")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_unspecified")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "==")
(LIT 0)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "is_unspecified")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_loopback")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_ip")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "network")
(PUNCT ".")
(ID "is_loopback")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IPv6Network")
(PUNCT "(")
(ID "_BaseV6")
(PUNCT ",")
(ID "_BaseNetwork")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This class represents and manipulates 128-bit IPv6 networks.\n\n    Attributes: [examples for IPv6('2001:db8::1000/124')]\n        .network_address: IPv6Address('2001:db8::1000')\n        .hostmask: IPv6Address('::f')\n        .broadcast_address: IPv6Address('2001:db8::100f')\n        .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0')\n        .prefixlen: 124\n\n    ")
(NEWLINE)
(ID "_address_class")
(PUNCT "=")
(ID "IPv6Address")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Instantiate a new IPv6 Network object.\n\n        Args:\n            address: A string or integer representing the IPv6 network or the\n              IP and prefix/netmask.\n              '2001:db8::/128'\n              '2001:db8:0000:0000:0000:0000:0000:0000/128'\n              '2001:db8::'\n              are all functionally the same in IPv6.  That is to say,\n              failing to provide a subnetmask will create an object with\n              a mask of /128.\n\n              Additionally, an integer can be passed, so\n              IPv6Network('2001:db8::') ==\n                IPv6Network(42540766411282592856903984951653826560)\n              or, more generally\n              IPv6Network(int(IPv6Network('2001:db8::'))) ==\n                IPv6Network('2001:db8::')\n\n            strict: A boolean. If true, ensure that we have been passed\n              A true network address, eg, 2001:db8::1000/124 and not an\n              IP address on a network, eg, 2001:db8::1/124.\n\n        Raises:\n            AddressValueError: If address isn't a valid IPv6 address.\n            NetmaskValueError: If the netmask isn't valid for\n              an IPv6 address.\n            ValueError: If strict was True and a network address was not\n              supplied.\n\n        ")
(NEWLINE)
(ID "_BaseV6")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "_BaseNetwork")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "address")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ALL_ONES")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "addr")
(PUNCT "=")
(ID "_split_optional_netmask")
(PUNCT "(")
(ID "address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_string")
(PUNCT "(")
(ID "addr")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "addr")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefix_from_prefix_string")
(PUNCT "(")
(ID "addr")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_ip_int_from_prefix")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "strict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "IPv6Address")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "&")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT ")")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s has host bits set")
(PUNCT "%")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT "=")
(ID "IPv6Address")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(PUNCT "&")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "netmask")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_prefixlen")
(PUNCT "==")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_max_prefixlen")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "hosts")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__iter__")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "hosts")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate Iterator over usable hosts in a network.\n\n          This is like __iter__ except it doesn't return the\n          Subnet-Router anycast address.\n\n        ")
(NEWLINE)
(ID "network")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ")")
(NEWLINE)
(ID "broadcast")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "network")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "broadcast")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "_address_class")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "is_site_local")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test if the address is reserved for site-local.\n\n        Note that the site-local address space has been deprecated by RFC 3879.\n        Use is_private to test if this address is in the space of unique local\n        addresses as defined by RFC 4193.\n\n        Returns:\n            A boolean, True if the address is reserved per RFC 3513 2.5.6.\n\n        ")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "network_address")
(PUNCT ".")
(ID "is_site_local")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "broadcast_address")
(PUNCT ".")
(ID "is_site_local")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
