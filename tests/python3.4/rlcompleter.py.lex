(LIT "Word completion for GNU readline.\n\nThe completer completes keywords, built-ins and globals in a selectable\nnamespace (which defaults to __main__); when completing NAME.NAME..., it\nevaluates (!) the expression up to the last dot and completes its attributes.\n\nIt's very cool to do \"import sys\" type \"sys.\", hit the completion key (twice),\nand see the list of names defined by the sys module!\n\nTip: to use the tab key as the completion key, call\n\n    readline.parse_and_bind(\"tab: complete\")\n\nNotes:\n\n- Exceptions raised by the completer function are *ignored* (and generally cause\n  the completion to fail).  This is a feature -- since readline sets the tty\n  device in raw (or cbreak) mode, printing a traceback wouldn't work well\n  without some complicated hoopla to save, reset and restore the tty state.\n\n- The evaluation of the NAME.NAME... form may cause arbitrary application\n  defined code to be executed if an object with a __getattr__ hook is found.\n  Since it is the responsibility of the application (or the user) to enable this\n  feature, I consider this an acceptable risk.  More complicated expressions\n  (e.g. function calls or indexing operations) are *not* evaluated.\n\n- When the original stdin is not a tty device, GNU readline is never\n  used, and this module (and the readline module) are silently inactive.\n\n")
(NEWLINE)
(KEYWORD import)
(ID "atexit")
(NEWLINE)
(KEYWORD import)
(ID "builtins")
(NEWLINE)
(KEYWORD import)
(ID "__main__")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Completer")
(PUNCT "]")
(NEWLINE)
(KEYWORD class)
(ID "Completer")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "namespace")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a new completer for the command line.\n\n        Completer([namespace]) -> completer instance.\n\n        If unspecified, the default namespace where completions are performed\n        is __main__ (technically, __main__.__dict__). Namespaces should be\n        given as dictionaries.\n\n        Completer instances should be used as the completion mechanism of\n        readline via the set_completer() call:\n\n        readline.set_completer(Completer(my_namespace).complete)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "namespace")
(KEYWORD and)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "namespace")
(PUNCT ",")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "namespace must be a dictionary")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "namespace")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "use_main_ns")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "use_main_ns")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "namespace")
(PUNCT "=")
(ID "namespace")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "complete")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "state")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the next possible completion for 'text'.\n\n        This is called successively with state == 0, 1, 2, ... until it\n        returns None.  The completion should begin with 'text'.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "use_main_ns")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "namespace")
(PUNCT "=")
(ID "__main__")
(PUNCT ".")
(ID "__dict__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "state")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT ".")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "matches")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "attr_matches")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "matches")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "global_matches")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "matches")
(PUNCT "[")
(ID "state")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_callable_postfix")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "val")
(PUNCT ",")
(ID "word")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "callable")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "word")
(PUNCT "=")
(ID "word")
(PUNCT "+")
(LIT "(")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "word")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "global_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute matches when text is a simple name.\n\n        Return a list of all keywords, built-in functions and names currently\n        defined in self.namespace that match.\n\n        ")
(NEWLINE)
(KEYWORD import)
(ID "keyword")
(NEWLINE)
(ID "matches")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "word")
(KEYWORD in)
(ID "keyword")
(PUNCT ".")
(ID "kwlist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "word")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(PUNCT "==")
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "matches")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "word")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "nspace")
(KEYWORD in)
(PUNCT "[")
(ID "builtins")
(PUNCT ".")
(ID "__dict__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "namespace")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "word")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "nspace")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "word")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(PUNCT "==")
(ID "text")
(KEYWORD and)
(ID "word")
(PUNCT "!=")
(LIT "__builtins__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "matches")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_callable_postfix")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "word")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "matches")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "attr_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute matches when text contains a dot.\n\n        Assuming the text is of the form NAME.NAME....[NAME], and is\n        evaluable in self.namespace, it will be evaluated and its attributes\n        (as revealed by dir()) are used as possible completions.  (For class\n        instances, class members are also considered.)\n\n        WARNING: this can still invoke arbitrary C code, if an object\n        with a __getattr__ hook is evaluated.\n\n        ")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(ID "m")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "(\\w+(\\.\\w+)*)\\.(\\w*)")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "expr")
(PUNCT ",")
(ID "attr")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "thisobject")
(PUNCT "=")
(ID "eval")
(PUNCT "(")
(ID "expr")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "namespace")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "words")
(PUNCT "=")
(ID "dir")
(PUNCT "(")
(ID "thisobject")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "__builtins__")
(KEYWORD in)
(ID "words")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "words")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(LIT "__builtins__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "thisobject")
(PUNCT ",")
(LIT "__class__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "words")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "__class__")
(PUNCT ")")
(NEWLINE)
(ID "words")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "get_class_members")
(PUNCT "(")
(ID "thisobject")
(PUNCT ".")
(ID "__class__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "matches")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "attr")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "word")
(KEYWORD in)
(ID "words")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "word")
(PUNCT "[")
(PUNCT ":")
(ID "n")
(PUNCT "]")
(PUNCT "==")
(ID "attr")
(KEYWORD and)
(ID "hasattr")
(PUNCT "(")
(ID "thisobject")
(PUNCT ",")
(ID "word")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "val")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "thisobject")
(PUNCT ",")
(ID "word")
(PUNCT ")")
(NEWLINE)
(ID "word")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_callable_postfix")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(LIT "%s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "expr")
(PUNCT ",")
(ID "word")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "matches")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "word")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "matches")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_class_members")
(PUNCT "(")
(ID "klass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret")
(PUNCT "=")
(ID "dir")
(PUNCT "(")
(ID "klass")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "klass")
(PUNCT ",")
(LIT "__bases__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "klass")
(PUNCT ".")
(ID "__bases__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret")
(PUNCT "=")
(ID "ret")
(PUNCT "+")
(ID "get_class_members")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "ret")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "readline")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "readline")
(PUNCT ".")
(ID "set_completer")
(PUNCT "(")
(ID "Completer")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "complete")
(PUNCT ")")
(NEWLINE)
(ID "atexit")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(KEYWORD lambda)
(PUNCT ":")
(ID "readline")
(PUNCT ".")
(ID "set_completer")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
