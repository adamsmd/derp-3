(LIT "Utility functions for copying and archiving files and directory trees.\n\nXXX The functions here don't copy the resource fork or other metadata on Mac.\n\n")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "stat")
(NEWLINE)
(KEYWORD from)
(ID "os")
(PUNCT ".")
(ID "path")
(KEYWORD import)
(ID "abspath")
(NEWLINE)
(KEYWORD import)
(ID "fnmatch")
(NEWLINE)
(KEYWORD import)
(ID "collections")
(NEWLINE)
(KEYWORD import)
(ID "errno")
(NEWLINE)
(KEYWORD import)
(ID "tarfile")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "bz2")
(NEWLINE)
(KEYWORD del)
(ID "bz2")
(NEWLINE)
(ID "_BZ2_SUPPORTED")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_BZ2_SUPPORTED")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "pwd")
(KEYWORD import)
(ID "getpwnam")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "getpwnam")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "grp")
(KEYWORD import)
(ID "getgrnam")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "getgrnam")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "copyfileobj")
(PUNCT ",")
(LIT "copyfile")
(PUNCT ",")
(LIT "copymode")
(PUNCT ",")
(LIT "copystat")
(PUNCT ",")
(LIT "copy")
(PUNCT ",")
(LIT "copy2")
(PUNCT ",")
(LIT "copytree")
(PUNCT ",")
(LIT "move")
(PUNCT ",")
(LIT "rmtree")
(PUNCT ",")
(LIT "Error")
(PUNCT ",")
(LIT "SpecialFileError")
(PUNCT ",")
(LIT "ExecError")
(PUNCT ",")
(LIT "make_archive")
(PUNCT ",")
(LIT "get_archive_formats")
(PUNCT ",")
(LIT "register_archive_format")
(PUNCT ",")
(LIT "unregister_archive_format")
(PUNCT ",")
(LIT "get_unpack_formats")
(PUNCT ",")
(LIT "register_unpack_format")
(PUNCT ",")
(LIT "unregister_unpack_format")
(PUNCT ",")
(LIT "unpack_archive")
(PUNCT ",")
(LIT "ignore_patterns")
(PUNCT ",")
(LIT "chown")
(PUNCT ",")
(LIT "which")
(PUNCT ",")
(LIT "get_terminal_size")
(PUNCT ",")
(LIT "SameFileError")
(PUNCT "]")
(NEWLINE)
(KEYWORD class)
(ID "Error")
(PUNCT "(")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "SameFileError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when source and destination are the same file.")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "SpecialFileError")
(PUNCT "(")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when trying to do a kind of operation (e.g. copying) which is\n    not supported on a special file (e.g. a named pipe)")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "ExecError")
(PUNCT "(")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when a command could not be executed")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "ReadError")
(PUNCT "(")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when an archive cannot be read")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "RegistryError")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when a registry operation with the archiving\n    and unpacking registeries fails")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copyfileobj")
(PUNCT "(")
(ID "fsrc")
(PUNCT ",")
(ID "fdst")
(PUNCT ",")
(ID "length")
(PUNCT "=")
(LIT 16)
(PUNCT "*")
(LIT 1024)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "copy data from file-like object fsrc to file-like object fdst")
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT "=")
(ID "fsrc")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "length")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "buf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "fdst")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "buf")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_samefile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ",")
(LIT "samefile")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "samefile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "abspath")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ")")
(PUNCT "==")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "abspath")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copyfile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copy data from src to dst.\n\n    If follow_symlinks is not set and src is a symbolic link, a new\n    symlink will be created instead of copying the file it points to.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "_samefile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "SameFileError")
(PUNCT "(")
(LIT "{!r} and {!r} are the same file")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(PUNCT "[")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "st")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "stat")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "stat")
(PUNCT ".")
(ID "S_ISFIFO")
(PUNCT "(")
(ID "st")
(PUNCT ".")
(ID "st_mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "SpecialFileError")
(PUNCT "(")
(LIT "`%s` is a named pipe")
(PUNCT "%")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "follow_symlinks")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "symlink")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "readlink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(KEYWORD as)
(ID "fsrc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(LIT "wb")
(PUNCT ")")
(KEYWORD as)
(ID "fdst")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "copyfileobj")
(PUNCT "(")
(ID "fsrc")
(PUNCT ",")
(ID "fdst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "dst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copymode")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copy mode bits from src to dst.\n\n    If follow_symlinks is not set, symlinks aren't followed if and only\n    if both `src` and `dst` are symlinks.  If `lchmod` isn't available\n    (e.g. Linux) this method does nothing.\n\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "follow_symlinks")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "lchmod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stat_func")
(PUNCT ",")
(ID "chmod_func")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "lstat")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "lchmod")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "chmod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stat_func")
(PUNCT ",")
(ID "chmod_func")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "stat")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "chmod")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "st")
(PUNCT "=")
(ID "stat_func")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(ID "chmod_func")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "stat")
(PUNCT ".")
(ID "S_IMODE")
(PUNCT "(")
(ID "st")
(PUNCT ".")
(ID "st_mode")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "listxattr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "_copyxattr")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copy extended filesystem attributes from `src` to `dst`.\n\n        Overwrite existing attributes.\n\n        If `follow_symlinks` is false, symlinks won't be followed.\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listxattr")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "errno")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(ID "errno")
(PUNCT ".")
(ID "ENOTSUP")
(PUNCT ",")
(ID "errno")
(PUNCT ".")
(ID "ENODATA")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "getxattr")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "setxattr")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "errno")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(ID "errno")
(PUNCT ".")
(ID "EPERM")
(PUNCT ",")
(ID "errno")
(PUNCT ".")
(ID "ENOTSUP")
(PUNCT ",")
(ID "errno")
(PUNCT ".")
(ID "ENODATA")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "_copyxattr")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "copystat")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copy all stat info (mode bits, atime, mtime, flags) from src to dst.\n\n    If the optional flag `follow_symlinks` is not set, symlinks aren't followed if and\n    only if both `src` and `dst` are symlinks.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "_nop")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(ID "ns")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "follow")
(PUNCT "=")
(ID "follow_symlinks")
(KEYWORD or)
(KEYWORD not)
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "follow")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "lookup")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "getattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "_nop")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "lookup")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fn")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "_nop")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "fn")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "supports_follow_symlinks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fn")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_nop")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "st")
(PUNCT "=")
(ID "lookup")
(PUNCT "(")
(LIT "stat")
(PUNCT ")")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow")
(PUNCT ")")
(NEWLINE)
(ID "mode")
(PUNCT "=")
(ID "stat")
(PUNCT ".")
(ID "S_IMODE")
(PUNCT "(")
(ID "st")
(PUNCT ".")
(ID "st_mode")
(PUNCT ")")
(NEWLINE)
(ID "lookup")
(PUNCT "(")
(LIT "utime")
(PUNCT ")")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "ns")
(PUNCT "=")
(PUNCT "(")
(ID "st")
(PUNCT ".")
(ID "st_atime_ns")
(PUNCT ",")
(ID "st")
(PUNCT ".")
(ID "st_mtime_ns")
(PUNCT ")")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lookup")
(PUNCT "(")
(LIT "chmod")
(PUNCT ")")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "mode")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NotImplementedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "st")
(PUNCT ",")
(LIT "st_flags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lookup")
(PUNCT "(")
(LIT "chflags")
(PUNCT ")")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "st")
(PUNCT ".")
(ID "st_flags")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "why")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "err")
(KEYWORD in)
(LIT "EOPNOTSUPP")
(PUNCT ",")
(LIT "ENOTSUP")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "errno")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(KEYWORD and)
(ID "why")
(PUNCT ".")
(ID "errno")
(PUNCT "==")
(ID "getattr")
(PUNCT "(")
(ID "errno")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "_copyxattr")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copy data and mode bits (\"cp src dst\"). Return the file's destination.\n\n    The destination may be a directory.\n\n    If follow_symlinks is false, symlinks won't be followed. This\n    resembles GNU's \"cp -P src dst\".\n\n    If source and destination are the same file, a SameFileError will be\n    raised.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dst")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "copyfile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(ID "copymode")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "dst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy2")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Copy data and all stat info (\"cp -p src dst\"). Return the file's\n    destination.\"\n\n    The destination may be a directory.\n\n    If follow_symlinks is false, symlinks won't be followed. This\n    resembles GNU's \"cp -P src dst\".\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dst")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "copyfile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(ID "copystat")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(ID "follow_symlinks")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "dst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ignore_patterns")
(PUNCT "(")
(PUNCT "*")
(ID "patterns")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Function that can be used as copytree() ignore parameter.\n\n    Patterns is a sequence of glob-style patterns\n    that are used to exclude files")
(NEWLINE)
(KEYWORD def)
(ID "_ignore_patterns")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "names")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ignored_names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "pattern")
(KEYWORD in)
(ID "patterns")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ignored_names")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "fnmatch")
(PUNCT ".")
(ID "filter")
(PUNCT "(")
(ID "names")
(PUNCT ",")
(ID "pattern")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "set")
(PUNCT "(")
(ID "ignored_names")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_ignore_patterns")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copytree")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "symlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "ignore")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "copy_function")
(PUNCT "=")
(ID "copy2")
(PUNCT ",")
(ID "ignore_dangling_symlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Recursively copy a directory tree.\n\n    The destination directory must not already exist.\n    If exception(s) occur, an Error is raised with a list of reasons.\n\n    If the optional symlinks flag is true, symbolic links in the\n    source tree result in symbolic links in the destination tree; if\n    it is false, the contents of the files pointed to by symbolic\n    links are copied. If the file pointed by the symlink doesn't\n    exist, an exception will be added in the list of errors raised in\n    an Error exception at the end of the copy process.\n\n    You can set the optional ignore_dangling_symlinks flag to true if you\n    want to silence this exception. Notice that this has no effect on\n    platforms that don't support os.symlink.\n\n    The optional ignore argument is a callable. If given, it\n    is called with the `src` parameter, which is the directory\n    being visited by copytree(), and `names` which is the list of\n    `src` contents, as returned by os.listdir():\n\n        callable(src, names) -> ignored_names\n\n    Since copytree() is called recursively, the callable will be\n    called once for each directory that is copied. It returns a\n    list of names relative to the `src` directory that should\n    not be copied.\n\n    The optional copy_function argument is a callable that will be used\n    to copy each file. It will be called with the source path and the\n    destination path as arguments. By default, copy2() is used, but any\n    function that supports the same signature (like copy()) can be used.\n\n    ")
(NEWLINE)
(ID "names")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ignore")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ignored_names")
(PUNCT "=")
(ID "ignore")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "names")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ignored_names")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "os")
(PUNCT ".")
(ID "makedirs")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(NEWLINE)
(ID "errors")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "ignored_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "srcname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "dstname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "srcname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "linkto")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "readlink")
(PUNCT "(")
(ID "srcname")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "symlinks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "symlink")
(PUNCT "(")
(ID "linkto")
(PUNCT ",")
(ID "dstname")
(PUNCT ")")
(NEWLINE)
(ID "copystat")
(PUNCT "(")
(ID "srcname")
(PUNCT ",")
(ID "dstname")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD not)
(ID "symlinks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "linkto")
(PUNCT ")")
(KEYWORD and)
(ID "ignore_dangling_symlinks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "copy_function")
(PUNCT "(")
(ID "srcname")
(PUNCT ",")
(ID "dstname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "srcname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "copytree")
(PUNCT "(")
(ID "srcname")
(PUNCT ",")
(ID "dstname")
(PUNCT ",")
(ID "symlinks")
(PUNCT ",")
(ID "ignore")
(PUNCT ",")
(ID "copy_function")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "copy_function")
(PUNCT "(")
(ID "srcname")
(PUNCT ",")
(ID "dstname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "Error")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "err")
(PUNCT ".")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "why")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "srcname")
(PUNCT ",")
(ID "dstname")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "why")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "copystat")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "why")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "why")
(PUNCT ",")
(LIT "winerror")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errors")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "why")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "errors")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "Error")
(PUNCT "(")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "dst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_rmtree_unsafe")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "Cannot call rmtree on a symbolic link")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "lstat")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(PUNCT ".")
(ID "st_mode")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "stat")
(PUNCT ".")
(ID "S_ISDIR")
(PUNCT "(")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_rmtree_unsafe")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_rmtree_safe_fd")
(PUNCT "(")
(ID "topfd")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "err")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "path")
(NEWLINE)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "orig_st")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "stat")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ",")
(ID "follow_symlinks")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "mode")
(PUNCT "=")
(ID "orig_st")
(PUNCT ".")
(ID "st_mode")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "stat")
(PUNCT ".")
(ID "S_ISDIR")
(PUNCT "(")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirfd")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "O_RDONLY")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "open")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "samestat")
(PUNCT "(")
(ID "orig_st")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "fstat")
(PUNCT "(")
(ID "dirfd")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_rmtree_safe_fd")
(PUNCT "(")
(ID "dirfd")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "Cannot call rmtree on a symbolic ")
(LIT "link")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(ID "dirfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dir_fd")
(PUNCT "=")
(ID "topfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "_use_fd_functions")
(PUNCT "=")
(PUNCT "(")
(PUNCT "{")
(ID "os")
(PUNCT ".")
(ID "open")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "stat")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT "}")
(PUNCT "<=")
(ID "os")
(PUNCT ".")
(ID "supports_dir_fd")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "listdir")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "supports_fd")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "stat")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "supports_follow_symlinks")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "rmtree")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "ignore_errors")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "onerror")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Recursively delete a directory tree.\n\n    If ignore_errors is set, errors are ignored; otherwise, if onerror\n    is set, it is called to handle the error with arguments (func,\n    path, exc_info) where func is platform and implementation dependent;\n    path is the argument to that function that caused it to fail; and\n    exc_info is a tuple returned by sys.exc_info().  If ignore_errors\n    is false and onerror is None, an exception is raised.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "ignore_errors")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "onerror")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "onerror")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "onerror")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "_use_fd_functions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fsdecode")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "orig_st")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "lstat")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "lstat")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fd")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "O_RDONLY")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "lstat")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "samestat")
(PUNCT "(")
(ID "orig_st")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "fstat")
(PUNCT "(")
(ID "fd")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_rmtree_safe_fd")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "rmdir")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "Cannot call rmtree on a symbolic link")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(ID "fd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_rmtree_unsafe")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "rmtree")
(PUNCT ".")
(ID "avoids_symlink_attacks")
(PUNCT "=")
(ID "_use_fd_functions")
(NEWLINE)
(KEYWORD def)
(ID "_basename")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sep")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "sep")
(PUNCT "+")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "altsep")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "path")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(ID "sep")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "move")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Recursively move a file or directory to another location. This is\n    similar to the Unix \"mv\" command. Return the file or directory's\n    destination.\n\n    If the destination is a directory or a symlink to a directory, the source\n    is moved inside the directory. The destination path must not already\n    exist.\n\n    If the destination already exists but is not a directory, it may be\n    overwritten depending on os.rename() semantics.\n\n    If the destination is on our current filesystem, then rename() is used.\n    Otherwise, src is copied to the destination and then removed. Symlinks are\n    recreated under the new name if os.rename() fails because of cross\n    filesystem renames.\n\n    A lot more could be done here...  A look at a mv.c shows a lot of\n    the issues this implementation glosses over.\n\n    ")
(NEWLINE)
(ID "real_dst")
(PUNCT "=")
(ID "dst")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_samefile")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "rename")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "real_dst")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dst")
(PUNCT ",")
(ID "_basename")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "real_dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "Error")
(PUNCT "(")
(LIT "Destination path '%s' already exists")
(PUNCT "%")
(ID "real_dst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "rename")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "real_dst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "linkto")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "readlink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "symlink")
(PUNCT "(")
(ID "linkto")
(PUNCT ",")
(ID "real_dst")
(PUNCT ")")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_destinsrc")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "Error")
(PUNCT "(")
(LIT "Cannot move a directory '%s' into itself '%s'.")
(PUNCT "%")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "copytree")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "real_dst")
(PUNCT ",")
(ID "symlinks")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "rmtree")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "copy2")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "real_dst")
(PUNCT ")")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "real_dst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_destinsrc")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "src")
(PUNCT "=")
(ID "abspath")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(ID "dst")
(PUNCT "=")
(ID "abspath")
(PUNCT "(")
(ID "dst")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "src")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "sep")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "src")
(PUNCT "+=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "sep")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "dst")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "sep")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dst")
(PUNCT "+=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "sep")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "dst")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_gid")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a gid, given a group name.")
(NEWLINE)
(KEYWORD if)
(ID "getgrnam")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "getgrnam")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "result")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_uid")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns an uid, given a user name.")
(NEWLINE)
(KEYWORD if)
(ID "getpwnam")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "getpwnam")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "result")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "result")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_make_tarball")
(PUNCT "(")
(ID "base_name")
(PUNCT ",")
(ID "base_dir")
(PUNCT ",")
(ID "compress")
(PUNCT "=")
(LIT "gzip")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "owner")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "group")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "logger")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a (possibly compressed) tar file from all the files under\n    'base_dir'.\n\n    'compress' must be \"gzip\" (the default), \"bzip2\", or None.\n\n    'owner' and 'group' can be used to define an owner and a group for the\n    archive that is being built. If not provided, the current owner and group\n    will be used.\n\n    The output tar file will be named 'base_name' +  \".tar\", possibly plus\n    the appropriate compression extension (\".gz\", or \".bz2\").\n\n    Returns the output filename.\n    ")
(NEWLINE)
(ID "tar_compression")
(PUNCT "=")
(PUNCT "{")
(LIT "gzip")
(PUNCT ":")
(LIT "gz")
(PUNCT ",")
(KEYWORD None)
(PUNCT ":")
(LIT "")
(PUNCT "}")
(NEWLINE)
(ID "compress_ext")
(PUNCT "=")
(PUNCT "{")
(LIT "gzip")
(PUNCT ":")
(LIT ".gz")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "_BZ2_SUPPORTED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tar_compression")
(PUNCT "[")
(LIT "bzip2")
(PUNCT "]")
(PUNCT "=")
(LIT "bz2")
(NEWLINE)
(ID "compress_ext")
(PUNCT "[")
(LIT "bzip2")
(PUNCT "]")
(PUNCT "=")
(LIT ".bz2")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "compress")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "compress")
(KEYWORD not)
(KEYWORD in)
(ID "compress_ext")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "bad value for 'compress', or compression format not ")
(LIT "supported : {0}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "compress")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "archive_name")
(PUNCT "=")
(ID "base_name")
(PUNCT "+")
(LIT ".tar")
(PUNCT "+")
(ID "compress_ext")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "compress")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "archive_dir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "archive_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "archive_dir")
(KEYWORD and)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "archive_dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "creating %s")
(PUNCT ",")
(ID "archive_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "makedirs")
(PUNCT "(")
(ID "archive_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "Creating tar archive")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "uid")
(PUNCT "=")
(ID "_get_uid")
(PUNCT "(")
(ID "owner")
(PUNCT ")")
(NEWLINE)
(ID "gid")
(PUNCT "=")
(ID "_get_gid")
(PUNCT "(")
(ID "group")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_set_uid_gid")
(PUNCT "(")
(ID "tarinfo")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "gid")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tarinfo")
(PUNCT ".")
(ID "gid")
(PUNCT "=")
(ID "gid")
(NEWLINE)
(ID "tarinfo")
(PUNCT ".")
(ID "gname")
(PUNCT "=")
(ID "group")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "uid")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tarinfo")
(PUNCT ".")
(ID "uid")
(PUNCT "=")
(ID "uid")
(NEWLINE)
(ID "tarinfo")
(PUNCT ".")
(ID "uname")
(PUNCT "=")
(ID "owner")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "tarinfo")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tar")
(PUNCT "=")
(ID "tarfile")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "archive_name")
(PUNCT ",")
(LIT "w|%s")
(PUNCT "%")
(ID "tar_compression")
(PUNCT "[")
(ID "compress")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tar")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "base_dir")
(PUNCT ",")
(ID "filter")
(PUNCT "=")
(ID "_set_uid_gid")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tar")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "archive_name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_call_external_zip")
(PUNCT "(")
(ID "base_dir")
(PUNCT ",")
(ID "zip_filename")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zipoptions")
(PUNCT "=")
(LIT "-r")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zipoptions")
(PUNCT "=")
(LIT "-rq")
(NEWLINE)
(DEDENT)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "errors")
(KEYWORD import)
(ID "DistutilsExecError")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "spawn")
(KEYWORD import)
(ID "spawn")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spawn")
(PUNCT "(")
(PUNCT "[")
(LIT "zip")
(PUNCT ",")
(ID "zipoptions")
(PUNCT ",")
(ID "zip_filename")
(PUNCT ",")
(ID "base_dir")
(PUNCT "]")
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "DistutilsExecError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ExecError")
(PUNCT "(")
(LIT "unable to create zip file '%s': ")
(LIT "could neither import the 'zipfile' module nor ")
(LIT "find a standalone zip utility")
(PUNCT ")")
(PUNCT "%")
(ID "zip_filename")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_make_zipfile")
(PUNCT "(")
(ID "base_name")
(PUNCT ",")
(ID "base_dir")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "logger")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a zip file from all the files under 'base_dir'.\n\n    The output zip file will be named 'base_name' + \".zip\".  Uses either the\n    \"zipfile\" Python module (if available) or the InfoZIP \"zip\" utility\n    (if installed and found on the default search path).  If neither tool is\n    available, raises ExecError.  Returns the name of the output zip\n    file.\n    ")
(NEWLINE)
(ID "zip_filename")
(PUNCT "=")
(ID "base_name")
(PUNCT "+")
(LIT ".zip")
(NEWLINE)
(ID "archive_dir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "base_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "archive_dir")
(KEYWORD and)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "archive_dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "creating %s")
(PUNCT ",")
(ID "archive_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "makedirs")
(PUNCT "(")
(ID "archive_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "zipfile")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zipfile")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "zipfile")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_call_external_zip")
(PUNCT "(")
(ID "base_dir")
(PUNCT ",")
(ID "zip_filename")
(PUNCT ",")
(ID "verbose")
(PUNCT ",")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "creating '%s' and adding '%s' to it")
(PUNCT ",")
(ID "zip_filename")
(PUNCT ",")
(ID "base_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "zipfile")
(PUNCT ".")
(ID "ZipFile")
(PUNCT "(")
(ID "zip_filename")
(PUNCT ",")
(LIT "w")
(PUNCT ",")
(ID "compression")
(PUNCT "=")
(ID "zipfile")
(PUNCT ".")
(ID "ZIP_DEFLATED")
(PUNCT ")")
(KEYWORD as)
(ID "zf")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "dirpath")
(PUNCT ",")
(ID "dirnames")
(PUNCT ",")
(ID "filenames")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "walk")
(PUNCT "(")
(ID "base_dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "filenames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normpath")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dirpath")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isfile")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zf")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "adding '%s'")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "zip_filename")
(NEWLINE)
(DEDENT)
(ID "_ARCHIVE_FORMATS")
(PUNCT "=")
(PUNCT "{")
(LIT "gztar")
(PUNCT ":")
(PUNCT "(")
(ID "_make_tarball")
(PUNCT ",")
(PUNCT "[")
(PUNCT "(")
(LIT "compress")
(PUNCT ",")
(LIT "gzip")
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(LIT "gzip'ed tar-file")
(PUNCT ")")
(PUNCT ",")
(LIT "tar")
(PUNCT ":")
(PUNCT "(")
(ID "_make_tarball")
(PUNCT ",")
(PUNCT "[")
(PUNCT "(")
(LIT "compress")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(LIT "uncompressed tar file")
(PUNCT ")")
(PUNCT ",")
(LIT "zip")
(PUNCT ":")
(PUNCT "(")
(ID "_make_zipfile")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(LIT "ZIP file")
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "_BZ2_SUPPORTED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_ARCHIVE_FORMATS")
(PUNCT "[")
(LIT "bztar")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "_make_tarball")
(PUNCT ",")
(PUNCT "[")
(PUNCT "(")
(LIT "compress")
(PUNCT ",")
(LIT "bzip2")
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(LIT "bzip2'ed tar-file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_archive_formats")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a list of supported formats for archiving and unarchiving.\n\n    Each element of the returned sequence is a tuple (name, description)\n    ")
(NEWLINE)
(ID "formats")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "registry")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "registry")
(KEYWORD in)
(ID "_ARCHIVE_FORMATS")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "formats")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "formats")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "register_archive_format")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "function")
(PUNCT ",")
(ID "extra_args")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "description")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Registers an archive format.\n\n    name is the name of the format. function is the callable that will be\n    used to create archives. If provided, extra_args is a sequence of\n    (name, value) tuples that will be passed as arguments to the callable.\n    description can be provided to describe the format, and will be returned\n    by the get_archive_formats() function.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "extra_args")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extra_args")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "callable")
(PUNCT "(")
(ID "function")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "The %s object is not callable")
(PUNCT "%")
(ID "function")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "extra_args")
(PUNCT ",")
(PUNCT "(")
(ID "tuple")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "extra_args needs to be a sequence")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "element")
(KEYWORD in)
(ID "extra_args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "element")
(PUNCT ",")
(PUNCT "(")
(ID "tuple")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ")")
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "element")
(PUNCT ")")
(PUNCT "!=")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "extra_args elements are : (arg_name, value)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_ARCHIVE_FORMATS")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "function")
(PUNCT ",")
(ID "extra_args")
(PUNCT ",")
(ID "description")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unregister_archive_format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_ARCHIVE_FORMATS")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "make_archive")
(PUNCT "(")
(ID "base_name")
(PUNCT ",")
(ID "format")
(PUNCT ",")
(ID "root_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "base_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "owner")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "group")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "logger")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create an archive file (eg. zip or tar).\n\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"bztar\"\n    or \"gztar\".\n\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the\n    archive.  'base_dir' is the directory where we start archiving from;\n    ie. 'base_dir' will be the common prefix of all files and\n    directories in the archive.  'root_dir' and 'base_dir' both default\n    to the current directory.  Returns the name of the archive file.\n\n    'owner' and 'group' are used when creating a tar archive. By default,\n    uses the current owner and group.\n    ")
(NEWLINE)
(ID "save_cwd")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "getcwd")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "root_dir")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(LIT "changing into '%s'")
(PUNCT ",")
(ID "root_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "base_name")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "abspath")
(PUNCT "(")
(ID "base_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "chdir")
(PUNCT "(")
(ID "root_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "base_dir")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "base_dir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "curdir")
(NEWLINE)
(DEDENT)
(ID "kwargs")
(PUNCT "=")
(PUNCT "{")
(LIT "dry_run")
(PUNCT ":")
(ID "dry_run")
(PUNCT ",")
(LIT "logger")
(PUNCT ":")
(ID "logger")
(PUNCT "}")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_info")
(PUNCT "=")
(ID "_ARCHIVE_FORMATS")
(PUNCT "[")
(ID "format")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown archive format '%s'")
(PUNCT "%")
(ID "format")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "func")
(PUNCT "=")
(ID "format_info")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "arg")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "format_info")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwargs")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT "=")
(ID "val")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "format")
(PUNCT "!=")
(LIT "zip")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwargs")
(PUNCT "[")
(LIT "owner")
(PUNCT "]")
(PUNCT "=")
(ID "owner")
(NEWLINE)
(ID "kwargs")
(PUNCT "[")
(LIT "group")
(PUNCT "]")
(PUNCT "=")
(ID "group")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "func")
(PUNCT "(")
(ID "base_name")
(PUNCT ",")
(ID "base_dir")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "root_dir")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "logger")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(LIT "changing back to '%s'")
(PUNCT ",")
(ID "save_cwd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "os")
(PUNCT ".")
(ID "chdir")
(PUNCT "(")
(ID "save_cwd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "filename")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_unpack_formats")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a list of supported formats for unpacking.\n\n    Each element of the returned sequence is a tuple\n    (name, extensions, description)\n    ")
(NEWLINE)
(ID "formats")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "info")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "info")
(PUNCT "[")
(LIT 3)
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "info")
(KEYWORD in)
(ID "_UNPACK_FORMATS")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "formats")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "formats")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_check_unpack_options")
(PUNCT "(")
(ID "extensions")
(PUNCT ",")
(ID "function")
(PUNCT ",")
(ID "extra_args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Checks what gets registered as an unpacker.")
(NEWLINE)
(ID "existing_extensions")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "info")
(KEYWORD in)
(ID "_UNPACK_FORMATS")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "ext")
(KEYWORD in)
(ID "info")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "existing_extensions")
(PUNCT "[")
(ID "ext")
(PUNCT "]")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "extension")
(KEYWORD in)
(ID "extensions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "extension")
(KEYWORD in)
(ID "existing_extensions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%s is already registered for \"%s\"")
(NEWLINE)
(KEYWORD raise)
(ID "RegistryError")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "extension")
(PUNCT ",")
(ID "existing_extensions")
(PUNCT "[")
(ID "extension")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "callable")
(PUNCT "(")
(ID "function")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "The registered function must be a callable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "register_unpack_format")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "extensions")
(PUNCT ",")
(ID "function")
(PUNCT ",")
(ID "extra_args")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "description")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Registers an unpack format.\n\n    `name` is the name of the format. `extensions` is a list of extensions\n    corresponding to the format.\n\n    `function` is the callable that will be\n    used to unpack archives. The callable will receive archives to unpack.\n    If it's unable to handle an archive, it needs to raise a ReadError\n    exception.\n\n    If provided, `extra_args` is a sequence of\n    (name, value) tuples that will be passed as arguments to the callable.\n    description can be provided to describe the format, and will be returned\n    by the get_unpack_formats() function.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "extra_args")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extra_args")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "_check_unpack_options")
(PUNCT "(")
(ID "extensions")
(PUNCT ",")
(ID "function")
(PUNCT ",")
(ID "extra_args")
(PUNCT ")")
(NEWLINE)
(ID "_UNPACK_FORMATS")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "extensions")
(PUNCT ",")
(ID "function")
(PUNCT ",")
(ID "extra_args")
(PUNCT ",")
(ID "description")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unregister_unpack_format")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Removes the pack format from the registery.")
(NEWLINE)
(KEYWORD del)
(ID "_UNPACK_FORMATS")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_ensure_directory")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Ensure that the parent directory of `path` exists")
(NEWLINE)
(ID "dirname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "dirname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "makedirs")
(PUNCT "(")
(ID "dirname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_unpack_zipfile")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "extract_dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Unpack zip `filename` to `extract_dir`\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "zipfile")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ReadError")
(PUNCT "(")
(LIT "zlib not supported, cannot unpack this archive.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "zipfile")
(PUNCT ".")
(ID "is_zipfile")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ReadError")
(PUNCT "(")
(LIT "%s is not a zip file")
(PUNCT "%")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "zip")
(PUNCT "=")
(ID "zipfile")
(PUNCT ".")
(ID "ZipFile")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "info")
(KEYWORD in)
(ID "zip")
(PUNCT ".")
(ID "infolist")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "info")
(PUNCT ".")
(ID "filename")
(NEWLINE)
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(KEYWORD or)
(LIT "..")
(KEYWORD in)
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "target")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "extract_dir")
(PUNCT ",")
(PUNCT "*")
(ID "name")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "target")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "_ensure_directory")
(PUNCT "(")
(ID "target")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "name")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "zip")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "info")
(PUNCT ".")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(LIT "wb")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "data")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "zip")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_unpack_tarfile")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "extract_dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir`\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tarobj")
(PUNCT "=")
(ID "tarfile")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "tarfile")
(PUNCT ".")
(ID "TarError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ReadError")
(PUNCT "(")
(LIT "%s is not a compressed or uncompressed tar file")
(PUNCT "%")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tarobj")
(PUNCT ".")
(ID "extractall")
(PUNCT "(")
(ID "extract_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tarobj")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_UNPACK_FORMATS")
(PUNCT "=")
(PUNCT "{")
(LIT "gztar")
(PUNCT ":")
(PUNCT "(")
(PUNCT "[")
(LIT ".tar.gz")
(PUNCT ",")
(LIT ".tgz")
(PUNCT "]")
(PUNCT ",")
(ID "_unpack_tarfile")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(LIT "gzip'ed tar-file")
(PUNCT ")")
(PUNCT ",")
(LIT "tar")
(PUNCT ":")
(PUNCT "(")
(PUNCT "[")
(LIT ".tar")
(PUNCT "]")
(PUNCT ",")
(ID "_unpack_tarfile")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(LIT "uncompressed tar file")
(PUNCT ")")
(PUNCT ",")
(LIT "zip")
(PUNCT ":")
(PUNCT "(")
(PUNCT "[")
(LIT ".zip")
(PUNCT "]")
(PUNCT ",")
(ID "_unpack_zipfile")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(LIT "ZIP file")
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "_BZ2_SUPPORTED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_UNPACK_FORMATS")
(PUNCT "[")
(LIT "bztar")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(PUNCT "[")
(LIT ".bz2")
(PUNCT "]")
(PUNCT ",")
(ID "_unpack_tarfile")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(LIT "bzip2'ed tar-file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_find_unpack_format")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "info")
(KEYWORD in)
(ID "_UNPACK_FORMATS")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "extension")
(KEYWORD in)
(ID "info")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "filename")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "extension")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unpack_archive")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "extract_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "format")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Unpack an archive.\n\n    `filename` is the name of the archive.\n\n    `extract_dir` is the name of the target directory, where the archive\n    is unpacked. If not provided, the current working directory is used.\n\n    `format` is the archive format: one of \"zip\", \"tar\", or \"gztar\". Or any\n    other registered format. If not provided, unpack_archive will use the\n    filename extension and see if an unpacker was registered for that\n    extension.\n\n    In case none is found, a ValueError is raised.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "extract_dir")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extract_dir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "getcwd")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "format")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format_info")
(PUNCT "=")
(ID "_UNPACK_FORMATS")
(PUNCT "[")
(ID "format")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Unknown unpack format '{0}'")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "format")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "func")
(PUNCT "=")
(ID "format_info")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "func")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "extract_dir")
(PUNCT ",")
(PUNCT "**")
(ID "dict")
(PUNCT "(")
(ID "format_info")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "format")
(PUNCT "=")
(ID "_find_unpack_format")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "format")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ReadError")
(PUNCT "(")
(LIT "Unknown archive format '{0}'")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "func")
(PUNCT "=")
(ID "_UNPACK_FORMATS")
(PUNCT "[")
(ID "format")
(PUNCT "]")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "kwargs")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "_UNPACK_FORMATS")
(PUNCT "[")
(ID "format")
(PUNCT "]")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "func")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "extract_dir")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "statvfs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "disk_usage")
(PUNCT ")")
(NEWLINE)
(ID "_ntuple_diskusage")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "namedtuple")
(PUNCT "(")
(LIT "usage")
(PUNCT ",")
(LIT "total used free")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "disk_usage")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return disk usage statistics about the given path.\n\n        Returned value is a named tuple with attributes 'total', 'used' and\n        'free', which are the amount of total, used and free space, in bytes.\n        ")
(NEWLINE)
(ID "st")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "statvfs")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(ID "free")
(PUNCT "=")
(ID "st")
(PUNCT ".")
(ID "f_bavail")
(PUNCT "*")
(ID "st")
(PUNCT ".")
(ID "f_frsize")
(NEWLINE)
(ID "total")
(PUNCT "=")
(ID "st")
(PUNCT ".")
(ID "f_blocks")
(PUNCT "*")
(ID "st")
(PUNCT ".")
(ID "f_frsize")
(NEWLINE)
(ID "used")
(PUNCT "=")
(PUNCT "(")
(ID "st")
(PUNCT ".")
(ID "f_blocks")
(PUNCT "-")
(ID "st")
(PUNCT ".")
(ID "f_bfree")
(PUNCT ")")
(PUNCT "*")
(ID "st")
(PUNCT ".")
(ID "f_frsize")
(NEWLINE)
(KEYWORD return)
(ID "_ntuple_diskusage")
(PUNCT "(")
(ID "total")
(PUNCT ",")
(ID "used")
(PUNCT ",")
(ID "free")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "nt")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "disk_usage")
(PUNCT ")")
(NEWLINE)
(ID "_ntuple_diskusage")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "namedtuple")
(PUNCT "(")
(LIT "usage")
(PUNCT ",")
(LIT "total used free")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "disk_usage")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return disk usage statistics about the given path.\n\n        Returned values is a named tuple with attributes 'total', 'used' and\n        'free', which are the amount of total, used and free space, in bytes.\n        ")
(NEWLINE)
(ID "total")
(PUNCT ",")
(ID "free")
(PUNCT "=")
(ID "nt")
(PUNCT ".")
(ID "_getdiskusage")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(ID "used")
(PUNCT "=")
(ID "total")
(PUNCT "-")
(ID "free")
(NEWLINE)
(KEYWORD return)
(ID "_ntuple_diskusage")
(PUNCT "(")
(ID "total")
(PUNCT ",")
(ID "used")
(PUNCT ",")
(ID "free")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "chown")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "user")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "group")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Change owner user and group of the given path.\n\n    user and group can be the uid/gid or the user/group names, and in that case,\n    they are converted to their respective uid/gid.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "user")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "group")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "user and/or group must be set")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_user")
(PUNCT "=")
(ID "user")
(NEWLINE)
(ID "_group")
(PUNCT "=")
(ID "group")
(NEWLINE)
(KEYWORD if)
(ID "user")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_user")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "user")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_user")
(PUNCT "=")
(ID "_get_uid")
(PUNCT "(")
(ID "user")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_user")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "LookupError")
(PUNCT "(")
(LIT "no such user: {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "user")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "group")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_group")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "group")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_group")
(PUNCT "=")
(ID "_get_gid")
(PUNCT "(")
(ID "group")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_group")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "LookupError")
(PUNCT "(")
(LIT "no such group: {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "group")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "os")
(PUNCT ".")
(ID "chown")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "_user")
(PUNCT ",")
(ID "_group")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_terminal_size")
(PUNCT "(")
(ID "fallback")
(PUNCT "=")
(PUNCT "(")
(LIT 80)
(PUNCT ",")
(LIT 24)
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get the size of the terminal window.\n\n    For each of the two dimensions, the environment variable, COLUMNS\n    and LINES respectively, is checked. If the variable is defined and\n    the value is a positive integer, it is used.\n\n    When COLUMNS or LINES is not defined, which is the common case,\n    the terminal connected to sys.__stdout__ is queried\n    by invoking os.get_terminal_size.\n\n    If the terminal size cannot be successfully queried, either because\n    the system doesn't support querying, or because we are not\n    connected to a terminal, the value given in fallback parameter\n    is used. Fallback defaults to (80, 24) which is the default\n    size used by many terminal emulators.\n\n    The value returned is a named tuple of type os.terminal_size.\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "columns")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(LIT "COLUMNS")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "KeyError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "columns")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(LIT "LINES")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "KeyError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "columns")
(PUNCT "<=")
(LIT 0)
(KEYWORD or)
(ID "lines")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "get_terminal_size")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "__stdout__")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "NameError")
(PUNCT ",")
(ID "OSError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "size")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "terminal_size")
(PUNCT "(")
(ID "fallback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "columns")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "columns")
(PUNCT "=")
(ID "size")
(PUNCT ".")
(ID "columns")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "lines")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT "=")
(ID "size")
(PUNCT ".")
(ID "lines")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "terminal_size")
(PUNCT "(")
(PUNCT "(")
(ID "columns")
(PUNCT ",")
(ID "lines")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "which")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "F_OK")
(PUNCT "|")
(ID "os")
(PUNCT ".")
(ID "X_OK")
(PUNCT ",")
(ID "path")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Given a command, mode, and a PATH string, return the path which\n    conforms to the given mode on the PATH, or None if there is no such\n    file.\n\n    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n    of os.environ.get(\"PATH\"), or can be overridden with a custom search\n    path.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "_access_check")
(PUNCT "(")
(ID "fn")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "access")
(PUNCT "(")
(ID "fn")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "cmd")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_access_check")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cmd")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "path")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "PATH")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "defpath")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "path")
(PUNCT "=")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "pathsep")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "platform")
(PUNCT "==")
(LIT "win32")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "curdir")
(KEYWORD in)
(ID "path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "curdir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "pathext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "PATHEXT")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "pathsep")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(ID "cmd")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "ext")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "ext")
(KEYWORD in)
(ID "pathext")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(PUNCT "[")
(ID "cmd")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(PUNCT "[")
(ID "cmd")
(PUNCT "+")
(ID "ext")
(KEYWORD for)
(ID "ext")
(KEYWORD in)
(ID "pathext")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(PUNCT "[")
(ID "cmd")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "seen")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "dir")
(KEYWORD in)
(ID "path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "normdir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "normdir")
(KEYWORD in)
(ID "seen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "seen")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "normdir")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "thefile")
(KEYWORD in)
(ID "files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dir")
(PUNCT ",")
(ID "thefile")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "_access_check")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ENDMARKER)
