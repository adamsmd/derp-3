(LIT "Disassembler of Python byte code into mnemonics.")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "types")
(NEWLINE)
(KEYWORD import)
(ID "collections")
(NEWLINE)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD from)
(ID "opcode")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(KEYWORD from)
(ID "opcode")
(KEYWORD import)
(ID "__all__")
(KEYWORD as)
(ID "_opcodes_all")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "code_info")
(PUNCT ",")
(LIT "dis")
(PUNCT ",")
(LIT "disassemble")
(PUNCT ",")
(LIT "distb")
(PUNCT ",")
(LIT "disco")
(PUNCT ",")
(LIT "findlinestarts")
(PUNCT ",")
(LIT "findlabels")
(PUNCT ",")
(LIT "show_code")
(PUNCT ",")
(LIT "get_instructions")
(PUNCT ",")
(LIT "Instruction")
(PUNCT ",")
(LIT "Bytecode")
(PUNCT "]")
(PUNCT "+")
(ID "_opcodes_all")
(NEWLINE)
(KEYWORD del)
(ID "_opcodes_all")
(NEWLINE)
(ID "_have_code")
(PUNCT "=")
(PUNCT "(")
(ID "types")
(PUNCT ".")
(ID "MethodType")
(PUNCT ",")
(ID "types")
(PUNCT ".")
(ID "FunctionType")
(PUNCT ",")
(ID "types")
(PUNCT ".")
(ID "CodeType")
(PUNCT ",")
(ID "type")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_try_compile")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Attempts to compile the given source, first as an expression and\n       then as a statement if the first approach fails.\n\n       Utility function to accept strings in functions that otherwise\n       expect code objects\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "compile")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(LIT "eval")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "SyntaxError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "compile")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(LIT "exec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "c")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "dis")
(PUNCT "(")
(ID "x")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Disassemble classes, methods, functions, or code.\n\n    With no argument, disassemble the last traceback.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "x")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "distb")
(PUNCT "(")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "__func__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "x")
(PUNCT ".")
(ID "__func__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "__code__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "x")
(PUNCT ".")
(ID "__code__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "__dict__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "items")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "x")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "x1")
(KEYWORD in)
(ID "items")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "x1")
(PUNCT ",")
(ID "_have_code")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Disassembly of %s:")
(PUNCT "%")
(ID "name")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dis")
(PUNCT "(")
(ID "x1")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(KEYWORD as)
(ID "msg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Sorry:")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "co_code")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "disassemble")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(PUNCT "(")
(ID "bytes")
(PUNCT ",")
(ID "bytearray")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_disassemble_bytes")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_disassemble_str")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "don't know how to disassemble %s objects")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "distb")
(PUNCT "(")
(ID "tb")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Disassemble a traceback (default: last traceback).")
(NEWLINE)
(KEYWORD if)
(ID "tb")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tb")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "last_traceback")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no last traceback to disassemble")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "tb")
(PUNCT ".")
(ID "tb_next")
(PUNCT ":")
(ID "tb")
(PUNCT "=")
(ID "tb")
(PUNCT ".")
(ID "tb_next")
(NEWLINE)
(DEDENT)
(ID "disassemble")
(PUNCT "(")
(ID "tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ",")
(ID "tb")
(PUNCT ".")
(ID "tb_lasti")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "COMPILER_FLAG_NAMES")
(PUNCT "=")
(PUNCT "{")
(LIT 1)
(PUNCT ":")
(LIT "OPTIMIZED")
(PUNCT ",")
(LIT 2)
(PUNCT ":")
(LIT "NEWLOCALS")
(PUNCT ",")
(LIT 4)
(PUNCT ":")
(LIT "VARARGS")
(PUNCT ",")
(LIT 8)
(PUNCT ":")
(LIT "VARKEYWORDS")
(PUNCT ",")
(LIT 16)
(PUNCT ":")
(LIT "NESTED")
(PUNCT ",")
(LIT 32)
(PUNCT ":")
(LIT "GENERATOR")
(PUNCT ",")
(LIT 64)
(PUNCT ":")
(LIT "NOFREE")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "pretty_flags")
(PUNCT "(")
(ID "flags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return pretty representation of code flags.")
(NEWLINE)
(ID "names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 32)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flag")
(PUNCT "=")
(LIT 1)
(PUNCT "<<")
(ID "i")
(NEWLINE)
(KEYWORD if)
(ID "flags")
(PUNCT "&")
(ID "flag")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "COMPILER_FLAG_NAMES")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "flag")
(PUNCT ",")
(ID "hex")
(PUNCT "(")
(ID "flag")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "flags")
(PUNCT "^=")
(ID "flag")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "flags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "hex")
(PUNCT "(")
(ID "flags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "names")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_code_object")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to handle methods, functions, strings and raw code objects")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "__func__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "x")
(PUNCT ".")
(ID "__func__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "__code__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "x")
(PUNCT ".")
(ID "__code__")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT "=")
(ID "_try_compile")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "<disassembly>")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(LIT "co_code")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "x")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "don't know how to disassemble %s objects")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "code_info")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Formatted details of methods, functions, or code.")
(NEWLINE)
(KEYWORD return)
(ID "_format_code_info")
(PUNCT "(")
(ID "_get_code_object")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format_code_info")
(PUNCT "(")
(ID "co")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Name:              %s")
(PUNCT "%")
(ID "co")
(PUNCT ".")
(ID "co_name")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Filename:          %s")
(PUNCT "%")
(ID "co")
(PUNCT ".")
(ID "co_filename")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Argument count:    %s")
(PUNCT "%")
(ID "co")
(PUNCT ".")
(ID "co_argcount")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Kw-only arguments: %s")
(PUNCT "%")
(ID "co")
(PUNCT ".")
(ID "co_kwonlyargcount")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Number of locals:  %s")
(PUNCT "%")
(ID "co")
(PUNCT ".")
(ID "co_nlocals")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Stack size:        %s")
(PUNCT "%")
(ID "co")
(PUNCT ".")
(ID "co_stacksize")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Flags:             %s")
(PUNCT "%")
(ID "pretty_flags")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_flags")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_consts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Constants:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i_c")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_consts")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%4d: %r")
(PUNCT "%")
(ID "i_c")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Names:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i_n")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_names")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%4d: %s")
(PUNCT "%")
(ID "i_n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Variable names:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i_n")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%4d: %s")
(PUNCT "%")
(ID "i_n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_freevars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Free variables:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i_n")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_freevars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%4d: %s")
(PUNCT "%")
(ID "i_n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_cellvars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "Cell variables:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i_n")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_cellvars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%4d: %s")
(PUNCT "%")
(ID "i_n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "show_code")
(PUNCT "(")
(ID "co")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Print details of methods, functions, or code to *file*.\n\n    If *file* is not provided, the output is printed on stdout.\n    ")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "code_info")
(PUNCT "(")
(ID "co")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_Instruction")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "namedtuple")
(PUNCT "(")
(LIT "_Instruction")
(PUNCT ",")
(LIT "opname opcode arg argval argrepr offset starts_line is_jump_target")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Instruction")
(PUNCT "(")
(ID "_Instruction")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Details for a bytecode operation\n\n       Defined fields:\n         opname - human readable name for operation\n         opcode - numeric code for operation\n         arg - numeric argument to operation (if any), otherwise None\n         argval - resolved arg value (if known), otherwise same as arg\n         argrepr - human readable description of operation argument\n         offset - start index of operation within bytecode sequence\n         starts_line - line started by this opcode (if any), otherwise None\n         is_jump_target - True if other code jumps to here, otherwise False\n    ")
(NEWLINE)
(KEYWORD def)
(ID "_disassemble")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lineno_width")
(PUNCT "=")
(LIT 3)
(PUNCT ",")
(ID "mark_as_current")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Format instruction details for inclusion in disassembly output\n\n        *lineno_width* sets the width of the line number field (0 omits it)\n        *mark_as_current* inserts a '-->' marker arrow as part of the line\n        ")
(NEWLINE)
(ID "fields")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "lineno_width")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "starts_line")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno_fmt")
(PUNCT "=")
(LIT "%%%dd")
(PUNCT "%")
(ID "lineno_width")
(NEWLINE)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "lineno_fmt")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "starts_line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT " ")
(PUNCT "*")
(ID "lineno_width")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "mark_as_current")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "-->")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "   ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "is_jump_target")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT ">>")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "  ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "offset")
(PUNCT ")")
(PUNCT ".")
(ID "rjust")
(PUNCT "(")
(LIT 4)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "opname")
(PUNCT ".")
(ID "ljust")
(PUNCT "(")
(LIT 20)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "arg")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "arg")
(PUNCT ")")
(PUNCT ".")
(ID "rjust")
(PUNCT "(")
(LIT 5)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "argrepr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fields")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "(")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "argrepr")
(PUNCT "+")
(LIT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "fields")
(PUNCT ")")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_instructions")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "first_line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Iterator for the opcodes in methods, functions or code\n\n    Generates a series of Instruction named tuples giving the details of\n    each operations in the supplied code.\n\n    If *first_line* is not None, it indicates the line number that should\n    be reported for the first source line in the disassembled code.\n    Otherwise, the source line information (if any) is taken directly from\n    the disassembled code object.\n    ")
(NEWLINE)
(ID "co")
(PUNCT "=")
(ID "_get_code_object")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(ID "cell_names")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_cellvars")
(PUNCT "+")
(ID "co")
(PUNCT ".")
(ID "co_freevars")
(NEWLINE)
(ID "linestarts")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "findlinestarts")
(PUNCT "(")
(ID "co")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "first_line")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line_offset")
(PUNCT "=")
(ID "first_line")
(PUNCT "-")
(ID "co")
(PUNCT ".")
(ID "co_firstlineno")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line_offset")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_get_instructions_bytes")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_code")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_names")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_consts")
(PUNCT ",")
(ID "cell_names")
(PUNCT ",")
(ID "linestarts")
(PUNCT ",")
(ID "line_offset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_const_info")
(PUNCT "(")
(ID "const_index")
(PUNCT ",")
(ID "const_list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to get optional details about const references\n\n       Returns the dereferenced constant and its repr if the constant\n       list is defined.\n       Otherwise returns the constant index and its repr().\n    ")
(NEWLINE)
(ID "argval")
(PUNCT "=")
(ID "const_index")
(NEWLINE)
(KEYWORD if)
(ID "const_list")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT "=")
(ID "const_list")
(PUNCT "[")
(ID "const_index")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "argval")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "argval")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_name_info")
(PUNCT "(")
(ID "name_index")
(PUNCT ",")
(ID "name_list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to get optional details about named references\n\n       Returns the dereferenced name as both value and repr if the name\n       list is defined.\n       Otherwise returns the name index and its repr().\n    ")
(NEWLINE)
(ID "argval")
(PUNCT "=")
(ID "name_index")
(NEWLINE)
(KEYWORD if)
(ID "name_list")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT "=")
(ID "name_list")
(PUNCT "[")
(ID "name_index")
(PUNCT "]")
(NEWLINE)
(ID "argrepr")
(PUNCT "=")
(ID "argval")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argrepr")
(PUNCT "=")
(ID "repr")
(PUNCT "(")
(ID "argval")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "argval")
(PUNCT ",")
(ID "argrepr")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_instructions_bytes")
(PUNCT "(")
(ID "code")
(PUNCT ",")
(ID "varnames")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "names")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "constants")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "cells")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "linestarts")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "line_offset")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Iterate over the instructions in a bytecode string.\n\n    Generates a sequence of Instruction namedtuples giving the details of each\n    opcode.  Additional information about the code's runtime environment\n    (e.g. variable names, constants) can be specified using optional\n    arguments.\n\n    ")
(NEWLINE)
(ID "labels")
(PUNCT "=")
(ID "findlabels")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(NEWLINE)
(ID "extended_arg")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "starts_line")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "free")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op")
(PUNCT "=")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "offset")
(PUNCT "=")
(ID "i")
(NEWLINE)
(KEYWORD if)
(ID "linestarts")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "starts_line")
(PUNCT "=")
(ID "linestarts")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "starts_line")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "starts_line")
(PUNCT "+=")
(ID "line_offset")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "is_jump_target")
(PUNCT "=")
(ID "i")
(KEYWORD in)
(ID "labels")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "argval")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "argrepr")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD if)
(ID "op")
(PUNCT ">=")
(ID "HAVE_ARGUMENT")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "arg")
(PUNCT "=")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "+")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT "*")
(LIT 256)
(PUNCT "+")
(ID "extended_arg")
(NEWLINE)
(ID "extended_arg")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 2)
(NEWLINE)
(KEYWORD if)
(ID "op")
(PUNCT "==")
(ID "EXTENDED_ARG")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extended_arg")
(PUNCT "=")
(ID "arg")
(PUNCT "*")
(LIT 65536)
(NEWLINE)
(DEDENT)
(ID "argval")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(KEYWORD if)
(ID "op")
(KEYWORD in)
(ID "hasconst")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT ",")
(ID "argrepr")
(PUNCT "=")
(ID "_get_const_info")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "constants")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "hasname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT ",")
(ID "argrepr")
(PUNCT "=")
(ID "_get_name_info")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "names")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "hasjrel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(ID "arg")
(NEWLINE)
(ID "argrepr")
(PUNCT "=")
(LIT "to ")
(PUNCT "+")
(ID "repr")
(PUNCT "(")
(ID "argval")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "haslocal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT ",")
(ID "argrepr")
(PUNCT "=")
(ID "_get_name_info")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "varnames")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "hascompare")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT "=")
(ID "cmp_op")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(NEWLINE)
(ID "argrepr")
(PUNCT "=")
(ID "argval")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "hasfree")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argval")
(PUNCT ",")
(ID "argrepr")
(PUNCT "=")
(ID "_get_name_info")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "cells")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "hasnargs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "argrepr")
(PUNCT "=")
(LIT "%d positional, %d keyword pair")
(PUNCT "%")
(PUNCT "(")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(PUNCT ",")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD yield)
(ID "Instruction")
(PUNCT "(")
(ID "opname")
(PUNCT "[")
(ID "op")
(PUNCT "]")
(PUNCT ",")
(ID "op")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "argval")
(PUNCT ",")
(ID "argrepr")
(PUNCT ",")
(ID "offset")
(PUNCT ",")
(ID "starts_line")
(PUNCT ",")
(ID "is_jump_target")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "disassemble")
(PUNCT "(")
(ID "co")
(PUNCT ",")
(ID "lasti")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Disassemble a code object.")
(NEWLINE)
(ID "cell_names")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_cellvars")
(PUNCT "+")
(ID "co")
(PUNCT ".")
(ID "co_freevars")
(NEWLINE)
(ID "linestarts")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "findlinestarts")
(PUNCT "(")
(ID "co")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "_disassemble_bytes")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_code")
(PUNCT ",")
(ID "lasti")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_names")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_consts")
(PUNCT ",")
(ID "cell_names")
(PUNCT ",")
(ID "linestarts")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_disassemble_bytes")
(PUNCT "(")
(ID "code")
(PUNCT ",")
(ID "lasti")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "varnames")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "names")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "constants")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "cells")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "linestarts")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "line_offset")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "show_lineno")
(PUNCT "=")
(ID "linestarts")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(ID "lineno_width")
(PUNCT "=")
(LIT 3)
(KEYWORD if)
(ID "show_lineno")
(KEYWORD else)
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "instr")
(KEYWORD in)
(ID "_get_instructions_bytes")
(PUNCT "(")
(ID "code")
(PUNCT ",")
(ID "varnames")
(PUNCT ",")
(ID "names")
(PUNCT ",")
(ID "constants")
(PUNCT ",")
(ID "cells")
(PUNCT ",")
(ID "linestarts")
(PUNCT ",")
(ID "line_offset")
(PUNCT "=")
(ID "line_offset")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_source_line")
(PUNCT "=")
(PUNCT "(")
(ID "show_lineno")
(KEYWORD and)
(ID "instr")
(PUNCT ".")
(ID "starts_line")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "instr")
(PUNCT ".")
(ID "offset")
(PUNCT ">")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new_source_line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "is_current_instr")
(PUNCT "=")
(ID "instr")
(PUNCT ".")
(ID "offset")
(PUNCT "==")
(ID "lasti")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "instr")
(PUNCT ".")
(ID "_disassemble")
(PUNCT "(")
(ID "lineno_width")
(PUNCT ",")
(ID "is_current_instr")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_disassemble_str")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compile the source string, then disassemble the code object.")
(NEWLINE)
(ID "disassemble")
(PUNCT "(")
(ID "_try_compile")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(LIT "<dis>")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "disco")
(PUNCT "=")
(ID "disassemble")
(NEWLINE)
(KEYWORD def)
(ID "findlabels")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Detect all offsets in a byte code which are jump targets.\n\n    Return the list of offsets.\n\n    ")
(NEWLINE)
(ID "labels")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "op")
(PUNCT "=")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "op")
(PUNCT ">=")
(ID "HAVE_ARGUMENT")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "arg")
(PUNCT "=")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "+")
(ID "code")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(PUNCT "*")
(LIT 256)
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 2)
(NEWLINE)
(ID "label")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "op")
(KEYWORD in)
(ID "hasjrel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "label")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD in)
(ID "hasjabs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "label")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "label")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "label")
(KEYWORD not)
(KEYWORD in)
(ID "labels")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "labels")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "label")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "labels")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "findlinestarts")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find the offsets in a byte code which are start of lines in the source.\n\n    Generate pairs (offset, lineno) as described in Python/compile.c.\n\n    ")
(NEWLINE)
(ID "byte_increments")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "code")
(PUNCT ".")
(ID "co_lnotab")
(PUNCT "[")
(LIT 0)
(PUNCT ":")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "line_increments")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "code")
(PUNCT ".")
(ID "co_lnotab")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "lastlineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(ID "code")
(PUNCT ".")
(ID "co_firstlineno")
(NEWLINE)
(ID "addr")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "byte_incr")
(PUNCT ",")
(ID "line_incr")
(KEYWORD in)
(ID "zip")
(PUNCT "(")
(ID "byte_increments")
(PUNCT ",")
(ID "line_increments")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "byte_incr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "lineno")
(PUNCT "!=")
(ID "lastlineno")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(PUNCT "(")
(ID "addr")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(ID "lastlineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(DEDENT)
(ID "addr")
(PUNCT "+=")
(ID "byte_incr")
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT "+=")
(ID "line_incr")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "lineno")
(PUNCT "!=")
(ID "lastlineno")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(PUNCT "(")
(ID "addr")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Bytecode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The bytecode operations of a piece of code\n\n    Instantiate this with a function, method, string of code, or a code object\n    (as returned by compile()).\n\n    Iterating over this yields the bytecode operations as Instruction instances.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "x")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "first_line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "current_offset")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "codeobj")
(PUNCT "=")
(ID "co")
(PUNCT "=")
(ID "_get_code_object")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "first_line")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "first_line")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_firstlineno")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_line_offset")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "first_line")
(PUNCT "=")
(ID "first_line")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_line_offset")
(PUNCT "=")
(ID "first_line")
(PUNCT "-")
(ID "co")
(PUNCT ".")
(ID "co_firstlineno")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_cell_names")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_cellvars")
(PUNCT "+")
(ID "co")
(PUNCT ".")
(ID "co_freevars")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_linestarts")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "findlinestarts")
(PUNCT "(")
(ID "co")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_original_object")
(PUNCT "=")
(ID "x")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "current_offset")
(PUNCT "=")
(ID "current_offset")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "co")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "codeobj")
(NEWLINE)
(KEYWORD return)
(ID "_get_instructions_bytes")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_code")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_names")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_consts")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_cell_names")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_linestarts")
(PUNCT ",")
(ID "line_offset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_line_offset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "{}({!r})")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_original_object")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "from_traceback")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Construct a Bytecode from the given traceback ")
(NEWLINE)
(KEYWORD while)
(ID "tb")
(PUNCT ".")
(ID "tb_next")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tb")
(PUNCT "=")
(ID "tb")
(PUNCT ".")
(ID "tb_next")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ",")
(ID "current_offset")
(PUNCT "=")
(ID "tb")
(PUNCT ".")
(ID "tb_lasti")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "info")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return formatted information about the code object.")
(NEWLINE)
(KEYWORD return)
(ID "_format_code_info")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "codeobj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "dis")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a formatted view of the bytecode operations.")
(NEWLINE)
(ID "co")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "codeobj")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "current_offset")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "offset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "current_offset")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "offset")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "io")
(PUNCT ".")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(KEYWORD as)
(ID "output")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_disassemble_bytes")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_code")
(PUNCT ",")
(ID "varnames")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT ",")
(ID "names")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_names")
(PUNCT ",")
(ID "constants")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_consts")
(PUNCT ",")
(ID "cells")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_cell_names")
(PUNCT ",")
(ID "linestarts")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_linestarts")
(PUNCT ",")
(ID "line_offset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_line_offset")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "output")
(PUNCT ",")
(ID "lasti")
(PUNCT "=")
(ID "offset")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "output")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Simple test program to disassemble a file.")
(NEWLINE)
(KEYWORD import)
(ID "argparse")
(NEWLINE)
(ID "parser")
(PUNCT "=")
(ID "argparse")
(PUNCT ".")
(ID "ArgumentParser")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "infile")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "argparse")
(PUNCT ".")
(ID "FileType")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "nargs")
(PUNCT "=")
(LIT "?")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(LIT "-")
(PUNCT ")")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "parse_args")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD with)
(ID "args")
(PUNCT ".")
(ID "infile")
(KEYWORD as)
(ID "infile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(ID "infile")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "code")
(PUNCT "=")
(ID "compile")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "args")
(PUNCT ".")
(ID "infile")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(LIT "exec")
(PUNCT ")")
(NEWLINE)
(ID "dis")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
