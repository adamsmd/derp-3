(LIT "\nMiddleware to check for obedience to the WSGI specification.\n\nSome of the things this checks:\n\n* Signature of the application and start_response (including that\n  keyword arguments are not used).\n\n* Environment checks:\n\n  - Environment is a dictionary (and not a subclass).\n\n  - That all the required keys are in the environment: REQUEST_METHOD,\n    SERVER_NAME, SERVER_PORT, wsgi.version, wsgi.input, wsgi.errors,\n    wsgi.multithread, wsgi.multiprocess, wsgi.run_once\n\n  - That HTTP_CONTENT_TYPE and HTTP_CONTENT_LENGTH are not in the\n    environment (these headers should appear as CONTENT_LENGTH and\n    CONTENT_TYPE).\n\n  - Warns if QUERY_STRING is missing, as the cgi module acts\n    unpredictably in that case.\n\n  - That CGI-style variables (that don't contain a .) have\n    (non-unicode) string values\n\n  - That wsgi.version is a tuple\n\n  - That wsgi.url_scheme is 'http' or 'https' (@@: is this too\n    restrictive?)\n\n  - Warns if the REQUEST_METHOD is not known (@@: probably too\n    restrictive).\n\n  - That SCRIPT_NAME and PATH_INFO are empty or start with /\n\n  - That at least one of SCRIPT_NAME or PATH_INFO are set.\n\n  - That CONTENT_LENGTH is a positive integer.\n\n  - That SCRIPT_NAME is not '/' (it should be '', and PATH_INFO should\n    be '/').\n\n  - That wsgi.input has the methods read, readline, readlines, and\n    __iter__\n\n  - That wsgi.errors has the methods flush, write, writelines\n\n* The status is a string, contains a space, starts with an integer,\n  and that integer is in range (> 100).\n\n* That the headers is a list (not a subclass, not another kind of\n  sequence).\n\n* That the items of the headers are tuples of strings.\n\n* That there is no 'status' header (that is used in CGI, but not in\n  WSGI).\n\n* That the headers don't contain newlines or colons, end in _ or -, or\n  contain characters codes below 037.\n\n* That Content-Type is given if there is content (CGI often has a\n  default content type, but WSGI does not).\n\n* That no Content-Type is given when there is no content (@@: is this\n  too restrictive?)\n\n* That the exc_info argument to start_response is a tuple or None.\n\n* That all calls to the writer are with strings, and no other methods\n  on the writer are accessed.\n\n* That wsgi.input is used properly:\n\n  - .read() is called with zero or one argument\n\n  - That it returns a string\n\n  - That readline, readlines, and __iter__ return strings\n\n  - That .close() is not called\n\n  - No other methods are provided\n\n* That wsgi.errors is used properly:\n\n  - .write() and .writelines() is called with a string\n\n  - That .close() is not called, and no other methods are provided.\n\n* The response iterator:\n\n  - That it is not a string (it should be a list of a single string; a\n    string will work, but perform horribly).\n\n  - That .__next__() returns a string\n\n  - That the iterator is not iterated over until start_response has\n    been called (that can signal either a server or application\n    error).\n\n  - That .close() is called (doesn't raise exception, only prints to\n    sys.stderr, because we only know it isn't called when the object\n    is garbage collected).\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "validator")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "header_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "^[a-zA-Z][a-zA-Z0-9\\-_]*$")
(PUNCT ")")
(NEWLINE)
(ID "bad_header_value_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "[\\000-\\037]")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "WSGIWarning")
(PUNCT "(")
(ID "Warning")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Raised in response to WSGI-spec-related warnings\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "assert_")
(PUNCT "(")
(ID "cond")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_string_type")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "title")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(KEYWORD is)
(ID "str")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "AssertionError")
(PUNCT "(")
(LIT "{0} must be of type str (got {1})")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "title")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "validator")
(PUNCT "(")
(ID "application")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    When applied between a WSGI server and a WSGI application, this\n    middleware will check for WSGI compliancy on a number of levels.\n    This middleware does not modify the request or response in any\n    way, but will raise an AssertionError if anything seems off\n    (except for a failure to close the application iterator, which\n    will be printed to stderr -- there's no way to raise an exception\n    at that point).\n    ")
(NEWLINE)
(KEYWORD def)
(ID "lint_app")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ",")
(LIT "Two arguments required")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "kw")
(PUNCT ",")
(LIT "No keyword arguments allowed")
(PUNCT ")")
(NEWLINE)
(ID "environ")
(PUNCT ",")
(ID "start_response")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "check_environ")
(PUNCT "(")
(ID "environ")
(PUNCT ")")
(NEWLINE)
(ID "start_response_started")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "start_response_wrapper")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 3)
(PUNCT ",")
(PUNCT "(")
(LIT "Invalid number of arguments: %s")
(PUNCT "%")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "kw")
(PUNCT ",")
(LIT "No keyword arguments allowed")
(PUNCT ")")
(NEWLINE)
(ID "status")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "headers")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_info")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_info")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "check_status")
(PUNCT "(")
(ID "status")
(PUNCT ")")
(NEWLINE)
(ID "check_headers")
(PUNCT "(")
(ID "headers")
(PUNCT ")")
(NEWLINE)
(ID "check_content_type")
(PUNCT "(")
(ID "status")
(PUNCT ",")
(ID "headers")
(PUNCT ")")
(NEWLINE)
(ID "check_exc_info")
(PUNCT "(")
(ID "exc_info")
(PUNCT ")")
(NEWLINE)
(ID "start_response_started")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "WriteWrapper")
(PUNCT "(")
(ID "start_response")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "environ")
(PUNCT "[")
(LIT "wsgi.input")
(PUNCT "]")
(PUNCT "=")
(ID "InputWrapper")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.input")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "environ")
(PUNCT "[")
(LIT "wsgi.errors")
(PUNCT "]")
(PUNCT "=")
(ID "ErrorWrapper")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.errors")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "iterator")
(PUNCT "=")
(ID "application")
(PUNCT "(")
(ID "environ")
(PUNCT ",")
(ID "start_response_wrapper")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "iterator")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "iterator")
(PUNCT "!=")
(KEYWORD False)
(PUNCT ",")
(LIT "The application must return an iterator, if only an empty list")
(PUNCT ")")
(NEWLINE)
(ID "check_iterator")
(PUNCT "(")
(ID "iterator")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "IteratorWrapper")
(PUNCT "(")
(ID "iterator")
(PUNCT ",")
(ID "start_response_started")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "lint_app")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "InputWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "wsgi_input")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "input")
(PUNCT "=")
(ID "wsgi_input")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "v")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "input")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(KEYWORD is)
(ID "bytes")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "v")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readline")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "<=")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "v")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "input")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(KEYWORD is)
(ID "bytes")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "v")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readlines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "<=")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "input")
(PUNCT ".")
(ID "readlines")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(KEYWORD is)
(ID "list")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(KEYWORD is)
(ID "bytes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "lines")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "input.close() must not be called")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ErrorWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "wsgi_errors")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT "=")
(ID "wsgi_errors")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(KEYWORD is)
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writelines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "seq")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "seq")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "errors.close() must not be called")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "WriteWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "wsgi_writer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT "=")
(ID "wsgi_writer")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__call__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(KEYWORD is)
(ID "bytes")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "writer")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "PartialIteratorWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "wsgi_iterator")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "iterator")
(PUNCT "=")
(ID "wsgi_iterator")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "IteratorWrapper")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "iterator")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IteratorWrapper")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "wsgi_iterator")
(PUNCT ",")
(ID "check_start_response")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "original_iterator")
(PUNCT "=")
(ID "wsgi_iterator")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "iterator")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "wsgi_iterator")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "check_start_response")
(PUNCT "=")
(ID "check_start_response")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__next__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ",")
(LIT "Iterator read after closed")
(PUNCT ")")
(NEWLINE)
(ID "v")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "iterator")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(ID "bytes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(KEYWORD False)
(PUNCT ",")
(LIT "Iterator yielded non-bytestring (%r)")
(PUNCT "%")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "check_start_response")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "check_start_response")
(PUNCT ",")
(LIT "The application returns and we started iterating over its body, but start_response has not yet been called")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "check_start_response")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "v")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "original_iterator")
(PUNCT ",")
(LIT "close")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "original_iterator")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Iterator garbage collected without being closed")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "assert_")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ",")
(LIT "Iterator garbage collected without being closed")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_environ")
(PUNCT "(")
(ID "environ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "environ")
(PUNCT ")")
(KEYWORD is)
(ID "dict")
(PUNCT ",")
(LIT "Environment is not of the right type: %r (environment: %r)")
(PUNCT "%")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "environ")
(PUNCT ")")
(PUNCT ",")
(ID "environ")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(PUNCT "[")
(LIT "REQUEST_METHOD")
(PUNCT ",")
(LIT "SERVER_NAME")
(PUNCT ",")
(LIT "SERVER_PORT")
(PUNCT ",")
(LIT "wsgi.version")
(PUNCT ",")
(LIT "wsgi.input")
(PUNCT ",")
(LIT "wsgi.errors")
(PUNCT ",")
(LIT "wsgi.multithread")
(PUNCT ",")
(LIT "wsgi.multiprocess")
(PUNCT ",")
(LIT "wsgi.run_once")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "key")
(KEYWORD in)
(ID "environ")
(PUNCT ",")
(LIT "Environment missing required key: %r")
(PUNCT "%")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(PUNCT "[")
(LIT "HTTP_CONTENT_TYPE")
(PUNCT ",")
(LIT "HTTP_CONTENT_LENGTH")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "key")
(KEYWORD not)
(KEYWORD in)
(ID "environ")
(PUNCT ",")
(LIT "Environment should not have the key: %s ")
(LIT "(use %s instead)")
(PUNCT "%")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "key")
(PUNCT "[")
(LIT 5)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "QUERY_STRING")
(KEYWORD not)
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "QUERY_STRING is not in the WSGI environment; the cgi ")
(LIT "module will use sys.argv when this variable is missing, ")
(LIT "so application errors are more likely")
(PUNCT ",")
(ID "WSGIWarning")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "environ")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT ".")
(KEYWORD in)
(ID "key")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(KEYWORD is)
(ID "str")
(PUNCT ",")
(LIT "Environmental variable %s is not a string: %r (value: %r)")
(PUNCT "%")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(ID "environ")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.version")
(PUNCT "]")
(PUNCT ")")
(KEYWORD is)
(ID "tuple")
(PUNCT ",")
(LIT "wsgi.version should be a tuple (%r)")
(PUNCT "%")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.version")
(PUNCT "]")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.url_scheme")
(PUNCT "]")
(KEYWORD in)
(PUNCT "(")
(LIT "http")
(PUNCT ",")
(LIT "https")
(PUNCT ")")
(PUNCT ",")
(LIT "wsgi.url_scheme unknown: %r")
(PUNCT "%")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.url_scheme")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "check_input")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.input")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "check_errors")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "wsgi.errors")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "environ")
(PUNCT "[")
(LIT "REQUEST_METHOD")
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "GET")
(PUNCT ",")
(LIT "HEAD")
(PUNCT ",")
(LIT "POST")
(PUNCT ",")
(LIT "OPTIONS")
(PUNCT ",")
(LIT "PUT")
(PUNCT ",")
(LIT "DELETE")
(PUNCT ",")
(LIT "TRACE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "Unknown REQUEST_METHOD: %r")
(PUNCT "%")
(ID "environ")
(PUNCT "[")
(LIT "REQUEST_METHOD")
(PUNCT "]")
(PUNCT ",")
(ID "WSGIWarning")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "SCRIPT_NAME")
(PUNCT ")")
(KEYWORD or)
(ID "environ")
(PUNCT "[")
(LIT "SCRIPT_NAME")
(PUNCT "]")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ",")
(LIT "SCRIPT_NAME doesn't start with /: %r")
(PUNCT "%")
(ID "environ")
(PUNCT "[")
(LIT "SCRIPT_NAME")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "PATH_INFO")
(PUNCT ")")
(KEYWORD or)
(ID "environ")
(PUNCT "[")
(LIT "PATH_INFO")
(PUNCT "]")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(PUNCT ",")
(LIT "PATH_INFO doesn't start with /: %r")
(PUNCT "%")
(ID "environ")
(PUNCT "[")
(LIT "PATH_INFO")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "CONTENT_LENGTH")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "CONTENT_LENGTH")
(PUNCT "]")
(PUNCT ")")
(PUNCT ">=")
(LIT 0)
(PUNCT ",")
(LIT "Invalid CONTENT_LENGTH: %r")
(PUNCT "%")
(ID "environ")
(PUNCT "[")
(LIT "CONTENT_LENGTH")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "SCRIPT_NAME")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(LIT "PATH_INFO")
(KEYWORD in)
(ID "environ")
(PUNCT ",")
(LIT "One of SCRIPT_NAME or PATH_INFO are required (PATH_INFO ")
(LIT "should at least be '/' if SCRIPT_NAME is empty)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "assert_")
(PUNCT "(")
(ID "environ")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "SCRIPT_NAME")
(PUNCT ")")
(PUNCT "!=")
(LIT "/")
(PUNCT ",")
(LIT "SCRIPT_NAME cannot be '/'; it should instead be '', and ")
(LIT "PATH_INFO should be '/'")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "check_input")
(PUNCT "(")
(ID "wsgi_input")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "attr")
(KEYWORD in)
(PUNCT "[")
(LIT "read")
(PUNCT ",")
(LIT "readline")
(PUNCT ",")
(LIT "readlines")
(PUNCT ",")
(LIT "__iter__")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "hasattr")
(PUNCT "(")
(ID "wsgi_input")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(PUNCT ",")
(LIT "wsgi.input (%r) doesn't have the attribute %s")
(PUNCT "%")
(PUNCT "(")
(ID "wsgi_input")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_errors")
(PUNCT "(")
(ID "wsgi_errors")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "attr")
(KEYWORD in)
(PUNCT "[")
(LIT "flush")
(PUNCT ",")
(LIT "write")
(PUNCT ",")
(LIT "writelines")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "hasattr")
(PUNCT "(")
(ID "wsgi_errors")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(PUNCT ",")
(LIT "wsgi.errors (%r) doesn't have the attribute %s")
(PUNCT "%")
(PUNCT "(")
(ID "wsgi_errors")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_status")
(PUNCT "(")
(ID "status")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "status")
(PUNCT "=")
(ID "check_string_type")
(PUNCT "(")
(ID "status")
(PUNCT ",")
(LIT "Status")
(PUNCT ")")
(NEWLINE)
(ID "status_code")
(PUNCT "=")
(ID "status")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "status_code")
(PUNCT ")")
(PUNCT "==")
(LIT 3)
(PUNCT ",")
(LIT "Status codes must be three characters: %r")
(PUNCT "%")
(ID "status_code")
(PUNCT ")")
(NEWLINE)
(ID "status_int")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "status_code")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "status_int")
(PUNCT ">=")
(LIT 100)
(PUNCT ",")
(LIT "Status code is invalid: %r")
(PUNCT "%")
(ID "status_int")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "status")
(PUNCT ")")
(PUNCT "<")
(LIT 4)
(KEYWORD or)
(ID "status")
(PUNCT "[")
(LIT 3)
(PUNCT "]")
(PUNCT "!=")
(LIT " ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The status string (%r) should be a three-digit integer ")
(LIT "followed by a single space and a status explanation")
(PUNCT "%")
(ID "status")
(PUNCT ",")
(ID "WSGIWarning")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_headers")
(PUNCT "(")
(ID "headers")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "headers")
(PUNCT ")")
(KEYWORD is)
(ID "list")
(PUNCT ",")
(LIT "Headers (%r) must be of type list: %r")
(PUNCT "%")
(PUNCT "(")
(ID "headers")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "headers")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "header_names")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(KEYWORD is)
(ID "tuple")
(PUNCT ",")
(LIT "Individual headers (%r) must be of type tuple: %r")
(PUNCT "%")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "item")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "check_string_type")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(LIT "Header name")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "check_string_type")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "Header value")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "!=")
(LIT "status")
(PUNCT ",")
(LIT "The Status header cannot be used; it conflicts with CGI ")
(LIT "script, and HTTP status is not given through headers ")
(LIT "(value: %r).")
(PUNCT "%")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "header_names")
(PUNCT "[")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(LIT "\n")
(KEYWORD not)
(KEYWORD in)
(ID "name")
(KEYWORD and)
(LIT ":")
(KEYWORD not)
(KEYWORD in)
(ID "name")
(PUNCT ",")
(LIT "Header names may not contain ':' or '\\n': %r")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(ID "header_re")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ",")
(LIT "Bad header name: %r")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "name")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "-")
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "name")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT "_")
(PUNCT ")")
(PUNCT ",")
(LIT "Names may not end in '-' or '_': %r")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "bad_header_value_re")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "Bad header value: %r (bad char: %r)")
(PUNCT "%")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "bad_header_value_re")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_content_type")
(PUNCT "(")
(ID "status")
(PUNCT ",")
(ID "headers")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "status")
(PUNCT "=")
(ID "check_string_type")
(PUNCT "(")
(ID "status")
(PUNCT ",")
(LIT "Status")
(PUNCT ")")
(NEWLINE)
(ID "code")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "status")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NO_MESSAGE_BODY")
(PUNCT "=")
(PUNCT "(")
(LIT 204)
(PUNCT ",")
(LIT 304)
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "check_string_type")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(LIT "Header name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "==")
(LIT "content-type")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "code")
(KEYWORD not)
(KEYWORD in)
(ID "NO_MESSAGE_BODY")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "assert_")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(PUNCT "(")
(LIT "Content-Type header found in a %s response, ")
(LIT "which must not return content.")
(PUNCT ")")
(PUNCT "%")
(ID "code")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "code")
(KEYWORD not)
(KEYWORD in)
(ID "NO_MESSAGE_BODY")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "No Content-Type header found in headers (%s)")
(PUNCT "%")
(ID "headers")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "check_exc_info")
(PUNCT "(")
(ID "exc_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(ID "exc_info")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "type")
(PUNCT "(")
(ID "exc_info")
(PUNCT ")")
(KEYWORD is)
(ID "tuple")
(PUNCT ",")
(LIT "exc_info (%r) is not a tuple: %r")
(PUNCT "%")
(PUNCT "(")
(ID "exc_info")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "exc_info")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "check_iterator")
(PUNCT "(")
(ID "iterator")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "assert_")
(PUNCT "(")
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "iterator")
(PUNCT ",")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(LIT "You should not return a string as your application iterator, ")
(LIT "instead return a single-item list containing a bytestring.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
