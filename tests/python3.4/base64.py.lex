(LIT "Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "struct")
(NEWLINE)
(KEYWORD import)
(ID "binascii")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "encode")
(PUNCT ",")
(LIT "decode")
(PUNCT ",")
(LIT "encodebytes")
(PUNCT ",")
(LIT "decodebytes")
(PUNCT ",")
(LIT "b64encode")
(PUNCT ",")
(LIT "b64decode")
(PUNCT ",")
(LIT "b32encode")
(PUNCT ",")
(LIT "b32decode")
(PUNCT ",")
(LIT "b16encode")
(PUNCT ",")
(LIT "b16decode")
(PUNCT ",")
(LIT "b85encode")
(PUNCT ",")
(LIT "b85decode")
(PUNCT ",")
(LIT "a85encode")
(PUNCT ",")
(LIT "a85decode")
(PUNCT ",")
(LIT "standard_b64encode")
(PUNCT ",")
(LIT "standard_b64decode")
(PUNCT ",")
(LIT "urlsafe_b64encode")
(PUNCT ",")
(LIT "urlsafe_b64decode")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(ID "bytes_types")
(PUNCT "=")
(PUNCT "(")
(ID "bytes")
(PUNCT ",")
(ID "bytearray")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "s")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "UnicodeEncodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "string argument should contain only ASCII characters")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "bytes_types")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "s")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "memoryview")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ".")
(ID "tobytes")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "argument should be a bytes-like object or ASCII ")
(LIT "string, not %r")
(PUNCT "%")
(ID "s")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "b64encode")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "altchars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a byte string using Base64.\n\n    s is the byte string to encode.  Optional altchars must be a byte\n    string of length 2 which specifies an alternative alphabet for the\n    '+' and '/' characters.  This allows an application to\n    e.g. generate url or filesystem safe Base64 strings.\n\n    The encoded byte string is returned.\n    ")
(NEWLINE)
(ID "encoded")
(PUNCT "=")
(ID "binascii")
(PUNCT ".")
(ID "b2a_base64")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "altchars")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "altchars")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "altchars")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "encoded")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "bytes")
(PUNCT ".")
(ID "maketrans")
(PUNCT "(")
(LIT #"+/")
(PUNCT ",")
(ID "altchars")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "encoded")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "b64decode")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "altchars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "validate")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a Base64 encoded byte string.\n\n    s is the byte string to decode.  Optional altchars must be a\n    string of length 2 which specifies the alternative alphabet used\n    instead of the '+' and '/' characters.\n\n    The decoded string is returned.  A binascii.Error is raised if s is\n    incorrectly padded.\n\n    If validate is False (the default), non-base64-alphabet characters are\n    discarded prior to the padding check.  If validate is True,\n    non-base64-alphabet characters in the input result in a binascii.Error.\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "altchars")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "altchars")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "altchars")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "altchars")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "altchars")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "bytes")
(PUNCT ".")
(ID "maketrans")
(PUNCT "(")
(ID "altchars")
(PUNCT ",")
(LIT #"+/")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "validate")
(KEYWORD and)
(KEYWORD not)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT #"^[A-Za-z0-9+/]*={0,2}$")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT "(")
(LIT "Non-base64 digit found")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "binascii")
(PUNCT ".")
(ID "a2b_base64")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "standard_b64encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a byte string using the standard Base64 alphabet.\n\n    s is the byte string to encode.  The encoded byte string is returned.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "b64encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "standard_b64decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a byte string encoded with the standard Base64 alphabet.\n\n    s is the byte string to decode.  The decoded byte string is\n    returned.  binascii.Error is raised if the input is incorrectly\n    padded or if there are non-alphabet characters present in the\n    input.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "b64decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_urlsafe_encode_translation")
(PUNCT "=")
(ID "bytes")
(PUNCT ".")
(ID "maketrans")
(PUNCT "(")
(LIT #"+/")
(PUNCT ",")
(LIT #"-_")
(PUNCT ")")
(NEWLINE)
(ID "_urlsafe_decode_translation")
(PUNCT "=")
(ID "bytes")
(PUNCT ".")
(ID "maketrans")
(PUNCT "(")
(LIT #"-_")
(PUNCT ",")
(LIT #"+/")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "urlsafe_b64encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a byte string using a url-safe Base64 alphabet.\n\n    s is the byte string to encode.  The encoded byte string is\n    returned.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "b64encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "_urlsafe_encode_translation")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "urlsafe_b64decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a byte string encoded with the standard Base64 alphabet.\n\n    s is the byte string to decode.  The decoded byte string is\n    returned.  binascii.Error is raised if the input is incorrectly\n    padded or if there are non-alphabet characters present in the\n    input.\n\n    The alphabet uses '-' instead of '+' and '_' instead of '/'.\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "_urlsafe_decode_translation")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "b64decode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_b32alphabet")
(PUNCT "=")
(LIT #"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567")
(NEWLINE)
(ID "_b32tab2")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_b32rev")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "b32encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a byte string using Base32.\n\n    s is the byte string to encode.  The encoded byte string is returned.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_b32tab2")
(NEWLINE)
(KEYWORD if)
(ID "_b32tab2")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b32tab")
(PUNCT "=")
(PUNCT "[")
(ID "bytes")
(PUNCT "(")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "_b32alphabet")
(PUNCT "]")
(NEWLINE)
(ID "_b32tab2")
(PUNCT "=")
(PUNCT "[")
(ID "a")
(PUNCT "+")
(ID "b")
(KEYWORD for)
(ID "a")
(KEYWORD in)
(ID "b32tab")
(KEYWORD for)
(ID "b")
(KEYWORD in)
(ID "b32tab")
(PUNCT "]")
(NEWLINE)
(ID "b32tab")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "bytes_types")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "memoryview")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ".")
(ID "tobytes")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "leftover")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "%")
(LIT 5)
(NEWLINE)
(KEYWORD if)
(ID "leftover")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "+")
(ID "bytes")
(PUNCT "(")
(LIT 5)
(PUNCT "-")
(ID "leftover")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "encoded")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "from_bytes")
(PUNCT "=")
(ID "int")
(PUNCT ".")
(ID "from_bytes")
(NEWLINE)
(ID "b32tab2")
(PUNCT "=")
(ID "_b32tab2")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ",")
(LIT 5)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "from_bytes")
(PUNCT "(")
(ID "s")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(LIT 5)
(PUNCT "]")
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(ID "encoded")
(PUNCT "+=")
(PUNCT "(")
(ID "b32tab2")
(PUNCT "[")
(ID "c")
(PUNCT ">>")
(LIT 30)
(PUNCT "]")
(PUNCT "+")
(ID "b32tab2")
(PUNCT "[")
(PUNCT "(")
(ID "c")
(PUNCT ">>")
(LIT 20)
(PUNCT ")")
(PUNCT "&")
(LIT 1023)
(PUNCT "]")
(PUNCT "+")
(ID "b32tab2")
(PUNCT "[")
(PUNCT "(")
(ID "c")
(PUNCT ">>")
(LIT 10)
(PUNCT ")")
(PUNCT "&")
(LIT 1023)
(PUNCT "]")
(PUNCT "+")
(ID "b32tab2")
(PUNCT "[")
(ID "c")
(PUNCT "&")
(LIT 1023)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "leftover")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoded")
(PUNCT "[")
(PUNCT "-")
(LIT 6)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(LIT #"======")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "leftover")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoded")
(PUNCT "[")
(PUNCT "-")
(LIT 4)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(LIT #"====")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "leftover")
(PUNCT "==")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoded")
(PUNCT "[")
(PUNCT "-")
(LIT 3)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(LIT #"===")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "leftover")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoded")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(LIT #"=")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "encoded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "b32decode")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "casefold")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "map01")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a Base32 encoded byte string.\n\n    s is the byte string to decode.  Optional casefold is a flag\n    specifying whether a lowercase alphabet is acceptable as input.\n    For security purposes, the default is False.\n\n    RFC 3548 allows for optional mapping of the digit 0 (zero) to the\n    letter O (oh), and for optional mapping of the digit 1 (one) to\n    either the letter I (eye) or letter L (el).  The optional argument\n    map01 when not None, specifies which letter the digit 1 should be\n    mapped to (when map01 is not None, the digit 0 is always mapped to\n    the letter O).  For security purposes the default is None, so that\n    0 and 1 are not allowed in the input.\n\n    The decoded byte string is returned.  binascii.Error is raised if\n    the input is incorrectly padded or if there are non-alphabet\n    characters present in the input.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_b32rev")
(NEWLINE)
(KEYWORD if)
(ID "_b32rev")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_b32rev")
(PUNCT "=")
(PUNCT "{")
(ID "v")
(PUNCT ":")
(ID "k")
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "_b32alphabet")
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "%")
(LIT 8)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT "(")
(LIT "Incorrect padding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "map01")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "map01")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "map01")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "map01")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "map01")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "translate")
(PUNCT "(")
(ID "bytes")
(PUNCT ".")
(ID "maketrans")
(PUNCT "(")
(LIT #"01")
(PUNCT ",")
(LIT #"O")
(PUNCT "+")
(ID "map01")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "casefold")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "upper")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "l")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT #"=")
(PUNCT ")")
(NEWLINE)
(ID "padchars")
(PUNCT "=")
(ID "l")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "decoded")
(PUNCT "=")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "b32rev")
(PUNCT "=")
(ID "_b32rev")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ",")
(LIT 8)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "quanta")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(LIT 8)
(PUNCT "]")
(NEWLINE)
(ID "acc")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "quanta")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "acc")
(PUNCT "=")
(PUNCT "(")
(ID "acc")
(PUNCT "<<")
(LIT 5)
(PUNCT ")")
(PUNCT "+")
(ID "b32rev")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT "(")
(LIT "Non-base32 digit found")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "decoded")
(PUNCT "+=")
(ID "acc")
(PUNCT ".")
(ID "to_bytes")
(PUNCT "(")
(LIT 5)
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "padchars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "acc")
(PUNCT "<<=")
(LIT 5)
(PUNCT "*")
(ID "padchars")
(NEWLINE)
(ID "last")
(PUNCT "=")
(ID "acc")
(PUNCT ".")
(ID "to_bytes")
(PUNCT "(")
(LIT 5)
(PUNCT ",")
(LIT "big")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "padchars")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "[")
(PUNCT "-")
(LIT 5)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "last")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "padchars")
(PUNCT "==")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "[")
(PUNCT "-")
(LIT 5)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "last")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "padchars")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "[")
(PUNCT "-")
(LIT 5)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "last")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 3)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "padchars")
(PUNCT "==")
(LIT 6)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded")
(PUNCT "[")
(PUNCT "-")
(LIT 5)
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "last")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 4)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT "(")
(LIT "Incorrect padding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "bytes")
(PUNCT "(")
(ID "decoded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "b16encode")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a byte string using Base16.\n\n    s is the byte string to encode.  The encoded byte string is returned.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "binascii")
(PUNCT ".")
(ID "hexlify")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ".")
(ID "upper")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "b16decode")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "casefold")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a Base16 encoded byte string.\n\n    s is the byte string to decode.  Optional casefold is a flag\n    specifying whether a lowercase alphabet is acceptable as input.\n    For security purposes, the default is False.\n\n    The decoded byte string is returned.  binascii.Error is raised if\n    s were incorrectly padded or if there are non-alphabet characters\n    present in the string.\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "casefold")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "upper")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "re")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(LIT #"[^0-9A-F]")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "binascii")
(PUNCT ".")
(ID "Error")
(PUNCT "(")
(LIT "Non-base16 digit found")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "binascii")
(PUNCT ".")
(ID "unhexlify")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_a85chars")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_a85chars2")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_A85START")
(PUNCT "=")
(LIT #"<~")
(NEWLINE)
(ID "_A85END")
(PUNCT "=")
(LIT #"~>")
(NEWLINE)
(KEYWORD def)
(ID "_85encode")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "chars")
(PUNCT ",")
(ID "chars2")
(PUNCT ",")
(ID "pad")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "foldnuls")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "foldspaces")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "bytes_types")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT "=")
(ID "memoryview")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ".")
(ID "tobytes")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "padding")
(PUNCT "=")
(PUNCT "(")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(PUNCT "%")
(LIT 4)
(NEWLINE)
(KEYWORD if)
(ID "padding")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT "=")
(ID "b")
(PUNCT "+")
(LIT #"\0")
(PUNCT "*")
(ID "padding")
(NEWLINE)
(DEDENT)
(ID "words")
(PUNCT "=")
(ID "struct")
(PUNCT ".")
(ID "Struct")
(PUNCT "(")
(LIT "!%dI")
(PUNCT "%")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT "//")
(LIT 4)
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "unpack")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(ID "chunks")
(PUNCT "=")
(PUNCT "[")
(LIT #"z")
(KEYWORD if)
(ID "foldnuls")
(KEYWORD and)
(KEYWORD not)
(ID "word")
(KEYWORD else)
(LIT #"y")
(KEYWORD if)
(ID "foldspaces")
(KEYWORD and)
(ID "word")
(PUNCT "==")
(LIT 538976288)
(KEYWORD else)
(PUNCT "(")
(ID "chars2")
(PUNCT "[")
(ID "word")
(PUNCT "//")
(LIT 614125)
(PUNCT "]")
(PUNCT "+")
(ID "chars2")
(PUNCT "[")
(ID "word")
(PUNCT "//")
(LIT 85)
(PUNCT "%")
(LIT 7225)
(PUNCT "]")
(PUNCT "+")
(ID "chars")
(PUNCT "[")
(ID "word")
(PUNCT "%")
(LIT 85)
(PUNCT "]")
(PUNCT ")")
(KEYWORD for)
(ID "word")
(KEYWORD in)
(ID "words")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "padding")
(KEYWORD and)
(KEYWORD not)
(ID "pad")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT #"z")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "chars")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "*")
(LIT 5)
(NEWLINE)
(DEDENT)
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(ID "padding")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "a85encode")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "foldspaces")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "wrapcol")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "pad")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "adobe")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a byte string using Ascii85.\n\n    b is the byte string to encode. The encoded byte string is returned.\n\n    foldspaces is an optional flag that uses the special short sequence 'y'\n    instead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This\n    feature is not supported by the \"standard\" Adobe encoding.\n\n    wrapcol controls whether the output should have newline ('\n') characters\n    added to it. If this is non-zero, each output line will be at most this\n    many characters long.\n\n    pad controls whether the input string is padded to a multiple of 4 before\n    encoding. Note that the btoa implementation always pads.\n\n    adobe controls whether the encoded byte sequence is framed with <~ and ~>,\n    which is used by the Adobe implementation.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_a85chars")
(PUNCT ",")
(ID "_a85chars2")
(NEWLINE)
(KEYWORD if)
(ID "_a85chars")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_a85chars")
(PUNCT "=")
(PUNCT "[")
(ID "bytes")
(PUNCT "(")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 33)
(PUNCT ",")
(LIT 118)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "_a85chars2")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(ID "a")
(PUNCT "+")
(ID "b")
(PUNCT ")")
(KEYWORD for)
(ID "a")
(KEYWORD in)
(ID "_a85chars")
(KEYWORD for)
(ID "b")
(KEYWORD in)
(ID "_a85chars")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "_85encode")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "_a85chars")
(PUNCT ",")
(ID "_a85chars2")
(PUNCT ",")
(ID "pad")
(PUNCT ",")
(KEYWORD True)
(PUNCT ",")
(ID "foldspaces")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "adobe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "_A85START")
(PUNCT "+")
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "wrapcol")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wrapcol")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 2)
(KEYWORD if)
(ID "adobe")
(KEYWORD else)
(LIT 1)
(PUNCT ",")
(ID "wrapcol")
(PUNCT ")")
(NEWLINE)
(ID "chunks")
(PUNCT "=")
(PUNCT "[")
(ID "result")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(ID "wrapcol")
(PUNCT "]")
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "result")
(PUNCT ")")
(PUNCT ",")
(ID "wrapcol")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "adobe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "chunks")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT "+")
(LIT 2)
(PUNCT ">")
(ID "wrapcol")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunks")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT #"")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "result")
(PUNCT "=")
(LIT #"\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "chunks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "adobe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(ID "_A85END")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "a85decode")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "foldspaces")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "adobe")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "ignorechars")
(PUNCT "=")
(LIT #" \t\n\r\v")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode an Ascii85 encoded byte string.\n\n    s is the byte string to decode.\n\n    foldspaces is a flag that specifies whether the 'y' short sequence should be\n    accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is\n    not supported by the \"standard\" Adobe encoding.\n\n    adobe controls whether the input sequence is in Adobe Ascii85 format (i.e.\n    is framed with <~ and ~>).\n\n    ignorechars should be a byte string containing characters to ignore from the\n    input. This should only contain whitespace characters, and by default\n    contains all whitespace characters in ASCII.\n    ")
(NEWLINE)
(ID "b")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "adobe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "b")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "_A85START")
(PUNCT ")")
(KEYWORD and)
(ID "b")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "_A85END")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Ascii85 encoded byte sequences must be bracketed ")
(LIT "by {!r} and {!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "_A85START")
(PUNCT ",")
(ID "_A85END")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "b")
(PUNCT "=")
(ID "b")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "packI")
(PUNCT "=")
(ID "struct")
(PUNCT ".")
(ID "Struct")
(PUNCT "(")
(LIT "!I")
(PUNCT ")")
(PUNCT ".")
(ID "pack")
(NEWLINE)
(ID "decoded")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "decoded_append")
(PUNCT "=")
(ID "decoded")
(PUNCT ".")
(ID "append")
(NEWLINE)
(ID "curr")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "curr_append")
(PUNCT "=")
(ID "curr")
(PUNCT ".")
(ID "append")
(NEWLINE)
(ID "curr_clear")
(PUNCT "=")
(ID "curr")
(PUNCT ".")
(ID "clear")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "b")
(PUNCT "+")
(LIT #"u")
(PUNCT "*")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT #"!")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "<=")
(ID "x")
(PUNCT "<=")
(LIT #"u")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "curr_append")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "curr")
(PUNCT ")")
(PUNCT "==")
(LIT 5)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "acc")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "curr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "acc")
(PUNCT "=")
(LIT 85)
(PUNCT "*")
(ID "acc")
(PUNCT "+")
(PUNCT "(")
(ID "x")
(PUNCT "-")
(LIT 33)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "decoded_append")
(PUNCT "(")
(ID "packI")
(PUNCT "(")
(ID "acc")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "struct")
(PUNCT ".")
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Ascii85 overflow")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "curr_clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "x")
(PUNCT "==")
(LIT #"z")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "curr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "z inside Ascii85 5-tuple")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "decoded_append")
(PUNCT "(")
(LIT #"\0\0\0\0")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "foldspaces")
(KEYWORD and)
(ID "x")
(PUNCT "==")
(LIT #"y")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "curr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "y inside Ascii85 5-tuple")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "decoded_append")
(PUNCT "(")
(LIT #"    ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "x")
(KEYWORD in)
(ID "ignorechars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Non-Ascii85 digit found: %c")
(PUNCT "%")
(ID "x")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "result")
(PUNCT "=")
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "decoded")
(PUNCT ")")
(NEWLINE)
(ID "padding")
(PUNCT "=")
(LIT 4)
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "curr")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "padding")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "result")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(ID "padding")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(ID "_b85alphabet")
(PUNCT "=")
(PUNCT "(")
(LIT #"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(LIT #"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~")
(PUNCT ")")
(NEWLINE)
(ID "_b85chars")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_b85chars2")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_b85dec")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "b85encode")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "pad")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode an ASCII-encoded byte array in base85 format.\n\n    If pad is true, the input is padded with \"\u0000\" so its length is a multiple of\n    4 characters before encoding.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_b85chars")
(PUNCT ",")
(ID "_b85chars2")
(NEWLINE)
(KEYWORD if)
(ID "_b85chars")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_b85chars")
(PUNCT "=")
(PUNCT "[")
(ID "bytes")
(PUNCT "(")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "_b85alphabet")
(PUNCT "]")
(NEWLINE)
(ID "_b85chars2")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(ID "a")
(PUNCT "+")
(ID "b")
(PUNCT ")")
(KEYWORD for)
(ID "a")
(KEYWORD in)
(ID "_b85chars")
(KEYWORD for)
(ID "b")
(KEYWORD in)
(ID "_b85chars")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_85encode")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "_b85chars")
(PUNCT ",")
(ID "_b85chars2")
(PUNCT ",")
(ID "pad")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "b85decode")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode base85-encoded byte array")
(NEWLINE)
(KEYWORD global)
(ID "_b85dec")
(NEWLINE)
(KEYWORD if)
(ID "_b85dec")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_b85dec")
(PUNCT "=")
(PUNCT "[")
(KEYWORD None)
(PUNCT "]")
(PUNCT "*")
(LIT 256)
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "c")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "_b85alphabet")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_b85dec")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(PUNCT "=")
(ID "i")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "b")
(PUNCT "=")
(ID "_bytes_from_decode_data")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(ID "padding")
(PUNCT "=")
(PUNCT "(")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(PUNCT "%")
(LIT 5)
(NEWLINE)
(ID "b")
(PUNCT "=")
(ID "b")
(PUNCT "+")
(LIT #"~")
(PUNCT "*")
(ID "padding")
(NEWLINE)
(ID "out")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "packI")
(PUNCT "=")
(ID "struct")
(PUNCT ".")
(ID "Struct")
(PUNCT "(")
(LIT "!I")
(PUNCT ")")
(PUNCT ".")
(ID "pack")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ",")
(LIT 5)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunk")
(PUNCT "=")
(ID "b")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(LIT 5)
(PUNCT "]")
(NEWLINE)
(ID "acc")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "chunk")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "acc")
(PUNCT "=")
(ID "acc")
(PUNCT "*")
(LIT 85)
(PUNCT "+")
(ID "_b85dec")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "j")
(PUNCT ",")
(ID "c")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_b85dec")
(PUNCT "[")
(ID "c")
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "bad base85 character at position %d")
(PUNCT "%")
(PUNCT "(")
(ID "i")
(PUNCT "+")
(ID "j")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "out")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "packI")
(PUNCT "(")
(ID "acc")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "struct")
(PUNCT ".")
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "base85 overflow in hunk starting at byte %d")
(PUNCT "%")
(ID "i")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "result")
(PUNCT "=")
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "out")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "padding")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "result")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(ID "padding")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(ID "MAXLINESIZE")
(PUNCT "=")
(LIT 76)
(NEWLINE)
(ID "MAXBINSIZE")
(PUNCT "=")
(PUNCT "(")
(ID "MAXLINESIZE")
(PUNCT "//")
(LIT 4)
(PUNCT ")")
(PUNCT "*")
(LIT 3)
(NEWLINE)
(KEYWORD def)
(ID "encode")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(ID "output")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a file; input and output are binary files.")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "input")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "MAXBINSIZE")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "s")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "<")
(ID "MAXBINSIZE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ns")
(PUNCT "=")
(ID "input")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "MAXBINSIZE")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ns")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "+=")
(ID "ns")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "binascii")
(PUNCT ".")
(ID "b2a_base64")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "output")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "decode")
(PUNCT "(")
(ID "input")
(PUNCT ",")
(ID "output")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a file; input and output are binary files.")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "input")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "=")
(ID "binascii")
(PUNCT ".")
(ID "a2b_base64")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "output")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_input_type_check")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "memoryview")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "expected bytes-like object, not %s")
(PUNCT "%")
(ID "s")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(KEYWORD from)
(ID "err")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "m")
(PUNCT ".")
(ID "format")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "c")
(PUNCT ",")
(LIT "b")
(PUNCT ",")
(LIT "B")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "(")
(LIT "expected single byte elements, not %r from %s")
(PUNCT "%")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "format")
(PUNCT ",")
(ID "s")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "m")
(PUNCT ".")
(ID "ndim")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "(")
(LIT "expected 1-D data, not %d-D data from %s")
(PUNCT "%")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "ndim")
(PUNCT ",")
(ID "s")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "encodebytes")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Encode a bytestring into a bytestring containing multiple lines\n    of base-64 data.")
(NEWLINE)
(ID "_input_type_check")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(ID "pieces")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ",")
(ID "MAXBINSIZE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "chunk")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "i")
(PUNCT "+")
(ID "MAXBINSIZE")
(PUNCT "]")
(NEWLINE)
(ID "pieces")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "binascii")
(PUNCT ".")
(ID "b2a_base64")
(PUNCT "(")
(ID "chunk")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "pieces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "encodestring")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Legacy alias of encodebytes().")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "encodestring() is a deprecated alias, use encodebytes()")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "encodebytes")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decodebytes")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decode a bytestring of base-64 data into a bytestring.")
(NEWLINE)
(ID "_input_type_check")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "binascii")
(PUNCT ".")
(ID "a2b_base64")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "decodestring")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Legacy alias of decodebytes().")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "decodestring() is a deprecated alias, use decodebytes()")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "decodebytes")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "main")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Small main program")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "getopt")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opts")
(PUNCT ",")
(ID "args")
(PUNCT "=")
(ID "getopt")
(PUNCT ".")
(ID "getopt")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(LIT "deut")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "getopt")
(PUNCT ".")
(ID "error")
(KEYWORD as)
(ID "msg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stderr")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "usage: %s [-d|-e|-u|-t] [file|-]\n        -d, -u: decode\n        -e: encode (default)\n        -t: encode and decode string 'Aladdin:open sesame'")
(PUNCT "%")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "exit")
(PUNCT "(")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "func")
(PUNCT "=")
(ID "encode")
(NEWLINE)
(KEYWORD for)
(ID "o")
(PUNCT ",")
(ID "a")
(KEYWORD in)
(ID "opts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "o")
(PUNCT "==")
(LIT "-e")
(PUNCT ":")
(ID "func")
(PUNCT "=")
(ID "encode")
(NEWLINE)
(KEYWORD if)
(ID "o")
(PUNCT "==")
(LIT "-d")
(PUNCT ":")
(ID "func")
(PUNCT "=")
(ID "decode")
(NEWLINE)
(KEYWORD if)
(ID "o")
(PUNCT "==")
(LIT "-u")
(PUNCT ":")
(ID "func")
(PUNCT "=")
(ID "decode")
(NEWLINE)
(KEYWORD if)
(ID "o")
(PUNCT "==")
(LIT "-t")
(PUNCT ":")
(ID "test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ";")
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "args")
(KEYWORD and)
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "!=")
(LIT "-")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(KEYWORD as)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "buffer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ".")
(ID "buffer")
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "buffer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s0")
(PUNCT "=")
(LIT #"Aladdin:open sesame")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "s0")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "s1")
(PUNCT "=")
(ID "encodebytes")
(PUNCT "(")
(ID "s0")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "s1")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "s2")
(PUNCT "=")
(ID "decodebytes")
(PUNCT "(")
(ID "s1")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "s2")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "s0")
(PUNCT "==")
(ID "s2")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "main")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
