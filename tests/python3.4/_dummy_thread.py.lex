(LIT "Drop-in replacement for the thread module.\n\nMeant to be used as a brain-dead substitute so that threaded code does\nnot need to be rewritten for when the thread module is not present.\n\nSuggested usage is::\n\n    try:\n        import _thread\n    except ImportError:\n        import _dummy_thread as _thread\n\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "error")
(PUNCT ",")
(LIT "start_new_thread")
(PUNCT ",")
(LIT "exit")
(PUNCT ",")
(LIT "get_ident")
(PUNCT ",")
(LIT "allocate_lock")
(PUNCT ",")
(LIT "interrupt_main")
(PUNCT ",")
(LIT "LockType")
(PUNCT "]")
(NEWLINE)
(ID "TIMEOUT_MAX")
(PUNCT "=")
(LIT 2)
(PUNCT "**")
(LIT 31)
(NEWLINE)
(ID "error")
(PUNCT "=")
(ID "RuntimeError")
(NEWLINE)
(KEYWORD def)
(ID "start_new_thread")
(PUNCT "(")
(ID "function")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "kwargs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of _thread.start_new_thread().\n\n    Compatibility is maintained by making sure that ``args`` is a\n    tuple and ``kwargs`` is a dictionary.  If an exception is raised\n    and it is SystemExit (which can be done by _thread.exit()) it is\n    caught and nothing is done; all other exceptions are printed out\n    by using traceback.print_exc().\n\n    If the executed function calls interrupt_main the KeyboardInterrupt will be\n    raised when the function returns.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "!=")
(ID "type")
(PUNCT "(")
(ID "tuple")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "2nd arg must be a tuple")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "kwargs")
(PUNCT ")")
(PUNCT "!=")
(ID "type")
(PUNCT "(")
(ID "dict")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "3rd arg must be a dict")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD global)
(ID "_main")
(NEWLINE)
(ID "_main")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "function")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "SystemExit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(ID "traceback")
(PUNCT ".")
(ID "print_exc")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_main")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD global)
(ID "_interrupt")
(NEWLINE)
(KEYWORD if)
(ID "_interrupt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_interrupt")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD raise)
(ID "KeyboardInterrupt")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "exit")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of _thread.exit().")
(NEWLINE)
(KEYWORD raise)
(ID "SystemExit")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of _thread.get_ident().\n\n    Since this module should only be used when _threadmodule is not\n    available, it is safe to assume that the current process is the\n    only thread.  Thus a constant can be safely returned.\n    ")
(NEWLINE)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "allocate_lock")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of _thread.allocate_lock().")
(NEWLINE)
(KEYWORD return)
(ID "LockType")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "stack_size")
(PUNCT "(")
(ID "size")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of _thread.stack_size().")
(NEWLINE)
(KEYWORD if)
(ID "size")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "error")
(PUNCT "(")
(LIT "setting thread stack size not supported")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_set_sentinel")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of _thread._set_sentinel().")
(NEWLINE)
(KEYWORD return)
(ID "LockType")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "LockType")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Class implementing dummy implementation of _thread.LockType.\n\n    Compatibility is maintained by maintaining self.locked_status\n    which is a boolean that stores the state of the lock.  Pickling of\n    the lock, though, should not be done since if the _thread module is\n    then used with an unpickled ``lock()`` from here problems could\n    occur from this class not having atomic methods.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "acquire")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "waitflag")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy implementation of acquire().\n\n        For blocking calls, self.locked_status is automatically set to\n        True and returned appropriately based on value of\n        ``waitflag``.  If it is non-blocking, then the value is\n        actually checked and not set if it is already acquired.  This\n        is all done so that threading.Condition's assert statements\n        aren't triggered and throw a little fit.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "waitflag")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "waitflag")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "timeout")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "time")
(NEWLINE)
(ID "time")
(PUNCT ".")
(ID "sleep")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "__enter__")
(PUNCT "=")
(ID "acquire")
(NEWLINE)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "typ")
(PUNCT ",")
(ID "val")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "release")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Release the dummy lock.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "error")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "locked")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "locked_status")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_interrupt")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "_main")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD def)
(ID "interrupt_main")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set _interrupt flag to True to have start_new_thread raise\n    KeyboardInterrupt upon exiting.")
(NEWLINE)
(KEYWORD if)
(ID "_main")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyboardInterrupt")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD global)
(ID "_interrupt")
(NEWLINE)
(ID "_interrupt")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
