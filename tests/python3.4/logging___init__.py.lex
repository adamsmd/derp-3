(LIT "\nLogging package for Python. Based on PEP 282 and comments thereto in\ncomp.lang.python.\n\nCopyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "os")
(PUNCT ",")
(ID "time")
(PUNCT ",")
(ID "io")
(PUNCT ",")
(ID "traceback")
(PUNCT ",")
(ID "warnings")
(PUNCT ",")
(ID "weakref")
(PUNCT ",")
(ID "collections")
(NEWLINE)
(KEYWORD from)
(ID "string")
(KEYWORD import)
(ID "Template")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "BASIC_FORMAT")
(PUNCT ",")
(LIT "BufferingFormatter")
(PUNCT ",")
(LIT "CRITICAL")
(PUNCT ",")
(LIT "DEBUG")
(PUNCT ",")
(LIT "ERROR")
(PUNCT ",")
(LIT "FATAL")
(PUNCT ",")
(LIT "FileHandler")
(PUNCT ",")
(LIT "Filter")
(PUNCT ",")
(LIT "Formatter")
(PUNCT ",")
(LIT "Handler")
(PUNCT ",")
(LIT "INFO")
(PUNCT ",")
(LIT "LogRecord")
(PUNCT ",")
(LIT "Logger")
(PUNCT ",")
(LIT "LoggerAdapter")
(PUNCT ",")
(LIT "NOTSET")
(PUNCT ",")
(LIT "NullHandler")
(PUNCT ",")
(LIT "StreamHandler")
(PUNCT ",")
(LIT "WARN")
(PUNCT ",")
(LIT "WARNING")
(PUNCT ",")
(LIT "addLevelName")
(PUNCT ",")
(LIT "basicConfig")
(PUNCT ",")
(LIT "captureWarnings")
(PUNCT ",")
(LIT "critical")
(PUNCT ",")
(LIT "debug")
(PUNCT ",")
(LIT "disable")
(PUNCT ",")
(LIT "error")
(PUNCT ",")
(LIT "exception")
(PUNCT ",")
(LIT "fatal")
(PUNCT ",")
(LIT "getLevelName")
(PUNCT ",")
(LIT "getLogger")
(PUNCT ",")
(LIT "getLoggerClass")
(PUNCT ",")
(LIT "info")
(PUNCT ",")
(LIT "log")
(PUNCT ",")
(LIT "makeLogRecord")
(PUNCT ",")
(LIT "setLoggerClass")
(PUNCT ",")
(LIT "warn")
(PUNCT ",")
(LIT "warning")
(PUNCT ",")
(LIT "getLogRecordFactory")
(PUNCT ",")
(LIT "setLogRecordFactory")
(PUNCT ",")
(LIT "lastResort")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "threading")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "threading")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "__author__")
(PUNCT "=")
(LIT "Vinay Sajip <vinay_sajip@red-dove.com>")
(NEWLINE)
(ID "__status__")
(PUNCT "=")
(LIT "production")
(NEWLINE)
(ID "__version__")
(PUNCT "=")
(LIT "0.5.1.2")
(NEWLINE)
(ID "__date__")
(PUNCT "=")
(LIT "07 February 2010")
(NEWLINE)
(ID "_startTime")
(PUNCT "=")
(ID "time")
(PUNCT ".")
(ID "time")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "raiseExceptions")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "logThreads")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "logMultiprocessing")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "logProcesses")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "CRITICAL")
(PUNCT "=")
(LIT 50)
(NEWLINE)
(ID "FATAL")
(PUNCT "=")
(ID "CRITICAL")
(NEWLINE)
(ID "ERROR")
(PUNCT "=")
(LIT 40)
(NEWLINE)
(ID "WARNING")
(PUNCT "=")
(LIT 30)
(NEWLINE)
(ID "WARN")
(PUNCT "=")
(ID "WARNING")
(NEWLINE)
(ID "INFO")
(PUNCT "=")
(LIT 20)
(NEWLINE)
(ID "DEBUG")
(PUNCT "=")
(LIT 10)
(NEWLINE)
(ID "NOTSET")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "_levelToName")
(PUNCT "=")
(PUNCT "{")
(ID "CRITICAL")
(PUNCT ":")
(LIT "CRITICAL")
(PUNCT ",")
(ID "ERROR")
(PUNCT ":")
(LIT "ERROR")
(PUNCT ",")
(ID "WARNING")
(PUNCT ":")
(LIT "WARNING")
(PUNCT ",")
(ID "INFO")
(PUNCT ":")
(LIT "INFO")
(PUNCT ",")
(ID "DEBUG")
(PUNCT ":")
(LIT "DEBUG")
(PUNCT ",")
(ID "NOTSET")
(PUNCT ":")
(LIT "NOTSET")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "_nameToLevel")
(PUNCT "=")
(PUNCT "{")
(LIT "CRITICAL")
(PUNCT ":")
(ID "CRITICAL")
(PUNCT ",")
(LIT "ERROR")
(PUNCT ":")
(ID "ERROR")
(PUNCT ",")
(LIT "WARN")
(PUNCT ":")
(ID "WARNING")
(PUNCT ",")
(LIT "WARNING")
(PUNCT ":")
(ID "WARNING")
(PUNCT ",")
(LIT "INFO")
(PUNCT ":")
(ID "INFO")
(PUNCT ",")
(LIT "DEBUG")
(PUNCT ":")
(ID "DEBUG")
(PUNCT ",")
(LIT "NOTSET")
(PUNCT ":")
(ID "NOTSET")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "getLevelName")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the textual representation of logging level 'level'.\n\n    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\n    INFO, DEBUG) then you get the corresponding string. If you have\n    associated levels with names using addLevelName then the name you have\n    associated with 'level' is returned.\n\n    If a numeric value corresponding to one of the defined levels is passed\n    in, the corresponding string representation is returned.\n\n    Otherwise, the string \"Level %s\" % level is returned.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "_levelToName")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "_nameToLevel")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(PUNCT "(")
(LIT "Level %s")
(PUNCT "%")
(ID "level")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "addLevelName")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "levelName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Associate 'levelName' with 'level'.\n\n    This is used when converting levels to text during message formatting.\n    ")
(NEWLINE)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_levelToName")
(PUNCT "[")
(ID "level")
(PUNCT "]")
(PUNCT "=")
(ID "levelName")
(NEWLINE)
(ID "_nameToLevel")
(PUNCT "[")
(ID "levelName")
(PUNCT "]")
(PUNCT "=")
(ID "level")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "sys")
(PUNCT ",")
(LIT "_getframe")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "currentframe")
(PUNCT "=")
(KEYWORD lambda)
(PUNCT ":")
(ID "sys")
(PUNCT ".")
(ID "_getframe")
(PUNCT "(")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "currentframe")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the frame object for the caller's stack frame.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "Exception")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ".")
(ID "f_back")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "_srcfile")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "addLevelName")
(PUNCT ".")
(ID "__code__")
(PUNCT ".")
(ID "co_filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_checkLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(ID "level")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "str")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(PUNCT "==")
(ID "level")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "level")
(KEYWORD not)
(KEYWORD in)
(ID "_nameToLevel")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Unknown level: %r")
(PUNCT "%")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rv")
(PUNCT "=")
(ID "_nameToLevel")
(PUNCT "[")
(ID "level")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Level not an integer or a valid string: %r")
(PUNCT "%")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "threading")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_lock")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "RLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Acquire the module-level lock for serializing access to shared data.\n\n    This should be released with _releaseLock().\n    ")
(NEWLINE)
(KEYWORD if)
(ID "_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_lock")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Release the module-level lock acquired by calling _acquireLock().\n    ")
(NEWLINE)
(KEYWORD if)
(ID "_lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_lock")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "LogRecord")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A LogRecord instance represents an event being logged.\n\n    LogRecord instances are created every time something is logged. They\n    contain all the information pertinent to the event being logged. The\n    main information passed in is in msg and args, which are combined\n    using str(msg) % args to create the message field of the record. The\n    record also includes information such as when the record was created,\n    the source line where the logging call was made, and any exception\n    information to be logged.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "pathname")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "exc_info")
(PUNCT ",")
(ID "func")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "sinfo")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize a logging record with interesting information.\n        ")
(NEWLINE)
(ID "ct")
(PUNCT "=")
(ID "time")
(PUNCT ".")
(ID "time")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "=")
(ID "msg")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "args")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "collections")
(PUNCT ".")
(ID "Mapping")
(PUNCT ")")
(KEYWORD and)
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "levelname")
(PUNCT "=")
(ID "getLevelName")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "levelno")
(PUNCT "=")
(ID "level")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pathname")
(PUNCT "=")
(ID "pathname")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "pathname")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "module")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "pathname")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "module")
(PUNCT "=")
(LIT "Unknown module")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "exc_info")
(PUNCT "=")
(ID "exc_info")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "exc_text")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack_info")
(PUNCT "=")
(ID "sinfo")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "funcName")
(PUNCT "=")
(ID "func")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "created")
(PUNCT "=")
(ID "ct")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "msecs")
(PUNCT "=")
(PUNCT "(")
(ID "ct")
(PUNCT "-")
(ID "int")
(PUNCT "(")
(ID "ct")
(PUNCT ")")
(PUNCT ")")
(PUNCT "*")
(LIT 1000)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "relativeCreated")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "created")
(PUNCT "-")
(ID "_startTime")
(PUNCT ")")
(PUNCT "*")
(LIT 1000)
(NEWLINE)
(KEYWORD if)
(ID "logThreads")
(KEYWORD and)
(ID "threading")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "thread")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "get_ident")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "threadName")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "current_thread")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "thread")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "threadName")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "logMultiprocessing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processName")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processName")
(PUNCT "=")
(LIT "MainProcess")
(NEWLINE)
(ID "mp")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "multiprocessing")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "mp")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "processName")
(PUNCT "=")
(ID "mp")
(PUNCT ".")
(ID "current_process")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "logProcesses")
(KEYWORD and)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "getpid")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "process")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "getpid")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "process")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<LogRecord: %s, %s, %s, %s, \"%s\">")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "levelno")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "pathname")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getMessage")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return the message for this LogRecord.\n\n        Return the message for this LogRecord after merging any user-supplied\n        arguments with the message.\n        ")
(NEWLINE)
(ID "msg")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "args")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "msg")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_logRecordFactory")
(PUNCT "=")
(ID "LogRecord")
(NEWLINE)
(KEYWORD def)
(ID "setLogRecordFactory")
(PUNCT "(")
(ID "factory")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Set the factory to be used when instantiating a log record.\n\n    :param factory: A callable which will be called to instantiate\n    a log record.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_logRecordFactory")
(NEWLINE)
(ID "_logRecordFactory")
(PUNCT "=")
(ID "factory")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getLogRecordFactory")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the factory to be used when instantiating a log record.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "_logRecordFactory")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "makeLogRecord")
(PUNCT "(")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Make a LogRecord whose attributes are defined by the specified dictionary,\n    This function is useful for converting a logging event received over\n    a socket connection (which is sent as a dictionary) into a LogRecord\n    instance.\n    ")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(ID "_logRecordFactory")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT "")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT "")
(PUNCT ",")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "rv")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "dict")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "PercentStyle")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "default_format")
(PUNCT "=")
(LIT "%(message)s")
(NEWLINE)
(ID "asctime_format")
(PUNCT "=")
(LIT "%(asctime)s")
(NEWLINE)
(ID "asctime_search")
(PUNCT "=")
(LIT "%(asctime)")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fmt")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT "=")
(ID "fmt")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "default_format")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "usesTime")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "asctime_search")
(PUNCT ")")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT "%")
(ID "record")
(PUNCT ".")
(ID "__dict__")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "StrFormatStyle")
(PUNCT "(")
(ID "PercentStyle")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "default_format")
(PUNCT "=")
(LIT "{message}")
(NEWLINE)
(ID "asctime_format")
(PUNCT "=")
(LIT "{asctime}")
(NEWLINE)
(ID "asctime_search")
(PUNCT "=")
(LIT "{asctime")
(NEWLINE)
(KEYWORD def)
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(PUNCT "**")
(ID "record")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "StringTemplateStyle")
(PUNCT "(")
(ID "PercentStyle")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "default_format")
(PUNCT "=")
(LIT "${message}")
(NEWLINE)
(ID "asctime_format")
(PUNCT "=")
(LIT "${asctime}")
(NEWLINE)
(ID "asctime_search")
(PUNCT "=")
(LIT "${asctime}")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fmt")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT "=")
(ID "fmt")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "default_format")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tpl")
(PUNCT "=")
(ID "Template")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "usesTime")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fmt")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fmt")
(NEWLINE)
(KEYWORD return)
(ID "fmt")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "$asctime")
(PUNCT ")")
(PUNCT ">=")
(LIT 0)
(KEYWORD or)
(ID "fmt")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "asctime_format")
(PUNCT ")")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_tpl")
(PUNCT ".")
(ID "substitute")
(PUNCT "(")
(PUNCT "**")
(ID "record")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "BASIC_FORMAT")
(PUNCT "=")
(LIT "%(levelname)s:%(name)s:%(message)s")
(NEWLINE)
(ID "_STYLES")
(PUNCT "=")
(PUNCT "{")
(LIT "%")
(PUNCT ":")
(PUNCT "(")
(ID "PercentStyle")
(PUNCT ",")
(ID "BASIC_FORMAT")
(PUNCT ")")
(PUNCT ",")
(LIT "{")
(PUNCT ":")
(PUNCT "(")
(ID "StrFormatStyle")
(PUNCT ",")
(LIT "{levelname}:{name}:{message}")
(PUNCT ")")
(PUNCT ",")
(LIT "$")
(PUNCT ":")
(PUNCT "(")
(ID "StringTemplateStyle")
(PUNCT ",")
(LIT "${levelname}:${name}:${message}")
(PUNCT ")")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD class)
(ID "Formatter")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Formatter instances are used to convert a LogRecord to text.\n\n    Formatters need to know how a LogRecord is constructed. They are\n    responsible for converting a LogRecord to (usually) a string which can\n    be interpreted by either a human or an external system. The base Formatter\n    allows a formatting string to be specified. If none is supplied, the\n    default value of \"%s(message)\" is used.\n\n    The Formatter can be initialized with a format string which makes use of\n    knowledge of the LogRecord attributes - e.g. the default value mentioned\n    above makes use of the fact that the user's message and arguments are pre-\n    formatted into a LogRecord's message attribute. Currently, the useful\n    attributes in a LogRecord are described by:\n\n    %(name)s            Name of the logger (logging channel)\n    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                        WARNING, ERROR, CRITICAL)\n    %(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                        \"WARNING\", \"ERROR\", \"CRITICAL\")\n    %(pathname)s        Full pathname of the source file where the logging\n                        call was issued (if available)\n    %(filename)s        Filename portion of pathname\n    %(module)s          Module (name portion of filename)\n    %(lineno)d          Source line number where the logging call was issued\n                        (if available)\n    %(funcName)s        Function name\n    %(created)f         Time when the LogRecord was created (time.time()\n                        return value)\n    %(asctime)s         Textual time when the LogRecord was created\n    %(msecs)d           Millisecond portion of the creation time\n    %(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                        relative to the time the logging module was loaded\n                        (typically at application startup time)\n    %(thread)d          Thread ID (if available)\n    %(threadName)s      Thread name (if available)\n    %(process)d         Process ID (if available)\n    %(message)s         The result of record.getMessage(), computed just as\n                        the record is emitted\n    ")
(NEWLINE)
(ID "converter")
(PUNCT "=")
(ID "time")
(PUNCT ".")
(ID "localtime")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fmt")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "datefmt")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "style")
(PUNCT "=")
(LIT "%")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument (if omitted, you get the ISO8601 format).\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n\n        .. versionchanged: 3.2\n           Added the ``style`` parameter.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "style")
(KEYWORD not)
(KEYWORD in)
(ID "_STYLES")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Style must be one of: %s")
(PUNCT "%")
(LIT ",")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "_STYLES")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_style")
(PUNCT "=")
(ID "_STYLES")
(PUNCT "[")
(ID "style")
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "(")
(ID "fmt")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fmt")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_style")
(PUNCT ".")
(ID "_fmt")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "datefmt")
(PUNCT "=")
(ID "datefmt")
(NEWLINE)
(DEDENT)
(ID "default_time_format")
(PUNCT "=")
(LIT "%Y-%m-%d %H:%M:%S")
(NEWLINE)
(ID "default_msec_format")
(PUNCT "=")
(LIT "%s,%03d")
(NEWLINE)
(KEYWORD def)
(ID "formatTime")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ",")
(ID "datefmt")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return the creation time of the specified LogRecord as formatted text.\n\n        This method should be called from format() by a formatter which\n        wants to make use of a formatted time. This method can be overridden\n        in formatters to provide for any specific requirement, but the\n        basic behaviour is as follows: if datefmt (a string) is specified,\n        it is used with time.strftime() to format the creation time of the\n        record. Otherwise, the ISO8601 format is used. The resulting\n        string is returned. This function uses a user-configurable function\n        to convert the creation time to a tuple. By default, time.localtime()\n        is used; to change this for a particular formatter instance, set the\n        'converter' attribute to a function with the same signature as\n        time.localtime() or time.gmtime(). To change it for all formatters,\n        for example if you want all logging times to be shown in GMT,\n        set the 'converter' attribute in the Formatter class.\n        ")
(NEWLINE)
(ID "ct")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "converter")
(PUNCT "(")
(ID "record")
(PUNCT ".")
(ID "created")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "datefmt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "time")
(PUNCT ".")
(ID "strftime")
(PUNCT "(")
(ID "datefmt")
(PUNCT ",")
(ID "ct")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "t")
(PUNCT "=")
(ID "time")
(PUNCT ".")
(ID "strftime")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "default_time_format")
(PUNCT ",")
(ID "ct")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "default_msec_format")
(PUNCT "%")
(PUNCT "(")
(ID "t")
(PUNCT ",")
(ID "record")
(PUNCT ".")
(ID "msecs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "s")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "formatException")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ei")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Format and return the specified exception information as a string.\n\n        This default implementation just uses\n        traceback.print_exception()\n        ")
(NEWLINE)
(ID "sio")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "tb")
(PUNCT "=")
(ID "ei")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "traceback")
(PUNCT ".")
(ID "print_exception")
(PUNCT "(")
(ID "ei")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "ei")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "tb")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "sio")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "sio")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "sio")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "s")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "usesTime")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Check if the format uses the creation time of the record.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_style")
(PUNCT ".")
(ID "usesTime")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "formatMessage")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_style")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "formatStack")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "stack_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        This method is provided as an extension point for specialized\n        formatting of stack information.\n\n        The input data is a string as returned from a call to\n        :func:`traceback.print_stack`, but with the last trailing newline\n        removed.\n\n        The base implementation just returns the value passed in.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "stack_info")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Format the specified record as text.\n\n        The record's attribute dictionary is used as the operand to a\n        string formatting operation which yields the returned string.\n        Before formatting the dictionary, a couple of preparatory steps\n        are carried out. The message attribute of the record is computed\n        using LogRecord.getMessage(). If the formatting string uses the\n        time (as determined by a call to usesTime(), formatTime() is\n        called to format the event time. If there is exception information,\n        it is formatted using formatException() and appended to the message.\n        ")
(NEWLINE)
(ID "record")
(PUNCT ".")
(ID "message")
(PUNCT "=")
(ID "record")
(PUNCT ".")
(ID "getMessage")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "usesTime")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "record")
(PUNCT ".")
(ID "asctime")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "formatTime")
(PUNCT "(")
(ID "record")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "datefmt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "formatMessage")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "record")
(PUNCT ".")
(ID "exc_info")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "record")
(PUNCT ".")
(ID "exc_text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "record")
(PUNCT ".")
(ID "exc_text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "formatException")
(PUNCT "(")
(ID "record")
(PUNCT ".")
(ID "exc_info")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "record")
(PUNCT ".")
(ID "exc_text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "!=")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "+")
(LIT "\n")
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "+")
(ID "record")
(PUNCT ".")
(ID "exc_text")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "record")
(PUNCT ".")
(ID "stack_info")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "!=")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "+")
(LIT "\n")
(NEWLINE)
(DEDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "formatStack")
(PUNCT "(")
(ID "record")
(PUNCT ".")
(ID "stack_info")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "s")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_defaultFormatter")
(PUNCT "=")
(ID "Formatter")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "BufferingFormatter")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A formatter suitable for formatting a number of records.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "linefmt")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Optionally specify a formatter which will be used to format each\n        individual record.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "linefmt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "linefmt")
(PUNCT "=")
(ID "linefmt")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "linefmt")
(PUNCT "=")
(ID "_defaultFormatter")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "formatHeader")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "records")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return the header string for the specified records.\n        ")
(NEWLINE)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "formatFooter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "records")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return the footer string for the specified records.\n        ")
(NEWLINE)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "records")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Format the specified records and return the result as a string.\n        ")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "records")
(PUNCT ")")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(ID "rv")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "formatHeader")
(PUNCT "(")
(ID "records")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "record")
(KEYWORD in)
(ID "records")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(ID "rv")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "linefmt")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rv")
(PUNCT "=")
(ID "rv")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "formatFooter")
(PUNCT "(")
(ID "records")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Filter")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Filter instances are used to perform arbitrary filtering of LogRecords.\n\n    Loggers and Handlers can optionally use Filter instances to filter\n    records as desired. The base filter class only allows events which are\n    below a certain point in the logger hierarchy. For example, a filter\n    initialized with \"A.B\" will allow events logged by loggers \"A.B\",\n    \"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\n    initialized with the empty string, all events are passed.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize a filter.\n\n        Initialize with the name of the logger which, together with its\n        children, will have its events allowed through the filter. If no\n        name is specified, allow every event.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "nlen")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "filter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Determine if the specified record is to be logged.\n\n        Is the specified record to be logged? Returns 0 for no, nonzero for\n        yes. If deemed appropriate, the record may be modified in-place.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "nlen")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "record")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "record")
(PUNCT ".")
(ID "name")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "nlen")
(PUNCT ")")
(PUNCT "!=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "record")
(PUNCT ".")
(ID "name")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "nlen")
(PUNCT "]")
(PUNCT "==")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Filterer")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A base class for loggers and handlers which allows them to share\n    common code.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the list of filters to be an empty list.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "filters")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "addFilter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filter")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Add the specified filter to this handler.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "filter")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "filters")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "filters")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "filter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "removeFilter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filter")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Remove the specified filter from this handler.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "filter")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "filters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "filters")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "filter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "filter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Determine if a record is loggable by consulting all the filters.\n\n        The default is to allow the record to be logged; any filter can veto\n        this and the record is then dropped. Returns a zero value if a record\n        is to be dropped, else non-zero.\n\n        .. versionchanged: 3.2\n\n           Allow filters to be just callables.\n        ")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "filters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(LIT "filter")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "filter")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "f")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "result")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_handlers")
(PUNCT "=")
(ID "weakref")
(PUNCT ".")
(ID "WeakValueDictionary")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "_handlerList")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "_removeHandlerRef")
(PUNCT "(")
(ID "wr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Remove a handler reference from the internal cleanup list.\n    ")
(NEWLINE)
(ID "acquire")
(PUNCT ",")
(ID "release")
(PUNCT ",")
(ID "handlers")
(PUNCT "=")
(ID "_acquireLock")
(PUNCT ",")
(ID "_releaseLock")
(PUNCT ",")
(ID "_handlerList")
(NEWLINE)
(KEYWORD if)
(ID "acquire")
(KEYWORD and)
(ID "release")
(KEYWORD and)
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "wr")
(KEYWORD in)
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "handlers")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "wr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_addHandlerRef")
(PUNCT "(")
(ID "handler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Add a handler to the internal cleanup list using a weak reference.\n    ")
(NEWLINE)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_handlerList")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "weakref")
(PUNCT ".")
(ID "ref")
(PUNCT "(")
(ID "handler")
(PUNCT ",")
(ID "_removeHandlerRef")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Handler")
(PUNCT "(")
(ID "Filterer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Handler instances dispatch logging events to specific destinations.\n\n    The base handler class. Acts as a placeholder which defines the Handler\n    interface. Handlers can optionally use Formatter instances to format\n    records as desired. By default, no formatter is specified; in this case,\n    the 'raw' message as determined by record.message is logged.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT "=")
(ID "NOTSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializes the instance - basically setting the formatter to None\n        and the filter list to empty.\n        ")
(NEWLINE)
(ID "Filterer")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "level")
(PUNCT "=")
(ID "_checkLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "formatter")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "_addHandlerRef")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "createLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_name")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_name")
(KEYWORD in)
(ID "_handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_handlers")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(KEYWORD if)
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_handlers")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "name")
(PUNCT "=")
(ID "property")
(PUNCT "(")
(ID "get_name")
(PUNCT ",")
(ID "set_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "createLock")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Acquire a thread lock for serializing access to the underlying I/O.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "threading")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "RLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "acquire")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Acquire the I/O thread lock.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "release")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Release the I/O thread lock.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "setLevel")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set the logging level of this handler.  level must be an int or a str.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "level")
(PUNCT "=")
(ID "_checkLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Format the specified record.\n\n        If a formatter is set, use it. Otherwise, use the default formatter\n        for the module.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "formatter")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fmt")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "formatter")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fmt")
(PUNCT "=")
(ID "_defaultFormatter")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "fmt")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "emit")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Do whatever it takes to actually log the specified logging record.\n\n        This version is intended to be implemented by subclasses and so\n        raises a NotImplementedError.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(PUNCT "(")
(LIT "emit must be implemented ")
(LIT "by Handler subclasses")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        ")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "filter")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "rv")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "emit")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setFormatter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fmt")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set the formatter for this handler.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "formatter")
(PUNCT "=")
(ID "fmt")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Ensure all logging output has been flushed.\n\n        This version does nothing and is intended to be implemented by\n        subclasses.\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Tidy up any resources used by the handler.\n\n        This version removes the handler from an internal map of handlers,\n        _handlers, which is used for handler lookup by name. Subclasses\n        should ensure that this gets called from overridden close()\n        methods.\n        ")
(NEWLINE)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_name")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_name")
(KEYWORD in)
(ID "_handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_handlers")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "handleError")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Handle errors which occur during an emit() call.\n\n        This method should be called from handlers when an exception is\n        encountered during an emit() call. If raiseExceptions is false,\n        exceptions get silently ignored. This is what is mostly wanted\n        for a logging system - most users will not care about errors in\n        the logging system, they are more interested in application errors.\n        You could, however, replace this with a custom handler if you wish.\n        The record which was being processed is passed in to this method.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "raiseExceptions")
(KEYWORD and)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "tb")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "--- Logging error ---\n")
(PUNCT ")")
(NEWLINE)
(ID "traceback")
(PUNCT ".")
(ID "print_exception")
(PUNCT "(")
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "tb")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Call stack:\n")
(PUNCT ")")
(NEWLINE)
(ID "frame")
(PUNCT "=")
(ID "tb")
(PUNCT ".")
(ID "tb_frame")
(NEWLINE)
(KEYWORD while)
(PUNCT "(")
(ID "frame")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_filename")
(PUNCT ")")
(PUNCT "==")
(ID "__path__")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "frame")
(PUNCT "=")
(ID "frame")
(PUNCT ".")
(ID "f_back")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "frame")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "traceback")
(PUNCT ".")
(ID "print_stack")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Logged from file %s, line %s\n")
(PUNCT "%")
(PUNCT "(")
(ID "record")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "record")
(PUNCT ".")
(ID "lineno")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Message: %r\n")
(LIT "Arguments: %s\n")
(PUNCT "%")
(PUNCT "(")
(ID "record")
(PUNCT ".")
(ID "msg")
(PUNCT ",")
(ID "record")
(PUNCT ".")
(ID "args")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Unable to print the message and arguments")
(LIT " - possible formatting error.\nUse the")
(LIT " traceback above to help find the error.\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "t")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "tb")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "StreamHandler")
(PUNCT "(")
(ID "Handler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A handler class which writes logging records, appropriately formatted,\n    to a stream. Note that this class does not close the stream, as\n    sys.stdout or sys.stderr may be used.\n    ")
(NEWLINE)
(ID "terminator")
(PUNCT "=")
(LIT "\n")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "stream")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the handler.\n\n        If stream is not specified, sys.stderr is used.\n        ")
(NEWLINE)
(ID "Handler")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "stream")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stream")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stderr")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT "=")
(ID "stream")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Flushes the stream.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "stream")
(KEYWORD and)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT ",")
(LIT "flush")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "emit")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Emit a record.\n\n        If a formatter is specified, it is used to format the record.\n        The record is then written to the stream with a trailing newline.  If\n        exception information is present, it is formatted using\n        traceback.print_exception and appended to the stream.  If the stream\n        has an 'encoding' attribute, it is used to determine how to do the\n        output to the stream.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(ID "stream")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stream")
(NEWLINE)
(ID "stream")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "stream")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "terminator")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handleError")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "FileHandler")
(PUNCT "(")
(ID "StreamHandler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A handler class which writes formatted logging records to disk files.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT "a")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "delay")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Open the specified file and use it as the stream for logging.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "baseFilename")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "abspath")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "mode")
(PUNCT "=")
(ID "mode")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "delay")
(PUNCT "=")
(ID "delay")
(NEWLINE)
(KEYWORD if)
(ID "delay")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Handler")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "StreamHandler")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_open")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Closes the stream.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT ",")
(LIT "close")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "StreamHandler")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_open")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Open the current base file with the (original) mode and encoding.\n        Return the resulting stream.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "baseFilename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "mode")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "emit")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Emit a record.\n\n        If the stream was not opened because 'delay' was specified in the\n        constructor, open it before calling the superclass's emit.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "stream")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "stream")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_open")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "StreamHandler")
(PUNCT ".")
(ID "emit")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_StderrHandler")
(PUNCT "(")
(ID "StreamHandler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    This class is like a StreamHandler using sys.stderr, but always uses\n    whatever sys.stderr is currently set to rather than the value of\n    sys.stderr at handler construction time.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT "=")
(ID "NOTSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the handler.\n        ")
(NEWLINE)
(ID "Handler")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "stream")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_defaultLastResort")
(PUNCT "=")
(ID "_StderrHandler")
(PUNCT "(")
(ID "WARNING")
(PUNCT ")")
(NEWLINE)
(ID "lastResort")
(PUNCT "=")
(ID "_defaultLastResort")
(NEWLINE)
(KEYWORD class)
(ID "PlaceHolder")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    PlaceHolder instances are used in the Manager logger hierarchy to take\n    the place of nodes for which no loggers have been defined. This class is\n    intended for internal use only and not as part of the public API.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "alogger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize with the specified logger being a child of this placeholder.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "loggerMap")
(PUNCT "=")
(PUNCT "{")
(ID "alogger")
(PUNCT ":")
(KEYWORD None)
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "alogger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Add the specified logger as a child of this placeholder.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "alogger")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "loggerMap")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "loggerMap")
(PUNCT "[")
(ID "alogger")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "_loggerClass")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "setLoggerClass")
(PUNCT "(")
(ID "klass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Set the class to be used when instantiating a logger. The class should\n    define __init__() such that only a name argument is required, and the\n    __init__() should call Logger.__init__()\n    ")
(NEWLINE)
(KEYWORD if)
(ID "klass")
(PUNCT "!=")
(ID "Logger")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "issubclass")
(PUNCT "(")
(ID "klass")
(PUNCT ",")
(ID "Logger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "logger not derived from logging.Logger: ")
(PUNCT "+")
(ID "klass")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD global)
(ID "_loggerClass")
(NEWLINE)
(ID "_loggerClass")
(PUNCT "=")
(ID "klass")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getLoggerClass")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the class to be used when instantiating a logger.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "_loggerClass")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Manager")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    There is [under normal circumstances] just one Manager instance, which\n    holds the hierarchy of loggers.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "rootnode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the manager with the root node of the logger hierarchy.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "root")
(PUNCT "=")
(ID "rootnode")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "disable")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "emittedNoHandlerWarning")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "loggerClass")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "logRecordFactory")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getLogger")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Get a logger with the specified name (channel name), creating it\n        if it doesn't yet exist. This name is a dot-separated hierarchical\n        name, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\n        If a PlaceHolder existed for the specified name [i.e. the logger\n        didn't exist but a child of it did], replace it with the created\n        logger and fix up the parent/child references which pointed to the\n        placeholder to now point to the logger.\n        ")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "A logger name must be a string")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "rv")
(PUNCT ",")
(ID "PlaceHolder")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ph")
(PUNCT "=")
(ID "rv")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "loggerClass")
(KEYWORD or)
(ID "_loggerClass")
(PUNCT ")")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "rv")
(PUNCT ".")
(ID "manager")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "rv")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fixupChildren")
(PUNCT "(")
(ID "ph")
(PUNCT ",")
(ID "rv")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fixupParents")
(PUNCT "(")
(ID "rv")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "loggerClass")
(KEYWORD or)
(ID "_loggerClass")
(PUNCT ")")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "rv")
(PUNCT ".")
(ID "manager")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "rv")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_fixupParents")
(PUNCT "(")
(ID "rv")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setLoggerClass")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "klass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set the class to be used when instantiating a logger with this Manager.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "klass")
(PUNCT "!=")
(ID "Logger")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "issubclass")
(PUNCT "(")
(ID "klass")
(PUNCT ",")
(ID "Logger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "logger not derived from logging.Logger: ")
(PUNCT "+")
(ID "klass")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "loggerClass")
(PUNCT "=")
(ID "klass")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setLogRecordFactory")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "factory")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set the factory to be used when instantiating a log record with this\n        Manager.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "logRecordFactory")
(PUNCT "=")
(ID "factory")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fixupParents")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "alogger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Ensure that there are either loggers or placeholders all the way\n        from the specified logger to the root of the logger hierarchy.\n        ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "alogger")
(PUNCT ".")
(ID "name")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "rfind")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD while)
(PUNCT "(")
(ID "i")
(PUNCT ">")
(LIT 0)
(PUNCT ")")
(KEYWORD and)
(KEYWORD not)
(ID "rv")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "substr")
(PUNCT "=")
(ID "name")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "substr")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT "[")
(ID "substr")
(PUNCT "]")
(PUNCT "=")
(ID "PlaceHolder")
(PUNCT "(")
(ID "alogger")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "loggerDict")
(PUNCT "[")
(ID "substr")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "Logger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(ID "obj")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "PlaceHolder")
(PUNCT ")")
(NEWLINE)
(ID "obj")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "alogger")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "i")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "rfind")
(PUNCT "(")
(LIT ".")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "rv")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "root")
(NEWLINE)
(DEDENT)
(ID "alogger")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fixupChildren")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ph")
(PUNCT ",")
(ID "alogger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Ensure that children of the placeholder ph are connected to the\n        specified logger.\n        ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "alogger")
(PUNCT ".")
(ID "name")
(NEWLINE)
(ID "namelen")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "c")
(KEYWORD in)
(ID "ph")
(PUNCT ".")
(ID "loggerMap")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "name")
(PUNCT "[")
(PUNCT ":")
(ID "namelen")
(PUNCT "]")
(PUNCT "!=")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "alogger")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "c")
(PUNCT ".")
(ID "parent")
(NEWLINE)
(ID "c")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "alogger")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Logger")
(PUNCT "(")
(ID "Filterer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Instances of the Logger class represent a single logging channel. A\n    \"logging channel\" indicates an area of an application. Exactly how an\n    \"area\" is defined is up to the application developer. Since an\n    application can have any number of areas, logging channels are identified\n    by a unique string. Application areas can be nested (e.g. an area\n    of \"input processing\" might include sub-areas \"read CSV files\", \"read\n    XLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\n    channel names are organized into a namespace hierarchy where levels are\n    separated by periods, much like the Java or Python package namespace. So\n    in the instance given above, channel names might be \"input\" for the upper\n    level, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\n    There is no arbitrary limit to the depth of nesting.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "level")
(PUNCT "=")
(ID "NOTSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the logger with a name and an optional level.\n        ")
(NEWLINE)
(ID "Filterer")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "level")
(PUNCT "=")
(ID "_checkLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "propagate")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "handlers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "disabled")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setLevel")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set the logging level of this logger.  level must be an int or a str.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "level")
(PUNCT "=")
(ID "_checkLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Log 'msg % args' with severity 'DEBUG'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.debug(\"Houston, we have a %s\", \"thorny problem\", exc_info=1)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "DEBUG")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "DEBUG")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "info")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Log 'msg % args' with severity 'INFO'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "INFO")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "INFO")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "warning")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Log 'msg % args' with severity 'WARNING'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.warning(\"Houston, we have a %s\", \"bit of a problem\", exc_info=1)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "WARNING")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "WARNING")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "warn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The 'warn' method is deprecated, ")
(LIT "use 'warning' instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "warning")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Log 'msg % args' with severity 'ERROR'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.error(\"Houston, we have a %s\", \"major problem\", exc_info=1)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "ERROR")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "ERROR")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "exception")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Convenience method for logging an ERROR with exception information.\n        ")
(NEWLINE)
(ID "kwargs")
(PUNCT "[")
(LIT "exc_info")
(PUNCT "]")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "critical")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Log 'msg % args' with severity 'CRITICAL'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.critical(\"Houston, we have a %s\", \"major disaster\", exc_info=1)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "CRITICAL")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "CRITICAL")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "fatal")
(PUNCT "=")
(ID "critical")
(NEWLINE)
(KEYWORD def)
(ID "log")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Log 'msg % args' with the integer severity 'level'.\n\n        To pass exception information, use the keyword argument exc_info with\n        a true value, e.g.\n\n        logger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=1)\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "raiseExceptions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "level must be an integer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "findCaller")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "stack_info")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Find the stack frame of the caller so that we can note the source\n        file name, line number and function name.\n        ")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "currentframe")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "f")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "f_back")
(NEWLINE)
(DEDENT)
(ID "rv")
(PUNCT "=")
(LIT "(unknown file)")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT "(unknown function)")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(KEYWORD while)
(ID "hasattr")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(LIT "f_code")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "co")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "f_code")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(PUNCT "==")
(ID "_srcfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "f_back")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "sinfo")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "stack_info")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sio")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "sio")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Stack (most recent call last):\n")
(PUNCT ")")
(NEWLINE)
(ID "traceback")
(PUNCT ".")
(ID "print_stack")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "sio")
(PUNCT ")")
(NEWLINE)
(ID "sinfo")
(PUNCT "=")
(ID "sio")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sinfo")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sinfo")
(PUNCT "=")
(ID "sinfo")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "sio")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rv")
(PUNCT "=")
(PUNCT "(")
(ID "co")
(PUNCT ".")
(ID "co_filename")
(PUNCT ",")
(ID "f")
(PUNCT ".")
(ID "f_lineno")
(PUNCT ",")
(ID "co")
(PUNCT ".")
(ID "co_name")
(PUNCT ",")
(ID "sinfo")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "makeRecord")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "fn")
(PUNCT ",")
(ID "lno")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "exc_info")
(PUNCT ",")
(ID "func")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "sinfo")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        A factory method which can be overridden in subclasses to create\n        specialized LogRecords.\n        ")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(ID "_logRecordFactory")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "fn")
(PUNCT ",")
(ID "lno")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "exc_info")
(PUNCT ",")
(ID "func")
(PUNCT ",")
(ID "sinfo")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "extra")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "extra")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "key")
(KEYWORD in)
(PUNCT "[")
(LIT "message")
(PUNCT ",")
(LIT "asctime")
(PUNCT "]")
(PUNCT ")")
(KEYWORD or)
(PUNCT "(")
(ID "key")
(KEYWORD in)
(ID "rv")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(LIT "Attempt to overwrite %r in LogRecord")
(PUNCT "%")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "rv")
(PUNCT ".")
(ID "__dict__")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "extra")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_log")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "exc_info")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_info")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Low-level logging routine which creates a LogRecord and then calls\n        all the handlers of this logger to handle the record.\n        ")
(NEWLINE)
(ID "sinfo")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "_srcfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fn")
(PUNCT ",")
(ID "lno")
(PUNCT ",")
(ID "func")
(PUNCT ",")
(ID "sinfo")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "findCaller")
(PUNCT "(")
(ID "stack_info")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fn")
(PUNCT ",")
(ID "lno")
(PUNCT ",")
(ID "func")
(PUNCT "=")
(LIT "(unknown file)")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT "(unknown function)")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fn")
(PUNCT ",")
(ID "lno")
(PUNCT ",")
(ID "func")
(PUNCT "=")
(LIT "(unknown file)")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT "(unknown function)")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "exc_info")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "exc_info")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_info")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "record")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "makeRecord")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "fn")
(PUNCT ",")
(ID "lno")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "exc_info")
(PUNCT ",")
(ID "func")
(PUNCT ",")
(ID "extra")
(PUNCT ",")
(ID "sinfo")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "handle")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Call the handlers for the specified record.\n\n        This method is used for unpickled records received from a socket, as\n        well as those created locally. Logger-level filtering is applied.\n        ")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "disabled")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "filter")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "callHandlers")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "addHandler")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "hdlr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Add the specified handler to this logger.\n        ")
(NEWLINE)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "hdlr")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handlers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "hdlr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "removeHandler")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "hdlr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Remove the specified handler from this logger.\n        ")
(NEWLINE)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hdlr")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handlers")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "hdlr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "hasHandlers")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        See if this logger has any handlers configured.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. Return True if a handler was found, else False.\n        Stop searching up the hierarchy whenever a logger with the \"propagate\"\n        attribute set to zero is found - that will be the last logger which\n        is checked for the existence of handlers.\n        ")
(NEWLINE)
(ID "c")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "rv")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD while)
(ID "c")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(PUNCT ".")
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rv")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "c")
(PUNCT ".")
(ID "propagate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "c")
(PUNCT ".")
(ID "parent")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "rv")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "callHandlers")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Pass a record to all relevant handlers.\n\n        Loop through all handlers for this logger and its parents in the\n        logger hierarchy. If no handler was found, output a one-off error\n        message to sys.stderr. Stop searching up the hierarchy whenever a\n        logger with the \"propagate\" attribute set to zero is found - that\n        will be the last logger whose handlers are called.\n        ")
(NEWLINE)
(ID "c")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "found")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(ID "c")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "hdlr")
(KEYWORD in)
(ID "c")
(PUNCT ".")
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "found")
(PUNCT "=")
(ID "found")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "record")
(PUNCT ".")
(ID "levelno")
(PUNCT ">=")
(ID "hdlr")
(PUNCT ".")
(ID "level")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hdlr")
(PUNCT ".")
(ID "handle")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "c")
(PUNCT ".")
(ID "propagate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "c")
(PUNCT ".")
(ID "parent")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(PUNCT "(")
(ID "found")
(PUNCT "==")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "lastResort")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "record")
(PUNCT ".")
(ID "levelno")
(PUNCT ">=")
(ID "lastResort")
(PUNCT ".")
(ID "level")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lastResort")
(PUNCT ".")
(ID "handle")
(PUNCT "(")
(ID "record")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "raiseExceptions")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "emittedNoHandlerWarning")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "No handlers could be found for logger")
(LIT " \"%s\"\n")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "emittedNoHandlerWarning")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getEffectiveLevel")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Get the effective level for this logger.\n\n        Loop through this logger and its parents in the logger hierarchy,\n        looking for a non-zero logging level. Return the first one found.\n        ")
(NEWLINE)
(ID "logger")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD while)
(ID "logger")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "logger")
(PUNCT ".")
(ID "level")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "logger")
(PUNCT ".")
(ID "level")
(NEWLINE)
(DEDENT)
(ID "logger")
(PUNCT "=")
(ID "logger")
(PUNCT ".")
(ID "parent")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "NOTSET")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isEnabledFor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Is this logger enabled for level 'level'?\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "disable")
(PUNCT ">=")
(ID "level")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "level")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "getEffectiveLevel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getChild")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "suffix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Get a logger which is a descendant to this one.\n\n        This is a convenience method, such that\n\n        logging.getLogger('abc').getChild('def.ghi')\n\n        is the same as\n\n        logging.getLogger('abc.def.ghi')\n\n        It's useful, for example, when the parent logger is named using\n        __name__ rather than a literal string.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "root")
(KEYWORD is)
(KEYWORD not)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "suffix")
(PUNCT "=")
(LIT ".")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "suffix")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "getLogger")
(PUNCT "(")
(ID "suffix")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "RootLogger")
(PUNCT "(")
(ID "Logger")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A root logger is not that different to any other logger, except that\n    it must have a logging level and there is only one instance of it in\n    the hierarchy.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the logger with the name \"root\".\n        ")
(NEWLINE)
(ID "Logger")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "root")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_loggerClass")
(PUNCT "=")
(ID "Logger")
(NEWLINE)
(KEYWORD class)
(ID "LoggerAdapter")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    An adapter for loggers which makes it easier to specify contextual\n    information in logging output.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "logger")
(PUNCT ",")
(ID "extra")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initialize the adapter with a logger and a dict-like object which\n        provides contextual information. This constructor signature allows\n        easy stacking of LoggerAdapters, if so desired.\n\n        You can effectively pass keyword arguments as shown in the\n        following example:\n\n        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2=\"v2\"))\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT "=")
(ID "logger")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "extra")
(PUNCT "=")
(ID "extra")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "process")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Process the logging message and keyword arguments passed in to\n        a logging call to insert contextual information. You can either\n        manipulate the message itself, the keyword args or both. Return\n        the message and kwargs modified (or not) to suit your needs.\n\n        Normally, you'll only need to override this one method in a\n        LoggerAdapter subclass for your specific needs.\n        ")
(NEWLINE)
(ID "kwargs")
(PUNCT "[")
(LIT "extra")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "extra")
(NEWLINE)
(KEYWORD return)
(ID "msg")
(PUNCT ",")
(ID "kwargs")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate a debug call to the underlying logger.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "DEBUG")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "info")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate an info call to the underlying logger.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "INFO")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "warning")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate a warning call to the underlying logger.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "WARNING")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "warn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The 'warn' method is deprecated, ")
(LIT "use 'warning' instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "warning")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate an error call to the underlying logger.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "ERROR")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "exception")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate an exception call to the underlying logger.\n        ")
(NEWLINE)
(ID "kwargs")
(PUNCT "[")
(LIT "exc_info")
(PUNCT "]")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "ERROR")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "critical")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate a critical call to the underlying logger.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "CRITICAL")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Delegate a log call to the underlying logger, after adding\n        contextual information from this adapter instance.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "isEnabledFor")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT ",")
(ID "kwargs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "process")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "_log")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "isEnabledFor")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Is this logger enabled for level 'level'?\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "disable")
(PUNCT ">=")
(ID "level")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "level")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "getEffectiveLevel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setLevel")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Set the specified level on the underlying logger.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "setLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getEffectiveLevel")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Get the effective level for the underlying logger.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "getEffectiveLevel")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "hasHandlers")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        See if the underlying logger has any handlers.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "logger")
(PUNCT ".")
(ID "hasHandlers")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "root")
(PUNCT "=")
(ID "RootLogger")
(PUNCT "(")
(ID "WARNING")
(PUNCT ")")
(NEWLINE)
(ID "Logger")
(PUNCT ".")
(ID "root")
(PUNCT "=")
(ID "root")
(NEWLINE)
(ID "Logger")
(PUNCT ".")
(ID "manager")
(PUNCT "=")
(ID "Manager")
(PUNCT "(")
(ID "Logger")
(PUNCT ".")
(ID "root")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "basicConfig")
(PUNCT "(")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Do basic configuration for the logging system.\n\n    This function does nothing if the root logger already has handlers\n    configured. It is a convenience method intended for use by simple scripts\n    to do one-shot configuration of the logging package.\n\n    The default behaviour is to create a StreamHandler which writes to\n    sys.stderr, set a formatter using the BASIC_FORMAT format string, and\n    add the handler to the root logger.\n\n    A number of optional keyword arguments may be specified, which can alter\n    the default behaviour.\n\n    filename  Specifies that a FileHandler be created, using the specified\n              filename, rather than a StreamHandler.\n    filemode  Specifies the mode to open the file, if filename is specified\n              (if filemode is unspecified, it defaults to 'a').\n    format    Use the specified format string for the handler.\n    datefmt   Use the specified date/time format.\n    style     If a format string is specified, use this to specify the\n              type of format string (possible values '%', '{', '$', for\n              %-formatting, :meth:`str.format` and :class:`string.Template`\n              - defaults to '%').\n    level     Set the root logger level to the specified level.\n    stream    Use the specified stream to initialize the StreamHandler. Note\n              that this argument is incompatible with 'filename' - if both\n              are present, 'stream' is ignored.\n    handlers  If specified, this should be an iterable of already created\n              handlers, which will be added to the root handler. Any handler\n              in the list which does not have a formatter assigned will be\n              assigned the formatter created in this function.\n\n    Note that you could specify a stream created using open(filename, mode)\n    rather than passing the filename and mode in. However, it should be\n    remembered that StreamHandler does not close its stream (since it may be\n    using sys.stdout or sys.stderr), whereas FileHandler closes its stream\n    when the handler is closed.\n\n    .. versionchanged:: 3.2\n       Added the ``style`` parameter.\n\n    .. versionchanged:: 3.3\n       Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n       incompatible arguments (e.g. ``handlers`` specified together with\n       ``filename``/``filemode``, or ``filename``/``filemode`` specified\n       together with ``stream``, or ``handlers`` specified together with\n       ``stream``.\n    ")
(NEWLINE)
(ID "_acquireLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "handlers")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "handlers")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "handlers")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "stream")
(KEYWORD in)
(ID "kwargs")
(KEYWORD and)
(LIT "filename")
(KEYWORD in)
(ID "kwargs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "'stream' and 'filename' should not be ")
(LIT "specified together")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "stream")
(KEYWORD in)
(ID "kwargs")
(KEYWORD or)
(LIT "filename")
(KEYWORD in)
(ID "kwargs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "'stream' or 'filename' should not be ")
(LIT "specified together with 'handlers'")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "handlers")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "filename")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "filemode")
(PUNCT ",")
(LIT "a")
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT "=")
(ID "FileHandler")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stream")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "stream")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT "=")
(ID "StreamHandler")
(PUNCT "(")
(ID "stream")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "handlers")
(PUNCT "=")
(PUNCT "[")
(ID "h")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "dfs")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "datefmt")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "style")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "style")
(PUNCT ",")
(LIT "%")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "style")
(KEYWORD not)
(KEYWORD in)
(ID "_STYLES")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Style must be one of: %s")
(PUNCT "%")
(LIT ",")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "_STYLES")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fs")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "format")
(PUNCT ",")
(ID "_STYLES")
(PUNCT "[")
(ID "style")
(PUNCT "]")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "fmt")
(PUNCT "=")
(ID "Formatter")
(PUNCT "(")
(ID "fs")
(PUNCT ",")
(ID "dfs")
(PUNCT ",")
(ID "style")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "h")
(KEYWORD in)
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "h")
(PUNCT ".")
(ID "formatter")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT ".")
(ID "setFormatter")
(PUNCT "(")
(ID "fmt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "addHandler")
(PUNCT "(")
(ID "h")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "level")
(PUNCT "=")
(ID "kwargs")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "level")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "level")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "root")
(PUNCT ".")
(ID "setLevel")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "kwargs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "keys")
(PUNCT "=")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "kwargs")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Unrecognised argument(s): %s")
(PUNCT "%")
(ID "keys")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_releaseLock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getLogger")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return a logger with the specified name, creating it if necessary.\n\n    If no name is specified, return the root logger.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Logger")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "getLogger")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "root")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "critical")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log a message with severity 'CRITICAL' on the root logger. If the logger\n    has no handlers, call basicConfig() to add a console handler with a\n    pre-defined format.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basicConfig")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "critical")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fatal")
(PUNCT "=")
(ID "critical")
(NEWLINE)
(KEYWORD def)
(ID "error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log a message with severity 'ERROR' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basicConfig")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "exception")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log a message with severity 'ERROR' on the root logger, with exception\n    information. If the logger has no handlers, basicConfig() is called to add\n    a console handler with a pre-defined format.\n    ")
(NEWLINE)
(ID "kwargs")
(PUNCT "[")
(LIT "exc_info")
(PUNCT "]")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "warning")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log a message with severity 'WARNING' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basicConfig")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "warning")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "warn")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The 'warn' function is deprecated, ")
(LIT "use 'warning' instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "warning")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "info")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log a message with severity 'INFO' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basicConfig")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log a message with severity 'DEBUG' on the root logger. If the logger has\n    no handlers, call basicConfig() to add a console handler with a pre-defined\n    format.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basicConfig")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Log 'msg % args' with the integer severity 'level' on the root logger. If\n    the logger has no handlers, call basicConfig() to add a console handler\n    with a pre-defined format.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "root")
(PUNCT ".")
(ID "handlers")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basicConfig")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ".")
(ID "log")
(PUNCT "(")
(ID "level")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "disable")
(PUNCT "(")
(ID "level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Disable all logging calls of severity 'level' and below.\n    ")
(NEWLINE)
(ID "root")
(PUNCT ".")
(ID "manager")
(PUNCT ".")
(ID "disable")
(PUNCT "=")
(ID "level")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shutdown")
(PUNCT "(")
(ID "handlerList")
(PUNCT "=")
(ID "_handlerList")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Perform any cleanup actions in the logging system (e.g. flushing\n    buffers).\n\n    Should be called at application exit.\n    ")
(NEWLINE)
(KEYWORD for)
(ID "wr")
(KEYWORD in)
(ID "reversed")
(PUNCT "(")
(ID "handlerList")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT "=")
(ID "wr")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "h")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT ".")
(ID "acquire")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "OSError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT ".")
(ID "release")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "raiseExceptions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD import)
(ID "atexit")
(NEWLINE)
(ID "atexit")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "shutdown")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "NullHandler")
(PUNCT "(")
(ID "Handler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    This handler does nothing. It's intended to be used to avoid the\n    \"No handlers could be found for logger XXX\" one-off warning. This is\n    important for library code, which may contain code to log events. If a user\n    of the library does not configure logging, the one-off warning might be\n    produced; to avoid this, the library developer simply needs to instantiate\n    a NullHandler and add it to the top-level logger of the library module or\n    package.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Stub.")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "emit")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "record")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Stub.")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "createLock")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_warnings_showwarning")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "_showwarning")
(PUNCT "(")
(ID "message")
(PUNCT ",")
(ID "category")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Implementation of showwarnings which redirects to logging, which will first\n    check to see if the file parameter is None. If a file is specified, it will\n    delegate to the original warnings implementation of showwarning. Otherwise,\n    it will call warnings.formatwarning and will log the resulting string to a\n    warnings logger named \"py.warnings\" with level logging.WARNING.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "file")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_warnings_showwarning")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_warnings_showwarning")
(PUNCT "(")
(ID "message")
(PUNCT ",")
(ID "category")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "warnings")
(PUNCT ".")
(ID "formatwarning")
(PUNCT "(")
(ID "message")
(PUNCT ",")
(ID "category")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "logger")
(PUNCT "=")
(ID "getLogger")
(PUNCT "(")
(LIT "py.warnings")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "logger")
(PUNCT ".")
(ID "handlers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logger")
(PUNCT ".")
(ID "addHandler")
(PUNCT "(")
(ID "NullHandler")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "logger")
(PUNCT ".")
(ID "warning")
(PUNCT "(")
(LIT "%s")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "captureWarnings")
(PUNCT "(")
(ID "capture")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    If capture is true, redirect all warnings to the logging package.\n    If capture is False, ensure that warnings are not redirected to logging\n    but to their original destinations.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_warnings_showwarning")
(NEWLINE)
(KEYWORD if)
(ID "capture")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_warnings_showwarning")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_warnings_showwarning")
(PUNCT "=")
(ID "warnings")
(PUNCT ".")
(ID "showwarning")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "showwarning")
(PUNCT "=")
(ID "_showwarning")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_warnings_showwarning")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "showwarning")
(PUNCT "=")
(ID "_warnings_showwarning")
(NEWLINE)
(ID "_warnings_showwarning")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
