(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "OrderedDict")
(NEWLINE)
(KEYWORD from)
(ID "types")
(KEYWORD import)
(ID "MappingProxyType")
(PUNCT ",")
(ID "DynamicClassAttribute")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Enum")
(PUNCT ",")
(LIT "IntEnum")
(PUNCT ",")
(LIT "unique")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "_is_descriptor")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns True if obj is a descriptor, False otherwise.")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "hasattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "__get__")
(PUNCT ")")
(KEYWORD or)
(ID "hasattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "__set__")
(PUNCT ")")
(KEYWORD or)
(ID "hasattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(LIT "__delete__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_is_dunder")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns True if a __dunder__ name, False otherwise.")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "name")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(ID "name")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "__")
(KEYWORD and)
(ID "name")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(LIT 3)
(PUNCT "]")
(PUNCT "!=")
(LIT "_")
(KEYWORD and)
(ID "name")
(PUNCT "[")
(PUNCT "-")
(LIT 3)
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(PUNCT "!=")
(LIT "_")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ">")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_is_sunder")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns True if a _sunder_ name, False otherwise.")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "name")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(ID "name")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "_")
(KEYWORD and)
(ID "name")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(PUNCT "!=")
(LIT "_")
(KEYWORD and)
(ID "name")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "!=")
(LIT "_")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ">")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_make_class_unpicklable")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Make the given class un-picklable.")
(NEWLINE)
(KEYWORD def)
(ID "_break_on_call_reduce")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "proto")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%r cannot be pickled")
(PUNCT "%")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "cls")
(PUNCT ".")
(ID "__reduce_ex__")
(PUNCT "=")
(ID "_break_on_call_reduce")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "__module__")
(PUNCT "=")
(LIT "<unknown>")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_EnumDict")
(PUNCT "(")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Track enum member order and ensure member names are not reused.\n\n    EnumMeta will use the names found in self._member_names as the\n    enumeration member names.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_member_names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Changes anything not dundered or not a descriptor.\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "_is_sunder")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "_names_ are reserved for future Enum use")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "_is_dunder")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_member_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Attempted to reuse key: %r")
(PUNCT "%")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "_is_descriptor")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Key already defined as: %r")
(PUNCT "%")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_member_names")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__setitem__")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Enum")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD class)
(ID "EnumMeta")
(PUNCT "(")
(ID "type")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Metaclass for Enum")
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__prepare__")
(PUNCT "(")
(ID "metacls")
(PUNCT ",")
(ID "cls")
(PUNCT ",")
(ID "bases")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_EnumDict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "metacls")
(PUNCT ",")
(ID "cls")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(ID "classdict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "member_type")
(PUNCT ",")
(ID "first_enum")
(PUNCT "=")
(ID "metacls")
(PUNCT ".")
(ID "_get_mixins_")
(PUNCT "(")
(ID "bases")
(PUNCT ")")
(NEWLINE)
(ID "__new__")
(PUNCT ",")
(ID "save_new")
(PUNCT ",")
(ID "use_args")
(PUNCT "=")
(ID "metacls")
(PUNCT ".")
(ID "_find_new_")
(PUNCT "(")
(ID "classdict")
(PUNCT ",")
(ID "member_type")
(PUNCT ",")
(ID "first_enum")
(PUNCT ")")
(NEWLINE)
(ID "members")
(PUNCT "=")
(PUNCT "{")
(ID "k")
(PUNCT ":")
(ID "classdict")
(PUNCT "[")
(ID "k")
(PUNCT "]")
(KEYWORD for)
(ID "k")
(KEYWORD in)
(ID "classdict")
(PUNCT ".")
(ID "_member_names")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "classdict")
(PUNCT ".")
(ID "_member_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "classdict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "invalid_names")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "members")
(PUNCT ")")
(PUNCT "&")
(PUNCT "{")
(LIT "mro")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "invalid_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid enum member name: {0}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(LIT ",")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "invalid_names")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "enum_class")
(PUNCT "=")
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "metacls")
(PUNCT ",")
(ID "cls")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(ID "classdict")
(PUNCT ")")
(NEWLINE)
(ID "enum_class")
(PUNCT ".")
(ID "_member_names_")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "enum_class")
(PUNCT ".")
(ID "_member_map_")
(PUNCT "=")
(ID "OrderedDict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "enum_class")
(PUNCT ".")
(ID "_member_type_")
(PUNCT "=")
(ID "member_type")
(NEWLINE)
(ID "enum_class")
(PUNCT ".")
(ID "_value2member_map_")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(LIT "__reduce_ex__")
(KEYWORD not)
(KEYWORD in)
(ID "classdict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "member_type")
(KEYWORD is)
(KEYWORD not)
(ID "object")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "methods")
(PUNCT "=")
(PUNCT "(")
(LIT "__getnewargs_ex__")
(PUNCT ",")
(LIT "__getnewargs__")
(PUNCT ",")
(LIT "__reduce_ex__")
(PUNCT ",")
(LIT "__reduce__")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "any")
(PUNCT "(")
(ID "m")
(KEYWORD in)
(ID "member_type")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "m")
(KEYWORD in)
(ID "methods")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_make_class_unpicklable")
(PUNCT "(")
(ID "enum_class")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "member_name")
(KEYWORD in)
(ID "classdict")
(PUNCT ".")
(ID "_member_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "members")
(PUNCT "[")
(ID "member_name")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "member_type")
(KEYWORD is)
(ID "tuple")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "use_args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_member")
(PUNCT "=")
(ID "__new__")
(PUNCT "(")
(ID "enum_class")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "enum_member")
(PUNCT ",")
(LIT "_value_")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_member")
(PUNCT ".")
(ID "_value_")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_member")
(PUNCT "=")
(ID "__new__")
(PUNCT "(")
(ID "enum_class")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "enum_member")
(PUNCT ",")
(LIT "_value_")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_member")
(PUNCT ".")
(ID "_value_")
(PUNCT "=")
(ID "member_type")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "value")
(PUNCT "=")
(ID "enum_member")
(PUNCT ".")
(ID "_value_")
(NEWLINE)
(ID "enum_member")
(PUNCT ".")
(ID "_name_")
(PUNCT "=")
(ID "member_name")
(NEWLINE)
(ID "enum_member")
(PUNCT ".")
(ID "__objclass__")
(PUNCT "=")
(ID "enum_class")
(NEWLINE)
(ID "enum_member")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "canonical_member")
(KEYWORD in)
(ID "enum_class")
(PUNCT ".")
(ID "_member_map_")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "canonical_member")
(PUNCT ".")
(ID "_value_")
(PUNCT "==")
(ID "enum_member")
(PUNCT ".")
(ID "_value_")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_member")
(PUNCT "=")
(ID "canonical_member")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_class")
(PUNCT ".")
(ID "_member_names_")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "member_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "enum_class")
(PUNCT ".")
(ID "_member_map_")
(PUNCT "[")
(ID "member_name")
(PUNCT "]")
(PUNCT "=")
(ID "enum_member")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_class")
(PUNCT ".")
(ID "_value2member_map_")
(PUNCT "[")
(ID "value")
(PUNCT "]")
(PUNCT "=")
(ID "enum_member")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(PUNCT "(")
(LIT "__repr__")
(PUNCT ",")
(LIT "__str__")
(PUNCT ",")
(LIT "__format__")
(PUNCT ",")
(LIT "__reduce_ex__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "class_method")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "enum_class")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "obj_method")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "member_type")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "enum_method")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "first_enum")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "obj_method")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "obj_method")
(KEYWORD is)
(ID "class_method")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setattr")
(PUNCT "(")
(ID "enum_class")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "enum_method")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "Enum")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "save_new")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_class")
(PUNCT ".")
(ID "__new_member__")
(PUNCT "=")
(ID "__new__")
(NEWLINE)
(DEDENT)
(ID "enum_class")
(PUNCT ".")
(ID "__new__")
(PUNCT "=")
(ID "Enum")
(PUNCT ".")
(ID "__new__")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "enum_class")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__call__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "names")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "module")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "qualname")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "type")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='red green blue')).\n\n        When used for the functional API:\n\n        `value` will be the name of the new class.\n\n        `names` should be either a string of white-space/comma delimited names\n        (values will start at 1), or an iterator/mapping of name, value pairs.\n\n        `module` should be set to the module this class is being created in;\n        if it is not set, an attempt to find that module will be made, but if\n        it fails the class will not be picklable.\n\n        `qualname` should be set to the actual location this class can be found\n        at in its module; by default it is set to the global scope.  If this is\n        not correct, unpickling will fail in some circumstances.\n\n        `type`, if set, will be mixed in as the first base class.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "names")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "_create_")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "names")
(PUNCT ",")
(ID "module")
(PUNCT "=")
(ID "module")
(PUNCT ",")
(ID "qualname")
(PUNCT "=")
(ID "qualname")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "type")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "member")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "isinstance")
(PUNCT "(")
(ID "member")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(KEYWORD and)
(ID "member")
(PUNCT ".")
(ID "_name_")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__delattr__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "attr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "attr")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(LIT "%s: cannot delete Enum member.")
(PUNCT "%")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__delattr__")
(PUNCT "(")
(ID "attr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__dir__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(PUNCT "[")
(LIT "__class__")
(PUNCT ",")
(LIT "__doc__")
(PUNCT ",")
(LIT "__members__")
(PUNCT ",")
(LIT "__module__")
(PUNCT "]")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "_member_names_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getattr__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the enum member matching `name`\n\n        We use __getattr__ instead of descriptors or inserting into the enum\n        class' __dict__ in order to support `name` and `value` being both\n        properties for enum members (which live in the class' __dict__) and\n        enum members themselves.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "_is_dunder")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(KEYWORD from)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_member_names_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "_member_names_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "__members__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a read-only view of the internal mapping.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "MappingProxyType")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<enum %r>")
(PUNCT "%")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reversed__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "reversed")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "_member_names_")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setattr__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n\n        ")
(NEWLINE)
(ID "member_map")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "_member_map_")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "member_map")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(LIT "Cannot reassign members.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__setattr__")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_create_")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "class_name")
(PUNCT ",")
(ID "names")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "module")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "qualname")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "type")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are auto-numbered from 1.\n        * An iterable of member names.  Values are auto-numbered from 1.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value.\n\n        ")
(NEWLINE)
(ID "metacls")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "__class__")
(NEWLINE)
(ID "bases")
(PUNCT "=")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(PUNCT ")")
(KEYWORD if)
(ID "type")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(ID "classdict")
(PUNCT "=")
(ID "metacls")
(PUNCT ".")
(ID "__prepare__")
(PUNCT "(")
(ID "class_name")
(PUNCT ",")
(ID "bases")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "names")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(ID "names")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ",")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "names")
(PUNCT ",")
(PUNCT "(")
(ID "tuple")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ")")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "names")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(ID "e")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(KEYWORD for)
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "e")
(PUNCT ")")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "names")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "member_name")
(PUNCT ",")
(ID "member_value")
(PUNCT "=")
(ID "item")
(PUNCT ",")
(ID "names")
(PUNCT "[")
(ID "item")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "member_name")
(PUNCT ",")
(ID "member_value")
(PUNCT "=")
(ID "item")
(NEWLINE)
(DEDENT)
(ID "classdict")
(PUNCT "[")
(ID "member_name")
(PUNCT "]")
(PUNCT "=")
(ID "member_value")
(NEWLINE)
(DEDENT)
(ID "enum_class")
(PUNCT "=")
(ID "metacls")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "metacls")
(PUNCT ",")
(ID "class_name")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(ID "classdict")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "_getframe")
(PUNCT "(")
(LIT 2)
(PUNCT ")")
(PUNCT ".")
(ID "f_globals")
(PUNCT "[")
(LIT "__name__")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "AttributeError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ")")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_make_class_unpicklable")
(PUNCT "(")
(ID "enum_class")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_class")
(PUNCT ".")
(ID "__module__")
(PUNCT "=")
(ID "module")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "qualname")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "enum_class")
(PUNCT ".")
(ID "__qualname__")
(PUNCT "=")
(ID "qualname")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "enum_class")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "staticmethod")
(NEWLINE)
(KEYWORD def)
(ID "_get_mixins_")
(PUNCT "(")
(ID "bases")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "bases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "object")
(PUNCT ",")
(ID "Enum")
(NEWLINE)
(DEDENT)
(ID "member_type")
(PUNCT "=")
(ID "first_enum")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "bases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "base")
(KEYWORD is)
(KEYWORD not)
(ID "Enum")
(KEYWORD and)
(ID "issubclass")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "Enum")
(PUNCT ")")
(KEYWORD and)
(ID "base")
(PUNCT ".")
(ID "_member_names_")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Cannot extend enumerations")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "issubclass")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "Enum")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "new enumerations must be created as ")
(LIT "`ClassName([mixin_type,] enum_type)`")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "issubclass")
(PUNCT "(")
(ID "bases")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "Enum")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "member_type")
(PUNCT "=")
(ID "bases")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "first_enum")
(PUNCT "=")
(ID "bases")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "bases")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "__mro__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "issubclass")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "Enum")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "first_enum")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first_enum")
(PUNCT "=")
(ID "base")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "member_type")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "member_type")
(PUNCT "=")
(ID "base")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "member_type")
(PUNCT ",")
(ID "first_enum")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "staticmethod")
(NEWLINE)
(KEYWORD def)
(ID "_find_new_")
(PUNCT "(")
(ID "classdict")
(PUNCT ",")
(ID "member_type")
(PUNCT ",")
(ID "first_enum")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the __new__ to be used for creating the enum members.\n\n        classdict: the class dictionary given to __new__\n        member_type: the data type whose __new__ will be used by default\n        first_enum: enumeration to check for an overriding __new__\n\n        ")
(NEWLINE)
(ID "__new__")
(PUNCT "=")
(ID "classdict")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "__new__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "save_new")
(PUNCT "=")
(ID "__new__")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "__new__")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "method")
(KEYWORD in)
(PUNCT "(")
(LIT "__new_member__")
(PUNCT ",")
(LIT "__new__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "possible")
(KEYWORD in)
(PUNCT "(")
(ID "member_type")
(PUNCT ",")
(ID "first_enum")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "target")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "possible")
(PUNCT ",")
(ID "method")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "target")
(KEYWORD not)
(KEYWORD in)
(PUNCT "{")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ".")
(ID "__new__")
(PUNCT ",")
(ID "object")
(PUNCT ".")
(ID "__new__")
(PUNCT ",")
(ID "Enum")
(PUNCT ".")
(ID "__new__")
(PUNCT ",")
(PUNCT "}")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__new__")
(PUNCT "=")
(ID "target")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "__new__")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__new__")
(PUNCT "=")
(ID "object")
(PUNCT ".")
(ID "__new__")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "__new__")
(KEYWORD is)
(ID "object")
(PUNCT ".")
(ID "__new__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "use_args")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "use_args")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "__new__")
(PUNCT ",")
(ID "save_new")
(PUNCT ",")
(ID "use_args")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Enum")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "EnumMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generic enumeration.\n\n    Derive from this class to define new enumerations.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(KEYWORD is)
(ID "cls")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_value2member_map_")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "_value2member_map_")
(PUNCT "[")
(ID "value")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "member")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_member_map_")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "member")
(PUNCT ".")
(ID "_value_")
(PUNCT "==")
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "member")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%r is not a valid %s")
(PUNCT "%")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<%s.%s: %r>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_name_")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_value_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_name_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__dir__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "added_behavior")
(PUNCT "=")
(PUNCT "[")
(ID "m")
(KEYWORD for)
(ID "cls")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "mro")
(PUNCT "(")
(PUNCT ")")
(KEYWORD for)
(ID "m")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "__dict__")
(KEYWORD if)
(ID "m")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "!=")
(LIT "_")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(PUNCT "[")
(LIT "__class__")
(PUNCT ",")
(LIT "__doc__")
(PUNCT ",")
(LIT "__module__")
(PUNCT ",")
(LIT "name")
(PUNCT ",")
(LIT "value")
(PUNCT "]")
(PUNCT "+")
(ID "added_behavior")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__format__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "format_spec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_member_type_")
(KEYWORD is)
(ID "object")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "str")
(NEWLINE)
(ID "val")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_member_type_")
(NEWLINE)
(ID "val")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_value_")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "__format__")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "format_spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name_")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reduce_ex__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "proto")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_value_")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "DynamicClassAttribute")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The name of the Enum member.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_name_")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "DynamicClassAttribute")
(NEWLINE)
(KEYWORD def)
(ID "value")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The value of the Enum member.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_value_")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "IntEnum")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "Enum")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Enum where members are also (and must be) ints")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unique")
(PUNCT "(")
(ID "enumeration")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Class decorator for enumerations ensuring unique member values.")
(NEWLINE)
(ID "duplicates")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "member")
(KEYWORD in)
(ID "enumeration")
(PUNCT ".")
(ID "__members__")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT "!=")
(ID "member")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "duplicates")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "member")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "duplicates")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "alias_details")
(PUNCT "=")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(LIT "%s -> %s")
(PUNCT "%")
(PUNCT "(")
(ID "alias")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(KEYWORD for)
(PUNCT "(")
(ID "alias")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(KEYWORD in)
(ID "duplicates")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "duplicate values found in %r: %s")
(PUNCT "%")
(PUNCT "(")
(ID "enumeration")
(PUNCT ",")
(ID "alias_details")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "enumeration")
(NEWLINE)
(DEDENT)
(ENDMARKER)
