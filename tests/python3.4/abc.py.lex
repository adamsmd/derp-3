(LIT "Abstract Base Classes (ABCs) according to PEP 3119.")
(NEWLINE)
(KEYWORD from)
(ID "_weakrefset")
(KEYWORD import)
(ID "WeakSet")
(NEWLINE)
(KEYWORD def)
(ID "abstractmethod")
(PUNCT "(")
(ID "funcobj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, ...):\n                ...\n    ")
(NEWLINE)
(ID "funcobj")
(PUNCT ".")
(ID "__isabstractmethod__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD return)
(ID "funcobj")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "abstractclassmethod")
(PUNCT "(")
(ID "classmethod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A decorator indicating abstract classmethods.\n\n    Similar to abstractmethod.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractclassmethod\n            def my_abstract_classmethod(cls, ...):\n                ...\n\n    'abstractclassmethod' is deprecated. Use 'classmethod' with\n    'abstractmethod' instead.\n    ")
(NEWLINE)
(ID "__isabstractmethod__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "callable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "callable")
(PUNCT ".")
(ID "__isabstractmethod__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "callable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "abstractstaticmethod")
(PUNCT "(")
(ID "staticmethod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A decorator indicating abstract staticmethods.\n\n    Similar to abstractmethod.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractstaticmethod\n            def my_abstract_staticmethod(...):\n                ...\n\n    'abstractstaticmethod' is deprecated. Use 'staticmethod' with\n    'abstractmethod' instead.\n    ")
(NEWLINE)
(ID "__isabstractmethod__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "callable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "callable")
(PUNCT ".")
(ID "__isabstractmethod__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "callable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "abstractproperty")
(PUNCT "(")
(ID "property")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A decorator indicating abstract properties.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract properties are overridden.\n    The abstract properties can be called using any of the normal\n    'super' call mechanisms.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractproperty\n            def my_abstract_property(self):\n                ...\n\n    This defines a read-only property; you can also define a read-write\n    abstract property using the 'long' form of property declaration:\n\n        class C(metaclass=ABCMeta):\n            def getx(self): ...\n            def setx(self, value): ...\n            x = abstractproperty(getx, setx)\n\n    'abstractproperty' is deprecated. Use 'property' with 'abstractmethod'\n    instead.\n    ")
(NEWLINE)
(ID "__isabstractmethod__")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "ABCMeta")
(PUNCT "(")
(ID "type")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Metaclass for defining Abstract Base Classes (ABCs).\n\n    Use this metaclass to create an ABC.  An ABC can be subclassed\n    directly, and then acts as a mix-in class.  You can also register\n    unrelated concrete classes (even built-in classes) and unrelated\n    ABCs as 'virtual subclasses' -- these and their descendants will\n    be considered subclasses of the registering ABC by the built-in\n    issubclass() function, but the registering ABC won't show up in\n    their MRO (Method Resolution Order) nor will method\n    implementations defined by the registering ABC be callable (not\n    even via super()).\n\n    ")
(NEWLINE)
(ID "_abc_invalidation_counter")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "mcls")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(ID "namespace")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "mcls")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(ID "namespace")
(PUNCT ")")
(NEWLINE)
(ID "abstracts")
(PUNCT "=")
(PUNCT "{")
(ID "name")
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "namespace")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "__isabstractmethod__")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "base")
(KEYWORD in)
(ID "bases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "getattr")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(LIT "__abstractmethods__")
(PUNCT ",")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "__isabstractmethod__")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "abstracts")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "cls")
(PUNCT ".")
(ID "__abstractmethods__")
(PUNCT "=")
(ID "frozenset")
(PUNCT "(")
(ID "abstracts")
(PUNCT ")")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "_abc_registry")
(PUNCT "=")
(ID "WeakSet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT "=")
(ID "WeakSet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache")
(PUNCT "=")
(ID "WeakSet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache_version")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(NEWLINE)
(KEYWORD return)
(ID "cls")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "register")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "subclass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Register a virtual subclass of an ABC.\n\n        Returns the subclass, to allow usage as a class decorator.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "subclass")
(PUNCT ",")
(ID "type")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Can only register classes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "issubclass")
(PUNCT "(")
(ID "subclass")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "subclass")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "issubclass")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "subclass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "Refusing to create an inheritance cycle")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_registry")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "subclass")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_dump_registry")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Debug helper to print the ABC registry.")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Class: %s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__module__")
(PUNCT ",")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Inv.counter: %s")
(PUNCT "%")
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "sorted")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "_abc_")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "%s: %r")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__instancecheck__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "instance")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Override for isinstance(instance, cls).")
(NEWLINE)
(ID "subclass")
(PUNCT "=")
(ID "instance")
(PUNCT ".")
(ID "__class__")
(NEWLINE)
(KEYWORD if)
(ID "subclass")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(ID "subtype")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "instance")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "subtype")
(KEYWORD is)
(ID "subclass")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache_version")
(PUNCT "==")
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(KEYWORD and)
(ID "subclass")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT ".")
(ID "__subclasscheck__")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "any")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__subclasscheck__")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(KEYWORD for)
(ID "c")
(KEYWORD in)
(PUNCT "{")
(ID "subclass")
(PUNCT ",")
(ID "subtype")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__subclasscheck__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "subclass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Override for issubclass(subclass, cls).")
(NEWLINE)
(KEYWORD if)
(ID "subclass")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache_version")
(PUNCT "<")
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache")
(PUNCT "=")
(ID "WeakSet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache_version")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "subclass")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "ok")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "__subclasshook__")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ok")
(KEYWORD is)
(KEYWORD not)
(ID "NotImplemented")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "ok")
(PUNCT ",")
(ID "bool")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ok")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ok")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD in)
(ID "getattr")
(PUNCT "(")
(ID "subclass")
(PUNCT ",")
(LIT "__mro__")
(PUNCT ",")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "rcls")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "_abc_registry")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "issubclass")
(PUNCT "(")
(ID "subclass")
(PUNCT ",")
(ID "rcls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "scls")
(KEYWORD in)
(ID "cls")
(PUNCT ".")
(ID "__subclasses__")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "issubclass")
(PUNCT "(")
(ID "subclass")
(PUNCT ",")
(ID "scls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_cache")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "cls")
(PUNCT ".")
(ID "_abc_negative_cache")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "subclass")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ABC")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper class that provides a standard way to create an ABC using\n    inheritance.\n    ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_cache_token")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the current ABC cache token.\n\n    The token is an opaque object (supporting equality testing) identifying the\n    current version of the ABC cache for virtual subclasses. The token changes\n    with every call to ``register()`` on any ABC.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "ABCMeta")
(PUNCT ".")
(ID "_abc_invalidation_counter")
(NEWLINE)
(DEDENT)
(ENDMARKER)
