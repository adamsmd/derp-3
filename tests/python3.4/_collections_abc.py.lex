(LIT "Abstract Base Classes (ABCs) for collections, according to PEP 3119.\n\nUnit tests are in test_collections.\n")
(NEWLINE)
(KEYWORD from)
(ID "abc")
(KEYWORD import)
(ID "ABCMeta")
(PUNCT ",")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Hashable")
(PUNCT ",")
(LIT "Iterable")
(PUNCT ",")
(LIT "Iterator")
(PUNCT ",")
(LIT "Sized")
(PUNCT ",")
(LIT "Container")
(PUNCT ",")
(LIT "Callable")
(PUNCT ",")
(LIT "Set")
(PUNCT ",")
(LIT "MutableSet")
(PUNCT ",")
(LIT "Mapping")
(PUNCT ",")
(LIT "MutableMapping")
(PUNCT ",")
(LIT "MappingView")
(PUNCT ",")
(LIT "KeysView")
(PUNCT ",")
(LIT "ItemsView")
(PUNCT ",")
(LIT "ValuesView")
(PUNCT ",")
(LIT "Sequence")
(PUNCT ",")
(LIT "MutableSequence")
(PUNCT ",")
(LIT "ByteString")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(ID "__name__")
(PUNCT "=")
(LIT "collections.abc")
(NEWLINE)
(ID "bytes_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(LIT #"")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "bytearray_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(ID "bytearray")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dict_keyiterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(PUNCT "{")
(PUNCT "}")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dict_valueiterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(PUNCT "{")
(PUNCT "}")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dict_itemiterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(PUNCT "{")
(PUNCT "}")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "list_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "list_reverseiterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(ID "reversed")
(PUNCT "(")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "range_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "set_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "str_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "tuple_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "zip_iterator")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(ID "zip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dict_keys")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(PUNCT "{")
(PUNCT "}")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dict_values")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(PUNCT "{")
(PUNCT "}")
(PUNCT ".")
(ID "values")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "dict_items")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(PUNCT "{")
(PUNCT "}")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "mappingproxy")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(ID "type")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Hashable")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__subclasshook__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "C")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Hashable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "__hash__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(PUNCT "[")
(LIT "__hash__")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Iterable")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD False)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__subclasshook__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "C")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Iterable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(LIT "__iter__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Iterator")
(PUNCT "(")
(ID "Iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__next__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the next item from the iterator. When exhausted, raise StopIteration")
(NEWLINE)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__subclasshook__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "C")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Iterator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "any")
(PUNCT "(")
(LIT "__next__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(KEYWORD and)
(ID "any")
(PUNCT "(")
(LIT "__iter__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "bytes_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "bytearray_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict_keyiterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict_valueiterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict_itemiterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "list_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "list_reverseiterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "range_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "set_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "str_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "tuple_iterator")
(PUNCT ")")
(NEWLINE)
(ID "Iterator")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "zip_iterator")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Sized")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__subclasshook__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "C")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Sized")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(LIT "__len__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Container")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "x")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__subclasshook__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "C")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Container")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(LIT "__contains__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Callable")
(PUNCT "(")
(ID "metaclass")
(PUNCT "=")
(ID "ABCMeta")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__call__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "__subclasshook__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "C")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cls")
(KEYWORD is)
(ID "Callable")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(LIT "__call__")
(KEYWORD in)
(ID "B")
(PUNCT ".")
(ID "__dict__")
(KEYWORD for)
(ID "B")
(KEYWORD in)
(ID "C")
(PUNCT ".")
(ID "__mro__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Set")
(PUNCT "(")
(ID "Sized")
(PUNCT ",")
(ID "Iterable")
(PUNCT ",")
(ID "Container")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A set is a finite, iterable container.\n\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__ and __len__.\n\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), redefine __le__ and __ge__,\n    then the other operations will automatically follow suit.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__le__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "elem")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "elem")
(KEYWORD not)
(KEYWORD in)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "<")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "__le__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__gt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "__ge__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ge__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "<")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "elem")
(KEYWORD in)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "elem")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "__le__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "_from_iterable")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Construct an instance of the class from any iterable input.\n\n        Must override this method if the class constructor signature\n        does not accept an iterable for an input.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "it")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__and__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "value")
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "other")
(KEYWORD if)
(ID "value")
(KEYWORD in)
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__rand__")
(PUNCT "=")
(ID "__and__")
(NEWLINE)
(KEYWORD def)
(ID "isdisjoint")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if two sets have a null intersection.")
(NEWLINE)
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__or__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(ID "chain")
(PUNCT "=")
(PUNCT "(")
(ID "e")
(KEYWORD for)
(ID "s")
(KEYWORD in)
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "s")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "chain")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__ror__")
(PUNCT "=")
(ID "__or__")
(NEWLINE)
(KEYWORD def)
(ID "__sub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "value")
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "self")
(KEYWORD if)
(ID "value")
(KEYWORD not)
(KEYWORD in)
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rsub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "value")
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "other")
(KEYWORD if)
(ID "value")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__xor__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Iterable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(ID "other")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT "-")
(ID "other")
(PUNCT ")")
(PUNCT "|")
(PUNCT "(")
(ID "other")
(PUNCT "-")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__rxor__")
(PUNCT "=")
(ID "__xor__")
(NEWLINE)
(KEYWORD def)
(ID "_hash")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compute the hash value of a set.\n\n        Note that we don't define __hash__: not all sets are hashable.\n        But if you define a hashable set type, its __hash__ should\n        call this function.\n\n        This must be compatible __eq__.\n\n        All sets ought to compare equal if they contain the same\n        elements, regardless of how they are implemented, and\n        regardless of the order of the elements; so there's not much\n        freedom for __eq__ or __hash__.  We match the algorithm used\n        by the built-in frozenset type.\n        ")
(NEWLINE)
(ID "MAX")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(NEWLINE)
(ID "MASK")
(PUNCT "=")
(LIT 2)
(PUNCT "*")
(ID "MAX")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT "=")
(LIT 1927868237)
(PUNCT "*")
(PUNCT "(")
(ID "n")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT "&=")
(ID "MASK")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hx")
(PUNCT "=")
(ID "hash")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(ID "h")
(PUNCT "^=")
(PUNCT "(")
(ID "hx")
(PUNCT "^")
(PUNCT "(")
(ID "hx")
(PUNCT "<<")
(LIT 16)
(PUNCT ")")
(PUNCT "^")
(LIT 89869747)
(PUNCT ")")
(PUNCT "*")
(LIT 3644798167)
(NEWLINE)
(ID "h")
(PUNCT "&=")
(ID "MASK")
(NEWLINE)
(DEDENT)
(ID "h")
(PUNCT "=")
(ID "h")
(PUNCT "*")
(LIT 69069)
(PUNCT "+")
(LIT 907133923)
(NEWLINE)
(ID "h")
(PUNCT "&=")
(ID "MASK")
(NEWLINE)
(KEYWORD if)
(ID "h")
(PUNCT ">")
(ID "MAX")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT "-=")
(ID "MASK")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "h")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "h")
(PUNCT "=")
(LIT 590923713)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "h")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Set")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "frozenset")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "MutableSet")
(PUNCT "(")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A mutable set is a finite, iterable container.\n\n    This class provides concrete generic implementations of all\n    methods except for __contains__, __iter__, __len__,\n    add(), and discard().\n\n    To override the comparisons (presumably for speed, as the\n    semantics are fixed), all you have to do is redefine __le__ and\n    then the other operations will automatically follow suit.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "add")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add an element.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "discard")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove an element.  Do not raise an exception if absent.")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remove")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove an element. If not a member, raise a KeyError.")
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the popped value.  Raise KeyError if empty.")
(NEWLINE)
(ID "it")
(PUNCT "=")
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "it")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This is slow (creates N new iterators!) but effective.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__ior__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "it")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iand__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "value")
(KEYWORD in)
(PUNCT "(")
(ID "self")
(PUNCT "-")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ixor__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "it")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "it")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "it")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_from_iterable")
(PUNCT "(")
(ID "it")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "it")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__isub__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "it")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "value")
(KEYWORD in)
(ID "it")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "MutableSet")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "set")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Mapping")
(PUNCT "(")
(ID "Sized")
(PUNCT ",")
(ID "Iterable")
(PUNCT ",")
(ID "Container")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(LIT "A Mapping is a generic container for associating key/value\n    pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __iter__, and __len__.\n\n    ")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "default")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "keys")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.keys() -> a set-like object providing a view on D's keys")
(NEWLINE)
(KEYWORD return)
(ID "KeysView")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "items")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.items() -> a set-like object providing a view on D's items")
(NEWLINE)
(KEYWORD return)
(ID "ItemsView")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "values")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.values() -> an object providing a view on D's values")
(NEWLINE)
(KEYWORD return)
(ID "ValuesView")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Mapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "dict")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT "==")
(ID "dict")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Mapping")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "mappingproxy")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "MappingView")
(PUNCT "(")
(ID "Sized")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "mapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT "=")
(ID "mapping")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "{0.__class__.__name__}({0._mapping!r})")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "KeysView")
(PUNCT "(")
(ID "MappingView")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "_from_iterable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "set")
(PUNCT "(")
(ID "it")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "KeysView")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict_keys")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "ItemsView")
(PUNCT "(")
(ID "MappingView")
(PUNCT ",")
(ID "Set")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "_from_iterable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "it")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "set")
(PUNCT "(")
(ID "it")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "item")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "v")
(PUNCT "==")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "ItemsView")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict_items")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "ValuesView")
(PUNCT "(")
(ID "MappingView")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "_mapping")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "ValuesView")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict_values")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "MutableMapping")
(PUNCT "(")
(ID "Mapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(LIT "A MutableMapping is a generic container for associating\n    key/value pairs.\n\n    This class provides concrete generic implementations of all\n    methods except for __getitem__, __setitem__, __delitem__,\n    __iter__, and __len__.\n\n    ")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(NEWLINE)
(DEDENT)
(ID "__marker")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "pop")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(ID "__marker")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n          If key is not found, d is returned if given, otherwise KeyError is raised.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "default")
(KEYWORD is)
(ID "self")
(PUNCT ".")
(ID "__marker")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "default")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "popitem")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.popitem() -> (k, v), remove and return some (key, value) pair\n           as a 2-tuple; but raise KeyError if D is empty.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(NEWLINE)
(DEDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "key")
(PUNCT ",")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.clear() -> None.  Remove all items from D.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "popitem")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "update")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\n            If E present and has a .keys() method, does:     for k in E: D[k] = E[k]\n            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\n            In either case, this is followed by: for k, v in F.items(): D[k] = v\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "descriptor 'update' of 'MutableMapping' object ")
(LIT "needs an argument")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT "=")
(ID "args")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "update expected at most 1 arguments, got %d")
(PUNCT "%")
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "other")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "Mapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "other")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "hasattr")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(LIT "keys")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "other")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "other")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "other")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "kwds")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "setdefault")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "default")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "default")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "MutableMapping")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "dict")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Sequence")
(PUNCT "(")
(ID "Sized")
(PUNCT ",")
(ID "Iterable")
(PUNCT ",")
(ID "Container")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "All the operations on a read-only sequence.\n\n    Concrete subclasses must override __new__ or __init__,\n    __getitem__, and __len__.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "IndexError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(KEYWORD yield)
(ID "v")
(NEWLINE)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "v")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "v")
(PUNCT "==")
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reversed__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "reversed")
(PUNCT "(")
(ID "range")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "index")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.index(value) -> integer -- return first index of value.\n           Raises ValueError if the value is not present.\n        ")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "v")
(PUNCT "==")
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "i")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "count")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.count(value) -> integer -- return number of occurrences of value")
(NEWLINE)
(KEYWORD return)
(ID "sum")
(PUNCT "(")
(LIT 1)
(KEYWORD for)
(ID "v")
(KEYWORD in)
(ID "self")
(KEYWORD if)
(ID "v")
(PUNCT "==")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "Sequence")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "tuple")
(PUNCT ")")
(NEWLINE)
(ID "Sequence")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "Sequence")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "range")
(PUNCT ")")
(NEWLINE)
(ID "Sequence")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "memoryview")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "ByteString")
(PUNCT "(")
(ID "Sequence")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This unifies bytes and bytearray.\n\n    XXX Should add all their methods.\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "ByteString")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "bytes")
(PUNCT ")")
(NEWLINE)
(ID "ByteString")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "bytearray")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "MutableSequence")
(PUNCT "(")
(ID "Sequence")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(LIT "All the operations on a read-write sequence.\n\n    Concrete subclasses must provide __new__ or __init__,\n    __getitem__, __setitem__, __delitem__, __len__, and insert().\n\n    ")
(NEWLINE)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "IndexError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "IndexError")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "abstractmethod")
(NEWLINE)
(KEYWORD def)
(ID "insert")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.insert(index, value) -- insert value before index")
(NEWLINE)
(KEYWORD raise)
(ID "IndexError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.append(value) -- append value to the end of the sequence")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.clear() -> None -- remove all items from S")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "reverse")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.reverse() -- reverse *IN PLACE*")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "n")
(PUNCT "//")
(LIT 2)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "self")
(PUNCT "[")
(ID "n")
(PUNCT "-")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "n")
(PUNCT "-")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "self")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "extend")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "values")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.extend(iterable) -- extend sequence by appending elements from the iterable")
(NEWLINE)
(KEYWORD for)
(ID "v")
(KEYWORD in)
(ID "values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "pop")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.pop([index]) -> item -- remove and return item at index (default last).\n           Raise IndexError if list is empty or index is out of range.\n        ")
(NEWLINE)
(ID "v")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "index")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "index")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "v")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remove")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "S.remove(value) -- remove first occurrence of value.\n           Raise ValueError if the value is not present.\n        ")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iadd__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "values")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "values")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "MutableSequence")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "list")
(PUNCT ")")
(NEWLINE)
(ID "MutableSequence")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "bytearray")
(PUNCT ")")
(NEWLINE)
(ENDMARKER)
