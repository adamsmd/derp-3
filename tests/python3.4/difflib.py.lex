(LIT "\nModule difflib -- helpers for computing deltas between objects.\n\nFunction get_close_matches(word, possibilities, n=3, cutoff=0.6):\n    Use SequenceMatcher to return list of the best \"good enough\" matches.\n\nFunction context_diff(a, b):\n    For two lists of strings, return a delta in context diff format.\n\nFunction ndiff(a, b):\n    Return a delta: the difference between `a` and `b` (lists of strings).\n\nFunction restore(delta, which):\n    Return one of the two sequences that generated an ndiff delta.\n\nFunction unified_diff(a, b):\n    For two lists of strings, return a delta in unified diff format.\n\nClass SequenceMatcher:\n    A flexible class for comparing pairs of sequences of any type.\n\nClass Differ:\n    For producing human-readable deltas from sequences of lines of text.\n\nClass HtmlDiff:\n    For producing HTML side by side comparison with change highlights.\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "get_close_matches")
(PUNCT ",")
(LIT "ndiff")
(PUNCT ",")
(LIT "restore")
(PUNCT ",")
(LIT "SequenceMatcher")
(PUNCT ",")
(LIT "Differ")
(PUNCT ",")
(LIT "IS_CHARACTER_JUNK")
(PUNCT ",")
(LIT "IS_LINE_JUNK")
(PUNCT ",")
(LIT "context_diff")
(PUNCT ",")
(LIT "unified_diff")
(PUNCT ",")
(LIT "HtmlDiff")
(PUNCT ",")
(LIT "Match")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "heapq")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "namedtuple")
(KEYWORD as)
(ID "_namedtuple")
(NEWLINE)
(ID "Match")
(PUNCT "=")
(ID "_namedtuple")
(PUNCT "(")
(LIT "Match")
(PUNCT ",")
(LIT "a b size")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_calculate_ratio")
(PUNCT "(")
(ID "matches")
(PUNCT ",")
(ID "length")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "length")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 2.0)
(PUNCT "*")
(ID "matches")
(PUNCT "/")
(ID "length")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 1.0)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "SequenceMatcher")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    SequenceMatcher is a flexible class for comparing pairs of sequences of\n    any type, so long as the sequence elements are hashable.  The basic\n    algorithm predates, and is a little fancier than, an algorithm\n    published in the late 1980's by Ratcliff and Obershelp under the\n    hyperbolic name \"gestalt pattern matching\".  The basic idea is to find\n    the longest contiguous matching subsequence that contains no \"junk\"\n    elements (R-O doesn't address junk).  The same idea is then applied\n    recursively to the pieces of the sequences to the left and to the right\n    of the matching subsequence.  This does not yield minimal edit\n    sequences, but does tend to yield matches that \"look right\" to people.\n\n    SequenceMatcher tries to compute a \"human-friendly diff\" between two\n    sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\n    longest *contiguous* & junk-free matching subsequence.  That's what\n    catches peoples' eyes.  The Windows(tm) windiff has another interesting\n    notion, pairing up elements that appear uniquely in each sequence.\n    That, and the method here, appear to yield more intuitive difference\n    reports than does diff.  This method appears to be the least vulnerable\n    to synching up on blocks of \"junk lines\", though (like blank lines in\n    ordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\n    because this is the only method of the 3 that has a *concept* of\n    \"junk\" <wink>.\n\n    Example, comparing two strings, and considering blanks to be \"junk\":\n\n    >>> s = SequenceMatcher(lambda x: x == \" \",\n    ...                     \"private Thread currentThread;\",\n    ...                     \"private volatile Thread currentThread;\")\n    >>>\n\n    .ratio() returns a float in [0, 1], measuring the \"similarity\" of the\n    sequences.  As a rule of thumb, a .ratio() value over 0.6 means the\n    sequences are close matches:\n\n    >>> print(round(s.ratio(), 3))\n    0.866\n    >>>\n\n    If you're only interested in where the sequences match,\n    .get_matching_blocks() is handy:\n\n    >>> for block in s.get_matching_blocks():\n    ...     print(\"a[%d] and b[%d] match for %d elements\" % block)\n    a[0] and b[0] match for 8 elements\n    a[8] and b[17] match for 21 elements\n    a[29] and b[38] match for 0 elements\n\n    Note that the last tuple returned by .get_matching_blocks() is always a\n    dummy, (len(a), len(b), 0), and this is the only case in which the last\n    tuple element (number of elements matched) is 0.\n\n    If you want to know how to change the first sequence into the second,\n    use .get_opcodes():\n\n    >>> for opcode in s.get_opcodes():\n    ...     print(\"%6s a[%d:%d] b[%d:%d]\" % opcode)\n     equal a[0:8] b[0:8]\n    insert a[8:8] b[8:17]\n     equal a[8:29] b[17:38]\n\n    See the Differ class for a fancy human-friendly file differencer, which\n    uses SequenceMatcher both to compare sequences of lines, and to compare\n    sequences of characters within similar (near-matching) lines.\n\n    See also function get_close_matches() in this module, which shows how\n    simple code building on SequenceMatcher can be used to do useful work.\n\n    Timing:  Basic R-O is cubic time worst case and quadratic time expected\n    case.  SequenceMatcher is quadratic time for the worst case and has\n    expected-case behavior dependent in a complicated way on how many\n    elements the sequences have in common; best case time is linear.\n\n    Methods:\n\n    __init__(isjunk=None, a='', b='')\n        Construct a SequenceMatcher.\n\n    set_seqs(a, b)\n        Set the two sequences to be compared.\n\n    set_seq1(a)\n        Set the first sequence to be compared.\n\n    set_seq2(b)\n        Set the second sequence to be compared.\n\n    find_longest_match(alo, ahi, blo, bhi)\n        Find longest matching block in a[alo:ahi] and b[blo:bhi].\n\n    get_matching_blocks()\n        Return list of triples describing matching subsequences.\n\n    get_opcodes()\n        Return list of 5-tuples describing how to turn a into b.\n\n    ratio()\n        Return a measure of the sequences' similarity (float in [0,1]).\n\n    quick_ratio()\n        Return an upper bound on .ratio() relatively quickly.\n\n    real_quick_ratio()\n        Return an upper bound on ratio() very quickly.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "isjunk")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "a")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "b")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "autojunk")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Construct a SequenceMatcher.\n\n        Optional arg isjunk is None (the default), or a one-argument\n        function that takes a sequence element and returns true iff the\n        element is junk.  None is equivalent to passing \"lambda x: 0\", i.e.\n        no elements are considered to be junk.  For example, pass\n            lambda x: x in \" \\t\"\n        if you're comparing lines as sequences of characters, and don't\n        want to synch up on blanks or hard tabs.\n\n        Optional arg a is the first of two sequences to be compared.  By\n        default, an empty string.  The elements of a must be hashable.  See\n        also .set_seqs() and .set_seq1().\n\n        Optional arg b is the second of two sequences to be compared.  By\n        default, an empty string.  The elements of b must be hashable. See\n        also .set_seqs() and .set_seq2().\n\n        Optional arg autojunk should be set to False to disable the\n        \"automatic junk heuristic\" that treats popular elements as junk\n        (see module documentation for more information).\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "isjunk")
(PUNCT "=")
(ID "isjunk")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "autojunk")
(PUNCT "=")
(ID "autojunk")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_seqs")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_seqs")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the two sequences to be compared.\n\n        >>> s = SequenceMatcher()\n        >>> s.set_seqs(\"abcd\", \"bcde\")\n        >>> s.ratio()\n        0.75\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_seq1")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_seq2")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_seq1")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the first sequence to be compared.\n\n        The second sequence to be compared is not changed.\n\n        >>> s = SequenceMatcher(None, \"abcd\", \"bcde\")\n        >>> s.ratio()\n        0.75\n        >>> s.set_seq1(\"bcde\")\n        >>> s.ratio()\n        1.0\n        >>>\n\n        SequenceMatcher computes and caches detailed information about the\n        second sequence, so if you want to compare one sequence S against\n        many sequences, use .set_seq2(S) once and call .set_seq1(x)\n        repeatedly for each of the other sequences.\n\n        See also set_seqs() and set_seq2().\n        ")
(NEWLINE)
(KEYWORD if)
(ID "a")
(KEYWORD is)
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT "=")
(ID "a")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "matching_blocks")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "opcodes")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_seq2")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the second sequence to be compared.\n\n        The first sequence to be compared is not changed.\n\n        >>> s = SequenceMatcher(None, \"abcd\", \"bcde\")\n        >>> s.ratio()\n        0.75\n        >>> s.set_seq2(\"abcd\")\n        >>> s.ratio()\n        1.0\n        >>>\n\n        SequenceMatcher computes and caches detailed information about the\n        second sequence, so if you want to compare one sequence S against\n        many sequences, use .set_seq2(S) once and call .set_seq1(x)\n        repeatedly for each of the other sequences.\n\n        See also set_seqs() and set_seq1().\n        ")
(NEWLINE)
(KEYWORD if)
(ID "b")
(KEYWORD is)
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT "=")
(ID "b")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "matching_blocks")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "opcodes")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "fullbcount")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__chain_b")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__chain_b")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "b")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "b2j")
(PUNCT "=")
(ID "b2j")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "elt")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indices")
(PUNCT "=")
(ID "b2j")
(PUNCT ".")
(ID "setdefault")
(PUNCT "(")
(ID "elt")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "indices")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "bjunk")
(PUNCT "=")
(ID "junk")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "isjunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "isjunk")
(NEWLINE)
(KEYWORD if)
(ID "isjunk")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "elt")
(KEYWORD in)
(ID "b2j")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isjunk")
(PUNCT "(")
(ID "elt")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "junk")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "elt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "elt")
(KEYWORD in)
(ID "junk")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "b2j")
(PUNCT "[")
(ID "elt")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "bpopular")
(PUNCT "=")
(ID "popular")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "autojunk")
(KEYWORD and)
(ID "n")
(PUNCT ">=")
(LIT 200)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ntest")
(PUNCT "=")
(ID "n")
(PUNCT "//")
(LIT 100)
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD for)
(ID "elt")
(PUNCT ",")
(ID "idxs")
(KEYWORD in)
(ID "b2j")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "idxs")
(PUNCT ")")
(PUNCT ">")
(ID "ntest")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "popular")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "elt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "elt")
(KEYWORD in)
(ID "popular")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "b2j")
(PUNCT "[")
(ID "elt")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "find_longest_match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find longest matching block in a[alo:ahi] and b[blo:bhi].\n\n        If isjunk is not defined:\n\n        Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where\n            alo <= i <= i+k <= ahi\n            blo <= j <= j+k <= bhi\n        and for all (i',j',k') meeting those conditions,\n            k >= k'\n            i <= i'\n            and if i == i', j <= j'\n\n        In other words, of all maximal matching blocks, return one that\n        starts earliest in a, and of all those maximal matching blocks that\n        start earliest in a, return the one that starts earliest in b.\n\n        >>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\")\n        >>> s.find_longest_match(0, 5, 0, 9)\n        Match(a=0, b=4, size=5)\n\n        If isjunk is defined, first the longest matching block is\n        determined as above, but with the additional restriction that no\n        junk element appears in the block.  Then that block is extended as\n        far as possible by matching (only) junk elements on both sides.  So\n        the resulting block never matches on junk except as identical junk\n        happens to be adjacent to an \"interesting\" match.\n\n        Here's the same example as before, but considering blanks to be\n        junk.  That prevents \" abcd\" from matching the \" abcd\" at the tail\n        end of the second sequence directly.  Instead only the \"abcd\" can\n        match, and matches the leftmost \"abcd\" in the second sequence:\n\n        >>> s = SequenceMatcher(lambda x: x==\" \", \" abcd\", \"abcd abcd\")\n        >>> s.find_longest_match(0, 5, 0, 9)\n        Match(a=1, b=0, size=4)\n\n        If no blocks match, return (alo, blo, 0).\n\n        >>> s = SequenceMatcher(None, \"ab\", \"c\")\n        >>> s.find_longest_match(0, 2, 0, 1)\n        Match(a=0, b=0, size=0)\n        ")
(NEWLINE)
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "b2j")
(PUNCT ",")
(ID "isbjunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "b2j")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "bjunk")
(PUNCT ".")
(ID "__contains__")
(NEWLINE)
(ID "besti")
(PUNCT ",")
(ID "bestj")
(PUNCT ",")
(ID "bestsize")
(PUNCT "=")
(ID "alo")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(LIT 0)
(NEWLINE)
(ID "j2len")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "nothing")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "j2lenget")
(PUNCT "=")
(ID "j2len")
(PUNCT ".")
(ID "get")
(NEWLINE)
(ID "newj2len")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "j")
(KEYWORD in)
(ID "b2j")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "a")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "nothing")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "j")
(PUNCT "<")
(ID "blo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "j")
(PUNCT ">=")
(ID "bhi")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "k")
(PUNCT "=")
(ID "newj2len")
(PUNCT "[")
(ID "j")
(PUNCT "]")
(PUNCT "=")
(ID "j2lenget")
(PUNCT "(")
(ID "j")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "k")
(PUNCT ">")
(ID "bestsize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "besti")
(PUNCT ",")
(ID "bestj")
(PUNCT ",")
(ID "bestsize")
(PUNCT "=")
(ID "i")
(PUNCT "-")
(ID "k")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "j")
(PUNCT "-")
(ID "k")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "k")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "j2len")
(PUNCT "=")
(ID "newj2len")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "besti")
(PUNCT ">")
(ID "alo")
(KEYWORD and)
(ID "bestj")
(PUNCT ">")
(ID "blo")
(KEYWORD and)
(KEYWORD not)
(ID "isbjunk")
(PUNCT "(")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(KEYWORD and)
(ID "a")
(PUNCT "[")
(ID "besti")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "besti")
(PUNCT ",")
(ID "bestj")
(PUNCT ",")
(ID "bestsize")
(PUNCT "=")
(ID "besti")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "bestj")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "bestsize")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "besti")
(PUNCT "+")
(ID "bestsize")
(PUNCT "<")
(ID "ahi")
(KEYWORD and)
(ID "bestj")
(PUNCT "+")
(ID "bestsize")
(PUNCT "<")
(ID "bhi")
(KEYWORD and)
(KEYWORD not)
(ID "isbjunk")
(PUNCT "(")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "+")
(ID "bestsize")
(PUNCT "]")
(PUNCT ")")
(KEYWORD and)
(ID "a")
(PUNCT "[")
(ID "besti")
(PUNCT "+")
(ID "bestsize")
(PUNCT "]")
(PUNCT "==")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "+")
(ID "bestsize")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bestsize")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "besti")
(PUNCT ">")
(ID "alo")
(KEYWORD and)
(ID "bestj")
(PUNCT ">")
(ID "blo")
(KEYWORD and)
(ID "isbjunk")
(PUNCT "(")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(KEYWORD and)
(ID "a")
(PUNCT "[")
(ID "besti")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "besti")
(PUNCT ",")
(ID "bestj")
(PUNCT ",")
(ID "bestsize")
(PUNCT "=")
(ID "besti")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "bestj")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "bestsize")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "besti")
(PUNCT "+")
(ID "bestsize")
(PUNCT "<")
(ID "ahi")
(KEYWORD and)
(ID "bestj")
(PUNCT "+")
(ID "bestsize")
(PUNCT "<")
(ID "bhi")
(KEYWORD and)
(ID "isbjunk")
(PUNCT "(")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "+")
(ID "bestsize")
(PUNCT "]")
(PUNCT ")")
(KEYWORD and)
(ID "a")
(PUNCT "[")
(ID "besti")
(PUNCT "+")
(ID "bestsize")
(PUNCT "]")
(PUNCT "==")
(ID "b")
(PUNCT "[")
(ID "bestj")
(PUNCT "+")
(ID "bestsize")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bestsize")
(PUNCT "=")
(ID "bestsize")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Match")
(PUNCT "(")
(ID "besti")
(PUNCT ",")
(ID "bestj")
(PUNCT ",")
(ID "bestsize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_matching_blocks")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return list of triples describing matching subsequences.\n\n        Each triple is of the form (i, j, n), and means that\n        a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in\n        i and in j.  New in Python 2.5, it's also guaranteed that if\n        (i, j, n) and (i', j', n') are adjacent triples in the list, and\n        the second is not the last triple in the list, then i+n != i' or\n        j+n != j'.  IOW, adjacent triples never describe adjacent equal\n        blocks.\n\n        The last triple is a dummy, (len(a), len(b), 0), and is the only\n        triple with n==0.\n\n        >>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n        >>> list(s.get_matching_blocks())\n        [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "matching_blocks")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "matching_blocks")
(NEWLINE)
(DEDENT)
(ID "la")
(PUNCT ",")
(ID "lb")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ")")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ")")
(NEWLINE)
(ID "queue")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "la")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "lb")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(ID "matching_blocks")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "queue")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT "=")
(ID "queue")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT ",")
(ID "j")
(PUNCT ",")
(ID "k")
(PUNCT "=")
(ID "x")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "find_longest_match")
(PUNCT "(")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "k")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "matching_blocks")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "alo")
(PUNCT "<")
(ID "i")
(KEYWORD and)
(ID "blo")
(PUNCT "<")
(ID "j")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "queue")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "alo")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "j")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "i")
(PUNCT "+")
(ID "k")
(PUNCT "<")
(ID "ahi")
(KEYWORD and)
(ID "j")
(PUNCT "+")
(ID "k")
(PUNCT "<")
(ID "bhi")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "queue")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "i")
(PUNCT "+")
(ID "k")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "j")
(PUNCT "+")
(ID "k")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "matching_blocks")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "i1")
(PUNCT "=")
(ID "j1")
(PUNCT "=")
(ID "k1")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "non_adjacent")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "i2")
(PUNCT ",")
(ID "j2")
(PUNCT ",")
(ID "k2")
(KEYWORD in)
(ID "matching_blocks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "i1")
(PUNCT "+")
(ID "k1")
(PUNCT "==")
(ID "i2")
(KEYWORD and)
(ID "j1")
(PUNCT "+")
(ID "k1")
(PUNCT "==")
(ID "j2")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k1")
(PUNCT "+=")
(ID "k2")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k1")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "non_adjacent")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "i1")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "k1")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "i1")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "k1")
(PUNCT "=")
(ID "i2")
(PUNCT ",")
(ID "j2")
(PUNCT ",")
(ID "k2")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "k1")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "non_adjacent")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "i1")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "k1")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "non_adjacent")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "la")
(PUNCT ",")
(ID "lb")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "matching_blocks")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "Match")
(PUNCT ".")
(ID "_make")
(PUNCT ",")
(ID "non_adjacent")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "matching_blocks")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_opcodes")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return list of 5-tuples describing how to turn a into b.\n\n        Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple\n        has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the\n        tuple preceding it, and likewise for j1 == the previous j2.\n\n        The tags are strings, with these meanings:\n\n        'replace':  a[i1:i2] should be replaced by b[j1:j2]\n        'delete':   a[i1:i2] should be deleted.\n                    Note that j1==j2 in this case.\n        'insert':   b[j1:j2] should be inserted at a[i1:i1].\n                    Note that i1==i2 in this case.\n        'equal':    a[i1:i2] == b[j1:j2]\n\n        >>> a = \"qabxcd\"\n        >>> b = \"abycdf\"\n        >>> s = SequenceMatcher(None, a, b)\n        >>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n        ...    print((\"%7s a[%d:%d] (%s) b[%d:%d] (%s)\" %\n        ...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2])))\n         delete a[0:1] (q) b[0:0] ()\n          equal a[1:3] (ab) b[0:2] (ab)\n        replace a[3:4] (x) b[2:3] (y)\n          equal a[4:6] (cd) b[3:5] (cd)\n         insert a[6:6] () b[5:6] (f)\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "opcodes")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "opcodes")
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "=")
(ID "j")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "opcodes")
(PUNCT "=")
(ID "answer")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "ai")
(PUNCT ",")
(ID "bj")
(PUNCT ",")
(ID "size")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "get_matching_blocks")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT "<")
(ID "ai")
(KEYWORD and)
(ID "j")
(PUNCT "<")
(ID "bj")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(LIT "replace")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "i")
(PUNCT "<")
(ID "ai")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(LIT "delete")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "j")
(PUNCT "<")
(ID "bj")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(LIT "insert")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "tag")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "answer")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "ai")
(PUNCT ",")
(ID "j")
(PUNCT ",")
(ID "bj")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT ",")
(ID "j")
(PUNCT "=")
(ID "ai")
(PUNCT "+")
(ID "size")
(PUNCT ",")
(ID "bj")
(PUNCT "+")
(ID "size")
(NEWLINE)
(KEYWORD if)
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "answer")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(LIT "equal")
(PUNCT ",")
(ID "ai")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "bj")
(PUNCT ",")
(ID "j")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "answer")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_grouped_opcodes")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 3)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Isolate change clusters by eliminating ranges with no changes.\n\n        Return a generator of groups with up to n lines of context.\n        Each group is in the same format as returned by get_opcodes().\n\n        >>> from pprint import pprint\n        >>> a = list(map(str, range(1,40)))\n        >>> b = a[:]\n        >>> b[8:8] = ['i']     # Make an insertion\n        >>> b[20] += 'x'       # Make a replacement\n        >>> b[23:28] = []      # Make a deletion\n        >>> b[30] += 'y'       # Make another replacement\n        >>> pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))\n        [[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],\n         [('equal', 16, 19, 17, 20),\n          ('replace', 19, 20, 20, 21),\n          ('equal', 20, 22, 21, 23),\n          ('delete', 22, 27, 23, 23),\n          ('equal', 27, 30, 23, 26)],\n         [('equal', 31, 34, 27, 30),\n          ('replace', 34, 35, 30, 31),\n          ('equal', 35, 38, 31, 34)]]\n        ")
(NEWLINE)
(ID "codes")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_opcodes")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "codes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "codes")
(PUNCT "=")
(PUNCT "[")
(PUNCT "(")
(LIT "equal")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "codes")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "equal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "j2")
(PUNCT "=")
(ID "codes")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "codes")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "tag")
(PUNCT ",")
(ID "max")
(PUNCT "(")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT "-")
(ID "n")
(PUNCT ")")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "max")
(PUNCT "(")
(ID "j1")
(PUNCT ",")
(ID "j2")
(PUNCT "-")
(ID "n")
(PUNCT ")")
(PUNCT ",")
(ID "j2")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "codes")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "equal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "j2")
(PUNCT "=")
(ID "codes")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "codes")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "min")
(PUNCT "(")
(ID "i2")
(PUNCT ",")
(ID "i1")
(PUNCT "+")
(ID "n")
(PUNCT ")")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "min")
(PUNCT "(")
(ID "j2")
(PUNCT ",")
(ID "j1")
(PUNCT "+")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "nn")
(PUNCT "=")
(ID "n")
(PUNCT "+")
(ID "n")
(NEWLINE)
(ID "group")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "j2")
(KEYWORD in)
(ID "codes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT "==")
(LIT "equal")
(KEYWORD and)
(ID "i2")
(PUNCT "-")
(ID "i1")
(PUNCT ">")
(ID "nn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "group")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "min")
(PUNCT "(")
(ID "i2")
(PUNCT ",")
(ID "i1")
(PUNCT "+")
(ID "n")
(PUNCT ")")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "min")
(PUNCT "(")
(ID "j2")
(PUNCT ",")
(ID "j1")
(PUNCT "+")
(ID "n")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "group")
(NEWLINE)
(ID "group")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "i1")
(PUNCT ",")
(ID "j1")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT "-")
(ID "n")
(PUNCT ")")
(PUNCT ",")
(ID "max")
(PUNCT "(")
(ID "j1")
(PUNCT ",")
(ID "j2")
(PUNCT "-")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "group")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "j2")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "group")
(KEYWORD and)
(KEYWORD not)
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "group")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "group")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "equal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "group")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "ratio")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a measure of the sequences' similarity (float in [0,1]).\n\n        Where T is the total number of elements in both sequences, and\n        M is the number of matches, this is 2.0*M / T.\n        Note that this is 1 if the sequences are identical, and 0 if\n        they have nothing in common.\n\n        .ratio() is expensive to compute if you haven't already computed\n        .get_matching_blocks() or .get_opcodes(), in which case you may\n        want to try .quick_ratio() or .real_quick_ratio() first to get an\n        upper bound.\n\n        >>> s = SequenceMatcher(None, \"abcd\", \"bcde\")\n        >>> s.ratio()\n        0.75\n        >>> s.quick_ratio()\n        0.75\n        >>> s.real_quick_ratio()\n        1.0\n        ")
(NEWLINE)
(ID "matches")
(PUNCT "=")
(ID "sum")
(PUNCT "(")
(ID "triple")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD for)
(ID "triple")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "get_matching_blocks")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_calculate_ratio")
(PUNCT "(")
(ID "matches")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "quick_ratio")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an upper bound on ratio() relatively quickly.\n\n        This isn't defined beyond that it is an upper bound on .ratio(), and\n        is faster to compute.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "fullbcount")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fullbcount")
(PUNCT "=")
(ID "fullbcount")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "elt")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullbcount")
(PUNCT "[")
(ID "elt")
(PUNCT "]")
(PUNCT "=")
(ID "fullbcount")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "elt")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "fullbcount")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fullbcount")
(NEWLINE)
(ID "avail")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "availhas")
(PUNCT ",")
(ID "matches")
(PUNCT "=")
(ID "avail")
(PUNCT ".")
(ID "__contains__")
(PUNCT ",")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "elt")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "availhas")
(PUNCT "(")
(ID "elt")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "numb")
(PUNCT "=")
(ID "avail")
(PUNCT "[")
(ID "elt")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "numb")
(PUNCT "=")
(ID "fullbcount")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "elt")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "avail")
(PUNCT "[")
(ID "elt")
(PUNCT "]")
(PUNCT "=")
(ID "numb")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "numb")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "matches")
(PUNCT "=")
(ID "matches")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "_calculate_ratio")
(PUNCT "(")
(ID "matches")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "real_quick_ratio")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an upper bound on ratio() very quickly.\n\n        This isn't defined beyond that it is an upper bound on .ratio(), and\n        is faster to compute than either .ratio() or .quick_ratio().\n        ")
(NEWLINE)
(ID "la")
(PUNCT ",")
(ID "lb")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "a")
(PUNCT ")")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_calculate_ratio")
(PUNCT "(")
(ID "min")
(PUNCT "(")
(ID "la")
(PUNCT ",")
(ID "lb")
(PUNCT ")")
(PUNCT ",")
(ID "la")
(PUNCT "+")
(ID "lb")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_close_matches")
(PUNCT "(")
(ID "word")
(PUNCT ",")
(ID "possibilities")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 3)
(PUNCT ",")
(ID "cutoff")
(PUNCT "=")
(LIT 0.6)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Use SequenceMatcher to return list of the best \"good enough\" matches.\n\n    word is a sequence for which close matches are desired (typically a\n    string).\n\n    possibilities is a list of sequences against which to match word\n    (typically a list of strings).\n\n    Optional arg n (default 3) is the maximum number of close matches to\n    return.  n must be > 0.\n\n    Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\n    that don't score at least that similar to word are ignored.\n\n    The best (no more than n) matches among the possibilities are returned\n    in a list, sorted by similarity score, most similar first.\n\n    >>> get_close_matches(\"appel\", [\"ape\", \"apple\", \"peach\", \"puppy\"])\n    ['apple', 'ape']\n    >>> import keyword as _keyword\n    >>> get_close_matches(\"wheel\", _keyword.kwlist)\n    ['while']\n    >>> get_close_matches(\"Apple\", _keyword.kwlist)\n    []\n    >>> get_close_matches(\"accept\", _keyword.kwlist)\n    ['except']\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "n")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "n must be > 0: %r")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(LIT 0.0)
(PUNCT "<=")
(ID "cutoff")
(PUNCT "<=")
(LIT 1.0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cutoff must be in [0.0, 1.0]: %r")
(PUNCT "%")
(PUNCT "(")
(ID "cutoff")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "SequenceMatcher")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT ".")
(ID "set_seq2")
(PUNCT "(")
(ID "word")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "possibilities")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT ".")
(ID "set_seq1")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT ".")
(ID "real_quick_ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">=")
(ID "cutoff")
(KEYWORD and)
(ID "s")
(PUNCT ".")
(ID "quick_ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">=")
(ID "cutoff")
(KEYWORD and)
(ID "s")
(PUNCT ".")
(ID "ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">=")
(ID "cutoff")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "x")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "heapq")
(PUNCT ".")
(ID "nlargest")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "result")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "x")
(KEYWORD for)
(ID "score")
(PUNCT ",")
(ID "x")
(KEYWORD in)
(ID "result")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_count_leading")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(ID "ch")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return number of `ch` characters at the start of `line`.\n\n    Example:\n\n    >>> _count_leading('   abc', ' ')\n    3\n    ")
(NEWLINE)
(ID "i")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "n")
(KEYWORD and)
(ID "line")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "==")
(ID "ch")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "i")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Differ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Differ is a class for comparing sequences of lines of text, and\n    producing human-readable differences or deltas.  Differ uses\n    SequenceMatcher both to compare sequences of lines, and to compare\n    sequences of characters within similar (near-matching) lines.\n\n    Each line of a Differ delta begins with a two-letter code:\n\n        '- '    line unique to sequence 1\n        '+ '    line unique to sequence 2\n        '  '    line common to both sequences\n        '? '    line not present in either input sequence\n\n    Lines beginning with '? ' attempt to guide the eye to intraline\n    differences, and were not present in either input sequence.  These lines\n    can be confusing if the sequences contain tab characters.\n\n    Note that Differ makes no claim to produce a *minimal* diff.  To the\n    contrary, minimal diffs are often counter-intuitive, because they synch\n    up anywhere possible, sometimes accidental matches 100 pages apart.\n    Restricting synch points to contiguous matches preserves some notion of\n    locality, at the occasional cost of producing a longer diff.\n\n    Example: Comparing two texts.\n\n    First we set up the texts, sequences of individual single-line strings\n    ending with newlines (such sequences can also be obtained from the\n    `readlines()` method of file-like objects):\n\n    >>> text1 = '''  1. Beautiful is better than ugly.\n    ...   2. Explicit is better than implicit.\n    ...   3. Simple is better than complex.\n    ...   4. Complex is better than complicated.\n    ... '''.splitlines(keepends=True)\n    >>> len(text1)\n    4\n    >>> text1[0][-1]\n    '\\n'\n    >>> text2 = '''  1. Beautiful is better than ugly.\n    ...   3.   Simple is better than complex.\n    ...   4. Complicated is better than complex.\n    ...   5. Flat is better than nested.\n    ... '''.splitlines(keepends=True)\n\n    Next we instantiate a Differ object:\n\n    >>> d = Differ()\n\n    Note that when instantiating a Differ object we may pass functions to\n    filter out line and character 'junk'.  See Differ.__init__ for details.\n\n    Finally, we compare the two:\n\n    >>> result = list(d.compare(text1, text2))\n\n    'result' is a list of strings, so let's pretty-print it:\n\n    >>> from pprint import pprint as _pprint\n    >>> _pprint(result)\n    ['    1. Beautiful is better than ugly.\\n',\n     '-   2. Explicit is better than implicit.\\n',\n     '-   3. Simple is better than complex.\\n',\n     '+   3.   Simple is better than complex.\\n',\n     '?     ++\\n',\n     '-   4. Complex is better than complicated.\\n',\n     '?            ^                     ---- ^\\n',\n     '+   4. Complicated is better than complex.\\n',\n     '?           ++++ ^                      ^\\n',\n     '+   5. Flat is better than nested.\\n']\n\n    As a single multi-line string it looks like this:\n\n    >>> print(''.join(result), end=\"\")\n        1. Beautiful is better than ugly.\n    -   2. Explicit is better than implicit.\n    -   3. Simple is better than complex.\n    +   3.   Simple is better than complex.\n    ?     ++\n    -   4. Complex is better than complicated.\n    ?            ^                     ---- ^\n    +   4. Complicated is better than complex.\n    ?           ++++ ^                      ^\n    +   5. Flat is better than nested.\n\n    Methods:\n\n    __init__(linejunk=None, charjunk=None)\n        Construct a text differencer, with optional filters.\n\n    compare(a, b)\n        Compare two sequences of lines; generate the resulting delta.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "linejunk")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "charjunk")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Construct a text differencer, with optional filters.\n\n        The two optional keyword parameters are for filter functions:\n\n        - `linejunk`: A function that should accept a single string argument,\n          and return true iff the string is junk. The module-level function\n          `IS_LINE_JUNK` may be used to filter out lines without visible\n          characters, except for at most one splat ('#').  It is recommended\n          to leave linejunk None; as of Python 2.3, the underlying\n          SequenceMatcher class has grown an adaptive notion of \"noise\" lines\n          that's better than any static definition the author has ever been\n          able to craft.\n\n        - `charjunk`: A function that should accept a string of length 1. The\n          module-level function `IS_CHARACTER_JUNK` may be used to filter out\n          whitespace characters (a blank or tab; **note**: bad idea to include\n          newline in this!).  Use of IS_CHARACTER_JUNK is recommended.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "linejunk")
(PUNCT "=")
(ID "linejunk")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "charjunk")
(PUNCT "=")
(ID "charjunk")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compare")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Compare two sequences of lines; generate the resulting delta.\n\n        Each sequence must contain individual single-line strings ending with\n        newlines. Such sequences can be obtained from the `readlines()` method\n        of file-like objects.  The delta generated also consists of newline-\n        terminated strings, ready to be printed as-is via the writeline()\n        method of a file-like object.\n\n        Example:\n\n        >>> print(''.join(Differ().compare('one\\ntwo\\nthree\\n'.splitlines(True),\n        ...                                'ore\\ntree\\nemu\\n'.splitlines(True))),\n        ...       end=\"\")\n        - one\n        ?  ^\n        + ore\n        ?  ^\n        - two\n        - three\n        ?  -\n        + tree\n        + emu\n        ")
(NEWLINE)
(ID "cruncher")
(PUNCT "=")
(ID "SequenceMatcher")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "linejunk")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(KEYWORD in)
(ID "cruncher")
(PUNCT ".")
(ID "get_opcodes")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT "==")
(LIT "replace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fancy_replace")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(PUNCT "==")
(LIT "delete")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "-")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(PUNCT "==")
(LIT "insert")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(PUNCT "==")
(LIT "equal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown tag %r")
(PUNCT "%")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "g")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_dump")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ",")
(ID "x")
(PUNCT ",")
(ID "lo")
(PUNCT ",")
(ID "hi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate comparison results for a same-tagged range.")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "lo")
(PUNCT ",")
(ID "hi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "%s %s")
(PUNCT "%")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "x")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_plain_replace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "alo")
(PUNCT "<")
(ID "ahi")
(KEYWORD and)
(ID "blo")
(PUNCT "<")
(ID "bhi")
(NEWLINE)
(KEYWORD if)
(ID "bhi")
(PUNCT "-")
(ID "blo")
(PUNCT "<")
(ID "ahi")
(PUNCT "-")
(ID "alo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(ID "second")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "-")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "-")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(NEWLINE)
(ID "second")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "g")
(KEYWORD in)
(ID "first")
(PUNCT ",")
(ID "second")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "g")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_fancy_replace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        When replacing one block of lines with another, search the blocks\n        for *similar* lines; the best-matching pair (if any) is used as a\n        synch point, and intraline difference marking is done on the\n        similar pair. Lots of work, but often worth it.\n\n        Example:\n\n        >>> d = Differ()\n        >>> results = d._fancy_replace(['abcDefghiJkl\\n'], 0, 1,\n        ...                            ['abcdefGhijkl\\n'], 0, 1)\n        >>> print(''.join(results), end=\"\")\n        - abcDefghiJkl\n        ?    ^  ^  ^\n        + abcdefGhijkl\n        ?    ^  ^  ^\n        ")
(NEWLINE)
(ID "best_ratio")
(PUNCT ",")
(ID "cutoff")
(PUNCT "=")
(LIT 0.74)
(PUNCT ",")
(LIT 0.75)
(NEWLINE)
(ID "cruncher")
(PUNCT "=")
(ID "SequenceMatcher")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "charjunk")
(PUNCT ")")
(NEWLINE)
(ID "eqi")
(PUNCT ",")
(ID "eqj")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "j")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bj")
(PUNCT "=")
(ID "b")
(PUNCT "[")
(ID "j")
(PUNCT "]")
(NEWLINE)
(ID "cruncher")
(PUNCT ".")
(ID "set_seq2")
(PUNCT "(")
(ID "bj")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ai")
(PUNCT "=")
(ID "a")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "ai")
(PUNCT "==")
(ID "bj")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "eqi")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "eqi")
(PUNCT ",")
(ID "eqj")
(PUNCT "=")
(ID "i")
(PUNCT ",")
(ID "j")
(NEWLINE)
(DEDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "cruncher")
(PUNCT ".")
(ID "set_seq1")
(PUNCT "(")
(ID "ai")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "cruncher")
(PUNCT ".")
(ID "real_quick_ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">")
(ID "best_ratio")
(KEYWORD and)
(ID "cruncher")
(PUNCT ".")
(ID "quick_ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">")
(ID "best_ratio")
(KEYWORD and)
(ID "cruncher")
(PUNCT ".")
(ID "ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">")
(ID "best_ratio")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "best_ratio")
(PUNCT ",")
(ID "best_i")
(PUNCT ",")
(ID "best_j")
(PUNCT "=")
(ID "cruncher")
(PUNCT ".")
(ID "ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "j")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "best_ratio")
(PUNCT "<")
(ID "cutoff")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "eqi")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_plain_replace")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "best_i")
(PUNCT ",")
(ID "best_j")
(PUNCT ",")
(ID "best_ratio")
(PUNCT "=")
(ID "eqi")
(PUNCT ",")
(ID "eqj")
(PUNCT ",")
(LIT 1.0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "eqi")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_fancy_helper")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "best_i")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "best_j")
(PUNCT ")")
(NEWLINE)
(ID "aelt")
(PUNCT ",")
(ID "belt")
(PUNCT "=")
(ID "a")
(PUNCT "[")
(ID "best_i")
(PUNCT "]")
(PUNCT ",")
(ID "b")
(PUNCT "[")
(ID "best_j")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "eqi")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "atags")
(PUNCT "=")
(ID "btags")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "cruncher")
(PUNCT ".")
(ID "set_seqs")
(PUNCT "(")
(ID "aelt")
(PUNCT ",")
(ID "belt")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "ai1")
(PUNCT ",")
(ID "ai2")
(PUNCT ",")
(ID "bj1")
(PUNCT ",")
(ID "bj2")
(KEYWORD in)
(ID "cruncher")
(PUNCT ".")
(ID "get_opcodes")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "la")
(PUNCT ",")
(ID "lb")
(PUNCT "=")
(ID "ai2")
(PUNCT "-")
(ID "ai1")
(PUNCT ",")
(ID "bj2")
(PUNCT "-")
(ID "bj1")
(NEWLINE)
(KEYWORD if)
(ID "tag")
(PUNCT "==")
(LIT "replace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "atags")
(PUNCT "+=")
(LIT "^")
(PUNCT "*")
(ID "la")
(NEWLINE)
(ID "btags")
(PUNCT "+=")
(LIT "^")
(PUNCT "*")
(ID "lb")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(PUNCT "==")
(LIT "delete")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "atags")
(PUNCT "+=")
(LIT "-")
(PUNCT "*")
(ID "la")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(PUNCT "==")
(LIT "insert")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "btags")
(PUNCT "+=")
(LIT "+")
(PUNCT "*")
(ID "lb")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(PUNCT "==")
(LIT "equal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "atags")
(PUNCT "+=")
(LIT " ")
(PUNCT "*")
(ID "la")
(NEWLINE)
(ID "btags")
(PUNCT "+=")
(LIT " ")
(PUNCT "*")
(ID "lb")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown tag %r")
(PUNCT "%")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_qformat")
(PUNCT "(")
(ID "aelt")
(PUNCT ",")
(ID "belt")
(PUNCT ",")
(ID "atags")
(PUNCT ",")
(ID "btags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "  ")
(PUNCT "+")
(ID "aelt")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_fancy_helper")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "best_i")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "best_j")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fancy_helper")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "alo")
(PUNCT "<")
(ID "ahi")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "blo")
(PUNCT "<")
(ID "bhi")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fancy_replace")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "-")
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "alo")
(PUNCT ",")
(ID "ahi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "blo")
(PUNCT "<")
(ID "bhi")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "g")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dump")
(PUNCT "(")
(LIT "+")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "blo")
(PUNCT ",")
(ID "bhi")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "g")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_qformat")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "aline")
(PUNCT ",")
(ID "bline")
(PUNCT ",")
(ID "atags")
(PUNCT ",")
(ID "btags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Format \"?\" output and deal with leading tabs.\n\n        Example:\n\n        >>> d = Differ()\n        >>> results = d._qformat('\\tabcDefghiJkl\\n', '\\tabcdefGhijkl\\n',\n        ...                      '  ^ ^  ^      ', '  ^ ^  ^      ')\n        >>> for line in results: print(repr(line))\n        ...\n        '- \\tabcDefghiJkl\\n'\n        '? \\t ^ ^  ^\\n'\n        '+ \\tabcdefGhijkl\\n'\n        '? \\t ^ ^  ^\\n'\n        ")
(NEWLINE)
(ID "common")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "_count_leading")
(PUNCT "(")
(ID "aline")
(PUNCT ",")
(LIT "\t")
(PUNCT ")")
(PUNCT ",")
(ID "_count_leading")
(PUNCT "(")
(ID "bline")
(PUNCT ",")
(LIT "\t")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "common")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "common")
(PUNCT ",")
(ID "_count_leading")
(PUNCT "(")
(ID "atags")
(PUNCT "[")
(PUNCT ":")
(ID "common")
(PUNCT "]")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "common")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "common")
(PUNCT ",")
(ID "_count_leading")
(PUNCT "(")
(ID "btags")
(PUNCT "[")
(PUNCT ":")
(ID "common")
(PUNCT "]")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "atags")
(PUNCT "=")
(ID "atags")
(PUNCT "[")
(ID "common")
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "btags")
(PUNCT "=")
(ID "btags")
(PUNCT "[")
(ID "common")
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(LIT "- ")
(PUNCT "+")
(ID "aline")
(NEWLINE)
(KEYWORD if)
(ID "atags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "? %s%s\n")
(PUNCT "%")
(PUNCT "(")
(LIT "\t")
(PUNCT "*")
(ID "common")
(PUNCT ",")
(ID "atags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(LIT "+ ")
(PUNCT "+")
(ID "bline")
(NEWLINE)
(KEYWORD if)
(ID "btags")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "? %s%s\n")
(PUNCT "%")
(PUNCT "(")
(LIT "\t")
(PUNCT "*")
(ID "common")
(PUNCT ",")
(ID "btags")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD def)
(ID "IS_LINE_JUNK")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(ID "pat")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\\s*#?\\s*$")
(PUNCT ")")
(PUNCT ".")
(ID "match")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return 1 for ignorable line: iff `line` is blank or contains a single '#'.\n\n    Examples:\n\n    >>> IS_LINE_JUNK('\\n')\n    True\n    >>> IS_LINE_JUNK('  #   \\n')\n    True\n    >>> IS_LINE_JUNK('hello\\n')\n    False\n    ")
(NEWLINE)
(KEYWORD return)
(ID "pat")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "IS_CHARACTER_JUNK")
(PUNCT "(")
(ID "ch")
(PUNCT ",")
(ID "ws")
(PUNCT "=")
(LIT " \t")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return 1 for ignorable character: iff `ch` is a space or tab.\n\n    Examples:\n\n    >>> IS_CHARACTER_JUNK(' ')\n    True\n    >>> IS_CHARACTER_JUNK('\\t')\n    True\n    >>> IS_CHARACTER_JUNK('\\n')\n    False\n    >>> IS_CHARACTER_JUNK('x')\n    False\n    ")
(NEWLINE)
(KEYWORD return)
(ID "ch")
(KEYWORD in)
(ID "ws")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format_range_unified")
(PUNCT "(")
(ID "start")
(PUNCT ",")
(ID "stop")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert range to the \"ed\" format")
(NEWLINE)
(ID "beginning")
(PUNCT "=")
(ID "start")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "length")
(PUNCT "=")
(ID "stop")
(PUNCT "-")
(ID "start")
(NEWLINE)
(KEYWORD if)
(ID "length")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "beginning")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "length")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "beginning")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "{},{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "beginning")
(PUNCT ",")
(ID "length")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "unified_diff")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "fromfile")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "tofile")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "fromfiledate")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "tofiledate")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 3)
(PUNCT ",")
(ID "lineterm")
(PUNCT "=")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Compare two sequences of lines; generate the delta as a unified diff.\n\n    Unified diffs are a compact way of showing line changes and a few\n    lines of context.  The number of context lines is set by 'n' which\n    defaults to three.\n\n    By default, the diff control lines (those with ---, +++, or @@) are\n    created with a trailing newline.  This is helpful so that inputs\n    created from file.readlines() result in diffs that are suitable for\n    file.writelines() since both the inputs and outputs have trailing\n    newlines.\n\n    For inputs that do not have trailing newlines, set the lineterm\n    argument to \"\" so that the output will be uniformly newline free.\n\n    The unidiff format normally has a header for filenames and modification\n    times.  Any or all of these may be specified using strings for\n    'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\n    The modification times are normally expressed in the ISO 8601 format.\n\n    Example:\n\n    >>> for line in unified_diff('one two three four'.split(),\n    ...             'zero one tree four'.split(), 'Original', 'Current',\n    ...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',\n    ...             lineterm=''):\n    ...     print(line)                 # doctest: +NORMALIZE_WHITESPACE\n    --- Original        2005-01-26 23:30:50\n    +++ Current         2010-04-02 10:20:52\n    @@ -1,4 +1,4 @@\n    +zero\n     one\n    -two\n    -three\n    +tree\n     four\n    ")
(NEWLINE)
(ID "started")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD for)
(ID "group")
(KEYWORD in)
(ID "SequenceMatcher")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ".")
(ID "get_grouped_opcodes")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "started")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "started")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "fromdate")
(PUNCT "=")
(LIT "\t{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fromfiledate")
(PUNCT ")")
(KEYWORD if)
(ID "fromfiledate")
(KEYWORD else)
(LIT "")
(NEWLINE)
(ID "todate")
(PUNCT "=")
(LIT "\t{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "tofiledate")
(PUNCT ")")
(KEYWORD if)
(ID "tofiledate")
(KEYWORD else)
(LIT "")
(NEWLINE)
(KEYWORD yield)
(LIT "--- {}{}{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fromfile")
(PUNCT ",")
(ID "fromdate")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(LIT "+++ {}{}{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "tofile")
(PUNCT ",")
(ID "todate")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT "=")
(ID "group")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "group")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "file1_range")
(PUNCT "=")
(ID "_format_range_unified")
(PUNCT "(")
(ID "first")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "last")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "file2_range")
(PUNCT "=")
(ID "_format_range_unified")
(PUNCT "(")
(ID "first")
(PUNCT "[")
(LIT 3)
(PUNCT "]")
(PUNCT ",")
(ID "last")
(PUNCT "[")
(LIT 4)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(LIT "@@ -{} +{} @@{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "file1_range")
(PUNCT ",")
(ID "file2_range")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "j2")
(KEYWORD in)
(ID "group")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT "==")
(LIT "equal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "a")
(PUNCT "[")
(ID "i1")
(PUNCT ":")
(ID "i2")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT " ")
(PUNCT "+")
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "tag")
(KEYWORD in)
(PUNCT "{")
(LIT "replace")
(PUNCT ",")
(LIT "delete")
(PUNCT "}")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "a")
(PUNCT "[")
(ID "i1")
(PUNCT ":")
(ID "i2")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "-")
(PUNCT "+")
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "tag")
(KEYWORD in)
(PUNCT "{")
(LIT "replace")
(PUNCT ",")
(LIT "insert")
(PUNCT "}")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "b")
(PUNCT "[")
(ID "j1")
(PUNCT ":")
(ID "j2")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT "+")
(PUNCT "+")
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_format_range_context")
(PUNCT "(")
(ID "start")
(PUNCT ",")
(ID "stop")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert range to the \"ed\" format")
(NEWLINE)
(ID "beginning")
(PUNCT "=")
(ID "start")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(ID "length")
(PUNCT "=")
(ID "stop")
(PUNCT "-")
(ID "start")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "length")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "beginning")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "length")
(PUNCT "<=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "beginning")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "{},{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "beginning")
(PUNCT ",")
(ID "beginning")
(PUNCT "+")
(ID "length")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "context_diff")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "fromfile")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "tofile")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "fromfiledate")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "tofiledate")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 3)
(PUNCT ",")
(ID "lineterm")
(PUNCT "=")
(LIT "\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Compare two sequences of lines; generate the delta as a context diff.\n\n    Context diffs are a compact way of showing line changes and a few\n    lines of context.  The number of context lines is set by 'n' which\n    defaults to three.\n\n    By default, the diff control lines (those with *** or ---) are\n    created with a trailing newline.  This is helpful so that inputs\n    created from file.readlines() result in diffs that are suitable for\n    file.writelines() since both the inputs and outputs have trailing\n    newlines.\n\n    For inputs that do not have trailing newlines, set the lineterm\n    argument to \"\" so that the output will be uniformly newline free.\n\n    The context diff format normally has a header for filenames and\n    modification times.  Any or all of these may be specified using\n    strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\n    The modification times are normally expressed in the ISO 8601 format.\n    If not specified, the strings default to blanks.\n\n    Example:\n\n    >>> print(''.join(context_diff('one\\ntwo\\nthree\\nfour\\n'.splitlines(True),\n    ...       'zero\\none\\ntree\\nfour\\n'.splitlines(True), 'Original', 'Current')),\n    ...       end=\"\")\n    *** Original\n    --- Current\n    ***************\n    *** 1,4 ****\n      one\n    ! two\n    ! three\n      four\n    --- 1,4 ----\n    + zero\n      one\n    ! tree\n      four\n    ")
(NEWLINE)
(ID "prefix")
(PUNCT "=")
(ID "dict")
(PUNCT "(")
(ID "insert")
(PUNCT "=")
(LIT "+ ")
(PUNCT ",")
(ID "delete")
(PUNCT "=")
(LIT "- ")
(PUNCT ",")
(ID "replace")
(PUNCT "=")
(LIT "! ")
(PUNCT ",")
(ID "equal")
(PUNCT "=")
(LIT "  ")
(PUNCT ")")
(NEWLINE)
(ID "started")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD for)
(ID "group")
(KEYWORD in)
(ID "SequenceMatcher")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ".")
(ID "get_grouped_opcodes")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "started")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "started")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "fromdate")
(PUNCT "=")
(LIT "\t{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fromfiledate")
(PUNCT ")")
(KEYWORD if)
(ID "fromfiledate")
(KEYWORD else)
(LIT "")
(NEWLINE)
(ID "todate")
(PUNCT "=")
(LIT "\t{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "tofiledate")
(PUNCT ")")
(KEYWORD if)
(ID "tofiledate")
(KEYWORD else)
(LIT "")
(NEWLINE)
(KEYWORD yield)
(LIT "*** {}{}{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fromfile")
(PUNCT ",")
(ID "fromdate")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(LIT "--- {}{}{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "tofile")
(PUNCT ",")
(ID "todate")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT "=")
(ID "group")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "group")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD yield)
(LIT "***************")
(PUNCT "+")
(ID "lineterm")
(NEWLINE)
(ID "file1_range")
(PUNCT "=")
(ID "_format_range_context")
(PUNCT "(")
(ID "first")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "last")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(LIT "*** {} ****{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "file1_range")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(ID "tag")
(KEYWORD in)
(PUNCT "{")
(LIT "replace")
(PUNCT ",")
(LIT "delete")
(PUNCT "}")
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(KEYWORD in)
(ID "group")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "i1")
(PUNCT ",")
(ID "i2")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(KEYWORD in)
(ID "group")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT "!=")
(LIT "insert")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "a")
(PUNCT "[")
(ID "i1")
(PUNCT ":")
(ID "i2")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "prefix")
(PUNCT "[")
(ID "tag")
(PUNCT "]")
(PUNCT "+")
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "file2_range")
(PUNCT "=")
(ID "_format_range_context")
(PUNCT "(")
(ID "first")
(PUNCT "[")
(LIT 3)
(PUNCT "]")
(PUNCT ",")
(ID "last")
(PUNCT "[")
(LIT 4)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(LIT "--- {} ----{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "file2_range")
(PUNCT ",")
(ID "lineterm")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "any")
(PUNCT "(")
(ID "tag")
(KEYWORD in)
(PUNCT "{")
(LIT "replace")
(PUNCT ",")
(LIT "insert")
(PUNCT "}")
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(KEYWORD in)
(ID "group")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "tag")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "j1")
(PUNCT ",")
(ID "j2")
(KEYWORD in)
(ID "group")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT "!=")
(LIT "delete")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "b")
(PUNCT "[")
(ID "j1")
(PUNCT ":")
(ID "j2")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "prefix")
(PUNCT "[")
(ID "tag")
(PUNCT "]")
(PUNCT "+")
(ID "line")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "ndiff")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ",")
(ID "linejunk")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "charjunk")
(PUNCT "=")
(ID "IS_CHARACTER_JUNK")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Compare `a` and `b` (lists of strings); return a `Differ`-style delta.\n\n    Optional keyword parameters `linejunk` and `charjunk` are for filter\n    functions (or None):\n\n    - linejunk: A function that should accept a single string argument, and\n      return true iff the string is junk.  The default is None, and is\n      recommended; as of Python 2.3, an adaptive notion of \"noise\" lines is\n      used that does a good job on its own.\n\n    - charjunk: A function that should accept a string of length 1. The\n      default is module-level function IS_CHARACTER_JUNK, which filters out\n      whitespace characters (a blank or tab; note: bad idea to include newline\n      in this!).\n\n    Tools/scripts/ndiff.py is a command-line front-end to this function.\n\n    Example:\n\n    >>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n    ...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n    >>> print(''.join(diff), end=\"\")\n    - one\n    ?  ^\n    + ore\n    ?  ^\n    - two\n    - three\n    ?  -\n    + tree\n    + emu\n    ")
(NEWLINE)
(KEYWORD return)
(ID "Differ")
(PUNCT "(")
(ID "linejunk")
(PUNCT ",")
(ID "charjunk")
(PUNCT ")")
(PUNCT ".")
(ID "compare")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_mdiff")
(PUNCT "(")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "linejunk")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "charjunk")
(PUNCT "=")
(ID "IS_CHARACTER_JUNK")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns generator yielding marked up from/to side by side differences.\n\n    Arguments:\n    fromlines -- list of text lines to compared to tolines\n    tolines -- list of text lines to be compared to fromlines\n    context -- number of context lines to display on each side of difference,\n               if None, all from/to text lines will be generated.\n    linejunk -- passed on to ndiff (see ndiff documentation)\n    charjunk -- passed on to ndiff (see ndiff documentation)\n\n    This function returns an iterator which returns a tuple:\n    (from line tuple, to line tuple, boolean flag)\n\n    from/to line tuple -- (line num, line text)\n        line num -- integer or None (to indicate a context separation)\n        line text -- original line text with following markers inserted:\n            '\\0+' -- marks start of added text\n            '\\0-' -- marks start of deleted text\n            '\\0^' -- marks start of changed text\n            '\\1' -- marks end of added/deleted/changed text\n\n    boolean flag -- None indicates context separation, True indicates\n        either \"from\" or \"to\" line contains a change, otherwise False.\n\n    This function/iterator was originally developed to generate side by side\n    file difference for making HTML pages (see HtmlDiff class for example\n    usage).\n\n    Note, this function utilizes the ndiff function to generate the side by\n    side difference markup.  Optional ndiff arguments may be passed to this\n    function and they in turn will be passed to ndiff.\n    ")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(ID "change_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "(\\++|\\-+|\\^+)")
(PUNCT ")")
(NEWLINE)
(ID "diff_lines_iterator")
(PUNCT "=")
(ID "ndiff")
(PUNCT "(")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ",")
(ID "linejunk")
(PUNCT ",")
(ID "charjunk")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(ID "format_key")
(PUNCT ",")
(ID "side")
(PUNCT ",")
(ID "num_lines")
(PUNCT "=")
(PUNCT "[")
(LIT 0)
(PUNCT ",")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns line of text with user's change markup and line formatting.\n\n        lines -- list of lines from the ndiff generator to produce a line of\n                 text from.  When producing the line of text to return, the\n                 lines used are removed from this list.\n        format_key -- '+' return first line in list with \"add\" markup around\n                          the entire line.\n                      '-' return first line in list with \"delete\" markup around\n                          the entire line.\n                      '?' return first line in list with add/delete/change\n                          intraline markup (indices obtained from second line)\n                      None return first line in list with no markup\n        side -- indice into the num_lines list (0=from,1=to)\n        num_lines -- from/to current line number.  This is NOT intended to be a\n                     passed parameter.  It is present as a keyword argument to\n                     maintain memory of the current line numbers between calls\n                     of this function.\n\n        Note, this function is purposefully not defined at the module scope so\n        that data it needs from its parent function (within whose context it\n        is defined) does not need to be of module scope.\n        ")
(NEWLINE)
(ID "num_lines")
(PUNCT "[")
(ID "side")
(PUNCT "]")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "format_key")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "num_lines")
(PUNCT "[")
(ID "side")
(PUNCT "]")
(PUNCT ",")
(ID "lines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "format_key")
(PUNCT "==")
(LIT "?")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT ",")
(ID "markers")
(PUNCT "=")
(ID "lines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "lines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "sub_info")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "record_sub_info")
(PUNCT "(")
(ID "match_object")
(PUNCT ",")
(ID "sub_info")
(PUNCT "=")
(ID "sub_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sub_info")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "[")
(ID "match_object")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "match_object")
(PUNCT ".")
(ID "span")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "match_object")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "change_re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(ID "record_sub_info")
(PUNCT ",")
(ID "markers")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(PUNCT "(")
(ID "begin")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(KEYWORD in)
(ID "sub_info")
(PUNCT "[")
(PUNCT ":")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT "[")
(LIT 0)
(PUNCT ":")
(ID "begin")
(PUNCT "]")
(PUNCT "+")
(LIT "\u0000")
(PUNCT "+")
(ID "key")
(PUNCT "+")
(ID "text")
(PUNCT "[")
(ID "begin")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(PUNCT "+")
(LIT "\u0001")
(PUNCT "+")
(ID "text")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "lines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(LIT " ")
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT "=")
(LIT "\u0000")
(PUNCT "+")
(ID "format_key")
(PUNCT "+")
(ID "text")
(PUNCT "+")
(LIT "\u0001")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "num_lines")
(PUNCT "[")
(ID "side")
(PUNCT "]")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_line_iterator")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Yields from/to lines of text with a change indication.\n\n        This function is an iterator.  It itself pulls lines from a\n        differencing iterator, processes them and yields them.  When it can\n        it yields both a \"from\" and a \"to\" line, otherwise it will yield one\n        or the other.  In addition to yielding the lines of from/to text, a\n        boolean flag is yielded to indicate if the text line(s) have\n        differences in them.\n\n        Note, this function is purposefully not defined at the module scope so\n        that data it needs from its parent function (within whose context it\n        is defined) does not need to be of module scope.\n        ")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "num_blanks_pending")
(PUNCT ",")
(ID "num_blanks_to_yield")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "len")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT "<")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "next")
(PUNCT "(")
(ID "diff_lines_iterator")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "X")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "s")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "line")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "lines")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "X")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_to_yield")
(PUNCT "=")
(ID "num_blanks_pending")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "-?+?")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "?")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "?")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "--++")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_pending")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "-")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(PUNCT "(")
(LIT "--?+")
(PUNCT ",")
(LIT "--+")
(PUNCT ",")
(LIT "- ")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT "=")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "-")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(ID "num_blanks_to_yield")
(PUNCT ",")
(ID "num_blanks_pending")
(PUNCT "=")
(ID "num_blanks_pending")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "-+?")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "?")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "-?+")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "?")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "-")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_pending")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "-")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "+--")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_pending")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(KEYWORD None)
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "+")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(PUNCT "(")
(LIT "+ ")
(PUNCT ",")
(LIT "+-")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "+")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "num_blanks_to_yield")
(PUNCT ",")
(ID "num_blanks_pending")
(PUNCT "=")
(ID "num_blanks_pending")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "+")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_pending")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(KEYWORD None)
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(LIT "+")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT " ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ",")
(ID "_make_line")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT ",")
(KEYWORD False)
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(PUNCT "(")
(ID "num_blanks_to_yield")
(PUNCT "<")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_to_yield")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(KEYWORD None)
(PUNCT ",")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(PUNCT "(")
(ID "num_blanks_to_yield")
(PUNCT ">")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "num_blanks_to_yield")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(PUNCT "(")
(LIT "")
(PUNCT ",")
(LIT "\n")
(PUNCT ")")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "s")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "X")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_line_pair_iterator")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Yields from/to lines of text with a change indication.\n\n        This function is an iterator.  It itself pulls lines from the line\n        iterator.  Its difference from that iterator is that this function\n        always yields a pair of from/to text lines (with the change\n        indication).  If necessary it will collect single from/to lines\n        until it has a matching pair from/to pair to yield.\n\n        Note, this function is purposefully not defined at the module scope so\n        that data it needs from its parent function (within whose context it\n        is defined) does not need to be of module scope.\n        ")
(NEWLINE)
(ID "line_iterator")
(PUNCT "=")
(ID "_line_iterator")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "fromlines")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "tolines")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(ID "found_diff")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "line_iterator")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "from_line")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromlines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "from_line")
(PUNCT ",")
(ID "found_diff")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "to_line")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tolines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "to_line")
(PUNCT ",")
(ID "found_diff")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "from_line")
(PUNCT ",")
(ID "fromDiff")
(PUNCT "=")
(ID "fromlines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "to_line")
(PUNCT ",")
(ID "to_diff")
(PUNCT "=")
(ID "tolines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(PUNCT "(")
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(ID "fromDiff")
(KEYWORD or)
(ID "to_diff")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "line_pair_iterator")
(PUNCT "=")
(ID "_line_pair_iterator")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "next")
(PUNCT "(")
(ID "line_pair_iterator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "lines_to_write")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "index")
(PUNCT ",")
(ID "contextLines")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(PUNCT "[")
(KEYWORD None)
(PUNCT "]")
(PUNCT "*")
(PUNCT "(")
(ID "context")
(PUNCT ")")
(NEWLINE)
(ID "found_diff")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD while)
(PUNCT "(")
(ID "found_diff")
(KEYWORD is)
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(ID "found_diff")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "line_pair_iterator")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "index")
(PUNCT "%")
(ID "context")
(NEWLINE)
(ID "contextLines")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(ID "found_diff")
(PUNCT ")")
(NEWLINE)
(ID "index")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "index")
(PUNCT ">")
(ID "context")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(NEWLINE)
(ID "lines_to_write")
(PUNCT "=")
(ID "context")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines_to_write")
(PUNCT "=")
(ID "index")
(NEWLINE)
(ID "index")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(PUNCT "(")
(ID "lines_to_write")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "index")
(PUNCT "%")
(ID "context")
(NEWLINE)
(ID "index")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "contextLines")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "lines_to_write")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "lines_to_write")
(PUNCT "=")
(ID "context")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD while)
(PUNCT "(")
(ID "lines_to_write")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(ID "found_diff")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "line_pair_iterator")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "found_diff")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines_to_write")
(PUNCT "=")
(ID "context")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines_to_write")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "from_line")
(PUNCT ",")
(ID "to_line")
(PUNCT ",")
(ID "found_diff")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "_file_template")
(PUNCT "=")
(LIT "\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n<html>\n\n<head>\n    <meta http-equiv=\"Content-Type\"\n          content=\"text/html; charset=ISO-8859-1\" />\n    <title></title>\n    <style type=\"text/css\">%(styles)s\n    </style>\n</head>\n\n<body>\n    %(table)s%(legend)s\n</body>\n\n</html>")
(NEWLINE)
(ID "_styles")
(PUNCT "=")
(LIT "\n        table.diff {font-family:Courier; border:medium;}\n        .diff_header {background-color:#e0e0e0}\n        td.diff_header {text-align:right}\n        .diff_next {background-color:#c0c0c0}\n        .diff_add {background-color:#aaffaa}\n        .diff_chg {background-color:#ffff77}\n        .diff_sub {background-color:#ffaaaa}")
(NEWLINE)
(ID "_table_template")
(PUNCT "=")
(LIT "\n    <table class=\"diff\" id=\"difflib_chg_%(prefix)s_top\"\n           cellspacing=\"0\" cellpadding=\"0\" rules=\"groups\" >\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        %(header_row)s\n        <tbody>\n%(data_rows)s        </tbody>\n    </table>")
(NEWLINE)
(ID "_legend")
(PUNCT "=")
(LIT "\n    <table class=\"diff\" summary=\"Legends\">\n        <tr> <th colspan=\"2\"> Legends </th> </tr>\n        <tr> <td> <table border=\"\" summary=\"Colors\">\n                      <tr><th> Colors </th> </tr>\n                      <tr><td class=\"diff_add\">&nbsp;Added&nbsp;</td></tr>\n                      <tr><td class=\"diff_chg\">Changed</td> </tr>\n                      <tr><td class=\"diff_sub\">Deleted</td> </tr>\n                  </table></td>\n             <td> <table border=\"\" summary=\"Links\">\n                      <tr><th colspan=\"2\"> Links </th> </tr>\n                      <tr><td>(f)irst change</td> </tr>\n                      <tr><td>(n)ext change</td> </tr>\n                      <tr><td>(t)op</td> </tr>\n                  </table></td> </tr>\n    </table>")
(NEWLINE)
(KEYWORD class)
(ID "HtmlDiff")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "For producing HTML side by side comparison with change highlights.\n\n    This class can be used to create an HTML table (or a complete HTML file\n    containing the table) showing a side by side, line by line comparison\n    of text with inter-line and intra-line change highlights.  The table can\n    be generated in either full or contextual difference mode.\n\n    The following methods are provided for HTML generation:\n\n    make_table -- generates HTML for a single side by side table\n    make_file -- generates complete HTML file with a single side by side table\n\n    See tools/scripts/diff.py for an example usage of this class.\n    ")
(NEWLINE)
(ID "_file_template")
(PUNCT "=")
(ID "_file_template")
(NEWLINE)
(ID "_styles")
(PUNCT "=")
(ID "_styles")
(NEWLINE)
(ID "_table_template")
(PUNCT "=")
(ID "_table_template")
(NEWLINE)
(ID "_legend")
(PUNCT "=")
(ID "_legend")
(NEWLINE)
(ID "_default_prefix")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tabsize")
(PUNCT "=")
(LIT 8)
(PUNCT ",")
(ID "wrapcolumn")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "linejunk")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "charjunk")
(PUNCT "=")
(ID "IS_CHARACTER_JUNK")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "HtmlDiff instance initializer\n\n        Arguments:\n        tabsize -- tab stop spacing, defaults to 8.\n        wrapcolumn -- column number where lines are broken and wrapped,\n            defaults to None where lines are not wrapped.\n        linejunk,charjunk -- keyword arguments passed into ndiff() (used to by\n            HtmlDiff() to generate the side by side HTML differences).  See\n            ndiff() documentation for argument default values and descriptions.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tabsize")
(PUNCT "=")
(ID "tabsize")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_wrapcolumn")
(PUNCT "=")
(ID "wrapcolumn")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_linejunk")
(PUNCT "=")
(ID "linejunk")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_charjunk")
(PUNCT "=")
(ID "charjunk")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "make_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ",")
(ID "fromdesc")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "todesc")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "numlines")
(PUNCT "=")
(LIT 5)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns HTML file of side by side comparison with change highlights\n\n        Arguments:\n        fromlines -- list of \"from\" lines\n        tolines -- list of \"to\" lines\n        fromdesc -- \"from\" file column header string\n        todesc -- \"to\" file column header string\n        context -- set to True for contextual differences (defaults to False\n            which shows full differences).\n        numlines -- number of context lines.  When context is set True,\n            controls number of lines displayed before and after the change.\n            When context is False, controls the number of lines to place\n            the \"next\" link anchors before the next change (so click of\n            \"next\" link jumps to just before the change).\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_file_template")
(PUNCT "%")
(ID "dict")
(PUNCT "(")
(ID "styles")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_styles")
(PUNCT ",")
(ID "legend")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_legend")
(PUNCT ",")
(ID "table")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "make_table")
(PUNCT "(")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ",")
(ID "fromdesc")
(PUNCT ",")
(ID "todesc")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ",")
(ID "numlines")
(PUNCT "=")
(ID "numlines")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_tab_newline_replace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns from/to line lists with tabs expanded and newlines removed.\n\n        Instead of tab characters being replaced by the number of spaces\n        needed to fill in to the next tab stop, this function will fill\n        the space with tab characters.  This is done so that the difference\n        algorithms can identify changes in a file when tabs are replaced by\n        spaces and vice versa.  At the end of the HTML generation, the tab\n        characters will be replaced with a nonbreakable space.\n        ")
(NEWLINE)
(KEYWORD def)
(ID "expand_tabs")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT "\u0000")
(PUNCT ")")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "expandtabs")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_tabsize")
(PUNCT ")")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT "\t")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "line")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\u0000")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fromlines")
(PUNCT "=")
(PUNCT "[")
(ID "expand_tabs")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "fromlines")
(PUNCT "]")
(NEWLINE)
(ID "tolines")
(PUNCT "=")
(PUNCT "[")
(ID "expand_tabs")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "tolines")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_split_line")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data_list")
(PUNCT ",")
(ID "line_num")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Builds list of text lines by splitting text lines at wrap point\n\n        This function will determine if the input text line needs to be\n        wrapped (split) into separate lines.  If so, the first wrap point\n        will be determined and the first line appended to the output\n        text line list.  This function is used recursively to handle\n        the second part of the split line to further split it.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line_num")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data_list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "line_num")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "size")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(ID "max")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_wrapcolumn")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "size")
(PUNCT "<=")
(ID "max")
(PUNCT ")")
(KEYWORD or)
(PUNCT "(")
(PUNCT "(")
(ID "size")
(PUNCT "-")
(PUNCT "(")
(ID "text")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\u0000")
(PUNCT ")")
(PUNCT "*")
(LIT 3)
(PUNCT ")")
(PUNCT ")")
(PUNCT "<=")
(ID "max")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data_list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "line_num")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "n")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "mark")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD while)
(ID "n")
(PUNCT "<")
(ID "max")
(KEYWORD and)
(ID "i")
(PUNCT "<")
(ID "size")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "text")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "==")
(LIT "\u0000")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "mark")
(PUNCT "=")
(ID "text")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "text")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "==")
(LIT "\u0001")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "mark")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "n")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "line1")
(PUNCT "=")
(ID "text")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "line2")
(PUNCT "=")
(ID "text")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "mark")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line1")
(PUNCT "=")
(ID "line1")
(PUNCT "+")
(LIT "\u0001")
(NEWLINE)
(ID "line2")
(PUNCT "=")
(LIT "\u0000")
(PUNCT "+")
(ID "mark")
(PUNCT "+")
(ID "line2")
(NEWLINE)
(DEDENT)
(ID "data_list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "line_num")
(PUNCT ",")
(ID "line1")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_split_line")
(PUNCT "(")
(ID "data_list")
(PUNCT ",")
(LIT ">")
(PUNCT ",")
(ID "line2")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_line_wrapper")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "diffs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns iterator that splits (wraps) mdiff text lines")
(NEWLINE)
(KEYWORD for)
(ID "fromdata")
(PUNCT ",")
(ID "todata")
(PUNCT ",")
(ID "flag")
(KEYWORD in)
(ID "diffs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "flag")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "fromdata")
(PUNCT ",")
(ID "todata")
(PUNCT ",")
(ID "flag")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "fromline")
(PUNCT ",")
(ID "fromtext")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "toline")
(PUNCT ",")
(ID "totext")
(PUNCT ")")
(PUNCT "=")
(ID "fromdata")
(PUNCT ",")
(ID "todata")
(NEWLINE)
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_split_line")
(PUNCT "(")
(ID "fromlist")
(PUNCT ",")
(ID "fromline")
(PUNCT ",")
(ID "fromtext")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_split_line")
(PUNCT "(")
(ID "tolist")
(PUNCT ",")
(ID "toline")
(PUNCT ",")
(ID "totext")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "fromlist")
(KEYWORD or)
(ID "tolist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fromlist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromdata")
(PUNCT "=")
(ID "fromlist")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromdata")
(PUNCT "=")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "tolist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "todata")
(PUNCT "=")
(ID "tolist")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "todata")
(PUNCT "=")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "fromdata")
(PUNCT ",")
(ID "todata")
(PUNCT ",")
(ID "flag")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_collect_lines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "diffs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Collects mdiff output into separate lists\n\n        Before storing the mdiff from/to data into a list, it is converted\n        into a single line of text with HTML markup.\n        ")
(NEWLINE)
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "fromdata")
(PUNCT ",")
(ID "todata")
(PUNCT ",")
(ID "flag")
(KEYWORD in)
(ID "diffs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromlist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_format_line")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "flag")
(PUNCT ",")
(PUNCT "*")
(ID "fromdata")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "tolist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_format_line")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "flag")
(PUNCT ",")
(PUNCT "*")
(ID "todata")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromlist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "tolist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "flaglist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "flag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format_line")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "side")
(PUNCT ",")
(ID "flag")
(PUNCT ",")
(ID "linenum")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns HTML markup of \"from\" / \"to\" text lines\n\n        side -- 0 or 1 indicating \"from\" or \"to\" text\n        flag -- indicates if difference on line\n        linenum -- line number (used for line number column)\n        text -- line text to be marked up\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "linenum")
(PUNCT "=")
(LIT "%d")
(PUNCT "%")
(ID "linenum")
(NEWLINE)
(ID "id")
(PUNCT "=")
(LIT " id=\"%s%s\"")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT "[")
(ID "side")
(PUNCT "]")
(PUNCT ",")
(ID "linenum")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "id")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "&")
(PUNCT ",")
(LIT "&amp;")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ">")
(PUNCT ",")
(LIT "&gt;")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "<")
(PUNCT ",")
(LIT "&lt;")
(PUNCT ")")
(NEWLINE)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT "&nbsp;")
(PUNCT ")")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "<td class=\"diff_header\"%s>%s</td><td nowrap=\"nowrap\">%s</td>")
(PUNCT "%")
(PUNCT "(")
(ID "id")
(PUNCT ",")
(ID "linenum")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_make_prefix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create unique anchor prefixes")
(NEWLINE)
(ID "fromprefix")
(PUNCT "=")
(LIT "from%d_")
(PUNCT "%")
(ID "HtmlDiff")
(PUNCT ".")
(ID "_default_prefix")
(NEWLINE)
(ID "toprefix")
(PUNCT "=")
(LIT "to%d_")
(PUNCT "%")
(ID "HtmlDiff")
(PUNCT ".")
(ID "_default_prefix")
(NEWLINE)
(ID "HtmlDiff")
(PUNCT ".")
(ID "_default_prefix")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT "=")
(PUNCT "[")
(ID "fromprefix")
(PUNCT ",")
(ID "toprefix")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_convert_flags")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(ID "numlines")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Makes list of \"next\" links")
(NEWLINE)
(ID "toprefix")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "next_id")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "flaglist")
(PUNCT ")")
(NEWLINE)
(ID "next_href")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "flaglist")
(PUNCT ")")
(NEWLINE)
(ID "num_chg")
(PUNCT ",")
(ID "in_change")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(KEYWORD False)
(NEWLINE)
(ID "last")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "flag")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "flaglist")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "flag")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "in_change")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "in_change")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "last")
(PUNCT "=")
(ID "i")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(PUNCT "[")
(LIT 0)
(PUNCT ",")
(ID "i")
(PUNCT "-")
(ID "numlines")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "next_id")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "=")
(LIT " id=\"difflib_chg_%s_%d\"")
(PUNCT "%")
(PUNCT "(")
(ID "toprefix")
(PUNCT ",")
(ID "num_chg")
(PUNCT ")")
(NEWLINE)
(ID "num_chg")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "next_href")
(PUNCT "[")
(ID "last")
(PUNCT "]")
(PUNCT "=")
(LIT "<a href=\"#difflib_chg_%s_%d\">n</a>")
(PUNCT "%")
(PUNCT "(")
(ID "toprefix")
(PUNCT ",")
(ID "num_chg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "in_change")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "flaglist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "flaglist")
(PUNCT "=")
(PUNCT "[")
(KEYWORD False)
(PUNCT "]")
(NEWLINE)
(ID "next_id")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(NEWLINE)
(ID "next_href")
(PUNCT "=")
(PUNCT "[")
(LIT "")
(PUNCT "]")
(NEWLINE)
(ID "last")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "context")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromlist")
(PUNCT "=")
(PUNCT "[")
(LIT "<td></td><td>&nbsp;No Differences Found&nbsp;</td>")
(PUNCT "]")
(NEWLINE)
(ID "tolist")
(PUNCT "=")
(ID "fromlist")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fromlist")
(PUNCT "=")
(ID "tolist")
(PUNCT "=")
(PUNCT "[")
(LIT "<td></td><td>&nbsp;Empty File&nbsp;</td>")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "flaglist")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "next_href")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(LIT "<a href=\"#difflib_chg_%s_0\">f</a>")
(PUNCT "%")
(ID "toprefix")
(NEWLINE)
(DEDENT)
(ID "next_href")
(PUNCT "[")
(ID "last")
(PUNCT "]")
(PUNCT "=")
(LIT "<a href=\"#difflib_chg_%s_top\">t</a>")
(PUNCT "%")
(PUNCT "(")
(ID "toprefix")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(PUNCT ",")
(ID "next_href")
(PUNCT ",")
(ID "next_id")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "make_table")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ",")
(ID "fromdesc")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "todesc")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "numlines")
(PUNCT "=")
(LIT 5)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns HTML table of side by side comparison with change highlights\n\n        Arguments:\n        fromlines -- list of \"from\" lines\n        tolines -- list of \"to\" lines\n        fromdesc -- \"from\" file column header string\n        todesc -- \"to\" file column header string\n        context -- set to True for contextual differences (defaults to False\n            which shows full differences).\n        numlines -- number of context lines.  When context is set True,\n            controls number of lines displayed before and after the change.\n            When context is False, controls the number of lines to place\n            the \"next\" link anchors before the next change (so click of\n            \"next\" link jumps to just before the change).\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_make_prefix")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_tab_newline_replace")
(PUNCT "(")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "context")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context_lines")
(PUNCT "=")
(ID "numlines")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "context_lines")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "diffs")
(PUNCT "=")
(ID "_mdiff")
(PUNCT "(")
(ID "fromlines")
(PUNCT ",")
(ID "tolines")
(PUNCT ",")
(ID "context_lines")
(PUNCT ",")
(ID "linejunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_linejunk")
(PUNCT ",")
(ID "charjunk")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_charjunk")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_wrapcolumn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "diffs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_line_wrapper")
(PUNCT "(")
(ID "diffs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_collect_lines")
(PUNCT "(")
(ID "diffs")
(PUNCT ")")
(NEWLINE)
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(PUNCT ",")
(ID "next_href")
(PUNCT ",")
(ID "next_id")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_convert_flags")
(PUNCT "(")
(ID "fromlist")
(PUNCT ",")
(ID "tolist")
(PUNCT ",")
(ID "flaglist")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(ID "numlines")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "fmt")
(PUNCT "=")
(LIT "            <tr><td class=\"diff_next\"%s>%s</td>%s")
(PUNCT "+")
(LIT "<td class=\"diff_next\">%s</td>%s</tr>\n")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "flaglist")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "flaglist")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "i")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "        </tbody>        \n        <tbody>\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fmt")
(PUNCT "%")
(PUNCT "(")
(ID "next_id")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "next_href")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "fromlist")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "next_href")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(ID "tolist")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "fromdesc")
(KEYWORD or)
(ID "todesc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "header_row")
(PUNCT "=")
(LIT "<thead><tr>%s%s%s%s</tr></thead>")
(PUNCT "%")
(PUNCT "(")
(LIT "<th class=\"diff_next\"><br /></th>")
(PUNCT ",")
(LIT "<th colspan=\"2\" class=\"diff_header\">%s</th>")
(PUNCT "%")
(ID "fromdesc")
(PUNCT ",")
(LIT "<th class=\"diff_next\"><br /></th>")
(PUNCT ",")
(LIT "<th colspan=\"2\" class=\"diff_header\">%s</th>")
(PUNCT "%")
(ID "todesc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "header_row")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "table")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_table_template")
(PUNCT "%")
(ID "dict")
(PUNCT "(")
(ID "data_rows")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ",")
(ID "header_row")
(PUNCT "=")
(ID "header_row")
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "table")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\u0000+")
(PUNCT ",")
(LIT "<span class=\"diff_add\">")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\u0000-")
(PUNCT ",")
(LIT "<span class=\"diff_sub\">")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\u0000^")
(PUNCT ",")
(LIT "<span class=\"diff_chg\">")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\u0001")
(PUNCT ",")
(LIT "</span>")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\t")
(PUNCT ",")
(LIT "&nbsp;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD del)
(ID "re")
(NEWLINE)
(KEYWORD def)
(ID "restore")
(PUNCT "(")
(ID "delta")
(PUNCT ",")
(ID "which")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Generate one of the two sequences that generated a delta.\n\n    Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract\n    lines originating from file 1 or 2 (parameter `which`), stripping off line\n    prefixes.\n\n    Examples:\n\n    >>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n    ...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n    >>> diff = list(diff)\n    >>> print(''.join(restore(diff, 1)), end=\"\")\n    one\n    two\n    three\n    >>> print(''.join(restore(diff, 2)), end=\"\")\n    ore\n    tree\n    emu\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(PUNCT "{")
(LIT 1)
(PUNCT ":")
(LIT "- ")
(PUNCT ",")
(LIT 2)
(PUNCT ":")
(LIT "+ ")
(PUNCT "}")
(PUNCT "[")
(ID "int")
(PUNCT "(")
(ID "which")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown delta choice (must be 1 or 2): %r")
(PUNCT "%")
(ID "which")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "prefixes")
(PUNCT "=")
(PUNCT "(")
(LIT "  ")
(PUNCT ",")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "delta")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(KEYWORD in)
(ID "prefixes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "line")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "doctest")
(PUNCT ",")
(ID "difflib")
(NEWLINE)
(KEYWORD return)
(ID "doctest")
(PUNCT ".")
(ID "testmod")
(PUNCT "(")
(ID "difflib")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
