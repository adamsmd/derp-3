(LIT "Support module for CGI (Common Gateway Interface) scripts.\n\nThis module defines a number of utilities for use by CGI scripts\nwritten in Python.\n")
(NEWLINE)
(ID "__version__")
(PUNCT "=")
(LIT "2.6")
(NEWLINE)
(KEYWORD from)
(ID "io")
(KEYWORD import)
(ID "StringIO")
(PUNCT ",")
(ID "BytesIO")
(PUNCT ",")
(ID "TextIOWrapper")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "Mapping")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "urllib")
(PUNCT ".")
(ID "parse")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "parser")
(KEYWORD import)
(ID "FeedParser")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "message")
(KEYWORD import)
(ID "Message")
(NEWLINE)
(KEYWORD from)
(ID "warnings")
(KEYWORD import)
(ID "warn")
(NEWLINE)
(KEYWORD import)
(ID "html")
(NEWLINE)
(KEYWORD import)
(ID "locale")
(NEWLINE)
(KEYWORD import)
(ID "tempfile")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "MiniFieldStorage")
(PUNCT ",")
(LIT "FieldStorage")
(PUNCT ",")
(LIT "parse")
(PUNCT ",")
(LIT "parse_qs")
(PUNCT ",")
(LIT "parse_qsl")
(PUNCT ",")
(LIT "parse_multipart")
(PUNCT ",")
(LIT "parse_header")
(PUNCT ",")
(LIT "print_exception")
(PUNCT ",")
(LIT "print_environ")
(PUNCT ",")
(LIT "print_form")
(PUNCT ",")
(LIT "print_directory")
(PUNCT ",")
(LIT "print_arguments")
(PUNCT ",")
(LIT "print_environ_usage")
(PUNCT ",")
(LIT "escape")
(PUNCT "]")
(NEWLINE)
(ID "logfile")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "logfp")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "initlog")
(PUNCT "(")
(PUNCT "*")
(ID "allargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write a log message, if there is a log file.\n\n    Even though this function is called initlog(), you should always\n    use log(); log is a variable that is set either to initlog\n    (initially), to dolog (once the log file has been opened), or to\n    nolog (when logging is disabled).\n\n    The first argument is a format string; the remaining arguments (if\n    any) are arguments to the % operator, so e.g.\n        log(\"%s: %s\", \"a\", \"b\")\n    will write \"a: b\" to the log file, followed by a newline.\n\n    If the global logfp is not None, it should be a file object to\n    which log data is written.\n\n    If the global logfp is None, the global logfile may be a string\n    giving a filename to open, in append mode.  This file should be\n    world writable!!!  If the file can't be opened, logging is\n    silently disabled (since there is no safe place where we could\n    send an error message).\n\n    ")
(NEWLINE)
(KEYWORD global)
(ID "log")
(PUNCT ",")
(ID "logfile")
(PUNCT ",")
(ID "logfp")
(NEWLINE)
(KEYWORD if)
(ID "logfile")
(KEYWORD and)
(KEYWORD not)
(ID "logfp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logfp")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "logfile")
(PUNCT ",")
(LIT "a")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "logfp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT "=")
(ID "nolog")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT "=")
(ID "dolog")
(NEWLINE)
(DEDENT)
(ID "log")
(PUNCT "(")
(PUNCT "*")
(ID "allargs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "dolog")
(PUNCT "(")
(ID "fmt")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write a log message to the log file.  See initlog() for docs.")
(NEWLINE)
(ID "logfp")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "fmt")
(PUNCT "%")
(ID "args")
(PUNCT "+")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "nolog")
(PUNCT "(")
(PUNCT "*")
(ID "allargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy function, assigned to log when logging is disabled.")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "closelog")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Close the log file.")
(NEWLINE)
(KEYWORD global)
(ID "log")
(PUNCT ",")
(ID "logfile")
(PUNCT ",")
(ID "logfp")
(NEWLINE)
(ID "logfile")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD if)
(ID "logfp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "logfp")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "logfp")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "log")
(PUNCT "=")
(ID "initlog")
(NEWLINE)
(DEDENT)
(ID "log")
(PUNCT "=")
(ID "initlog")
(NEWLINE)
(ID "maxlen")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "fp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "environ")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "strict_parsing")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a query in the environment or from a file (default stdin)\n\n        Arguments, all optional:\n\n        fp              : file pointer; default: sys.stdin.buffer\n\n        environ         : environment dictionary; default: os.environ\n\n        keep_blank_values: flag indicating whether blank values in\n            percent-encoded forms should be treated as blank strings.\n            A true value indicates that blanks should be retained as\n            blank strings.  The default false value indicates that\n            blank values are to be ignored and treated as if they were\n            not included.\n\n        strict_parsing: flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored.\n            If true, errors raise a ValueError exception.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "fp")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fp")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(LIT "encoding")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "fp")
(PUNCT ".")
(ID "encoding")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(LIT "latin-1")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "TextIOWrapper")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fp")
(PUNCT "=")
(ID "fp")
(PUNCT ".")
(ID "buffer")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(LIT "REQUEST_METHOD")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "environ")
(PUNCT "[")
(LIT "REQUEST_METHOD")
(PUNCT "]")
(PUNCT "=")
(LIT "GET")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "environ")
(PUNCT "[")
(LIT "REQUEST_METHOD")
(PUNCT "]")
(PUNCT "==")
(LIT "POST")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT ",")
(ID "pdict")
(PUNCT "=")
(ID "parse_header")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "CONTENT_TYPE")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ctype")
(PUNCT "==")
(LIT "multipart/form-data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "parse_multipart")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "pdict")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "ctype")
(PUNCT "==")
(LIT "application/x-www-form-urlencoded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "clength")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(LIT "CONTENT_LENGTH")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "maxlen")
(KEYWORD and)
(ID "clength")
(PUNCT ">")
(ID "maxlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Maximum content length exceeded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "qs")
(PUNCT "=")
(ID "fp")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "clength")
(PUNCT ")")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "QUERY_STRING")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "qs")
(PUNCT ":")
(ID "qs")
(PUNCT "=")
(ID "qs")
(PUNCT "+")
(LIT "&")
(NEWLINE)
(ID "qs")
(PUNCT "=")
(ID "qs")
(PUNCT "+")
(ID "environ")
(PUNCT "[")
(LIT "QUERY_STRING")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "qs")
(PUNCT ":")
(ID "qs")
(PUNCT "=")
(ID "qs")
(PUNCT "+")
(LIT "&")
(NEWLINE)
(ID "qs")
(PUNCT "=")
(ID "qs")
(PUNCT "+")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "environ")
(PUNCT "[")
(LIT "QUERY_STRING")
(PUNCT "]")
(PUNCT "=")
(ID "qs")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(LIT "QUERY_STRING")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(ID "environ")
(PUNCT "[")
(LIT "QUERY_STRING")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "environ")
(PUNCT "[")
(LIT "QUERY_STRING")
(PUNCT "]")
(PUNCT "=")
(ID "qs")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "urllib")
(PUNCT ".")
(ID "parse")
(PUNCT ".")
(ID "parse_qs")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_qs")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "strict_parsing")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a query given as a string argument.")
(NEWLINE)
(ID "warn")
(PUNCT "(")
(LIT "cgi.parse_qs is deprecated, use urllib.parse.parse_qs instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "urllib")
(PUNCT ".")
(ID "parse")
(PUNCT ".")
(ID "parse_qs")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_qsl")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "strict_parsing")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a query given as a string argument.")
(NEWLINE)
(ID "warn")
(PUNCT "(")
(LIT "cgi.parse_qsl is deprecated, use urllib.parse.parse_qsl instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "urllib")
(PUNCT ".")
(ID "parse")
(PUNCT ".")
(ID "parse_qsl")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_multipart")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "pdict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse multipart input.\n\n    Arguments:\n    fp   : input file\n    pdict: dictionary containing other parameters of content-type header\n\n    Returns a dictionary just like parse_qs(): keys are the field names, each\n    value is a list of values for that field.  This is easy to use but not\n    much good if you are expecting megabytes to be uploaded -- in that case,\n    use the FieldStorage class instead which is much more flexible.  Note\n    that content-type is the raw, unparsed contents of the content-type\n    header.\n\n    XXX This does not parse nested multipart parts -- use FieldStorage for\n    that.\n\n    XXX This should really be subsumed by FieldStorage altogether -- no\n    point in having two implementations of the same parsing algorithm.\n    Also, FieldStorage protects itself better against certain DoS attacks\n    by limiting the size of the data read in one chunk.  The API here\n    does not support that kind of protection.  This also affects parse()\n    since it can call parse_multipart().\n\n    ")
(NEWLINE)
(KEYWORD import)
(ID "http")
(PUNCT ".")
(ID "client")
(NEWLINE)
(ID "boundary")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD if)
(LIT "boundary")
(KEYWORD in)
(ID "pdict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "boundary")
(PUNCT "=")
(ID "pdict")
(PUNCT "[")
(LIT "boundary")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "valid_boundary")
(PUNCT "(")
(ID "boundary")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid boundary in multipart form: %r")
(PUNCT "%")
(PUNCT "(")
(ID "boundary")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "nextpart")
(PUNCT "=")
(LIT #"--")
(PUNCT "+")
(ID "boundary")
(NEWLINE)
(ID "lastpart")
(PUNCT "=")
(LIT #"--")
(PUNCT "+")
(ID "boundary")
(PUNCT "+")
(LIT #"--")
(NEWLINE)
(ID "partdict")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "terminator")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD while)
(ID "terminator")
(PUNCT "!=")
(ID "lastpart")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bytes")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "data")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "terminator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "headers")
(PUNCT "=")
(ID "http")
(PUNCT ".")
(ID "client")
(PUNCT ".")
(ID "parse_headers")
(PUNCT "(")
(ID "fp")
(PUNCT ")")
(NEWLINE)
(ID "clength")
(PUNCT "=")
(ID "headers")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "content-length")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "clength")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bytes")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "clength")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "bytes")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "maxlen")
(KEYWORD and)
(ID "bytes")
(PUNCT ">")
(ID "maxlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Maximum content length exceeded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "fp")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "bytes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "fp")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "terminator")
(PUNCT "=")
(ID "lastpart")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT #"--")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "terminator")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "terminator")
(KEYWORD in)
(PUNCT "(")
(ID "nextpart")
(PUNCT ",")
(ID "lastpart")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "data")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "bytes")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "lines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "lines")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT #"\r\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT #"\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "lines")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(ID "line")
(NEWLINE)
(ID "data")
(PUNCT "=")
(LIT #"")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "headers")
(PUNCT "[")
(LIT "content-disposition")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "key")
(PUNCT ",")
(ID "params")
(PUNCT "=")
(ID "parse_header")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "key")
(PUNCT "!=")
(LIT "form-data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "name")
(KEYWORD in)
(ID "params")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "params")
(PUNCT "[")
(LIT "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "partdict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "partdict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "partdict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(ID "data")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "partdict")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_parseparam")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "s")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT ";")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "end")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "end")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(PUNCT "(")
(ID "s")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\"")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT "-")
(ID "s")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT "\\\"")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT ")")
(PUNCT "%")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";")
(PUNCT ",")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "end")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "end")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "f")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(NEWLINE)
(KEYWORD yield)
(ID "f")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "parse_header")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    ")
(NEWLINE)
(ID "parts")
(PUNCT "=")
(ID "_parseparam")
(PUNCT "(")
(LIT ";")
(PUNCT "+")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "key")
(PUNCT "=")
(ID "parts")
(PUNCT ".")
(ID "__next__")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "pdict")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "parts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "p")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "=")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "p")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "p")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ">=")
(LIT 2)
(KEYWORD and)
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(ID "value")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "\"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "value")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\\\\")
(PUNCT ",")
(LIT "\\")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\\\"")
(PUNCT ",")
(LIT "\"")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "pdict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "key")
(PUNCT ",")
(ID "pdict")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "MiniFieldStorage")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Like FieldStorage, for use when no file uploads are possible.")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "list")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "type")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "type_options")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "disposition")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "disposition_options")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "headers")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor from field name and value.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return printable representation.")
(NEWLINE)
(KEYWORD return)
(LIT "MiniFieldStorage(%r, %r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "FieldStorage")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Store a sequence of fields, reading multipart/form-data.\n\n    This class provides naming, typing, files stored on disk, and\n    more.  At the top level, it is accessible like a dictionary, whose\n    keys are the field names.  (Note: None can occur as a field name.)\n    The items are either a Python list (if there's multiple values) or\n    another FieldStorage or MiniFieldStorage object.  If it's a single\n    object, it has the following attributes:\n\n    name: the field name, if specified; otherwise None\n\n    filename: the filename, if specified; otherwise None; this is the\n        client side filename, *not* the file name on which it is\n        stored (that's a temporary file you don't deal with)\n\n    value: the value as a *string*; for file uploads, this\n        transparently reads the file every time you request the value\n        and returns *bytes*\n\n    file: the file(-like) object from which you can read the data *as\n        bytes* ; None if the data is stored a simple string\n\n    type: the content-type, or None if not specified\n\n    type_options: dictionary of options specified on the content-type\n        line\n\n    disposition: content-disposition, or None if not specified\n\n    disposition_options: dictionary of corresponding options\n\n    headers: a dictionary(-like) object (sometimes email.message.Message or a\n        subclass thereof) containing *all* headers\n\n    The class is subclassable, mostly for the purpose of overriding\n    the make_file() method, which is called internally to come up with\n    a file open for reading and writing.  This makes it possible to\n    override the default choice of storing all files in a temporary\n    directory and unlinking them as soon as they have been opened.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "headers")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "outerboundary")
(PUNCT "=")
(LIT #"")
(PUNCT ",")
(ID "environ")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "strict_parsing")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "limit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "replace")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor.  Read multipart/* until last part.\n\n        Arguments, all optional:\n\n        fp              : file pointer; default: sys.stdin.buffer\n            (not used when the request method is GET)\n            Can be :\n            1. a TextIOWrapper object\n            2. an object whose read() and readline() methods return bytes\n\n        headers         : header dictionary-like object; default:\n            taken from environ as per CGI spec\n\n        outerboundary   : terminating multipart boundary\n            (for internal use only)\n\n        environ         : environment dictionary; default: os.environ\n\n        keep_blank_values: flag indicating whether blank values in\n            percent-encoded forms should be treated as blank strings.\n            A true value indicates that blanks should be retained as\n            blank strings.  The default false value indicates that\n            blank values are to be ignored and treated as if they were\n            not included.\n\n        strict_parsing: flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored.\n            If true, errors raise a ValueError exception.\n\n        limit : used internally to read parts of multipart/form-data forms,\n            to exit from the reading loop when reached. It is the difference\n            between the form content-length and the number of bytes already\n            read\n\n        encoding, errors : the encoding and error handler used to decode the\n            binary stream to strings. Must be the same as the charset defined\n            for the page sending the form (content-type : meta http-equiv or\n            header)\n\n        ")
(NEWLINE)
(ID "method")
(PUNCT "=")
(LIT "GET")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "keep_blank_values")
(PUNCT "=")
(ID "keep_blank_values")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "strict_parsing")
(PUNCT "=")
(ID "strict_parsing")
(NEWLINE)
(KEYWORD if)
(LIT "REQUEST_METHOD")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "method")
(PUNCT "=")
(ID "environ")
(PUNCT "[")
(LIT "REQUEST_METHOD")
(PUNCT "]")
(PUNCT ".")
(ID "upper")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "qs_on_post")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "method")
(PUNCT "==")
(LIT "GET")
(KEYWORD or)
(ID "method")
(PUNCT "==")
(LIT "HEAD")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "QUERY_STRING")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(ID "environ")
(PUNCT "[")
(LIT "QUERY_STRING")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "qs")
(PUNCT "=")
(ID "qs")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "locale")
(PUNCT ".")
(ID "getpreferredencoding")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(ID "fp")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(ID "qs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "headers")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "headers")
(PUNCT "=")
(PUNCT "{")
(LIT "content-type")
(PUNCT ":")
(LIT "application/x-www-form-urlencoded")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "headers")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "headers")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "method")
(PUNCT "==")
(LIT "POST")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "headers")
(PUNCT "[")
(LIT "content-type")
(PUNCT "]")
(PUNCT "=")
(LIT "application/x-www-form-urlencoded")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "CONTENT_TYPE")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "headers")
(PUNCT "[")
(LIT "content-type")
(PUNCT "]")
(PUNCT "=")
(ID "environ")
(PUNCT "[")
(LIT "CONTENT_TYPE")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "QUERY_STRING")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "qs_on_post")
(PUNCT "=")
(ID "environ")
(PUNCT "[")
(LIT "QUERY_STRING")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "CONTENT_LENGTH")
(KEYWORD in)
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "headers")
(PUNCT "[")
(LIT "content-length")
(PUNCT "]")
(PUNCT "=")
(ID "environ")
(PUNCT "[")
(LIT "CONTENT_LENGTH")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "headers")
(PUNCT ",")
(PUNCT "(")
(ID "Mapping")
(PUNCT ",")
(ID "Message")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "headers must be mapping or an instance of ")
(LIT "email.message.Message")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT "=")
(ID "headers")
(NEWLINE)
(KEYWORD if)
(ID "fp")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ".")
(ID "buffer")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "TextIOWrapper")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT "=")
(ID "fp")
(PUNCT ".")
(ID "buffer")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "hasattr")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(LIT "read")
(PUNCT ")")
(KEYWORD and)
(ID "hasattr")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(LIT "readline")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "fp must be file pointer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT "=")
(ID "fp")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT "=")
(ID "errors")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "outerboundary")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "outerboundary must be bytes, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "outerboundary")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "outerboundary")
(PUNCT "=")
(ID "outerboundary")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "limit")
(PUNCT "=")
(ID "limit")
(NEWLINE)
(ID "cdisp")
(PUNCT ",")
(ID "pdict")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(LIT "content-disposition")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cdisp")
(PUNCT ",")
(ID "pdict")
(PUNCT "=")
(ID "parse_header")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT "[")
(LIT "content-disposition")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "disposition")
(PUNCT "=")
(ID "cdisp")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "disposition_options")
(PUNCT "=")
(ID "pdict")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(LIT "name")
(KEYWORD in)
(ID "pdict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "pdict")
(PUNCT "[")
(LIT "name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(LIT "filename")
(KEYWORD in)
(ID "pdict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "pdict")
(PUNCT "[")
(LIT "filename")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_binary_file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "filename")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(LIT "content-type")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT ",")
(ID "pdict")
(PUNCT "=")
(ID "parse_header")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT "[")
(LIT "content-type")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "outerboundary")
(KEYWORD or)
(ID "method")
(PUNCT "!=")
(LIT "POST")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT ",")
(ID "pdict")
(PUNCT "=")
(LIT "text/plain")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ctype")
(PUNCT ",")
(ID "pdict")
(PUNCT "=")
(LIT "application/x-www-form-urlencoded")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT "=")
(ID "ctype")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "type_options")
(PUNCT "=")
(ID "pdict")
(NEWLINE)
(KEYWORD if)
(LIT "boundary")
(KEYWORD in)
(ID "pdict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "innerboundary")
(PUNCT "=")
(ID "pdict")
(PUNCT "[")
(LIT "boundary")
(PUNCT "]")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "innerboundary")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(DEDENT)
(ID "clen")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(LIT "content-length")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "clen")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "headers")
(PUNCT "[")
(LIT "content-length")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "maxlen")
(KEYWORD and)
(ID "clen")
(PUNCT ">")
(ID "maxlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Maximum content length exceeded")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "length")
(PUNCT "=")
(ID "clen")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "limit")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "clen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "limit")
(PUNCT "=")
(ID "clen")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "ctype")
(PUNCT "==")
(LIT "application/x-www-form-urlencoded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_urlencoded")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "ctype")
(PUNCT "[")
(PUNCT ":")
(LIT 10)
(PUNCT "]")
(PUNCT "==")
(LIT "multipart/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_multi")
(PUNCT "(")
(ID "environ")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_single")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a printable representation.")
(NEWLINE)
(KEYWORD return)
(LIT "FieldStorage(%r, %r, %r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getattr__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(PUNCT "!=")
(LIT "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "AttributeError")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "list")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "list")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dictionary style indexing.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "list")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "not indexable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "found")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "item")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "key")
(PUNCT ":")
(ID "found")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "found")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "found")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "found")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "found")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getvalue")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dictionary style get() method, including 'value' lookup.")
(NEWLINE)
(KEYWORD if)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "x")
(PUNCT ".")
(ID "value")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "value")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(PUNCT ".")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "default")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getfirst")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Return the first value received.")
(NEWLINE)
(KEYWORD if)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(PUNCT ".")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "default")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getlist")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Return list of received values.")
(NEWLINE)
(KEYWORD if)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "x")
(PUNCT ".")
(ID "value")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "value")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "value")
(PUNCT ".")
(ID "value")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "keys")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dictionary style keys() method.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "list")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "not indexable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "set")
(PUNCT "(")
(ID "item")
(PUNCT ".")
(ID "name")
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dictionary style __contains__ method.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "list")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "not indexable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "any")
(PUNCT "(")
(ID "item")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "key")
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dictionary style len(x) support.")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bool__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "list")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Cannot be converted to bool.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "bool")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_urlencoded")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read data in query string format.")
(NEWLINE)
(ID "qs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "length")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s should return bytes, got %s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "qs")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "qs")
(PUNCT "=")
(ID "qs")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "qs_on_post")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qs")
(PUNCT "+=")
(LIT "&")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "qs_on_post")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "query")
(PUNCT "=")
(ID "urllib")
(PUNCT ".")
(ID "parse")
(PUNCT ".")
(ID "parse_qsl")
(PUNCT "(")
(ID "qs")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "keep_blank_values")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "strict_parsing")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "query")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "MiniFieldStorage")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "skip_lines")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "FieldStorageClass")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "read_multi")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "environ")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read a part that is itself multipart.")
(NEWLINE)
(ID "ib")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "innerboundary")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "valid_boundary")
(PUNCT "(")
(ID "ib")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid boundary in multipart form: %r")
(PUNCT "%")
(PUNCT "(")
(ID "ib")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "qs_on_post")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "query")
(PUNCT "=")
(ID "urllib")
(PUNCT ".")
(ID "parse")
(PUNCT ".")
(ID "parse_qsl")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "qs_on_post")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "keep_blank_values")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "strict_parsing")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "query")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "MiniFieldStorage")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "klass")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "FieldStorageClass")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "__class__")
(NEWLINE)
(ID "first_line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "first_line")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s should return bytes, got %s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "first_line")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "first_line")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "FeedParser")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "hdr_text")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "hdr_text")
(PUNCT "+=")
(ID "data")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "hdr_text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "hdr_text")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "hdr_text")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "headers")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "part")
(PUNCT "=")
(ID "klass")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ",")
(ID "headers")
(PUNCT ",")
(ID "ib")
(PUNCT ",")
(ID "environ")
(PUNCT ",")
(ID "keep_blank_values")
(PUNCT ",")
(ID "strict_parsing")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "limit")
(PUNCT "-")
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "part")
(PUNCT ".")
(ID "bytes_read")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "list")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "part")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "part")
(PUNCT ".")
(ID "done")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "length")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "skip_lines")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_single")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read an atomic part.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "length")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_binary")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "skip_lines")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_lines")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "seek")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bufsize")
(PUNCT "=")
(LIT 8)
(PUNCT "*")
(LIT 1024)
(NEWLINE)
(KEYWORD def)
(ID "read_binary")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read binary data.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "make_file")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "todo")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "length")
(NEWLINE)
(KEYWORD if)
(ID "todo")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "todo")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "min")
(PUNCT "(")
(ID "todo")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "bufsize")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "%s should return bytes, got %s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(ID "todo")
(PUNCT "=")
(ID "todo")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "read_lines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read lines until EOF or outerboundary.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_binary_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__file")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__file")
(PUNCT "=")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "outerboundary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_lines_to_outerboundary")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "read_lines_to_eof")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "line is always bytes, not string")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "__file")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "__file")
(PUNCT ".")
(ID "tell")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ">")
(LIT 1000)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "make_file")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__file")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_binary_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "read_lines_to_eof")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read lines until EOF.")
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(LIT 1)
(PUNCT "<<")
(LIT 16)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "__write")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "read_lines_to_outerboundary")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: read lines until outerboundary.\n        Data is read as bytes: boundaries and line ends must be converted\n        to bytes for comparisons.\n        ")
(NEWLINE)
(ID "next_boundary")
(PUNCT "=")
(LIT #"--")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "outerboundary")
(NEWLINE)
(ID "last_boundary")
(PUNCT "=")
(ID "next_boundary")
(PUNCT "+")
(LIT #"--")
(NEWLINE)
(ID "delim")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "last_line_lfend")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "_read")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "_read")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "limit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(LIT 1)
(PUNCT "<<")
(LIT 16)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "delim")
(PUNCT "==")
(LIT #"\r")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "delim")
(PUNCT "+")
(ID "line")
(NEWLINE)
(ID "delim")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT #"--")
(PUNCT ")")
(KEYWORD and)
(ID "last_line_lfend")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "strippedline")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "strippedline")
(PUNCT "==")
(ID "next_boundary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "strippedline")
(PUNCT "==")
(ID "last_boundary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "odelim")
(PUNCT "=")
(ID "delim")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\r\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "delim")
(PUNCT "=")
(LIT #"\r\n")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "last_line_lfend")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "line")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "delim")
(PUNCT "=")
(LIT #"\n")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "last_line_lfend")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "line")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\r")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "delim")
(PUNCT "=")
(LIT #"\r")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "last_line_lfend")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "delim")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "last_line_lfend")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "__write")
(PUNCT "(")
(ID "odelim")
(PUNCT "+")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "skip_lines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal: skip lines until outer boundary if defined.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "outerboundary")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "next_boundary")
(PUNCT "=")
(LIT #"--")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "outerboundary")
(NEWLINE)
(ID "last_boundary")
(PUNCT "=")
(ID "next_boundary")
(PUNCT "+")
(LIT #"--")
(NEWLINE)
(ID "last_line_lfend")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fp")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(LIT 1)
(PUNCT "<<")
(LIT 16)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "bytes_read")
(PUNCT "+=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"--")
(PUNCT ")")
(KEYWORD and)
(ID "last_line_lfend")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "strippedline")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "strippedline")
(PUNCT "==")
(ID "next_boundary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "strippedline")
(PUNCT "==")
(ID "last_boundary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "done")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "last_line_lfend")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "make_file")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Overridable: return a readable & writable file.\n\n        The file will be used as follows:\n        - data is written to it\n        - seek(0)\n        - data is read from it\n\n        The file is opened in binary mode for files, in text mode\n        for other fields\n\n        This version opens a temporary file for reading and writing,\n        and immediately deletes (unlinks) it.  The trick (on Unix!) is\n        that the file can still be used, but it can't be opened by\n        another process, and it will automatically be deleted when it\n        is closed or when the current process terminates.\n\n        If you want a more permanent file, you derive a class which\n        overrides this method.  If you want a visible temporary file\n        that is nevertheless automatically deleted when the script\n        terminates, try defining a __del__ method in a derived class\n        which unlinks the temporary files you have created.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_binary_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "tempfile")
(PUNCT ".")
(ID "TemporaryFile")
(PUNCT "(")
(LIT "wb+")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "tempfile")
(PUNCT ".")
(ID "TemporaryFile")
(PUNCT "(")
(LIT "w+")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "encoding")
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "test")
(PUNCT "(")
(ID "environ")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Robust test CGI script, usable as main program.\n\n    Write minimal HTTP headers and dump all information provided to\n    the script in HTML form.\n\n    ")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Content-type: text/html")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "form")
(PUNCT "=")
(ID "FieldStorage")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print_directory")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print_arguments")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print_form")
(PUNCT "(")
(ID "form")
(PUNCT ")")
(NEWLINE)
(ID "print_environ")
(PUNCT "(")
(ID "environ")
(PUNCT ")")
(NEWLINE)
(ID "print_environ_usage")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "f")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exec")
(PUNCT "(")
(LIT "testing print_exception() -- <I>italics?</I>")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "g")
(PUNCT "(")
(ID "f")
(PUNCT "=")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "<H3>What follows is a test, not an actual exception:</H3>")
(PUNCT ")")
(NEWLINE)
(ID "g")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print_exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "<H1>Second try with a small maxlen...</H1>")
(PUNCT ")")
(NEWLINE)
(KEYWORD global)
(ID "maxlen")
(NEWLINE)
(ID "maxlen")
(PUNCT "=")
(LIT 50)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "form")
(PUNCT "=")
(ID "FieldStorage")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print_directory")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print_arguments")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print_form")
(PUNCT "(")
(ID "form")
(PUNCT ")")
(NEWLINE)
(ID "print_environ")
(PUNCT "(")
(ID "environ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print_exception")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "print_exception")
(PUNCT "(")
(ID "type")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "tb")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "limit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "tb")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<H3>Traceback (most recent call last):</H3>")
(PUNCT ")")
(NEWLINE)
(ID "list")
(PUNCT "=")
(ID "traceback")
(PUNCT ".")
(ID "format_tb")
(PUNCT "(")
(ID "tb")
(PUNCT ",")
(ID "limit")
(PUNCT ")")
(PUNCT "+")
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<PRE>%s<B>%s</B></PRE>")
(PUNCT "%")
(PUNCT "(")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "list")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "list")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "tb")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_environ")
(PUNCT "(")
(ID "environ")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dump the shell environment as HTML.")
(NEWLINE)
(ID "keys")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "environ")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<H3>Shell Environment:</H3>")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<DL>")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "keys")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "<DT>")
(PUNCT ",")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ",")
(LIT "<DD>")
(PUNCT ",")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "environ")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "</DL>")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_form")
(PUNCT "(")
(ID "form")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dump the contents of a form as HTML.")
(NEWLINE)
(ID "keys")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "form")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<H3>Form Contents:</H3>")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "keys")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "<P>No form fields.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "<DL>")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "keys")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "<DT>")
(PUNCT "+")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "+")
(LIT ":")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "form")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<i>")
(PUNCT "+")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(LIT "</i>")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<DD>")
(PUNCT "+")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "</DL>")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_directory")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dump the current directory as HTML.")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<H3>Current Working Directory:</H3>")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pwd")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "getcwd")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "msg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "OSError:")
(PUNCT ",")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "html")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "pwd")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_arguments")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "<H3>Command Line Arguments:</H3>")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "print_environ_usage")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dump a list of environment variables used by CGI as HTML.")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "\n<H3>These environment variables could have been set:</H3>\n<UL>\n<LI>AUTH_TYPE\n<LI>CONTENT_LENGTH\n<LI>CONTENT_TYPE\n<LI>DATE_GMT\n<LI>DATE_LOCAL\n<LI>DOCUMENT_NAME\n<LI>DOCUMENT_ROOT\n<LI>DOCUMENT_URI\n<LI>GATEWAY_INTERFACE\n<LI>LAST_MODIFIED\n<LI>PATH\n<LI>PATH_INFO\n<LI>PATH_TRANSLATED\n<LI>QUERY_STRING\n<LI>REMOTE_ADDR\n<LI>REMOTE_HOST\n<LI>REMOTE_IDENT\n<LI>REMOTE_USER\n<LI>REQUEST_METHOD\n<LI>SCRIPT_NAME\n<LI>SERVER_NAME\n<LI>SERVER_PORT\n<LI>SERVER_PROTOCOL\n<LI>SERVER_ROOT\n<LI>SERVER_SOFTWARE\n</UL>\nIn addition, HTTP headers sent by the server may be passed in the\nenvironment as well.  Here are some common variable names:\n<UL>\n<LI>HTTP_ACCEPT\n<LI>HTTP_CONNECTION\n<LI>HTTP_HOST\n<LI>HTTP_PRAGMA\n<LI>HTTP_REFERER\n<LI>HTTP_USER_AGENT\n</UL>\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "escape")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "quote")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deprecated API.")
(NEWLINE)
(ID "warn")
(PUNCT "(")
(LIT "cgi.escape is deprecated, use html.escape instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "&")
(PUNCT ",")
(LIT "&amp;")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "<")
(PUNCT ",")
(LIT "&lt;")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ">")
(PUNCT ",")
(LIT "&gt;")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "quote")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\"")
(PUNCT ",")
(LIT "&quot;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "s")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "valid_boundary")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_vb_pattern")
(PUNCT "=")
(LIT #"^[ -~]{0,200}[!-~]$")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_vb_pattern")
(PUNCT "=")
(LIT "^[ -~]{0,200}[!-~]$")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "_vb_pattern")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
