(LIT "Queues")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Queue")
(PUNCT ",")
(LIT "PriorityQueue")
(PUNCT ",")
(LIT "LifoQueue")
(PUNCT ",")
(LIT "JoinableQueue")
(PUNCT ",")
(LIT "QueueFull")
(PUNCT ",")
(LIT "QueueEmpty")
(PUNCT "]")
(NEWLINE)
(KEYWORD import)
(ID "collections")
(NEWLINE)
(KEYWORD import)
(ID "heapq")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "events")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "futures")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "locks")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "tasks")
(KEYWORD import)
(ID "coroutine")
(NEWLINE)
(KEYWORD class)
(ID "QueueEmpty")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Exception raised when Queue.get_nowait() is called on a Queue object\n    which is empty.\n    ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "QueueFull")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Exception raised when the Queue.put_nowait() method is called on a Queue\n    object which is full.\n    ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Queue")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A queue, useful for coordinating producer and consumer coroutines.\n\n    If maxsize is less than or equal to zero, the queue size is infinite. If it\n    is an integer greater than 0, then \"yield from put()\" will block when the\n    queue reaches maxsize, until an item is removed by get().\n\n    Unlike the standard library Queue, you can reliably know this Queue's size\n    with qsize(), since your single-threaded asyncio application won't be\n    interrupted between calling qsize() and doing an operation on the Queue.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "maxsize")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "loop")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT "=")
(ID "events")
(PUNCT ".")
(ID "get_event_loop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT "=")
(ID "loop")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT "=")
(ID "maxsize")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "deque")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "deque")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_init")
(PUNCT "(")
(ID "maxsize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "maxsize")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT "=")
(ID "collections")
(PUNCT ".")
(ID "deque")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_put")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<{} at {:#x} {}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "id")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_format")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<{} {}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_format")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(LIT "maxsize={!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "_queue")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT " _queue={!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "list")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT " _getters[{}]")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT " _putters[{}]")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_consume_done_getters")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "_getters")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_consume_done_putters")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "_putters")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "done")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "qsize")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Number of items in the queue.")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "maxsize")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Number of items allowed in the queue.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "empty")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if the queue is empty, False otherwise.")
(NEWLINE)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_queue")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "full")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if there are maxsize items in the queue.\n\n        Note: if the Queue was initialized with maxsize=0 (the default),\n        then full() is never True.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "qsize")
(PUNCT "(")
(PUNCT ")")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "put")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Put an item into the queue.\n\n        Put an item into the queue. If the queue is full, wait until a free\n        slot is available before adding item.\n\n        This method is a coroutine.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_consume_done_getters")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ",")
(PUNCT "(")
(LIT "queue non-empty, why are getters waiting?")
(PUNCT ")")
(NEWLINE)
(ID "getter")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(ID "getter")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "qsize")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waiter")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(ID "waiter")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(KEYWORD from)
(ID "waiter")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "put_nowait")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Put an item into the queue without blocking.\n\n        If no free slot is immediately available, raise QueueFull.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_consume_done_getters")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ",")
(PUNCT "(")
(LIT "queue non-empty, why are getters waiting?")
(PUNCT ")")
(NEWLINE)
(ID "getter")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(ID "getter")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_maxsize")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "qsize")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "QueueFull")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove and return an item from the queue.\n\n        If queue is empty, wait until an item is available.\n\n        This method is a coroutine.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_consume_done_putters")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "full")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(LIT "queue not full, why are putters waiting?")
(NEWLINE)
(ID "item")
(PUNCT ",")
(ID "putter")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ".")
(ID "call_soon")
(PUNCT "(")
(ID "putter")
(PUNCT ".")
(ID "_set_result_unless_cancelled")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "qsize")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "waiter")
(PUNCT "=")
(ID "futures")
(PUNCT ".")
(ID "Future")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_getters")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(KEYWORD yield)
(KEYWORD from)
(ID "waiter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_nowait")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove and return an item from the queue.\n\n        Return an item if one is immediately available, else raise QueueEmpty.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_consume_done_putters")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "full")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(LIT "queue not full, why are putters waiting?")
(NEWLINE)
(ID "item")
(PUNCT ",")
(ID "putter")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_putters")
(PUNCT ".")
(ID "popleft")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(ID "putter")
(PUNCT ".")
(ID "set_result")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "qsize")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "QueueEmpty")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "PriorityQueue")
(PUNCT "(")
(ID "Queue")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A subclass of Queue; retrieves entries in priority order (lowest first).\n\n    Entries are typically tuples of the form: (priority number, data).\n    ")
(NEWLINE)
(KEYWORD def)
(ID "_init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "maxsize")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_put")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ",")
(ID "heappush")
(PUNCT "=")
(ID "heapq")
(PUNCT ".")
(ID "heappush")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "heappush")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "heappop")
(PUNCT "=")
(ID "heapq")
(PUNCT ".")
(ID "heappop")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "heappop")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "LifoQueue")
(PUNCT "(")
(ID "Queue")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A subclass of Queue that retrieves most recently added entries first.")
(NEWLINE)
(KEYWORD def)
(ID "_init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "maxsize")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_put")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_queue")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "JoinableQueue")
(PUNCT "(")
(ID "Queue")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A subclass of Queue with task_done() and join() methods.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "maxsize")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "maxsize")
(PUNCT "=")
(ID "maxsize")
(PUNCT ",")
(ID "loop")
(PUNCT "=")
(ID "loop")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_finished")
(PUNCT "=")
(ID "locks")
(PUNCT ".")
(ID "Event")
(PUNCT "(")
(ID "loop")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_loop")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_finished")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_format")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "=")
(ID "Queue")
(PUNCT ".")
(ID "_format")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT "+=")
(LIT " tasks={}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_put")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "_put")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_finished")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "task_done")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Indicate that a formerly enqueued task is complete.\n\n        Used by queue consumers. For each get() used to fetch a task,\n        a subsequent call to task_done() tells the queue that the processing\n        on the task is complete.\n\n        If a join() is currently blocking, it will resume when all items have\n        been processed (meaning that a task_done() call was received for every\n        item that had been put() into the queue).\n\n        Raises ValueError if called more times than there were items placed in\n        the queue.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "task_done() called too many times")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_finished")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "coroutine")
(NEWLINE)
(KEYWORD def)
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Block until all items in the queue have been gotten and processed.\n\n        The count of unfinished tasks goes up whenever an item is added to the\n        queue. The count goes down whenever a consumer thread calls task_done()\n        to indicate that the item was retrieved and all work on it is complete.\n        When the count of unfinished tasks drops to zero, join() unblocks.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_unfinished_tasks")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "self")
(PUNCT ".")
(ID "_finished")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
