(LIT "Generic socket server classes.\n\nThis module tries to capture the various aspects of defining a server:\n\nFor socket-based servers:\n\n- address family:\n        - AF_INET{,6}: IP (Internet Protocol) sockets (default)\n        - AF_UNIX: Unix domain sockets\n        - others, e.g. AF_DECNET are conceivable (see <socket.h>\n- socket type:\n        - SOCK_STREAM (reliable stream, e.g. TCP)\n        - SOCK_DGRAM (datagrams, e.g. UDP)\n\nFor request-based servers (including socket-based):\n\n- client address verification before further looking at the request\n        (This is actually a hook for any processing that needs to look\n         at the request before anything else, e.g. logging)\n- how to handle multiple requests:\n        - synchronous (one request is handled at a time)\n        - forking (each request is handled by a new process)\n        - threading (each request is handled by a new thread)\n\nThe classes in this module favor the server type that is simplest to\nwrite: a synchronous TCP/IP server.  This is bad class design, but\nsave some typing.  (There's also the issue that a deep class hierarchy\nslows down method lookups.)\n\nThere are five classes in an inheritance diagram, four of which represent\nsynchronous servers of four types:\n\n        +------------+\n        | BaseServer |\n        +------------+\n              |\n              v\n        +-----------+        +------------------+\n        | TCPServer |------->| UnixStreamServer |\n        +-----------+        +------------------+\n              |\n              v\n        +-----------+        +--------------------+\n        | UDPServer |------->| UnixDatagramServer |\n        +-----------+        +--------------------+\n\nNote that UnixDatagramServer derives from UDPServer, not from\nUnixStreamServer -- the only difference between an IP and a Unix\nstream server is the address family, which is simply repeated in both\nunix server classes.\n\nForking and threading versions of each type of server can be created\nusing the ForkingMixIn and ThreadingMixIn mix-in classes.  For\ninstance, a threading UDP server class is created as follows:\n\n        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass\n\nThe Mix-in class must come first, since it overrides a method defined\nin UDPServer! Setting the various member variables also changes\nthe behavior of the underlying server mechanism.\n\nTo implement a service, you must derive a class from\nBaseRequestHandler and redefine its handle() method.  You can then run\nvarious versions of the service by combining one of the server classes\nwith your request handler class.\n\nThe request handler class must be different for datagram or stream\nservices.  This can be hidden by using the request handler\nsubclasses StreamRequestHandler or DatagramRequestHandler.\n\nOf course, you still have to use your head!\n\nFor instance, it makes no sense to use a forking server if the service\ncontains state in memory that can be modified by requests (since the\nmodifications in the child process would never reach the initial state\nkept in the parent process and passed to each child).  In this case,\nyou can use a threading server, but you will probably have to use\nlocks to avoid two requests that come in nearly simultaneous to apply\nconflicting changes to the server state.\n\nOn the other hand, if you are building e.g. an HTTP server, where all\ndata is stored externally (e.g. in the file system), a synchronous\nclass will essentially render the service \"deaf\" while one request is\nbeing handled -- which may be for a very long time if a client is slow\nto read all the data it has requested.  Here a threading or forking\nserver is appropriate.\n\nIn some cases, it may be appropriate to process part of a request\nsynchronously, but to finish processing in a forked child depending on\nthe request data.  This can be implemented by using a synchronous\nserver and doing an explicit fork in the request handler class\nhandle() method.\n\nAnother approach to handling multiple simultaneous requests in an\nenvironment that supports neither threads nor fork (or where these are\ntoo expensive or inappropriate for the service) is to maintain an\nexplicit table of partially finished requests and to use select() to\ndecide which request to work on next (or whether to handle a new\nincoming request).  This is particularly important for stream services\nwhere each client can potentially be connected for a long time (if\nthreads or subprocesses cannot be used).\n\nFuture work:\n- Standard classes for Sun RPC (which uses either UDP or TCP)\n- Standard mix-in classes to implement various authentication\n  and encryption schemes\n- Standard framework for select-based multiplexing\n\nXXX Open problems:\n- What to do with out-of-band data?\n\nBaseServer:\n- split generic \"request\" functionality out into BaseServer class.\n  Copyright (C) 2000  Luke Kenneth Casson Leighton <lkcl@samba.org>\n\n  example: read entries from a SQL database (requires overriding\n  get_request() to return a table entry from the database).\n  entry is processed by a RequestHandlerClass.\n\n")
(NEWLINE)
(ID "__version__")
(PUNCT "=")
(LIT "0.4")
(NEWLINE)
(KEYWORD import)
(ID "socket")
(NEWLINE)
(KEYWORD import)
(ID "select")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "errno")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "threading")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "dummy_threading")
(KEYWORD as)
(ID "threading")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "BaseServer")
(PUNCT ",")
(LIT "TCPServer")
(PUNCT ",")
(LIT "UDPServer")
(PUNCT ",")
(LIT "ForkingUDPServer")
(PUNCT ",")
(LIT "ForkingTCPServer")
(PUNCT ",")
(LIT "ThreadingUDPServer")
(PUNCT ",")
(LIT "ThreadingTCPServer")
(PUNCT ",")
(LIT "BaseRequestHandler")
(PUNCT ",")
(LIT "StreamRequestHandler")
(PUNCT ",")
(LIT "DatagramRequestHandler")
(PUNCT ",")
(LIT "ThreadingMixIn")
(PUNCT ",")
(LIT "ForkingMixIn")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "socket")
(PUNCT ",")
(LIT "AF_UNIX")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(PUNCT "[")
(LIT "UnixStreamServer")
(PUNCT ",")
(LIT "UnixDatagramServer")
(PUNCT ",")
(LIT "ThreadingUnixStreamServer")
(PUNCT ",")
(LIT "ThreadingUnixDatagramServer")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_eintr_retry")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "restart a system call interrupted by EINTR")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "func")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "errno")
(PUNCT "!=")
(ID "errno")
(PUNCT ".")
(ID "EINTR")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BaseServer")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for server classes.\n\n    Methods for the caller:\n\n    - __init__(server_address, RequestHandlerClass)\n    - serve_forever(poll_interval=0.5)\n    - shutdown()\n    - handle_request()  # if you do not use serve_forever()\n    - fileno() -> int   # for select()\n\n    Methods that may be overridden:\n\n    - server_bind()\n    - server_activate()\n    - get_request() -> request, client_address\n    - handle_timeout()\n    - verify_request(request, client_address)\n    - server_close()\n    - process_request(request, client_address)\n    - shutdown_request(request)\n    - close_request(request)\n    - service_actions()\n    - handle_error()\n\n    Methods for derived classes:\n\n    - finish_request(request, client_address)\n\n    Class variables that may be overridden by derived classes or\n    instances:\n\n    - timeout\n    - address_family\n    - socket_type\n    - allow_reuse_address\n\n    Instance variables:\n\n    - RequestHandlerClass\n    - socket\n\n    ")
(NEWLINE)
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "server_address")
(PUNCT ",")
(ID "RequestHandlerClass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor.  May be extended, do not override.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "server_address")
(PUNCT "=")
(ID "server_address")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "RequestHandlerClass")
(PUNCT "=")
(ID "RequestHandlerClass")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__is_shut_down")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "Event")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__shutdown_request")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "server_activate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called by constructor to activate the server.\n\n        May be overridden.\n\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "serve_forever")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "poll_interval")
(PUNCT "=")
(LIT 0.5)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handle one request at a time until shutdown.\n\n        Polls for shutdown every poll_interval seconds. Ignores\n        self.timeout. If you need to do periodic tasks, do them in\n        another thread.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__is_shut_down")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "__shutdown_request")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT ",")
(ID "w")
(PUNCT ",")
(ID "e")
(PUNCT "=")
(ID "_eintr_retry")
(PUNCT "(")
(ID "select")
(PUNCT ".")
(ID "select")
(PUNCT ",")
(PUNCT "[")
(ID "self")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "poll_interval")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(KEYWORD in)
(ID "r")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_handle_request_noblock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "service_actions")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "__shutdown_request")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__is_shut_down")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "shutdown")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Stops the serve_forever loop.\n\n        Blocks until the loop has finished. This must be called while\n        serve_forever() is running in another thread, or it will\n        deadlock.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__shutdown_request")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "__is_shut_down")
(PUNCT ".")
(ID "wait")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "service_actions")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called by the serve_forever() loop.\n\n        May be overridden by a subclass / Mixin to implement any code that\n        needs to be run during the loop.\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "handle_request")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handle one request, possibly blocking.\n\n        Respects self.timeout.\n        ")
(NEWLINE)
(ID "timeout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "gettimeout")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "timeout")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "timeout")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fd_sets")
(PUNCT "=")
(ID "_eintr_retry")
(PUNCT "(")
(ID "select")
(PUNCT ".")
(ID "select")
(PUNCT ",")
(PUNCT "[")
(ID "self")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "fd_sets")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handle_timeout")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_handle_request_noblock")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_handle_request_noblock")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handle one request, without blocking.\n\n        I assume that select.select has returned that the socket is\n        readable before this function was called, so there should be\n        no risk of blocking in get_request().\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_request")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "verify_request")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "process_request")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handle_error")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shutdown_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "handle_timeout")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called if no new request arrives within self.timeout.\n\n        Overridden by ForkingMixIn.\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "verify_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Verify the request.  May be overridden.\n\n        Return True if we should proceed with this request.\n\n        ")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "process_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Call finish_request.\n\n        Overridden by ForkingMixIn and ThreadingMixIn.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "finish_request")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shutdown_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "server_close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called to clean-up the server.\n\n        May be overridden.\n\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "finish_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Finish one request by instantiating RequestHandlerClass.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "RequestHandlerClass")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shutdown_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called to shutdown and close an individual request.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "close_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called to clean up an individual request.")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "handle_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handle an error gracefully.  May be overridden.\n\n        The default is to print a traceback and continue.\n\n        ")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "-")
(PUNCT "*")
(LIT 40)
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Exception happened during processing of request from")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(ID "traceback")
(PUNCT ".")
(ID "print_exc")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "-")
(PUNCT "*")
(LIT 40)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "TCPServer")
(PUNCT "(")
(ID "BaseServer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for various socket-based server classes.\n\n    Defaults to synchronous IP stream (i.e., TCP).\n\n    Methods for the caller:\n\n    - __init__(server_address, RequestHandlerClass, bind_and_activate=True)\n    - serve_forever(poll_interval=0.5)\n    - shutdown()\n    - handle_request()  # if you don't use serve_forever()\n    - fileno() -> int   # for select()\n\n    Methods that may be overridden:\n\n    - server_bind()\n    - server_activate()\n    - get_request() -> request, client_address\n    - handle_timeout()\n    - verify_request(request, client_address)\n    - process_request(request, client_address)\n    - shutdown_request(request)\n    - close_request(request)\n    - handle_error()\n\n    Methods for derived classes:\n\n    - finish_request(request, client_address)\n\n    Class variables that may be overridden by derived classes or\n    instances:\n\n    - timeout\n    - address_family\n    - socket_type\n    - request_queue_size (only for stream sockets)\n    - allow_reuse_address\n\n    Instance variables:\n\n    - server_address\n    - RequestHandlerClass\n    - socket\n\n    ")
(NEWLINE)
(ID "address_family")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "AF_INET")
(NEWLINE)
(ID "socket_type")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "SOCK_STREAM")
(NEWLINE)
(ID "request_queue_size")
(PUNCT "=")
(LIT 5)
(NEWLINE)
(ID "allow_reuse_address")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "server_address")
(PUNCT ",")
(ID "RequestHandlerClass")
(PUNCT ",")
(ID "bind_and_activate")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor.  May be extended, do not override.")
(NEWLINE)
(ID "BaseServer")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "server_address")
(PUNCT ",")
(ID "RequestHandlerClass")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "socket")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "address_family")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "socket_type")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "bind_and_activate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "server_bind")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "server_activate")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "server_close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "server_bind")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called by constructor to bind the socket.\n\n        May be overridden.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "allow_reuse_address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "setsockopt")
(PUNCT "(")
(ID "socket")
(PUNCT ".")
(ID "SOL_SOCKET")
(PUNCT ",")
(ID "socket")
(PUNCT ".")
(ID "SO_REUSEADDR")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "bind")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "server_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "server_address")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "getsockname")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "server_activate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called by constructor to activate the server.\n\n        May be overridden.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "listen")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "request_queue_size")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "server_close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called to clean-up the server.\n\n        May be overridden.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return socket file number.\n\n        Interface required by select().\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_request")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get the request and client address from the socket.\n\n        May be overridden.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "accept")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shutdown_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called to shutdown and close an individual request.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "request")
(PUNCT ".")
(ID "shutdown")
(PUNCT "(")
(ID "socket")
(PUNCT ".")
(ID "SHUT_WR")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "close_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Called to clean up an individual request.")
(NEWLINE)
(ID "request")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "UDPServer")
(PUNCT "(")
(ID "TCPServer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "UDP server class.")
(NEWLINE)
(ID "allow_reuse_address")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "socket_type")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "SOCK_DGRAM")
(NEWLINE)
(ID "max_packet_size")
(PUNCT "=")
(LIT 8192)
(NEWLINE)
(KEYWORD def)
(ID "get_request")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT ",")
(ID "client_addr")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "recvfrom")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "max_packet_size")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "data")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ")")
(PUNCT ",")
(ID "client_addr")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "server_activate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shutdown_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ForkingMixIn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Mix-in class to handle each request in a new process.")
(NEWLINE)
(ID "timeout")
(PUNCT "=")
(LIT 300)
(NEWLINE)
(ID "active_children")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "max_children")
(PUNCT "=")
(LIT 40)
(NEWLINE)
(KEYWORD def)
(ID "collect_children")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Internal routine to wait for children that have exited.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "active_children")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ")")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "max_children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pid")
(PUNCT ",")
(ID "_")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "waitpid")
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "pid")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "InterruptedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ChildProcessError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "pid")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pid")
(PUNCT ",")
(ID "_")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "waitpid")
(PUNCT "(")
(ID "pid")
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "WNOHANG")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "pid")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ChildProcessError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ".")
(ID "discard")
(PUNCT "(")
(ID "pid")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "handle_timeout")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wait for zombies after self.timeout seconds of inactivity.\n\n        May be extended, do not override.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "collect_children")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "service_actions")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Collect the zombie child processes regularly in the ForkingMixIn.\n\n        service_actions is called in the BaseServer's serve_forver loop.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "collect_children")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "process_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Fork a new subprocess to process the request.")
(NEWLINE)
(ID "pid")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fork")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pid")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "active_children")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "active_children")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "pid")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "close_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "finish_request")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shutdown_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "_exit")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handle_error")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shutdown_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "_exit")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ThreadingMixIn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Mix-in class to handle each request in a new thread.")
(NEWLINE)
(ID "daemon_threads")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD def)
(ID "process_request_thread")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Same as in BaseServer but as a thread.\n\n        In addition, exception handling is done here.\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "finish_request")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shutdown_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handle_error")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "shutdown_request")
(PUNCT "(")
(ID "request")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "process_request")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Start a new thread to process the request.")
(NEWLINE)
(ID "t")
(PUNCT "=")
(ID "threading")
(PUNCT ".")
(ID "Thread")
(PUNCT "(")
(ID "target")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "process_request_thread")
(PUNCT ",")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "t")
(PUNCT ".")
(ID "daemon")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "daemon_threads")
(NEWLINE)
(ID "t")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ForkingUDPServer")
(PUNCT "(")
(ID "ForkingMixIn")
(PUNCT ",")
(ID "UDPServer")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(KEYWORD class)
(ID "ForkingTCPServer")
(PUNCT "(")
(ID "ForkingMixIn")
(PUNCT ",")
(ID "TCPServer")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(KEYWORD class)
(ID "ThreadingUDPServer")
(PUNCT "(")
(ID "ThreadingMixIn")
(PUNCT ",")
(ID "UDPServer")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(KEYWORD class)
(ID "ThreadingTCPServer")
(PUNCT "(")
(ID "ThreadingMixIn")
(PUNCT ",")
(ID "TCPServer")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "socket")
(PUNCT ",")
(LIT "AF_UNIX")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD class)
(ID "UnixStreamServer")
(PUNCT "(")
(ID "TCPServer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_family")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "AF_UNIX")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "UnixDatagramServer")
(PUNCT "(")
(ID "UDPServer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_family")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "AF_UNIX")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "ThreadingUnixStreamServer")
(PUNCT "(")
(ID "ThreadingMixIn")
(PUNCT ",")
(ID "UnixStreamServer")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(KEYWORD class)
(ID "ThreadingUnixDatagramServer")
(PUNCT "(")
(ID "ThreadingMixIn")
(PUNCT ",")
(ID "UnixDatagramServer")
(PUNCT ")")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "BaseRequestHandler")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for request handler classes.\n\n    This class is instantiated for each request to be handled.  The\n    constructor sets the instance variables request, client_address\n    and server, and then calls the handle() method.  To implement a\n    specific service, all you need to do is to derive a class which\n    defines a handle() method.\n\n    The handle() method can find the request as self.request, the\n    client address as self.client_address, and the server (in case it\n    needs access to per-server information) as self.server.  Since a\n    separate instance is created for each request, the handle() method\n    can define arbitrary other instance variariables.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "request")
(PUNCT ",")
(ID "client_address")
(PUNCT ",")
(ID "server")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "request")
(PUNCT "=")
(ID "request")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "client_address")
(PUNCT "=")
(ID "client_address")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "server")
(PUNCT "=")
(ID "server")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "setup")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "handle")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "finish")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "setup")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "handle")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "finish")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "StreamRequestHandler")
(PUNCT "(")
(ID "BaseRequestHandler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Define self.rfile and self.wfile for stream sockets.")
(NEWLINE)
(ID "rbufsize")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "wbufsize")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "disable_nagle_algorithm")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD def)
(ID "setup")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "connection")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "request")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "connection")
(PUNCT ".")
(ID "settimeout")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "disable_nagle_algorithm")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "connection")
(PUNCT ".")
(ID "setsockopt")
(PUNCT "(")
(ID "socket")
(PUNCT ".")
(ID "IPPROTO_TCP")
(PUNCT ",")
(ID "socket")
(PUNCT ".")
(ID "TCP_NODELAY")
(PUNCT ",")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "rfile")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "connection")
(PUNCT ".")
(ID "makefile")
(PUNCT "(")
(LIT "rb")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "rbufsize")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "wfile")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "connection")
(PUNCT ".")
(ID "makefile")
(PUNCT "(")
(LIT "wb")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "wbufsize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "finish")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "wfile")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "wfile")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "socket")
(PUNCT ".")
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "wfile")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rfile")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DatagramRequestHandler")
(PUNCT "(")
(ID "BaseRequestHandler")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Define self.rfile and self.wfile for datagram sockets.")
(NEWLINE)
(KEYWORD def)
(ID "setup")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "io")
(KEYWORD import)
(ID "BytesIO")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "packet")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "request")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rfile")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "packet")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "wfile")
(PUNCT "=")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "finish")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "sendto")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "wfile")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "client_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
