(LIT "Lightweight XML support for Python.\n\n XML is an inherently hierarchical data format, and the most natural way to\n represent it is with a tree.  This module has two classes for this purpose:\n\n    1. ElementTree represents the whole XML document as a tree and\n\n    2. Element represents a single node in this tree.\n\n Interactions with the whole document (reading and writing to/from files) are\n usually done on the ElementTree level.  Interactions with a single XML element\n and its sub-elements are done on the Element level.\n\n Element is a flexible container object designed to store hierarchical data\n structures in memory. It can be described as a cross between a list and a\n dictionary.  Each Element has a number of properties associated with it:\n\n    'tag' - a string containing the element's name.\n\n    'attributes' - a Python dictionary storing the element's attributes.\n\n    'text' - a string containing the element's text content.\n\n    'tail' - an optional string containing text after the element's end tag.\n\n    And a number of child elements stored in a Python sequence.\n\n To create an element instance, use the Element constructor,\n or the SubElement factory function.\n\n You can also use the ElementTree class to wrap an element structure\n and convert it to and from XML.\n\n")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Comment")
(PUNCT ",")
(LIT "dump")
(PUNCT ",")
(LIT "Element")
(PUNCT ",")
(LIT "ElementTree")
(PUNCT ",")
(LIT "fromstring")
(PUNCT ",")
(LIT "fromstringlist")
(PUNCT ",")
(LIT "iselement")
(PUNCT ",")
(LIT "iterparse")
(PUNCT ",")
(LIT "parse")
(PUNCT ",")
(LIT "ParseError")
(PUNCT ",")
(LIT "PI")
(PUNCT ",")
(LIT "ProcessingInstruction")
(PUNCT ",")
(LIT "QName")
(PUNCT ",")
(LIT "SubElement")
(PUNCT ",")
(LIT "tostring")
(PUNCT ",")
(LIT "tostringlist")
(PUNCT ",")
(LIT "TreeBuilder")
(PUNCT ",")
(LIT "VERSION")
(PUNCT ",")
(LIT "XML")
(PUNCT ",")
(LIT "XMLID")
(PUNCT ",")
(LIT "XMLParser")
(PUNCT ",")
(LIT "register_namespace")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(ID "VERSION")
(PUNCT "=")
(LIT "1.3.0")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD import)
(ID "contextlib")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "ElementPath")
(NEWLINE)
(KEYWORD class)
(ID "ParseError")
(PUNCT "(")
(ID "SyntaxError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "An error when parsing an XML document.\n\n    In addition to its exception value, a ParseError contains\n    two extra attributes:\n        'code'     - the specific exception code\n        'position' - the line and column of the error\n\n    ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iselement")
(PUNCT "(")
(ID "element")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return True if *element* appears to be an Element.")
(NEWLINE)
(KEYWORD return)
(ID "hasattr")
(PUNCT "(")
(ID "element")
(PUNCT ",")
(LIT "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Element")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "An XML element.\n\n    This class is the reference implementation of the Element interface.\n\n    An element's length is its number of subelements.  That means if you\n    want to check if an element is truly empty, you should check BOTH\n    its length AND its text attribute.\n\n    The element tag, attribute names, and attribute values can be either\n    bytes or strings.\n\n    *tag* is the element name.  *attrib* is an optional dictionary containing\n    element attributes. *extra* are additional element attributes given as\n    keyword arguments.\n\n    Example form:\n        <tag attrib>text<child/>...</tag>tail\n\n    ")
(NEWLINE)
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(LIT "The element's name.")
(NEWLINE)
(ID "attrib")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(LIT "Dictionary of the element's attributes.")
(NEWLINE)
(ID "text")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(LIT "\n    Text before first subelement. This is either a string or the value None.\n    Note that if there is no text, this attribute may be either\n    None or the empty string, depending on the parser.\n\n    ")
(NEWLINE)
(ID "tail")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(LIT "\n    Text after this element's end tag, but before the next sibling element's\n    start tag.  This is either a string or the value None.  Note that if there\n    was no text, this attribute may be either None or an empty string,\n    depending on the parser.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ",")
(ID "attrib")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(PUNCT ",")
(PUNCT "**")
(ID "extra")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "attrib")
(PUNCT ",")
(ID "dict")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "attrib must be dict, not %s")
(PUNCT "%")
(PUNCT "(")
(ID "attrib")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "attrib")
(PUNCT "=")
(ID "attrib")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "attrib")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "extra")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tag")
(PUNCT "=")
(ID "tag")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT "=")
(ID "attrib")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<Element %s at 0x%x>")
(PUNCT "%")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "tag")
(PUNCT ")")
(PUNCT ",")
(ID "id")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "makeelement")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ",")
(ID "attrib")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a new element with the same type.\n\n        *tag* is a string containing the element name.\n        *attrib* is a dictionary containing the element attributes.\n\n        Do not call this method, use the SubElement factory function instead.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "attrib")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copy")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return copy of current element.\n\n        This creates a shallow copy. Subelements will be shared with the\n        original tree.\n\n        ")
(NEWLINE)
(ID "elem")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "makeelement")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "tag")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT ")")
(NEWLINE)
(ID "elem")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "text")
(NEWLINE)
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tail")
(NEWLINE)
(ID "elem")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD return)
(ID "elem")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bool__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The behavior of this method will change in future versions.  ")
(LIT "Use specific 'len(elem)' or 'elem is not None' test instead.")
(PUNCT ",")
(ID "FutureWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ")")
(PUNCT "!=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT "[")
(ID "index")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ",")
(ID "element")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT "[")
(ID "index")
(PUNCT "]")
(PUNCT "=")
(ID "element")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT "[")
(ID "index")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "subelement")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add *subelement* to the end of this element.\n\n        The new element will appear in document order after the last existing\n        subelement (or directly after the text, if it's the first subelement),\n        but before the end tag for this element.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_assert_is_element")
(PUNCT "(")
(ID "subelement")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "subelement")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "extend")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "elements")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Append subelements from a sequence.\n\n        *elements* is a sequence with zero or more elements.\n\n        ")
(NEWLINE)
(KEYWORD for)
(ID "element")
(KEYWORD in)
(ID "elements")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_assert_is_element")
(PUNCT "(")
(ID "element")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "elements")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "insert")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "index")
(PUNCT ",")
(ID "subelement")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Insert *subelement* at position *index*.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_assert_is_element")
(PUNCT "(")
(ID "subelement")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(ID "index")
(PUNCT ",")
(ID "subelement")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_assert_is_element")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "e")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "e")
(PUNCT ",")
(ID "_Element_Py")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "expected an Element, not %s")
(PUNCT "%")
(ID "type")
(PUNCT "(")
(ID "e")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "remove")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "subelement")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove matching subelement.\n\n        Unlike the find methods, this method compares elements based on\n        identity, NOT ON tag value or contents.  To remove subelements by\n        other means, the easiest way is to use a list comprehension to\n        select what elements to keep, and then use slice assignment to update\n        the parent element.\n\n        ValueError is raised if a matching element could not be found.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(ID "subelement")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getchildren")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "(Deprecated) Return all subelements.\n\n        Elements are returned in document order.\n\n        ")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This method will be removed in future versions.  ")
(LIT "Use 'list(elem)' or iteration over elem instead.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_children")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find first matching element by tag name or path.\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return the first matching element, or None if no element was found.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "ElementPath")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "findtext")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find text for first matching element by tag name or path.\n\n        *path* is a string having either an element tag or an XPath,\n        *default* is the value to return if the element was not found,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return text content of first matching element, or default value if\n        none was found.  Note that if an element is found having no text\n        content, the empty string is returned.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "ElementPath")
(PUNCT ".")
(ID "findtext")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "default")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "findall")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find all matching subelements by tag name or path.\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Returns list containing all matching elements in document order.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "ElementPath")
(PUNCT ".")
(ID "findall")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iterfind")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find all matching subelements by tag name or path.\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return an iterable yielding all matching elements in document order.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "ElementPath")
(PUNCT ".")
(ID "iterfind")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clear")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Reset element.\n\n        This function removes all subelements, clears all attributes, and sets\n        the text and tail attributes to None.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tail")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get element attribute.\n\n        Equivalent to attrib.get, but some implementations may handle this a\n        bit more efficiently.  *key* is what attribute to look for, and\n        *default* is what to return if the attribute was not found.\n\n        Returns a string containing the attribute value, or the default if\n        attribute was not found.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "default")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set element attribute.\n\n        Equivalent to attrib[key] = value, but some implementations may handle\n        this a bit more efficiently.  *key* is what attribute to set, and\n        *value* is the attribute value to set it to.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "keys")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get list of attribute names.\n\n        Names are returned in an arbitrary order, just like an ordinary\n        Python dict.  Equivalent to attrib.keys()\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "items")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get element attributes as a sequence.\n\n        The attributes are returned in arbitrary order.  Equivalent to\n        attrib.items().\n\n        Return a list of (name, value) tuples.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "attrib")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create tree iterator.\n\n        The iterator loops over the element and all subelements in document\n        order, returning all elements with a matching tag.\n\n        If the tree structure is modified during iteration, new or removed\n        elements may or may not be included.  To get a stable set, use the\n        list() function on the iterator, and loop over the resulting list.\n\n        *tag* is what tags to look for (default is to return all elements)\n\n        Return an iterator containing all the matching elements.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "tag")
(PUNCT "==")
(LIT "*")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "tag")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "tag")
(PUNCT "==")
(ID "tag")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "e")
(PUNCT ".")
(ID "iter")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getiterator")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This method will be removed in future versions.  ")
(LIT "Use 'elem.iter()' or 'list(elem.iter())' instead.")
(PUNCT ",")
(ID "PendingDeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "iter")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "itertext")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create text iterator.\n\n        The iterator loops over the element and all subelements in document\n        order, returning all inner text.\n\n        ")
(NEWLINE)
(ID "tag")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tag")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(KEYWORD and)
(ID "tag")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "e")
(PUNCT ".")
(ID "itertext")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "e")
(PUNCT ".")
(ID "tail")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "SubElement")
(PUNCT "(")
(ID "parent")
(PUNCT ",")
(ID "tag")
(PUNCT ",")
(ID "attrib")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(PUNCT ",")
(PUNCT "**")
(ID "extra")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Subelement factory which creates an element instance, and appends it\n    to an existing parent.\n\n    The element tag, attribute names, and attribute values can be either\n    bytes or Unicode strings.\n\n    *parent* is the parent element, *tag* is the subelements name, *attrib* is\n    an optional directory containing element attributes, *extra* are\n    additional attributes given as keyword arguments.\n\n    ")
(NEWLINE)
(ID "attrib")
(PUNCT "=")
(ID "attrib")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "attrib")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "extra")
(PUNCT ")")
(NEWLINE)
(ID "element")
(PUNCT "=")
(ID "parent")
(PUNCT ".")
(ID "makeelement")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "attrib")
(PUNCT ")")
(NEWLINE)
(ID "parent")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "element")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "element")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "Comment")
(PUNCT "(")
(ID "text")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Comment element factory.\n\n    This function creates a special element which the standard serializer\n    serializes as an XML comment.\n\n    *text* is a string containing the comment string.\n\n    ")
(NEWLINE)
(ID "element")
(PUNCT "=")
(ID "Element")
(PUNCT "(")
(ID "Comment")
(PUNCT ")")
(NEWLINE)
(ID "element")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "text")
(NEWLINE)
(KEYWORD return)
(ID "element")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "ProcessingInstruction")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(ID "text")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Processing Instruction element factory.\n\n    This function creates a special element which the standard serializer\n    serializes as an XML comment.\n\n    *target* is a string containing the processing instruction, *text* is a\n    string containing the processing instruction contents, if any.\n\n    ")
(NEWLINE)
(ID "element")
(PUNCT "=")
(ID "Element")
(PUNCT "(")
(ID "ProcessingInstruction")
(PUNCT ")")
(NEWLINE)
(ID "element")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "target")
(NEWLINE)
(KEYWORD if)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "element")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "element")
(PUNCT ".")
(ID "text")
(PUNCT "+")
(LIT " ")
(PUNCT "+")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "element")
(NEWLINE)
(DEDENT)
(ID "PI")
(PUNCT "=")
(ID "ProcessingInstruction")
(NEWLINE)
(KEYWORD class)
(ID "QName")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Qualified name wrapper.\n\n    This class can be used to wrap a QName attribute value in order to get\n    proper namespace handing on output.\n\n    *text_or_uri* is a string containing the QName value either in the form\n    {uri}local, or if the tag argument is given, the URI part of a QName.\n\n    *tag* is an optional argument which if given, will make the first\n    argument (text_or_uri) be interpreted as a URI, and this argument (tag)\n    be interpreted as a local name.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text_or_uri")
(PUNCT ",")
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text_or_uri")
(PUNCT "=")
(LIT "{%s}%s")
(PUNCT "%")
(PUNCT "(")
(ID "text_or_uri")
(PUNCT ",")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "text_or_uri")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<QName %r>")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "hash")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__le__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "<=")
(ID "other")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "<=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "<")
(ID "other")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "<")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ge__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ">=")
(ID "other")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ">=")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__gt__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ">")
(ID "other")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT ">")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "==")
(ID "other")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ne__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "!=")
(ID "other")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "text")
(PUNCT "!=")
(ID "other")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ElementTree")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "An XML element hierarchy.\n\n    This class also provides support for serialization to and from\n    standard XML.\n\n    *element* is an optional root element node,\n    *file* is an optional file handle or file name of an XML file whose\n    contents will be used to initialize the tree with.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "element")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT "=")
(ID "element")
(NEWLINE)
(KEYWORD if)
(ID "file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "parse")
(PUNCT "(")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getroot")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return root element of this tree.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_setroot")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "element")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Replace root element of this tree.\n\n        This will discard the current contents of the tree and replace it\n        with the given element.  Use with care!\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT "=")
(ID "element")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Load external XML document into element tree.\n\n        *source* is a file name or file object, *parser* is an optional parser\n        instance that defaults to XMLParser.\n\n        ParseError is raised if the parser fails to parse the document.\n\n        Returns the root element of the given source document.\n\n        ")
(NEWLINE)
(ID "close_source")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(LIT "read")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(NEWLINE)
(ID "close_source")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "parser")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "XMLParser")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "parser")
(PUNCT ",")
(LIT "_parse_whole")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "_parse_whole")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "source")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 65536)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "close_source")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "iter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create and return tree iterator for the root element.\n\n        The iterator loops over all elements in this tree, in document order.\n\n        *tag* is a string with the tag name to iterate over\n        (default is to return all elements).\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ".")
(ID "iter")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getiterator")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This method will be removed in future versions.  ")
(LIT "Use 'tree.iter()' or 'list(tree.iter())' instead.")
(PUNCT ",")
(ID "PendingDeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "iter")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "find")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find first matching element by tag name or path.\n\n        Same as getroot().find(path), which is Element.find()\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return the first matching element, or None if no element was found.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "path")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(LIT ".")
(PUNCT "+")
(ID "path")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This search is broken in 1.3 and earlier, and will be ")
(LIT "fixed in a future version.  If you rely on the current ")
(LIT "behaviour, change it to %r")
(PUNCT "%")
(ID "path")
(PUNCT ",")
(ID "FutureWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "findtext")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find first matching element by tag name or path.\n\n        Same as getroot().findtext(path),  which is Element.findtext()\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return the first matching element, or None if no element was found.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "path")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(LIT ".")
(PUNCT "+")
(ID "path")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This search is broken in 1.3 and earlier, and will be ")
(LIT "fixed in a future version.  If you rely on the current ")
(LIT "behaviour, change it to %r")
(PUNCT "%")
(ID "path")
(PUNCT ",")
(ID "FutureWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ".")
(ID "findtext")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "default")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "findall")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find all matching subelements by tag name or path.\n\n        Same as getroot().findall(path), which is Element.findall().\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return list containing all matching elements in document order.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "path")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(LIT ".")
(PUNCT "+")
(ID "path")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This search is broken in 1.3 and earlier, and will be ")
(LIT "fixed in a future version.  If you rely on the current ")
(LIT "behaviour, change it to %r")
(PUNCT "%")
(ID "path")
(PUNCT ",")
(ID "FutureWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ".")
(ID "findall")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iterfind")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find all matching subelements by tag name or path.\n\n        Same as getroot().iterfind(path), which is element.iterfind()\n\n        *path* is a string having either an element tag or an XPath,\n        *namespaces* is an optional mapping from namespace prefix to full name.\n\n        Return an iterable yielding all matching elements in document order.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "path")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(LIT ".")
(PUNCT "+")
(ID "path")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This search is broken in 1.3 and earlier, and will be ")
(LIT "fixed in a future version.  If you rely on the current ")
(LIT "behaviour, change it to %r")
(PUNCT "%")
(ID "path")
(PUNCT ",")
(ID "FutureWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ".")
(ID "iterfind")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "file_or_filename")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "xml_declaration")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "default_namespace")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "method")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write element tree to a file as XML.\n\n        Arguments:\n          *file_or_filename* -- file name or a file object opened for writing\n\n          *encoding* -- the output encoding (default: US-ASCII)\n\n          *xml_declaration* -- bool indicating if an XML declaration should be\n                               added to the output. If None, an XML declaration\n                               is added if encoding IS NOT either of:\n                               US-ASCII, UTF-8, or Unicode\n\n          *default_namespace* -- sets the default XML namespace (for \"xmlns\")\n\n          *method* -- either \"xml\" (default), \"html, \"text\", or \"c14n\"\n\n          *short_empty_elements* -- controls the formatting of elements\n                                    that contain no content. If True (default)\n                                    they are emitted as a single self-closed\n                                    tag, otherwise they are emitted as a pair\n                                    of start/end tags\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "method")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "method")
(PUNCT "=")
(LIT "xml")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "method")
(KEYWORD not)
(KEYWORD in)
(ID "_serialize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown method %r")
(PUNCT "%")
(ID "method")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "encoding")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "method")
(PUNCT "==")
(LIT "c14n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(LIT "utf-8")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(LIT "us-ascii")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "_get_writer")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ",")
(ID "encoding")
(PUNCT ")")
(KEYWORD as)
(ID "write")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "method")
(PUNCT "==")
(LIT "xml")
(KEYWORD and)
(PUNCT "(")
(ID "xml_declaration")
(KEYWORD or)
(PUNCT "(")
(ID "xml_declaration")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "encoding")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "utf-8")
(PUNCT ",")
(LIT "us-ascii")
(PUNCT ",")
(LIT "unicode")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "declared_encoding")
(PUNCT "=")
(ID "encoding")
(NEWLINE)
(KEYWORD if)
(ID "encoding")
(PUNCT "==")
(LIT "unicode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "locale")
(NEWLINE)
(ID "declared_encoding")
(PUNCT "=")
(ID "locale")
(PUNCT ".")
(ID "getpreferredencoding")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT "<?xml version='1.0' encoding='%s'?>\n")
(PUNCT "%")
(PUNCT "(")
(ID "declared_encoding")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "method")
(PUNCT "==")
(LIT "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_serialize_text")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qnames")
(PUNCT ",")
(ID "namespaces")
(PUNCT "=")
(ID "_namespaces")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ",")
(ID "default_namespace")
(PUNCT ")")
(NEWLINE)
(ID "serialize")
(PUNCT "=")
(ID "_serialize")
(PUNCT "[")
(ID "method")
(PUNCT "]")
(NEWLINE)
(ID "serialize")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(ID "namespaces")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(ID "short_empty_elements")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "write_c14n")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "file")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "method")
(PUNCT "=")
(LIT "c14n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "contextlib")
(PUNCT ".")
(ID "contextmanager")
(NEWLINE)
(KEYWORD def)
(ID "_get_writer")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ",")
(ID "encoding")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "=")
(ID "file_or_filename")
(PUNCT ".")
(ID "write")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "encoding")
(PUNCT "==")
(LIT "unicode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ",")
(LIT "w")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "xmlcharrefreplace")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "file")
(PUNCT ".")
(ID "write")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "encoding")
(PUNCT "==")
(LIT "unicode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "write")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "contextlib")
(PUNCT ".")
(ID "ExitStack")
(PUNCT "(")
(PUNCT ")")
(KEYWORD as)
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ",")
(ID "io")
(PUNCT ".")
(ID "BufferedIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "file_or_filename")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ",")
(ID "io")
(PUNCT ".")
(ID "RawIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BufferedWriter")
(PUNCT "(")
(ID "file_or_filename")
(PUNCT ")")
(NEWLINE)
(ID "stack")
(PUNCT ".")
(ID "callback")
(PUNCT "(")
(ID "file")
(PUNCT ".")
(ID "detach")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BufferedIOBase")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "file")
(PUNCT ".")
(ID "writable")
(PUNCT "=")
(KEYWORD lambda)
(PUNCT ":")
(KEYWORD True)
(NEWLINE)
(ID "file")
(PUNCT ".")
(ID "write")
(PUNCT "=")
(ID "write")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT ".")
(ID "seekable")
(PUNCT "=")
(ID "file_or_filename")
(PUNCT ".")
(ID "seekable")
(NEWLINE)
(ID "file")
(PUNCT ".")
(ID "tell")
(PUNCT "=")
(ID "file_or_filename")
(PUNCT ".")
(ID "tell")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "file")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "TextIOWrapper")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(LIT "xmlcharrefreplace")
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(ID "stack")
(PUNCT ".")
(ID "callback")
(PUNCT "(")
(ID "file")
(PUNCT ".")
(ID "detach")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "file")
(PUNCT ".")
(ID "write")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_namespaces")
(PUNCT "(")
(ID "elem")
(PUNCT ",")
(ID "default_namespace")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qnames")
(PUNCT "=")
(PUNCT "{")
(KEYWORD None)
(PUNCT ":")
(KEYWORD None)
(PUNCT "}")
(NEWLINE)
(ID "namespaces")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "default_namespace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "namespaces")
(PUNCT "[")
(ID "default_namespace")
(PUNCT "]")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_qname")
(PUNCT "(")
(ID "qname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "qname")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "{")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "uri")
(PUNCT ",")
(ID "tag")
(PUNCT "=")
(ID "qname")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "rsplit")
(PUNCT "(")
(LIT "}")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "prefix")
(PUNCT "=")
(ID "namespaces")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "uri")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "prefix")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefix")
(PUNCT "=")
(ID "_namespace_map")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "uri")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "prefix")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefix")
(PUNCT "=")
(LIT "ns%d")
(PUNCT "%")
(ID "len")
(PUNCT "(")
(ID "namespaces")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "prefix")
(PUNCT "!=")
(LIT "xml")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "namespaces")
(PUNCT "[")
(ID "uri")
(PUNCT "]")
(PUNCT "=")
(ID "prefix")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "prefix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qnames")
(PUNCT "[")
(ID "qname")
(PUNCT "]")
(PUNCT "=")
(LIT "%s:%s")
(PUNCT "%")
(PUNCT "(")
(ID "prefix")
(PUNCT ",")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "qnames")
(PUNCT "[")
(ID "qname")
(PUNCT "]")
(PUNCT "=")
(ID "tag")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "default_namespace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "cannot use non-qualified names with ")
(LIT "default_namespace option")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "qnames")
(PUNCT "[")
(ID "qname")
(PUNCT "]")
(PUNCT "=")
(ID "qname")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "TypeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_raise_serialization_error")
(PUNCT "(")
(ID "qname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "elem")
(KEYWORD in)
(ID "elem")
(PUNCT ".")
(ID "iter")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "tag")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(PUNCT ".")
(ID "text")
(KEYWORD not)
(KEYWORD in)
(ID "qnames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "add_qname")
(PUNCT "(")
(ID "tag")
(PUNCT ".")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "tag")
(KEYWORD not)
(KEYWORD in)
(ID "qnames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "add_qname")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "tag")
(KEYWORD is)
(KEYWORD not)
(ID "Comment")
(KEYWORD and)
(ID "tag")
(KEYWORD is)
(KEYWORD not)
(ID "PI")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_raise_serialization_error")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "elem")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "=")
(ID "key")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "key")
(KEYWORD not)
(KEYWORD in)
(ID "qnames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "add_qname")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(KEYWORD and)
(ID "value")
(PUNCT ".")
(ID "text")
(KEYWORD not)
(KEYWORD in)
(ID "qnames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "add_qname")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "text")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(KEYWORD and)
(ID "text")
(PUNCT ".")
(ID "text")
(KEYWORD not)
(KEYWORD in)
(ID "qnames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "add_qname")
(PUNCT "(")
(ID "text")
(PUNCT ".")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "qnames")
(PUNCT ",")
(ID "namespaces")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_serialize_xml")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "elem")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(ID "namespaces")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "tag")
(NEWLINE)
(ID "text")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "text")
(NEWLINE)
(KEYWORD if)
(ID "tag")
(KEYWORD is)
(ID "Comment")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "<!--%s-->")
(PUNCT "%")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(KEYWORD is)
(ID "ProcessingInstruction")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "<?%s?>")
(PUNCT "%")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(ID "qnames")
(PUNCT "[")
(ID "tag")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "tag")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "elem")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_serialize_xml")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(ID "short_empty_elements")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "<")
(PUNCT "+")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(ID "items")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "elem")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "items")
(KEYWORD or)
(ID "namespaces")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "namespaces")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "v")
(PUNCT ",")
(ID "k")
(KEYWORD in)
(ID "sorted")
(PUNCT "(")
(ID "namespaces")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(KEYWORD lambda)
(ID "x")
(PUNCT ":")
(ID "x")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(LIT ":")
(PUNCT "+")
(ID "k")
(NEWLINE)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT " xmlns%s=\"%s\"")
(PUNCT "%")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "_escape_attrib")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "sorted")
(PUNCT "(")
(ID "items")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "k")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "qnames")
(PUNCT "[")
(ID "v")
(PUNCT ".")
(ID "text")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "_escape_attrib")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT " %s=\"%s\"")
(PUNCT "%")
(PUNCT "(")
(ID "qnames")
(PUNCT "[")
(ID "k")
(PUNCT "]")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "text")
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "elem")
(PUNCT ")")
(KEYWORD or)
(KEYWORD not)
(ID "short_empty_elements")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT ">")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "elem")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_serialize_xml")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(ID "short_empty_elements")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT "</")
(PUNCT "+")
(ID "tag")
(PUNCT "+")
(LIT ">")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT " />")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "_escape_cdata")
(PUNCT "(")
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "HTML_EMPTY")
(PUNCT "=")
(PUNCT "(")
(LIT "area")
(PUNCT ",")
(LIT "base")
(PUNCT ",")
(LIT "basefont")
(PUNCT ",")
(LIT "br")
(PUNCT ",")
(LIT "col")
(PUNCT ",")
(LIT "frame")
(PUNCT ",")
(LIT "hr")
(PUNCT ",")
(LIT "img")
(PUNCT ",")
(LIT "input")
(PUNCT ",")
(LIT "isindex")
(PUNCT ",")
(LIT "link")
(PUNCT ",")
(LIT "meta")
(PUNCT ",")
(LIT "param")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "HTML_EMPTY")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "HTML_EMPTY")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NameError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_serialize_html")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "elem")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(ID "namespaces")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "tag")
(NEWLINE)
(ID "text")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "text")
(NEWLINE)
(KEYWORD if)
(ID "tag")
(KEYWORD is)
(ID "Comment")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "<!--%s-->")
(PUNCT "%")
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "tag")
(KEYWORD is)
(ID "ProcessingInstruction")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "<?%s?>")
(PUNCT "%")
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tag")
(PUNCT "=")
(ID "qnames")
(PUNCT "[")
(ID "tag")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "tag")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "elem")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_serialize_html")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "<")
(PUNCT "+")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(ID "items")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "elem")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "items")
(KEYWORD or)
(ID "namespaces")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "namespaces")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "v")
(PUNCT ",")
(ID "k")
(KEYWORD in)
(ID "sorted")
(PUNCT "(")
(ID "namespaces")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "key")
(PUNCT "=")
(KEYWORD lambda)
(ID "x")
(PUNCT ":")
(ID "x")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(LIT ":")
(PUNCT "+")
(ID "k")
(NEWLINE)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT " xmlns%s=\"%s\"")
(PUNCT "%")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "_escape_attrib")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "sorted")
(PUNCT "(")
(ID "items")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "k")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "k")
(PUNCT "=")
(ID "k")
(PUNCT ".")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "v")
(PUNCT ",")
(ID "QName")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "qnames")
(PUNCT "[")
(ID "v")
(PUNCT ".")
(ID "text")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "_escape_attrib_html")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT " %s=\"%s\"")
(PUNCT "%")
(PUNCT "(")
(ID "qnames")
(PUNCT "[")
(ID "k")
(PUNCT "]")
(PUNCT ",")
(ID "v")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "write")
(PUNCT "(")
(LIT ">")
(PUNCT ")")
(NEWLINE)
(ID "ltag")
(PUNCT "=")
(ID "tag")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ltag")
(PUNCT "==")
(LIT "script")
(KEYWORD or)
(ID "ltag")
(PUNCT "==")
(LIT "style")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "elem")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_serialize_html")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "e")
(PUNCT ",")
(ID "qnames")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "ltag")
(KEYWORD not)
(KEYWORD in)
(ID "HTML_EMPTY")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(LIT "</")
(PUNCT "+")
(ID "tag")
(PUNCT "+")
(LIT ">")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "_escape_cdata")
(PUNCT "(")
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_serialize_text")
(PUNCT "(")
(ID "write")
(PUNCT ",")
(ID "elem")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "part")
(KEYWORD in)
(ID "elem")
(PUNCT ".")
(ID "itertext")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "part")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "write")
(PUNCT "(")
(ID "elem")
(PUNCT ".")
(ID "tail")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_serialize")
(PUNCT "=")
(PUNCT "{")
(LIT "xml")
(PUNCT ":")
(ID "_serialize_xml")
(PUNCT ",")
(LIT "html")
(PUNCT ":")
(ID "_serialize_html")
(PUNCT ",")
(LIT "text")
(PUNCT ":")
(ID "_serialize_text")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "register_namespace")
(PUNCT "(")
(ID "prefix")
(PUNCT ",")
(ID "uri")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Register a namespace prefix.\n\n    The registry is global, and any existing mapping for either the\n    given prefix or the namespace URI will be removed.\n\n    *prefix* is the namespace prefix, *uri* is a namespace uri. Tags and\n    attributes in this namespace will be serialized with prefix if possible.\n\n    ValueError is raised if prefix is reserved or is invalid.\n\n    ")
(NEWLINE)
(KEYWORD if)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "ns\\d+$")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Prefix format reserved for internal use")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "k")
(PUNCT ",")
(ID "v")
(KEYWORD in)
(ID "list")
(PUNCT "(")
(ID "_namespace_map")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "k")
(PUNCT "==")
(ID "uri")
(KEYWORD or)
(ID "v")
(PUNCT "==")
(ID "prefix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "_namespace_map")
(PUNCT "[")
(ID "k")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_namespace_map")
(PUNCT "[")
(ID "uri")
(PUNCT "]")
(PUNCT "=")
(ID "prefix")
(NEWLINE)
(DEDENT)
(ID "_namespace_map")
(PUNCT "=")
(PUNCT "{")
(LIT "http://www.w3.org/XML/1998/namespace")
(PUNCT ":")
(LIT "xml")
(PUNCT ",")
(LIT "http://www.w3.org/1999/xhtml")
(PUNCT ":")
(LIT "html")
(PUNCT ",")
(LIT "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
(PUNCT ":")
(LIT "rdf")
(PUNCT ",")
(LIT "http://schemas.xmlsoap.org/wsdl/")
(PUNCT ":")
(LIT "wsdl")
(PUNCT ",")
(LIT "http://www.w3.org/2001/XMLSchema")
(PUNCT ":")
(LIT "xs")
(PUNCT ",")
(LIT "http://www.w3.org/2001/XMLSchema-instance")
(PUNCT ":")
(LIT "xsi")
(PUNCT ",")
(LIT "http://purl.org/dc/elements/1.1/")
(PUNCT ":")
(LIT "dc")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "register_namespace")
(PUNCT ".")
(ID "_namespace_map")
(PUNCT "=")
(ID "_namespace_map")
(NEWLINE)
(KEYWORD def)
(ID "_raise_serialization_error")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "cannot serialize %r (type %s)")
(PUNCT "%")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_escape_cdata")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "&")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "&")
(PUNCT ",")
(LIT "&amp;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "<")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "<")
(PUNCT ",")
(LIT "&lt;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT ">")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ">")
(PUNCT ",")
(LIT "&gt;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_raise_serialization_error")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_escape_attrib")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "&")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "&")
(PUNCT ",")
(LIT "&amp;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "<")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "<")
(PUNCT ",")
(LIT "&lt;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT ">")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ">")
(PUNCT ",")
(LIT "&gt;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "\"")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\"")
(PUNCT ",")
(LIT "&quot;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "\n")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(LIT "&#10;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_raise_serialization_error")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_escape_attrib_html")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "&")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "&")
(PUNCT ",")
(LIT "&amp;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT ">")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT ">")
(PUNCT ",")
(LIT "&gt;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "\"")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\"")
(PUNCT ",")
(LIT "&quot;")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "TypeError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_raise_serialization_error")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "tostring")
(PUNCT "(")
(ID "element")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "method")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate string representation of XML element.\n\n    All subelements are included.  If encoding is \"unicode\", a string\n    is returned. Otherwise a bytestring is returned.\n\n    *element* is an Element instance, *encoding* is an optional output\n    encoding defaulting to US-ASCII, *method* is an optional output which can\n    be one of \"xml\" (default), \"html\", \"text\" or \"c14n\".\n\n    Returns an (optionally) encoded string containing the XML data.\n\n    ")
(NEWLINE)
(ID "stream")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "encoding")
(PUNCT "==")
(LIT "unicode")
(KEYWORD else)
(ID "io")
(PUNCT ".")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "ElementTree")
(PUNCT "(")
(ID "element")
(PUNCT ")")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "stream")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "method")
(PUNCT "=")
(ID "method")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(ID "short_empty_elements")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "stream")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_ListDataStream")
(PUNCT "(")
(ID "io")
(PUNCT ".")
(ID "BufferedIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "An auxiliary stream accumulating into a list reference.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lst")
(PUNCT "=")
(ID "lst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seekable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lst")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "tell")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "lst")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "tostringlist")
(PUNCT "(")
(ID "element")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "method")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lst")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "stream")
(PUNCT "=")
(ID "_ListDataStream")
(PUNCT "(")
(ID "lst")
(PUNCT ")")
(NEWLINE)
(ID "ElementTree")
(PUNCT "(")
(ID "element")
(PUNCT ")")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "stream")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "method")
(PUNCT "=")
(ID "method")
(PUNCT ",")
(ID "short_empty_elements")
(PUNCT "=")
(ID "short_empty_elements")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "lst")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "dump")
(PUNCT "(")
(ID "elem")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write element tree or element structure to sys.stdout.\n\n    This function should be used for debugging only.\n\n    *elem* is either an ElementTree, or a single Element.  The exact output\n    format is implementation dependent.  In this version, it's written as an\n    ordinary XML file.\n\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "elem")
(PUNCT ",")
(ID "ElementTree")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "elem")
(PUNCT "=")
(ID "ElementTree")
(PUNCT "(")
(ID "elem")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "elem")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(LIT "unicode")
(PUNCT ")")
(NEWLINE)
(ID "tail")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "getroot")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "tail")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "tail")
(KEYWORD or)
(ID "tail")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "!=")
(LIT "\n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse XML document into element tree.\n\n    *source* is a filename or file object containing XML data,\n    *parser* is an optional parser instance defaulting to XMLParser.\n\n    Return an ElementTree instance.\n\n    ")
(NEWLINE)
(ID "tree")
(PUNCT "=")
(ID "ElementTree")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "tree")
(PUNCT ".")
(ID "parse")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "parser")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "tree")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iterparse")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "events")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Incrementally parse XML document into ElementTree.\n\n    This class also reports what's going on to the user based on the\n    *events* it is initialized with.  The supported events are the strings\n    \"start\", \"end\", \"start-ns\" and \"end-ns\" (the \"ns\" events are used to get\n    detailed namespace information).  If *events* is omitted, only\n    \"end\" events are reported.\n\n    *source* is a filename or file object containing XML data, *events* is\n    a list of events to report back, *parser* is an optional parser instance.\n\n    Returns an iterator providing (event, elem) pairs.\n\n    ")
(NEWLINE)
(ID "close_source")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(LIT "read")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(NEWLINE)
(ID "close_source")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_IterParseIterator")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "events")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "close_source")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "XMLPullParser")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "events")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "_parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_events_queue")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_index")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT "=")
(ID "_parser")
(KEYWORD or)
(ID "XMLParser")
(PUNCT "(")
(ID "target")
(PUNCT "=")
(ID "TreeBuilder")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "events")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "events")
(PUNCT "=")
(PUNCT "(")
(LIT "end")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "_setevents")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_events_queue")
(PUNCT ",")
(ID "events")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "feed")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Feed encoded data to parser.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_parser")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "feed() called after end of stream")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "SyntaxError")
(KEYWORD as)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_events_queue")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_close_and_return_root")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "root")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(ID "root")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Finish feeding data to parser.\n\n        Unlike XMLParser, does not return the root element. Use\n        read_events() to consume elements from XMLPullParser.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_close_and_return_root")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_events")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an iterator over currently available (event, elem) pairs.\n\n        Events are consumed from the internal event queue as they are\n        retrieved from the iterator.\n        ")
(NEWLINE)
(ID "events")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_events_queue")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "index")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_index")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "event")
(PUNCT "=")
(ID "events")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_index")
(PUNCT "]")
(NEWLINE)
(ID "events")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_index")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "index")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "index")
(PUNCT "*")
(LIT 2)
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "events")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "events")
(PUNCT "[")
(PUNCT ":")
(ID "index")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_index")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_index")
(PUNCT "=")
(ID "index")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "event")
(PUNCT ",")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "event")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "event")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_IterParseIterator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "events")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "close_source")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT "=")
(ID "XMLPullParser")
(PUNCT "(")
(ID "events")
(PUNCT "=")
(ID "events")
(PUNCT ",")
(ID "_parser")
(PUNCT "=")
(ID "parser")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(ID "source")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_close_file")
(PUNCT "=")
(ID "close_source")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "root")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__next__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "event")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "read_events")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "event")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "_parser")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "root")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_root")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_close_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 16)
(PUNCT "*")
(LIT 1024)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_root")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "_close_and_return_root")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "XML")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse XML document from string constant.\n\n    This function can be used to embed \"XML Literals\" in Python code.\n\n    *text* is a string containing XML data, *parser* is an\n    optional parser instance, defaulting to the standard XMLParser.\n\n    Returns an Element instance.\n\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "parser")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "XMLParser")
(PUNCT "(")
(ID "target")
(PUNCT "=")
(ID "TreeBuilder")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "parser")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "XMLID")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse XML document from string constant for its IDs.\n\n    *text* is a string containing XML data, *parser* is an\n    optional parser instance, defaulting to the standard XMLParser.\n\n    Returns an (Element, dict) tuple, in which the\n    dict maps element id:s to elements.\n\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "parser")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "XMLParser")
(PUNCT "(")
(ID "target")
(PUNCT "=")
(ID "TreeBuilder")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(ID "tree")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "ids")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "elem")
(KEYWORD in)
(ID "tree")
(PUNCT ".")
(ID "iter")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "id")
(PUNCT "=")
(ID "elem")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(LIT "id")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "id")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ids")
(PUNCT "[")
(ID "id")
(PUNCT "]")
(PUNCT "=")
(ID "elem")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "tree")
(PUNCT ",")
(ID "ids")
(NEWLINE)
(DEDENT)
(ID "fromstring")
(PUNCT "=")
(ID "XML")
(NEWLINE)
(KEYWORD def)
(ID "fromstringlist")
(PUNCT "(")
(ID "sequence")
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse XML document from sequence of string fragments.\n\n    *sequence* is a list of other sequence, *parser* is an optional parser\n    instance, defaulting to the standard XMLParser.\n\n    Returns an Element instance.\n\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "parser")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "XMLParser")
(PUNCT "(")
(ID "target")
(PUNCT "=")
(ID "TreeBuilder")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "text")
(KEYWORD in)
(ID "sequence")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "feed")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "parser")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "TreeBuilder")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generic element structure builder.\n\n    This builder converts a sequence of start, data, and end method\n    calls to a well-formed element structure.\n\n    You can use this class to build an element structure using a custom XML\n    parser, or a parser for some other XML-like format.\n\n    *element_factory* is an optional element factory which is called\n    to create new Element instances, as necessary.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "element_factory")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_elem")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tail")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "element_factory")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "element_factory")
(PUNCT "=")
(ID "Element")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_factory")
(PUNCT "=")
(ID "element_factory")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Flush builder buffers and return toplevel document Element.")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_elem")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ",")
(LIT "missing end tags")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_last")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ",")
(LIT "missing toplevel element")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_last")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_flush")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_last")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_tail")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT ".")
(ID "tail")
(KEYWORD is)
(KEYWORD None)
(PUNCT ",")
(LIT "internal error (tail)")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT ".")
(ID "tail")
(PUNCT "=")
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT ".")
(ID "text")
(KEYWORD is)
(KEYWORD None)
(PUNCT ",")
(LIT "internal error (text)")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT ".")
(ID "text")
(PUNCT "=")
(ID "text")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "data")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add text to current element.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_data")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "start")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ",")
(ID "attrs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Open new element and return it.\n\n        *tag* is the element name, *attrs* is a dict containing element\n        attributes.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT "=")
(ID "elem")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_factory")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "attrs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_elem")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_elem")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "elem")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_elem")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "elem")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tail")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD return)
(ID "elem")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "end")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Close and return current Element.\n\n        *tag* is the element name.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_elem")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT ".")
(ID "tag")
(PUNCT "==")
(ID "tag")
(PUNCT ",")
(LIT "end tag mismatch (expected %s, got %s)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_last")
(PUNCT ".")
(ID "tag")
(PUNCT ",")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_tail")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_last")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "XMLParser")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Element structure builder for XML source data based on the expat parser.\n\n    *html* are predefined HTML entities (not supported currently),\n    *target* is an optional target object which defaults to an instance of the\n    standard TreeBuilder class, *encoding* is an optional encoding string\n    which if given, overrides the encoding specified in the XML file:\n    http://www.iana.org/assignments/character-sets\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "html")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "target")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "xml")
(PUNCT ".")
(ID "parsers")
(KEYWORD import)
(ID "expat")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "pyexpat")
(KEYWORD as)
(ID "expat")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ImportError")
(PUNCT "(")
(LIT "No module named expat; use SimpleXMLTreeBuilder instead")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "parser")
(PUNCT "=")
(ID "expat")
(PUNCT ".")
(ID "ParserCreate")
(PUNCT "(")
(ID "encoding")
(PUNCT ",")
(LIT "}")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "target")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "target")
(PUNCT "=")
(ID "TreeBuilder")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT "=")
(ID "parser")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_target")
(PUNCT "=")
(ID "target")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_error")
(PUNCT "=")
(ID "expat")
(PUNCT ".")
(ID "error")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_names")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "DefaultHandlerExpand")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_default")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(LIT "start")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "StartElementHandler")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_start")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(LIT "end")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "EndElementHandler")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_end")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(LIT "data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "CharacterDataHandler")
(PUNCT "=")
(ID "target")
(PUNCT ".")
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(LIT "comment")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "CommentHandler")
(PUNCT "=")
(ID "target")
(PUNCT ".")
(ID "comment")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "target")
(PUNCT ",")
(LIT "pi")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "ProcessingInstructionHandler")
(PUNCT "=")
(ID "target")
(PUNCT ".")
(ID "pi")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "buffer_text")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "ordered_attributes")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "specified_attributes")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "entity")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "version")
(PUNCT "=")
(LIT "Expat %d.%d.%d")
(PUNCT "%")
(ID "expat")
(PUNCT ".")
(ID "version_info")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_setevents")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "events_queue")
(PUNCT ",")
(ID "events_to_report")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_parser")
(NEWLINE)
(ID "append")
(PUNCT "=")
(ID "events_queue")
(PUNCT ".")
(ID "append")
(NEWLINE)
(KEYWORD for)
(ID "event_name")
(KEYWORD in)
(ID "events_to_report")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "event_name")
(PUNCT "==")
(LIT "start")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "ordered_attributes")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "specified_attributes")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD def)
(ID "handler")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "attrib_in")
(PUNCT ",")
(ID "event")
(PUNCT "=")
(ID "event_name")
(PUNCT ",")
(ID "append")
(PUNCT "=")
(ID "append")
(PUNCT ",")
(ID "start")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_start")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "event")
(PUNCT ",")
(ID "start")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "attrib_in")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "StartElementHandler")
(PUNCT "=")
(ID "handler")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "event_name")
(PUNCT "==")
(LIT "end")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "handler")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "event")
(PUNCT "=")
(ID "event_name")
(PUNCT ",")
(ID "append")
(PUNCT "=")
(ID "append")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_end")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "event")
(PUNCT ",")
(ID "end")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "EndElementHandler")
(PUNCT "=")
(ID "handler")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "event_name")
(PUNCT "==")
(LIT "start-ns")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "handler")
(PUNCT "(")
(ID "prefix")
(PUNCT ",")
(ID "uri")
(PUNCT ",")
(ID "event")
(PUNCT "=")
(ID "event_name")
(PUNCT ",")
(ID "append")
(PUNCT "=")
(ID "append")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "event")
(PUNCT ",")
(PUNCT "(")
(ID "prefix")
(KEYWORD or)
(LIT "")
(PUNCT ",")
(ID "uri")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "StartNamespaceDeclHandler")
(PUNCT "=")
(ID "handler")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "event_name")
(PUNCT "==")
(LIT "end-ns")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "handler")
(PUNCT "(")
(ID "prefix")
(PUNCT ",")
(ID "event")
(PUNCT "=")
(ID "event_name")
(PUNCT ",")
(ID "append")
(PUNCT "=")
(ID "append")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "event")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "parser")
(PUNCT ".")
(ID "EndNamespaceDeclHandler")
(PUNCT "=")
(ID "handler")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown event %r")
(PUNCT "%")
(ID "event_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_raiseerror")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "err")
(PUNCT "=")
(ID "ParseError")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "err")
(PUNCT ".")
(ID "code")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "code")
(NEWLINE)
(ID "err")
(PUNCT ".")
(ID "position")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "value")
(PUNCT ".")
(ID "offset")
(NEWLINE)
(KEYWORD raise)
(ID "err")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fixname")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_names")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "key")
(NEWLINE)
(KEYWORD if)
(LIT "}")
(KEYWORD in)
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(LIT "{")
(PUNCT "+")
(ID "name")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_names")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_start")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ",")
(ID "attr_list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fixname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fixname")
(NEWLINE)
(ID "tag")
(PUNCT "=")
(ID "fixname")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(NEWLINE)
(ID "attrib")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "attr_list")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "attr_list")
(PUNCT ")")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "attrib")
(PUNCT "[")
(ID "fixname")
(PUNCT "(")
(ID "attr_list")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "attr_list")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(ID "tag")
(PUNCT ",")
(ID "attrib")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_end")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tag")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_fixname")
(PUNCT "(")
(ID "tag")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_default")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefix")
(PUNCT "=")
(ID "text")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "prefix")
(PUNCT "==")
(LIT "&")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data_handler")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ".")
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data_handler")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "entity")
(PUNCT "[")
(ID "text")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "xml")
(PUNCT ".")
(ID "parsers")
(KEYWORD import)
(ID "expat")
(NEWLINE)
(ID "err")
(PUNCT "=")
(ID "expat")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "undefined entity %s: line %d, column %d")
(PUNCT "%")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ".")
(ID "ErrorLineNumber")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ".")
(ID "ErrorColumnNumber")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "err")
(PUNCT ".")
(ID "code")
(PUNCT "=")
(LIT 11)
(NEWLINE)
(ID "err")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ".")
(ID "ErrorLineNumber")
(NEWLINE)
(ID "err")
(PUNCT ".")
(ID "offset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ".")
(ID "ErrorColumnNumber")
(NEWLINE)
(KEYWORD raise)
(ID "err")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "prefix")
(PUNCT "==")
(LIT "<")
(KEYWORD and)
(ID "text")
(PUNCT "[")
(PUNCT ":")
(LIT 9)
(PUNCT "]")
(PUNCT "==")
(LIT "<!DOCTYPE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "_doctype")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "prefix")
(PUNCT "==")
(LIT ">")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "type")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "type")
(PUNCT "==")
(LIT "PUBLIC")
(KEYWORD and)
(ID "n")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "pubid")
(PUNCT ",")
(ID "system")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_doctype")
(NEWLINE)
(KEYWORD if)
(ID "pubid")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pubid")
(PUNCT "=")
(ID "pubid")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "type")
(PUNCT "==")
(LIT "SYSTEM")
(KEYWORD and)
(ID "n")
(PUNCT "==")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "system")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_doctype")
(NEWLINE)
(ID "pubid")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ",")
(LIT "doctype")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ".")
(ID "doctype")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "pubid")
(PUNCT ",")
(ID "system")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "doctype")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "_XMLParser__doctype")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_XMLParser__doctype")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "pubid")
(PUNCT ",")
(ID "system")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "doctype")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "pubid")
(PUNCT ",")
(ID "system")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_doctype")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "doctype")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "pubid")
(PUNCT ",")
(ID "system")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "(Deprecated)  Handle doctype declaration\n\n        *name* is the Doctype name, *pubid* is the public identifier,\n        and *system* is the system identifier.\n\n        ")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This method of XMLParser is deprecated.  Define doctype() ")
(LIT "method on the TreeBuilder target.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__doctype")
(PUNCT "=")
(ID "doctype")
(NEWLINE)
(KEYWORD def)
(ID "feed")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Feed encoded data to parser.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ".")
(ID "Parse")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "self")
(PUNCT ".")
(ID "_error")
(KEYWORD as)
(ID "v")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_raiseerror")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Finish feeding data to parser and return element structure.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ".")
(ID "Parse")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "self")
(PUNCT ".")
(ID "_error")
(KEYWORD as)
(ID "v")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_raiseerror")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "close_handler")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ".")
(ID "close")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "close_handler")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "parser")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_parser")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "target")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_target")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_Element_Py")
(PUNCT "=")
(ID "Element")
(NEWLINE)
(KEYWORD from)
(ID "_elementtree")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ENDMARKER)
