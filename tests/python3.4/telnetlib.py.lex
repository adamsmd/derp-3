(LIT "TELNET client class.\n\nBased on RFC 854: TELNET Protocol Specification, by J. Postel and\nJ. Reynolds\n\nExample:\n\n>>> from telnetlib import Telnet\n>>> tn = Telnet('www.python.org', 79)   # connect to finger port\n>>> tn.write(b'guido\\r\\n')\n>>> print(tn.read_all())\nLogin       Name               TTY         Idle    When    Where\nguido    Guido van Rossum      pts/2        <Dec  2 11:10> snag.cnri.reston..\n\n>>>\n\nNote that read_all() won't read until eof -- it just reads some data\n-- but it guarantees to read at least one byte unless EOF is hit.\n\nIt is possible to pass a Telnet object to a selector in order to wait until\nmore data is available.  Note that in this case, read_eager() may return b''\neven if there was data on the socket, because the protocol negotiation may have\neaten the data.  This is why EOFError is needed in some cases to distinguish\nbetween \"no data\" and \"connection closed\" (since the socket also appears ready\nfor reading when it is closed).\n\nTo do:\n- option negotiation\n- timeout should be intrinsic to the connection object instead of an\n  option on one of the read calls only\n\n")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "socket")
(NEWLINE)
(KEYWORD import)
(ID "selectors")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "time")
(KEYWORD import)
(ID "monotonic")
(KEYWORD as)
(ID "_time")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "time")
(KEYWORD import)
(ID "time")
(KEYWORD as)
(ID "_time")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Telnet")
(PUNCT "]")
(NEWLINE)
(ID "DEBUGLEVEL")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "TELNET_PORT")
(PUNCT "=")
(LIT 23)
(NEWLINE)
(ID "IAC")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 255)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "DONT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 254)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "DO")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 253)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "WONT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 252)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "WILL")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 251)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "theNULL")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SE")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 240)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NOP")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 241)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "DM")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 242)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "BRK")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 243)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "IP")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 244)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "AO")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 245)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "AYT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 246)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "EC")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 247)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "EL")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 248)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "GA")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 249)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SB")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 250)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "BINARY")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "ECHO")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "RCP")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SGA")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 3)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAMS")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 4)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "STATUS")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 5)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TM")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 6)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "RCTE")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 7)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOL")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 8)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOP")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 9)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOCRD")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 10)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOHTS")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 11)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOHTD")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 12)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOFFD")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 13)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOVTS")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 14)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOVTD")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 15)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAOLFD")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 16)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "XASCII")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 17)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "LOGOUT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 18)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "BM")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 19)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "DET")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 20)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SUPDUP")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 21)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SUPDUPOUTPUT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 22)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SNDLOC")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 23)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TTYPE")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 24)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "EOR")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 25)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TUID")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 26)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "OUTMRK")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 27)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TTYLOC")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 28)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "VT3270REGIME")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 29)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "X3PAD")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 30)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NAWS")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 31)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TSPEED")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 32)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "LFLOW")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 33)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "LINEMODE")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 34)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "XDISPLOC")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 35)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "OLD_ENVIRON")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 36)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "AUTHENTICATION")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 37)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "ENCRYPT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 38)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NEW_ENVIRON")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 39)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TN3270E")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 40)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "XAUTH")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 41)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "CHARSET")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 42)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "RSP")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 43)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "COM_PORT_OPTION")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 44)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SUPPRESS_LOCAL_ECHO")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 45)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "TLS")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 46)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "KERMIT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 47)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SEND_URL")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 48)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "FORWARD_X")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 49)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "PRAGMA_LOGON")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 138)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "SSPI_LOGON")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 139)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "PRAGMA_HEARTBEAT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 140)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "EXOPL")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 255)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "NOOPT")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "selectors")
(PUNCT ",")
(LIT "PollSelector")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_TelnetSelector")
(PUNCT "=")
(ID "selectors")
(PUNCT ".")
(ID "PollSelector")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_TelnetSelector")
(PUNCT "=")
(ID "selectors")
(PUNCT ".")
(ID "SelectSelector")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Telnet")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Telnet interface class.\n\n    An instance of this class represents a connection to a telnet\n    server.  The instance is initially not connected; the open()\n    method must be used to establish a connection.  Alternatively, the\n    host name and optional port number can be passed to the\n    constructor, too.\n\n    Don't try to reopen an already connected instance.\n\n    This class has many read_*() methods.  Note that some of them\n    raise EOFError when the end of the connection is read, because\n    they can return an empty string for other reasons.  See the\n    individual doc strings.\n\n    read_until(expected, [timeout])\n        Read until the expected string has been seen, or a timeout is\n        hit (default is no timeout); may block.\n\n    read_all()\n        Read all data until EOF; may block.\n\n    read_some()\n        Read at least one byte or EOF; may block.\n\n    read_very_eager()\n        Read all data available already queued or on the socket,\n        without blocking.\n\n    read_eager()\n        Read either data already queued or some data available on the\n        socket, without blocking.\n\n    read_lazy()\n        Read all data in the raw queue (processing it first), without\n        doing any socket I/O.\n\n    read_very_lazy()\n        Reads all data in the cooked queue, without doing any socket\n        I/O.\n\n    read_sb_data()\n        Reads available data between SB ... SE sequence. Don't block.\n\n    set_option_negotiation_callback(callback)\n        Each time a telnet option is read on the input flow, this callback\n        (if set) is called with the following parameters :\n        callback(telnet socket, command, option)\n            option will be chr(0) when there is no option.\n        No other action is done afterwards by telnetlib.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "host")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "port")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "_GLOBAL_DEFAULT_TIMEOUT")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor.\n\n        When called without arguments, create an unconnected instance.\n        With a hostname argument, it connects the instance; port number\n        and timeout are optional.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "debuglevel")
(PUNCT "=")
(ID "DEBUGLEVEL")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "host")
(PUNCT "=")
(ID "host")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "port")
(PUNCT "=")
(ID "port")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "timeout")
(PUNCT "=")
(ID "timeout")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "host")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "_GLOBAL_DEFAULT_TIMEOUT")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Connect to a host.\n\n        The optional second argument is the port number, which\n        defaults to the standard telnet port (23).\n\n        Don't try to reopen an already connected instance.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "port")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(ID "TELNET_PORT")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "host")
(PUNCT "=")
(ID "host")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "port")
(PUNCT "=")
(ID "port")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "timeout")
(PUNCT "=")
(ID "timeout")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "create_connection")
(PUNCT "(")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT ")")
(PUNCT ",")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Destructor -- close the connection.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "msg")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Print a debug message, when the debug level is > 0.\n\n        If extra arguments are present, they are substituted in the\n        message using the standard string formatting operator.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "debuglevel")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Telnet(%s,%s):")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "host")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "port")
(PUNCT ")")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_debuglevel")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "debuglevel")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the debug level.\n\n        The higher it is, the more debug output you get (on sys.stdout).\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "debuglevel")
(PUNCT "=")
(ID "debuglevel")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Close the connection.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_socket")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the socket object used internally.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "sock")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the fileno() of the socket object used internally.")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "buffer")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write a string to the socket, doubling any IAC characters.\n\n        Can block if the connection is blocked.  May raise\n        OSError if the connection is closed.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "IAC")
(KEYWORD in)
(ID "buffer")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffer")
(PUNCT "=")
(ID "buffer")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(ID "IAC")
(PUNCT ",")
(ID "IAC")
(PUNCT "+")
(ID "IAC")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "(")
(LIT "send %r")
(PUNCT ",")
(ID "buffer")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ".")
(ID "sendall")
(PUNCT "(")
(ID "buffer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_until")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "match")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read until a given string is encountered or until timeout.\n\n        When no match is found, return whatever is available instead,\n        possibly the empty string.  Raise EOFError if the connection\n        is closed and no cooked data is available.\n\n        ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "match")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "match")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(ID "n")
(NEWLINE)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "buf")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "deadline")
(PUNCT "=")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "timeout")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "_TelnetSelector")
(PUNCT "(")
(PUNCT ")")
(KEYWORD as)
(ID "selector")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "selector")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "selectors")
(PUNCT ".")
(ID "EVENT_READ")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "selector")
(PUNCT ".")
(ID "select")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT ")")
(PUNCT "-")
(ID "n")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "match")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(ID "n")
(NEWLINE)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "buf")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "timeout")
(PUNCT "=")
(ID "deadline")
(PUNCT "-")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "timeout")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "read_very_lazy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_all")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read all data until EOF; block until connection closed.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD return)
(ID "buf")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_some")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read at least one byte of cooked data unless EOF is hit.\n\n        Return b'' if EOF is hit.  Block if no data is immediately\n        available.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD return)
(ID "buf")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_very_eager")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read everything that's possible without blocking in I/O (eager).\n\n        Raise EOFError if connection closed and no cooked data\n        available.  Return b'' if no cooked data available otherwise.\n        Don't block unless in the midst of an IAC sequence.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "eof")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "sock_avail")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "read_very_lazy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_eager")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read readily available data.\n\n        Raise EOFError if connection closed and no cooked data\n        available.  Return b'' if no cooked data available otherwise.\n        Don't block unless in the midst of an IAC sequence.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "eof")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "sock_avail")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "read_very_lazy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_lazy")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Process and return data that's already in the queues (lazy).\n\n        Raise EOFError if connection closed and no data available.\n        Return b'' if no cooked data available otherwise.  Don't block\n        unless in the midst of an IAC sequence.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "read_very_lazy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_very_lazy")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return any data available in the cooked queue (very lazy).\n\n        Raise EOFError if connection closed and no data available.\n        Return b'' if no cooked data available otherwise.  Don't block.\n\n        ")
(NEWLINE)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "buf")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "eof")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "EOFError")
(PUNCT "(")
(LIT "telnet connection closed")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "buf")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_sb_data")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return any data available in the SB ... SE queue.\n\n        Return b'' if no SB ... SE available. Should only be called\n        after seeing a SB or SE command. When a new SB command is\n        found, old unread SB data will be discarded. Don't block.\n\n        ")
(NEWLINE)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD return)
(ID "buf")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_option_negotiation_callback")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "callback")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Provide a callback function called after each receipt of a telnet option.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT "=")
(ID "callback")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "process_rawq")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Transfer from raw queue to cooked queue.\n\n        Set self.eof when connection is closed.  Don't block unless in\n        the midst of an IAC sequence.\n\n        ")
(NEWLINE)
(ID "buf")
(PUNCT "=")
(PUNCT "[")
(LIT #"")
(PUNCT ",")
(LIT #"")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "rawq_getchar")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(ID "theNULL")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT #"\21")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "c")
(PUNCT "!=")
(ID "IAC")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "]")
(PUNCT "=")
(ID "buf")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "]")
(PUNCT "+")
(ID "c")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "+=")
(ID "c")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(KEYWORD in)
(PUNCT "(")
(ID "DO")
(PUNCT ",")
(ID "DONT")
(PUNCT ",")
(ID "WILL")
(PUNCT ",")
(ID "WONT")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "+=")
(ID "c")
(NEWLINE)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(ID "IAC")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buf")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "]")
(PUNCT "=")
(ID "buf")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "]")
(PUNCT "+")
(ID "c")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(ID "SB")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "c")
(PUNCT "==")
(ID "SE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "+")
(ID "buf")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "buf")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ",")
(ID "c")
(PUNCT ",")
(ID "NOOPT")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "(")
(LIT "IAC %d not recognized")
(PUNCT "%")
(ID "ord")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cmd")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "opt")
(PUNCT "=")
(ID "c")
(NEWLINE)
(KEYWORD if)
(ID "cmd")
(KEYWORD in)
(PUNCT "(")
(ID "DO")
(PUNCT ",")
(ID "DONT")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "(")
(LIT "IAC %s %d")
(PUNCT ",")
(ID "cmd")
(PUNCT "==")
(ID "DO")
(KEYWORD and)
(LIT "DO")
(KEYWORD or)
(LIT "DONT")
(PUNCT ",")
(ID "ord")
(PUNCT "(")
(ID "opt")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ",")
(ID "cmd")
(PUNCT ",")
(ID "opt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ".")
(ID "sendall")
(PUNCT "(")
(ID "IAC")
(PUNCT "+")
(ID "WONT")
(PUNCT "+")
(ID "opt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "cmd")
(KEYWORD in)
(PUNCT "(")
(ID "WILL")
(PUNCT ",")
(ID "WONT")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "(")
(LIT "IAC %s %d")
(PUNCT ",")
(ID "cmd")
(PUNCT "==")
(ID "WILL")
(KEYWORD and)
(LIT "WILL")
(KEYWORD or)
(LIT "WONT")
(PUNCT ",")
(ID "ord")
(PUNCT "(")
(ID "opt")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "option_callback")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ",")
(ID "cmd")
(PUNCT ",")
(ID "opt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ".")
(ID "sendall")
(PUNCT "(")
(ID "IAC")
(PUNCT "+")
(ID "DONT")
(PUNCT "+")
(ID "opt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "EOFError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "iacseq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sb")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "+")
(ID "buf")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "sbdataq")
(PUNCT "+")
(ID "buf")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "rawq_getchar")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get next char from raw queue.\n\n        Block if no data is immediately available.  Raise EOFError\n        when connection is closed.\n\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "EOFError")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT ":")
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "c")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fill_rawq")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Fill raw queue from exactly one recv() system call.\n\n        Block if no data is immediately available.  Set self.eof when\n        connection is closed.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "irawq")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "buf")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "sock")
(PUNCT ".")
(ID "recv")
(PUNCT "(")
(LIT 50)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "msg")
(PUNCT "(")
(LIT "recv %r")
(PUNCT ",")
(ID "buf")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT "=")
(PUNCT "(")
(KEYWORD not)
(ID "buf")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "rawq")
(PUNCT "+")
(ID "buf")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "sock_avail")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test whether data is available on the socket.")
(NEWLINE)
(KEYWORD with)
(ID "_TelnetSelector")
(PUNCT "(")
(PUNCT ")")
(KEYWORD as)
(ID "selector")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "selector")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "selectors")
(PUNCT ".")
(ID "EVENT_READ")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "bool")
(PUNCT "(")
(ID "selector")
(PUNCT ".")
(ID "select")
(PUNCT "(")
(LIT 0)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "interact")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Interaction function, emulates a very dumb telnet client.")
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "platform")
(PUNCT "==")
(LIT "win32")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "mt_interact")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "_TelnetSelector")
(PUNCT "(")
(PUNCT ")")
(KEYWORD as)
(ID "selector")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "selector")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "selectors")
(PUNCT ".")
(ID "EVENT_READ")
(PUNCT ")")
(NEWLINE)
(ID "selector")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ",")
(ID "selectors")
(PUNCT ".")
(ID "EVENT_READ")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "events")
(KEYWORD in)
(ID "selector")
(PUNCT ".")
(ID "select")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(PUNCT ".")
(ID "fileobj")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read_eager")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "EOFError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "*** Connection closed by remote host ***")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "text")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "key")
(PUNCT ".")
(ID "fileobj")
(KEYWORD is)
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "mt_interact")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Multithreaded version of interact().")
(NEWLINE)
(KEYWORD import)
(ID "_thread")
(NEWLINE)
(ID "_thread")
(PUNCT ".")
(ID "start_new_thread")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "listener")
(PUNCT ",")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "line")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "listener")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper for mt_interact() -- this executes in the other thread.")
(NEWLINE)
(KEYWORD while)
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read_eager")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "EOFError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "*** Connection closed by remote host ***")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "data")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ".")
(ID "flush")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "expect")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "list")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read until one from a list of a regular expressions matches.\n\n        The first argument is a list of regular expressions, either\n        compiled (re.RegexObject instances) or uncompiled (strings).\n        The optional second argument is a timeout, in seconds; default\n        is no timeout.\n\n        Return a tuple of three items: the index in the list of the\n        first regular expression that matches; the match object\n        returned; and the text read up till and including the match.\n\n        If EOF is read and no text was read, raise EOFError.\n        Otherwise, when nothing matches, return (-1, None, text) where\n        text is the text received so far (may be the empty string if a\n        timeout happened).\n\n        If a regular expression ends with a greedy match (e.g. '.*')\n        or if more than one expression can match the same input, the\n        results are undeterministic, and may depend on the I/O timing.\n\n        ")
(NEWLINE)
(ID "re")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "list")
(PUNCT "=")
(ID "list")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "indices")
(PUNCT "=")
(ID "range")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "list")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "indices")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "list")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ",")
(LIT "search")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "re")
(PUNCT ":")
(KEYWORD import)
(ID "re")
(NEWLINE)
(ID "list")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "list")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "deadline")
(PUNCT "=")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(ID "timeout")
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "_TelnetSelector")
(PUNCT "(")
(PUNCT ")")
(KEYWORD as)
(ID "selector")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "selector")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "selectors")
(PUNCT ".")
(ID "EVENT_READ")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "process_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "indices")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "list")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "e")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "[")
(PUNCT ":")
(ID "e")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "cookedq")
(PUNCT "[")
(ID "e")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "m")
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ready")
(PUNCT "=")
(ID "selector")
(PUNCT ".")
(ID "select")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(ID "timeout")
(PUNCT "=")
(ID "deadline")
(PUNCT "-")
(ID "_time")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ready")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "timeout")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "fill_rawq")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "read_very_lazy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "text")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "eof")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "EOFError")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "text")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test program for telnetlib.\n\n    Usage: python telnetlib.py [-d] ... [host [port]]\n\n    Default host is localhost; default port is 23.\n\n    ")
(NEWLINE)
(ID "debuglevel")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(KEYWORD and)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "-d")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "debuglevel")
(PUNCT "=")
(ID "debuglevel")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD del)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "host")
(PUNCT "=")
(LIT "localhost")
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "host")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "port")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "portstr")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "portstr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "port")
(PUNCT "=")
(ID "socket")
(PUNCT ".")
(ID "getservbyname")
(PUNCT "(")
(ID "portstr")
(PUNCT ",")
(LIT "tcp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "tn")
(PUNCT "=")
(ID "Telnet")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "tn")
(PUNCT ".")
(ID "set_debuglevel")
(PUNCT "(")
(ID "debuglevel")
(PUNCT ")")
(NEWLINE)
(ID "tn")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(LIT 0.5)
(PUNCT ")")
(NEWLINE)
(ID "tn")
(PUNCT ".")
(ID "interact")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "tn")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "test")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
