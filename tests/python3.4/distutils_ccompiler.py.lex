(LIT "distutils.ccompiler\n\nContains CCompiler, an abstract base class that defines the interface\nfor the Distutils compiler abstraction model.")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "os")
(PUNCT ",")
(ID "re")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "errors")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "spawn")
(KEYWORD import)
(ID "spawn")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "file_util")
(KEYWORD import)
(ID "move_file")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "dir_util")
(KEYWORD import)
(ID "mkpath")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "dep_util")
(KEYWORD import)
(ID "newer_pairwise")
(PUNCT ",")
(ID "newer_group")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "util")
(KEYWORD import)
(ID "split_quoted")
(PUNCT ",")
(ID "execute")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(KEYWORD import)
(ID "log")
(NEWLINE)
(KEYWORD class)
(ID "CCompiler")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Abstract base class to define the interface that must be implemented\n    by real compiler classes.  Also has some utility methods used by\n    several compiler classes.\n\n    The basic idea behind a compiler abstraction class is that each\n    instance can be used for all the compile/link steps in building a\n    single project.  Thus, attributes common to all of those compile and\n    link steps -- include directories, macros to define, libraries to link\n    against, etc. -- are attributes of the compiler instance.  To allow for\n    variability in how individual files are treated, most of those\n    attributes may be varied on a per-compilation or per-link basis.\n    ")
(NEWLINE)
(ID "compiler_type")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "src_extensions")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "obj_extension")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "static_lib_extension")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "shared_lib_extension")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "static_lib_format")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "shared_lib_format")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "exe_extension")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "language_map")
(PUNCT "=")
(PUNCT "{")
(LIT ".c")
(PUNCT ":")
(LIT "c")
(PUNCT ",")
(LIT ".cc")
(PUNCT ":")
(LIT "c++")
(PUNCT ",")
(LIT ".cpp")
(PUNCT ":")
(LIT "c++")
(PUNCT ",")
(LIT ".cxx")
(PUNCT ":")
(LIT "c++")
(PUNCT ",")
(LIT ".m")
(PUNCT ":")
(LIT "objc")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "language_order")
(PUNCT "=")
(PUNCT "[")
(LIT "c++")
(PUNCT ",")
(LIT "objc")
(PUNCT ",")
(LIT "c")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "force")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "dry_run")
(PUNCT "=")
(ID "dry_run")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "force")
(PUNCT "=")
(ID "force")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "verbose")
(PUNCT "=")
(ID "verbose")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "macros")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "libraries")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "library_dirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "runtime_library_dirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "objects")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "executables")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "set_executable")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "executables")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_executables")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Define the executables (and options for them) that will be run\n        to perform the various stages of compilation.  The exact set of\n        executables that may be specified here depends on the compiler\n        class (via the 'executables' class attribute), but most will have:\n          compiler      the C/C++ compiler\n          linker_so     linker used to create shared objects and libraries\n          linker_exe    linker used to create binary executables\n          archiver      static library creator\n\n        On platforms with a command-line (Unix, DOS/Windows), each of these\n        is a string that will be split into executable name and (optional)\n        list of arguments.  (Splitting the string is done similarly to how\n        Unix shells operate: words are delimited by spaces, but quotes and\n        backslashes can override this.  See\n        'distutils.util.split_quoted()'.)\n        ")
(NEWLINE)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "kwargs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "executables")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unknown executable '%s' for class %s")
(PUNCT "%")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "set_executable")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "kwargs")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_executable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "split_quoted")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "setattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_find_macro")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "defn")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "macros")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "defn")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "i")
(NEWLINE)
(DEDENT)
(ID "i")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_check_macro_definitions")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "definitions")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Ensures that every element of 'definitions' is a valid macro\n        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do\n        nothing if all definitions are OK, raise TypeError otherwise.\n        ")
(NEWLINE)
(KEYWORD for)
(ID "defn")
(KEYWORD in)
(ID "definitions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "defn")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(KEYWORD and)
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "defn")
(PUNCT ")")
(KEYWORD in)
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(KEYWORD and)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "defn")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(KEYWORD or)
(ID "defn")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ")")
(PUNCT ")")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "defn")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(PUNCT "(")
(LIT "invalid macro definition '%s': ")
(PUNCT "%")
(ID "defn")
(PUNCT ")")
(PUNCT "+")
(LIT "must be tuple (string,), (string, string), or ")
(PUNCT "+")
(LIT "(string, None)")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "define_macro")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Define a preprocessor macro for all compilations driven by this\n        compiler object.  The optional parameter 'value' should be a\n        string; if it is not supplied, then the macro will be defined\n        without an explicit value and the exact outcome depends on the\n        compiler used (XXX true? does ANSI say anything about this?)\n        ")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_find_macro")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "macros")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "macros")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "undefine_macro")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Undefine a preprocessor macro for all compilations driven by\n        this compiler object.  If the same macro is defined by\n        'define_macro()' and undefined by 'undefine_macro()' the last call\n        takes precedence (including multiple redefinitions or\n        undefinitions).  If the macro is redefined/undefined on a\n        per-compilation basis (ie. in the call to 'compile()'), then that\n        takes precedence.\n        ")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_find_macro")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "macros")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "undefn")
(PUNCT "=")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "macros")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "undefn")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_include_dir")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add 'dir' to the list of directories that will be searched for\n        header files.  The compiler is instructed to search directories in\n        the order in which they are supplied by successive calls to\n        'add_include_dir()'.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_include_dirs")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dirs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the list of directories that will be searched to 'dirs' (a\n        list of strings).  Overrides any preceding calls to\n        'add_include_dir()'; subsequence calls to 'add_include_dir()' add\n        to the list passed to 'set_include_dirs()'.  This does not affect\n        any list of standard include directories that the compiler may\n        search by default.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(PUNCT "=")
(ID "dirs")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_library")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "libname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add 'libname' to the list of libraries that will be included in\n        all links driven by this compiler object.  Note that 'libname'\n        should *not* be the name of a file containing a library, but the\n        name of the library itself: the actual filename will be inferred by\n        the linker, the compiler, or the compiler class (depending on the\n        platform).\n\n        The linker will be instructed to link against libraries in the\n        order they were supplied to 'add_library()' and/or\n        'set_libraries()'.  It is perfectly valid to duplicate library\n        names; the linker will be instructed to link against libraries as\n        many times as they are mentioned.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "libraries")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "libname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_libraries")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "libnames")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the list of libraries to be included in all links driven by\n        this compiler object to 'libnames' (a list of strings).  This does\n        not affect any standard system libraries that the linker may\n        include by default.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "libraries")
(PUNCT "=")
(ID "libnames")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_library_dir")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add 'dir' to the list of directories that will be searched for\n        libraries specified to 'add_library()' and 'set_libraries()'.  The\n        linker will be instructed to search for libraries in the order they\n        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "library_dirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_library_dirs")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dirs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the list of library search directories to 'dirs' (a list of\n        strings).  This does not affect any standard library search path\n        that the linker may search by default.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "library_dirs")
(PUNCT "=")
(ID "dirs")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_runtime_library_dir")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add 'dir' to the list of directories that will be searched for\n        shared libraries at runtime.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "runtime_library_dirs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_runtime_library_dirs")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dirs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the list of directories to search for shared libraries at\n        runtime to 'dirs' (a list of strings).  This does not affect any\n        standard search path that the runtime linker may search by\n        default.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "runtime_library_dirs")
(PUNCT "=")
(ID "dirs")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_link_object")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add 'object' to the list of object files (or analogues, such as\n        explicitly named library files or the output of \"resource\n        compilers\") to be included in every link driven by this compiler\n        object.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "objects")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_link_objects")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the list of object files (or analogues) to be included in\n        every link to 'objects'.  This does not affect any standard object\n        files that the linker may include by default (such as system\n        libraries).\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "objects")
(PUNCT "=")
(ID "objects")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_setup_compile")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "outdir")
(PUNCT ",")
(ID "macros")
(PUNCT ",")
(ID "incdirs")
(PUNCT ",")
(ID "sources")
(PUNCT ",")
(ID "depends")
(PUNCT ",")
(ID "extra")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Process arguments and decide which source files to compile.")
(NEWLINE)
(KEYWORD if)
(ID "outdir")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outdir")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "output_dir")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "outdir")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'output_dir' must be a string or None")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "macros")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "macros")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "macros")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "macros")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "macros")
(PUNCT "=")
(ID "macros")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "macros")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'macros' (if supplied) must be a list of tuples")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "incdirs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "incdirs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "incdirs")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "incdirs")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "incdirs")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'include_dirs' (if supplied) must be a list of strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "extra")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extra")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "objects")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "object_filenames")
(PUNCT "(")
(ID "sources")
(PUNCT ",")
(ID "strip_dir")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(ID "outdir")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "objects")
(PUNCT ")")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "sources")
(PUNCT ")")
(NEWLINE)
(ID "pp_opts")
(PUNCT "=")
(ID "gen_preprocess_options")
(PUNCT "(")
(ID "macros")
(PUNCT ",")
(ID "incdirs")
(PUNCT ")")
(NEWLINE)
(ID "build")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "sources")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "src")
(PUNCT "=")
(ID "sources")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "obj")
(PUNCT "=")
(ID "objects")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "ext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "mkpath")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "build")
(PUNCT "[")
(ID "obj")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "ext")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "macros")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "extra")
(PUNCT ",")
(ID "pp_opts")
(PUNCT ",")
(ID "build")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_cc_args")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pp_opts")
(PUNCT ",")
(ID "debug")
(PUNCT ",")
(ID "before")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cc_args")
(PUNCT "=")
(ID "pp_opts")
(PUNCT "+")
(PUNCT "[")
(LIT "-c")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "debug")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cc_args")
(PUNCT "[")
(PUNCT ":")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(LIT "-g")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "before")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cc_args")
(PUNCT "[")
(PUNCT ":")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "before")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cc_args")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fix_compile_args")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "output_dir")
(PUNCT ",")
(ID "macros")
(PUNCT ",")
(ID "include_dirs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Typecheck and fix-up some of the arguments to the 'compile()'\n        method, and return fixed-up values.  Specifically: if 'output_dir'\n        is None, replaces it with 'self.output_dir'; ensures that 'macros'\n        is a list, and augments it with 'self.macros'; ensures that\n        'include_dirs' is a list, and augments it with 'self.include_dirs'.\n        Guarantees that the returned values are of the correct type,\n        i.e. for 'output_dir' either string or None, and for 'macros' and\n        'include_dirs' either list or None.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "output_dir")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output_dir")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "output_dir")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'output_dir' must be a string or None")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "macros")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "macros")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "macros")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "macros")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "macros")
(PUNCT "=")
(ID "macros")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "macros")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'macros' (if supplied) must be a list of tuples")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "include_dirs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "include_dirs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "include_dirs")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "include_dirs")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "include_dirs")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "include_dirs")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'include_dirs' (if supplied) must be a list of strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "output_dir")
(PUNCT ",")
(ID "macros")
(PUNCT ",")
(ID "include_dirs")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prep_compile")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sources")
(PUNCT ",")
(ID "output_dir")
(PUNCT ",")
(ID "depends")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Decide which souce files must be recompiled.\n\n        Determine the list of object files corresponding to 'sources',\n        and figure out which ones really need to be recompiled.\n        Return a list of all object files and a dictionary telling\n        which source files can be skipped.\n        ")
(NEWLINE)
(ID "objects")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "object_filenames")
(PUNCT "(")
(ID "sources")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(ID "output_dir")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "objects")
(PUNCT ")")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "sources")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "objects")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fix_object_args")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Typecheck and fix up some arguments supplied to various methods.\n        Specifically: ensure that 'objects' is a list; if output_dir is\n        None, replace with self.output_dir.  Return fixed versions of\n        'objects' and 'output_dir'.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "objects")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'objects' must be a list or tuple of strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "objects")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "objects")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "output_dir")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output_dir")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "output_dir")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'output_dir' must be a string or None")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "objects")
(PUNCT ",")
(ID "output_dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_fix_lib_args")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "libraries")
(PUNCT ",")
(ID "library_dirs")
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Typecheck and fix up some of the arguments supplied to the\n        'link_*' methods.  Specifically: ensure that all arguments are\n        lists, and augment them with their permanent versions\n        (eg. 'self.libraries' augments 'libraries').  Return a tuple with\n        fixed versions of all arguments.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "libraries")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "libraries")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "libraries")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "libraries")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "libraries")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "libraries")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "libraries")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'libraries' (if supplied) must be a list of strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "library_dirs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "library_dirs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "library_dirs")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "library_dirs")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "library_dirs")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "library_dirs")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "library_dirs")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'library_dirs' (if supplied) must be a list of strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "runtime_library_dirs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runtime_library_dirs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "runtime_library_dirs")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "runtime_library_dirs")
(PUNCT ",")
(PUNCT "(")
(ID "list")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "runtime_library_dirs")
(PUNCT "=")
(PUNCT "(")
(ID "list")
(PUNCT "(")
(ID "runtime_library_dirs")
(PUNCT ")")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "runtime_library_dirs")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "'runtime_library_dirs' (if supplied) ")
(LIT "must be a list of strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "libraries")
(PUNCT ",")
(ID "library_dirs")
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_need_link")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_file")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return true if we need to relink the files listed in 'objects'\n        to recreate 'output_file'.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "force")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newer")
(PUNCT "=")
(ID "newer_group")
(PUNCT "(")
(ID "objects")
(PUNCT ",")
(ID "output_file")
(PUNCT ",")
(ID "missing")
(PUNCT "=")
(LIT "newer")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newer")
(PUNCT "=")
(ID "newer_group")
(PUNCT "(")
(ID "objects")
(PUNCT ",")
(ID "output_file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "newer")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "detect_language")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sources")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Detect the language of a given file, or list of files. Uses\n        language_map, and language_order to do the job.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "sources")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sources")
(PUNCT "=")
(PUNCT "[")
(ID "sources")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "lang")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "index")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "language_order")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "source")
(KEYWORD in)
(ID "sources")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "base")
(PUNCT ",")
(ID "ext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(NEWLINE)
(ID "extlang")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "language_map")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "ext")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "extindex")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "language_order")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(ID "extlang")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "extindex")
(PUNCT "<")
(ID "index")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lang")
(PUNCT "=")
(ID "extlang")
(NEWLINE)
(ID "index")
(PUNCT "=")
(ID "extindex")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "lang")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "preprocess")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "output_file")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "macros")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "include_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_preargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_postargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Preprocess a single C/C++ source file, named in 'source'.\n        Output will be written to file named 'output_file', or stdout if\n        'output_file' not supplied.  'macros' is a list of macro\n        definitions as for 'compile()', which will augment the macros set\n        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a\n        list of directory names that will be added to the default list.\n\n        Raises PreprocessError on failure.\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compile")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sources")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "macros")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "include_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extra_preargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_postargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "depends")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compile one or more source files.\n\n        'sources' must be a list of filenames, most likely C/C++\n        files, but in reality anything that can be handled by a\n        particular compiler and compiler class (eg. MSVCCompiler can\n        handle resource files in 'sources').  Return a list of object\n        filenames, one per source filename in 'sources'.  Depending on\n        the implementation, not all source files will necessarily be\n        compiled, but all corresponding object filenames will be\n        returned.\n\n        If 'output_dir' is given, object files will be put under it, while\n        retaining their original path component.  That is, \"foo/bar.c\"\n        normally compiles to \"foo/bar.o\" (for a Unix implementation); if\n        'output_dir' is \"build\", then it would compile to\n        \"build/foo/bar.o\".\n\n        'macros', if given, must be a list of macro definitions.  A macro\n        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.\n        The former defines a macro; if the value is None, the macro is\n        defined without an explicit value.  The 1-tuple case undefines a\n        macro.  Later definitions/redefinitions/ undefinitions take\n        precedence.\n\n        'include_dirs', if given, must be a list of strings, the\n        directories to add to the default include file search path for this\n        compilation only.\n\n        'debug' is a boolean; if true, the compiler will be instructed to\n        output debug symbols in (or alongside) the object file(s).\n\n        'extra_preargs' and 'extra_postargs' are implementation- dependent.\n        On platforms that have the notion of a command-line (e.g. Unix,\n        DOS/Windows), they are most likely lists of strings: extra\n        command-line arguments to prepand/append to the compiler command\n        line.  On other platforms, consult the implementation class\n        documentation.  In any event, they are intended as an escape hatch\n        for those occasions when the abstract compiler framework doesn't\n        cut the mustard.\n\n        'depends', if given, is a list of filenames that all targets\n        depend on.  If a source file is older than any file in\n        depends, then the source file will be recompiled.  This\n        supports dependency tracking, but only at a coarse\n        granularity.\n\n        Raises CompileError on failure.\n        ")
(NEWLINE)
(ID "macros")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ",")
(ID "pp_opts")
(PUNCT ",")
(ID "build")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_setup_compile")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "macros")
(PUNCT ",")
(ID "include_dirs")
(PUNCT ",")
(ID "sources")
(PUNCT ",")
(ID "depends")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ")")
(NEWLINE)
(ID "cc_args")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_cc_args")
(PUNCT "(")
(ID "pp_opts")
(PUNCT ",")
(ID "debug")
(PUNCT ",")
(ID "extra_preargs")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "obj")
(KEYWORD in)
(ID "objects")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "src")
(PUNCT ",")
(ID "ext")
(PUNCT "=")
(ID "build")
(PUNCT "[")
(ID "obj")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_compile")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "src")
(PUNCT ",")
(ID "ext")
(PUNCT ",")
(ID "cc_args")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ",")
(ID "pp_opts")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "objects")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_compile")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ",")
(ID "src")
(PUNCT ",")
(ID "ext")
(PUNCT ",")
(ID "cc_args")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ",")
(ID "pp_opts")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compile 'src' to product 'obj'.")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "create_static_lib")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_libname")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "target_lang")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Link a bunch of stuff together to create a static library file.\n        The \"bunch of stuff\" consists of the list of object files supplied\n        as 'objects', the extra object files supplied to\n        'add_link_object()' and/or 'set_link_objects()', the libraries\n        supplied to 'add_library()' and/or 'set_libraries()', and the\n        libraries supplied as 'libraries' (if any).\n\n        'output_libname' should be a library name, not a filename; the\n        filename will be inferred from the library name.  'output_dir' is\n        the directory where the library file will be put.\n\n        'debug' is a boolean; if true, debugging information will be\n        included in the library (note that on most platforms, it is the\n        compile step where this matters: the 'debug' flag is included here\n        just for consistency).\n\n        'target_lang' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LibError on failure.\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "SHARED_OBJECT")
(PUNCT "=")
(LIT "shared_object")
(NEWLINE)
(ID "SHARED_LIBRARY")
(PUNCT "=")
(LIT "shared_library")
(NEWLINE)
(ID "EXECUTABLE")
(PUNCT "=")
(LIT "executable")
(NEWLINE)
(KEYWORD def)
(ID "link")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "target_desc")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_filename")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "libraries")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "export_symbols")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extra_preargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_postargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "build_temp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "target_lang")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Link a bunch of stuff together to create an executable or\n        shared library file.\n\n        The \"bunch of stuff\" consists of the list of object files supplied\n        as 'objects'.  'output_filename' should be a filename.  If\n        'output_dir' is supplied, 'output_filename' is relative to it\n        (i.e. 'output_filename' can provide directory components if\n        needed).\n\n        'libraries' is a list of libraries to link against.  These are\n        library names, not filenames, since they're translated into\n        filenames in a platform-specific way (eg. \"foo\" becomes \"libfoo.a\"\n        on Unix and \"foo.lib\" on DOS/Windows).  However, they can include a\n        directory component, which means the linker will look in that\n        specific directory rather than searching all the normal locations.\n\n        'library_dirs', if supplied, should be a list of directories to\n        search for libraries that were specified as bare library names\n        (ie. no directory component).  These are on top of the system\n        default and those supplied to 'add_library_dir()' and/or\n        'set_library_dirs()'.  'runtime_library_dirs' is a list of\n        directories that will be embedded into the shared library and used\n        to search for other shared libraries that *it* depends on at\n        run-time.  (This may only be relevant on Unix.)\n\n        'export_symbols' is a list of symbols that the shared library will\n        export.  (This appears to be relevant only on Windows.)\n\n        'debug' is as for 'compile()' and 'create_static_lib()', with the\n        slight distinction that it actually matters on most platforms (as\n        opposed to 'create_static_lib()', which includes a 'debug' flag\n        mostly for form's sake).\n\n        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except\n        of course that they supply command-line arguments for the\n        particular linker being used).\n\n        'target_lang' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LinkError on failure.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "link_shared_lib")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_libname")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "libraries")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "export_symbols")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extra_preargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_postargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "build_temp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "target_lang")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "link")
(PUNCT "(")
(ID "CCompiler")
(PUNCT ".")
(ID "SHARED_LIBRARY")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "library_filename")
(PUNCT "(")
(ID "output_libname")
(PUNCT ",")
(ID "lib_type")
(PUNCT "=")
(LIT "shared")
(PUNCT ")")
(PUNCT ",")
(ID "output_dir")
(PUNCT ",")
(ID "libraries")
(PUNCT ",")
(ID "library_dirs")
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT ",")
(ID "export_symbols")
(PUNCT ",")
(ID "debug")
(PUNCT ",")
(ID "extra_preargs")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ",")
(ID "build_temp")
(PUNCT ",")
(ID "target_lang")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "link_shared_object")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_filename")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "libraries")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "export_symbols")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extra_preargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_postargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "build_temp")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "target_lang")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "link")
(PUNCT "(")
(ID "CCompiler")
(PUNCT ".")
(ID "SHARED_OBJECT")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_filename")
(PUNCT ",")
(ID "output_dir")
(PUNCT ",")
(ID "libraries")
(PUNCT ",")
(ID "library_dirs")
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT ",")
(ID "export_symbols")
(PUNCT ",")
(ID "debug")
(PUNCT ",")
(ID "extra_preargs")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ",")
(ID "build_temp")
(PUNCT ",")
(ID "target_lang")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "link_executable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "output_progname")
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "libraries")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "extra_preargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "extra_postargs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "target_lang")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "link")
(PUNCT "(")
(ID "CCompiler")
(PUNCT ".")
(ID "EXECUTABLE")
(PUNCT ",")
(ID "objects")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "executable_filename")
(PUNCT "(")
(ID "output_progname")
(PUNCT ")")
(PUNCT ",")
(ID "output_dir")
(PUNCT ",")
(ID "libraries")
(PUNCT ",")
(ID "library_dirs")
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "debug")
(PUNCT ",")
(ID "extra_preargs")
(PUNCT ",")
(ID "extra_postargs")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "target_lang")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "library_dir_option")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the compiler option to add 'dir' to the list of\n        directories searched for libraries.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "runtime_library_dir_option")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dir")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the compiler option to add 'dir' to the list of\n        directories searched for runtime libraries.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "library_option")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lib")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the compiler option to add 'dir' to the list of libraries\n        linked into the shared library or executable.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "has_function")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "funcname")
(PUNCT ",")
(ID "includes")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "include_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "libraries")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "library_dirs")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a boolean indicating whether funcname is supported on\n        the current platform.  The optional arguments can be used to\n        augment the compilation environment.\n        ")
(NEWLINE)
(KEYWORD import)
(ID "tempfile")
(NEWLINE)
(KEYWORD if)
(ID "includes")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "includes")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "include_dirs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "include_dirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "libraries")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "libraries")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "library_dirs")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "library_dirs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "fd")
(PUNCT ",")
(ID "fname")
(PUNCT "=")
(ID "tempfile")
(PUNCT ".")
(ID "mkstemp")
(PUNCT "(")
(LIT ".c")
(PUNCT ",")
(ID "funcname")
(PUNCT ",")
(ID "text")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fdopen")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "incl")
(KEYWORD in)
(ID "includes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "#include \"%s\"\n")
(PUNCT "%")
(ID "incl")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "f")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "main (int argc, char **argv) {\n    %s();\n}\n")
(PUNCT "%")
(ID "funcname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "objects")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(PUNCT "[")
(ID "fname")
(PUNCT "]")
(PUNCT ",")
(ID "include_dirs")
(PUNCT "=")
(ID "include_dirs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "CompileError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "link_executable")
(PUNCT "(")
(ID "objects")
(PUNCT ",")
(LIT "a.out")
(PUNCT ",")
(ID "libraries")
(PUNCT "=")
(ID "libraries")
(PUNCT ",")
(ID "library_dirs")
(PUNCT "=")
(ID "library_dirs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "LinkError")
(PUNCT ",")
(ID "TypeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "find_library_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dirs")
(PUNCT ",")
(ID "lib")
(PUNCT ",")
(ID "debug")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Search the specified list of directories for a static or shared\n        library file 'lib' and return the full path to that file.  If\n        'debug' true, look for a debugging version (if that makes sense on\n        the current platform).  Return None if 'lib' wasn't found in any of\n        the specified directories.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "object_filenames")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source_filenames")
(PUNCT ",")
(ID "strip_dir")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "output_dir")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output_dir")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "obj_names")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "src_name")
(KEYWORD in)
(ID "source_filenames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "base")
(PUNCT ",")
(ID "ext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "src_name")
(PUNCT ")")
(NEWLINE)
(ID "base")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitdrive")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "base")
(PUNCT "=")
(ID "base")
(PUNCT "[")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isabs")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "ext")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "src_extensions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "UnknownFileError")
(PUNCT "(")
(LIT "unknown file type '%s' (from '%s')")
(PUNCT "%")
(PUNCT "(")
(ID "ext")
(PUNCT ",")
(ID "src_name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "strip_dir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "base")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "base")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "obj_names")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "base")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "obj_extension")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "obj_names")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "shared_object_filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "basename")
(PUNCT ",")
(ID "strip_dir")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "output_dir")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "strip_dir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basename")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "basename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "basename")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "shared_lib_extension")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "executable_filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "basename")
(PUNCT ",")
(ID "strip_dir")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "output_dir")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "strip_dir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "basename")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "basename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "basename")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "exe_extension")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "library_filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "libname")
(PUNCT ",")
(ID "lib_type")
(PUNCT "=")
(LIT "static")
(PUNCT ",")
(ID "strip_dir")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "output_dir")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "output_dir")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "lib_type")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "static")
(PUNCT ",")
(LIT "shared")
(PUNCT ",")
(LIT "dylib")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "'lib_type' must be \"static\", \"shared\" or \"dylib\"")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fmt")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lib_type")
(PUNCT "+")
(LIT "_lib_format")
(PUNCT ")")
(NEWLINE)
(ID "ext")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lib_type")
(PUNCT "+")
(LIT "_lib_extension")
(PUNCT ")")
(NEWLINE)
(ID "dir")
(PUNCT ",")
(ID "base")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "libname")
(PUNCT ")")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "fmt")
(PUNCT "%")
(PUNCT "(")
(ID "base")
(PUNCT ",")
(ID "ext")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "strip_dir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dir")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "output_dir")
(PUNCT ",")
(ID "dir")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "announce")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "level")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "debug_print")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "debug")
(KEYWORD import)
(ID "DEBUG")
(NEWLINE)
(KEYWORD if)
(ID "DEBUG")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "warn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "warning: %s\n")
(PUNCT "%")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execute")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "func")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "level")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "execute")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "spawn")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "cmd")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spawn")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "move_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "move_file")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dst")
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "mkpath")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT 511)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mkpath")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "mode")
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_default_compilers")
(PUNCT "=")
(PUNCT "(")
(PUNCT "(")
(LIT "cygwin.*")
(PUNCT ",")
(LIT "unix")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "posix")
(PUNCT ",")
(LIT "unix")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(LIT "nt")
(PUNCT ",")
(LIT "msvc")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "get_default_compiler")
(PUNCT "(")
(ID "osname")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "platform")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Determine the default compiler to use for the given platform.\n\n       osname should be one of the standard Python OS names (i.e. the\n       ones returned by os.name) and platform the common value\n       returned by sys.platform for the platform in question.\n\n       The default values are os.name and sys.platform in case the\n       parameters are not given.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "osname")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "osname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "platform")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "platform")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "platform")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "pattern")
(PUNCT ",")
(ID "compiler")
(KEYWORD in)
(ID "_default_compilers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "pattern")
(PUNCT ",")
(ID "platform")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD or)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "pattern")
(PUNCT ",")
(ID "osname")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "compiler")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT "unix")
(NEWLINE)
(DEDENT)
(ID "compiler_class")
(PUNCT "=")
(PUNCT "{")
(LIT "unix")
(PUNCT ":")
(PUNCT "(")
(LIT "unixccompiler")
(PUNCT ",")
(LIT "UnixCCompiler")
(PUNCT ",")
(LIT "standard UNIX-style compiler")
(PUNCT ")")
(PUNCT ",")
(LIT "msvc")
(PUNCT ":")
(PUNCT "(")
(LIT "msvccompiler")
(PUNCT ",")
(LIT "MSVCCompiler")
(PUNCT ",")
(LIT "Microsoft Visual C++")
(PUNCT ")")
(PUNCT ",")
(LIT "cygwin")
(PUNCT ":")
(PUNCT "(")
(LIT "cygwinccompiler")
(PUNCT ",")
(LIT "CygwinCCompiler")
(PUNCT ",")
(LIT "Cygwin port of GNU C Compiler for Win32")
(PUNCT ")")
(PUNCT ",")
(LIT "mingw32")
(PUNCT ":")
(PUNCT "(")
(LIT "cygwinccompiler")
(PUNCT ",")
(LIT "Mingw32CCompiler")
(PUNCT ",")
(LIT "Mingw32 port of GNU C Compiler for Win32")
(PUNCT ")")
(PUNCT ",")
(LIT "bcpp")
(PUNCT ":")
(PUNCT "(")
(LIT "bcppcompiler")
(PUNCT ",")
(LIT "BCPPCompiler")
(PUNCT ",")
(LIT "Borland C++ Compiler")
(PUNCT ")")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "show_compilers")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Print list of available compilers (used by the \"--help-compiler\"\n    options to \"build\", \"build_ext\", \"build_clib\").\n    ")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "fancy_getopt")
(KEYWORD import)
(ID "FancyGetopt")
(NEWLINE)
(ID "compilers")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "compiler")
(KEYWORD in)
(ID "compiler_class")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "compilers")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(LIT "compiler=")
(PUNCT "+")
(ID "compiler")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "compiler_class")
(PUNCT "[")
(ID "compiler")
(PUNCT "]")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "compilers")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "pretty_printer")
(PUNCT "=")
(ID "FancyGetopt")
(PUNCT "(")
(ID "compilers")
(PUNCT ")")
(NEWLINE)
(ID "pretty_printer")
(PUNCT ".")
(ID "print_help")
(PUNCT "(")
(LIT "List of available compilers:")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "new_compiler")
(PUNCT "(")
(ID "plat")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "compiler")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "force")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate an instance of some CCompiler subclass for the supplied\n    platform/compiler combination.  'plat' defaults to 'os.name'\n    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler\n    for that platform.  Currently only 'posix' and 'nt' are supported, and\n    the default compilers are \"traditional Unix interface\" (UnixCCompiler\n    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly\n    possible to ask for a Unix compiler object under Windows, and a\n    Microsoft compiler object under Unix -- if you supply a value for\n    'compiler', 'plat' is ignored.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "plat")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "plat")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "compiler")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "compiler")
(PUNCT "=")
(ID "get_default_compiler")
(PUNCT "(")
(ID "plat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "module_name")
(PUNCT ",")
(ID "class_name")
(PUNCT ",")
(ID "long_description")
(PUNCT ")")
(PUNCT "=")
(ID "compiler_class")
(PUNCT "[")
(ID "compiler")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "don't know how to compile C/C++ code on platform '%s'")
(PUNCT "%")
(ID "plat")
(NEWLINE)
(KEYWORD if)
(ID "compiler")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "+")
(LIT " with '%s' compiler")
(PUNCT "%")
(ID "compiler")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "DistutilsPlatformError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module_name")
(PUNCT "=")
(LIT "distutils.")
(PUNCT "+")
(ID "module_name")
(NEWLINE)
(ID "__import__")
(PUNCT "(")
(ID "module_name")
(PUNCT ")")
(NEWLINE)
(ID "module")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "module_name")
(PUNCT "]")
(NEWLINE)
(ID "klass")
(PUNCT "=")
(ID "vars")
(PUNCT "(")
(ID "module")
(PUNCT ")")
(PUNCT "[")
(ID "class_name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DistutilsModuleError")
(PUNCT "(")
(LIT "can't compile C/C++ code: unable to load module '%s'")
(PUNCT "%")
(ID "module_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DistutilsModuleError")
(PUNCT "(")
(LIT "can't compile C/C++ code: unable to find class '%s' ")
(LIT "in module '%s'")
(PUNCT "%")
(PUNCT "(")
(ID "class_name")
(PUNCT ",")
(ID "module_name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "klass")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "dry_run")
(PUNCT ",")
(ID "force")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "gen_preprocess_options")
(PUNCT "(")
(ID "macros")
(PUNCT ",")
(ID "include_dirs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate C pre-processor options (-D, -U, -I) as used by at least\n    two types of compilers: the typical Unix compiler and Visual C++.\n    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)\n    means undefine (-U) macro 'name', and (name,value) means define (-D)\n    macro 'name' to 'value'.  'include_dirs' is just a list of directory\n    names to be added to the header file search path (-I).  Returns a list\n    of command-line options suitable for either Unix compilers or Visual\n    C++.\n    ")
(NEWLINE)
(ID "pp_opts")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "macro")
(KEYWORD in)
(ID "macros")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "macro")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(KEYWORD and)
(LIT 1)
(PUNCT "<=")
(ID "len")
(PUNCT "(")
(ID "macro")
(PUNCT ")")
(PUNCT "<=")
(LIT 2)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "bad macro definition '%s': ")
(LIT "each element of 'macros' list must be a 1- or 2-tuple")
(PUNCT "%")
(ID "macro")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "macro")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pp_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "-U%s")
(PUNCT "%")
(ID "macro")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "macro")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "macro")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pp_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "-D%s")
(PUNCT "%")
(ID "macro")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pp_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "-D%s=%s")
(PUNCT "%")
(ID "macro")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "dir")
(KEYWORD in)
(ID "include_dirs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pp_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "-I%s")
(PUNCT "%")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "pp_opts")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "gen_lib_options")
(PUNCT "(")
(ID "compiler")
(PUNCT ",")
(ID "library_dirs")
(PUNCT ",")
(ID "runtime_library_dirs")
(PUNCT ",")
(ID "libraries")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate linker options for searching library directories and\n    linking with specific libraries.  'libraries' and 'library_dirs' are,\n    respectively, lists of library names (not filenames!) and search\n    directories.  Returns a list of command-line options suitable for use\n    with some compiler (depending on the two format strings passed in).\n    ")
(NEWLINE)
(ID "lib_opts")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "dir")
(KEYWORD in)
(ID "library_dirs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lib_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "compiler")
(PUNCT ".")
(ID "library_dir_option")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "dir")
(KEYWORD in)
(ID "runtime_library_dirs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opt")
(PUNCT "=")
(ID "compiler")
(PUNCT ".")
(ID "runtime_library_dir_option")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "opt")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lib_opts")
(PUNCT "=")
(ID "lib_opts")
(PUNCT "+")
(ID "opt")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lib_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "opt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD for)
(ID "lib")
(KEYWORD in)
(ID "libraries")
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "(")
(ID "lib_dir")
(PUNCT ",")
(ID "lib_name")
(PUNCT ")")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "lib")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "lib_dir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lib_file")
(PUNCT "=")
(ID "compiler")
(PUNCT ".")
(ID "find_library_file")
(PUNCT "(")
(PUNCT "[")
(ID "lib_dir")
(PUNCT "]")
(PUNCT ",")
(ID "lib_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "lib_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lib_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "lib_file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "compiler")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "no library file corresponding to ")
(LIT "'%s' found (skipping)")
(PUNCT "%")
(ID "lib")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lib_opts")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "compiler")
(PUNCT ".")
(ID "library_option")
(PUNCT "(")
(ID "lib")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "lib_opts")
(NEWLINE)
(DEDENT)
(ENDMARKER)
