(LIT "\nThe Python Debugger Pdb\n=======================\n\nTo use the debugger in its simplest form:\n\n        >>> import pdb\n        >>> pdb.run('<a statement>')\n\nThe debugger's prompt is '(Pdb) '.  This will stop in the first\nfunction call in <a statement>.\n\nAlternatively, if a statement terminated with an unhandled exception,\nyou can use pdb's post-mortem facility to inspect the contents of the\ntraceback:\n\n        >>> <a statement>\n        <exception traceback>\n        >>> import pdb\n        >>> pdb.pm()\n\nThe commands recognized by the debugger are listed in the next\nsection.  Most can be abbreviated as indicated; e.g., h(elp) means\nthat 'help' can be typed as 'h' or 'help' (but not as 'he' or 'hel',\nnor as 'H' or 'Help' or 'HELP').  Optional arguments are enclosed in\nsquare brackets.  Alternatives in the command syntax are separated\nby a vertical bar (|).\n\nA blank line repeats the previous command literally, except for\n'list', where it lists the next 11 lines.\n\nCommands that the debugger doesn't recognize are assumed to be Python\nstatements and are executed in the context of the program being\ndebugged.  Python statements can also be prefixed with an exclamation\npoint ('!').  This is a powerful way to inspect the program being\ndebugged; it is even possible to change variables or call functions.\nWhen an exception occurs in such a statement, the exception name is\nprinted but the debugger's state is not changed.\n\nThe debugger supports aliases, which can save typing.  And aliases can\nhave parameters (see the alias help entry) which allows one a certain\nlevel of adaptability to the context under examination.\n\nMultiple commands may be entered on a single line, separated by the\npair ';;'.  No intelligence is applied to separating the commands; the\ninput is split at the first ';;', even if it is in the middle of a\nquoted string.\n\nIf a file \".pdbrc\" exists in your home directory or in the current\ndirectory, it is read in and executed as if it had been typed at the\ndebugger prompt.  This is particularly useful for aliases.  If both\nfiles exist, the one in the home directory is read first and aliases\ndefined there can be overriden by the local file.\n\nAside from aliases, the debugger is not directly programmable; but it\nis implemented as a class from which you can derive your own debugger\nclass, which you can make as fancy as you like.\n\n\nDebugger commands\n=================\n\n")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "cmd")
(NEWLINE)
(KEYWORD import)
(ID "bdb")
(NEWLINE)
(KEYWORD import)
(ID "dis")
(NEWLINE)
(KEYWORD import)
(ID "code")
(NEWLINE)
(KEYWORD import)
(ID "glob")
(NEWLINE)
(KEYWORD import)
(ID "pprint")
(NEWLINE)
(KEYWORD import)
(ID "signal")
(NEWLINE)
(KEYWORD import)
(ID "inspect")
(NEWLINE)
(KEYWORD import)
(ID "traceback")
(NEWLINE)
(KEYWORD import)
(ID "linecache")
(NEWLINE)
(KEYWORD class)
(ID "Restart")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Causes a debugger to be restarted for the debugged python program.")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "run")
(PUNCT ",")
(LIT "pm")
(PUNCT ",")
(LIT "Pdb")
(PUNCT ",")
(LIT "runeval")
(PUNCT ",")
(LIT "runctx")
(PUNCT ",")
(LIT "runcall")
(PUNCT ",")
(LIT "set_trace")
(PUNCT ",")
(LIT "post_mortem")
(PUNCT ",")
(LIT "help")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "find_function")
(PUNCT "(")
(ID "funcname")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cre")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "def\\s+%s\\s*[(]")
(PUNCT "%")
(ID "re")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "funcname")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fp")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD with)
(ID "fp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "lineno")
(PUNCT ",")
(ID "line")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "start")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "cre")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "funcname")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getsourcelines")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "findsource")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "inspect")
(PUNCT ".")
(ID "isframe")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(KEYWORD and)
(ID "obj")
(PUNCT ".")
(ID "f_globals")
(KEYWORD is)
(ID "obj")
(PUNCT ".")
(ID "f_locals")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lines")
(PUNCT ",")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "inspect")
(PUNCT ".")
(ID "ismodule")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lines")
(PUNCT ",")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "inspect")
(PUNCT ".")
(ID "getblock")
(PUNCT "(")
(ID "lines")
(PUNCT "[")
(ID "lineno")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "lasti2lineno")
(PUNCT "(")
(ID "code")
(PUNCT ",")
(ID "lasti")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "linestarts")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "dis")
(PUNCT ".")
(ID "findlinestarts")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "linestarts")
(PUNCT ".")
(ID "reverse")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "lineno")
(KEYWORD in)
(ID "linestarts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "lasti")
(PUNCT ">=")
(ID "i")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lineno")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "_rstr")
(PUNCT "(")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "String that doesn't quote its repr.")
(NEWLINE)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "line_prefix")
(PUNCT "=")
(LIT "\n-> ")
(NEWLINE)
(KEYWORD class)
(ID "Pdb")
(PUNCT "(")
(ID "bdb")
(PUNCT ".")
(ID "Bdb")
(PUNCT ",")
(ID "cmd")
(PUNCT ".")
(ID "Cmd")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "completekey")
(PUNCT "=")
(LIT "tab")
(PUNCT ",")
(ID "stdin")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stdout")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "skip")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "nosigint")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bdb")
(PUNCT ".")
(ID "Bdb")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "skip")
(PUNCT "=")
(ID "skip")
(PUNCT ")")
(NEWLINE)
(ID "cmd")
(PUNCT ".")
(ID "Cmd")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "completekey")
(PUNCT ",")
(ID "stdin")
(PUNCT ",")
(ID "stdout")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "stdout")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "use_rawinput")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "prompt")
(PUNCT "=")
(LIT "(Pdb) ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tb_lineno")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "readline")
(NEWLINE)
(ID "readline")
(PUNCT ".")
(ID "set_completer_delims")
(PUNCT "(")
(LIT " \t\n`@#$%^&*()=+[{]}\\|;:'\",<>?")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "allow_kbdint")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "nosigint")
(PUNCT "=")
(ID "nosigint")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rcLines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(LIT "HOME")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "envHome")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(LIT "HOME")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "envHome")
(PUNCT ",")
(LIT ".pdbrc")
(PUNCT ")")
(PUNCT ")")
(KEYWORD as)
(ID "rcFile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "rcLines")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "rcFile")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(LIT ".pdbrc")
(PUNCT ")")
(KEYWORD as)
(ID "rcFile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "rcLines")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "rcFile")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_defining")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_bnum")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "sigint_handler")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "signum")
(PUNCT ",")
(ID "frame")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "allow_kbdint")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyboardInterrupt")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "\nProgram interrupted. (Use 'cont' to resume).")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_step")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_trace")
(PUNCT "(")
(ID "frame")
(PUNCT ")")
(NEWLINE)
(ID "signal")
(PUNCT ".")
(ID "signal")
(PUNCT "(")
(ID "signal")
(PUNCT ".")
(ID "SIGINT")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_previous_sigint_handler")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "reset")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bdb")
(PUNCT ".")
(ID "Bdb")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "forget")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "forget")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tb_lineno")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "setup")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "f")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "forget")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_stack")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "tb")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "tb")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "lasti2lineno")
(PUNCT "(")
(ID "tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ",")
(ID "tb")
(PUNCT ".")
(ID "tb_lasti")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tb_lineno")
(PUNCT "[")
(ID "tb")
(PUNCT ".")
(ID "tb_frame")
(PUNCT "]")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "tb")
(PUNCT "=")
(ID "tb")
(PUNCT ".")
(ID "tb_next")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_locals")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "execRcLines")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execRcLines")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "rcLines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "rcLines")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "rcLines")
(NEWLINE)
(ID "rcLines")
(PUNCT ".")
(ID "reverse")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "rcLines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "rcLines")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "rcLines")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "line")
(KEYWORD and)
(ID "line")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "!=")
(LIT "#")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "onecmd")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "rcLines")
(PUNCT "+=")
(ID "reversed")
(PUNCT "(")
(ID "rcLines")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "user_call")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ",")
(ID "argument_list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This method is called when there is the remote possibility\n        that we ever need to stop in this function.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "stop_here")
(PUNCT "(")
(ID "frame")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "--Call--")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "user_line")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This function is called when we stop or break at this line.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "canonic")
(PUNCT "(")
(ID "frame")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_filename")
(PUNCT ")")
(KEYWORD or)
(ID "frame")
(PUNCT ".")
(ID "f_lineno")
(PUNCT "<=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "bp_commands")
(PUNCT "(")
(ID "frame")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "bp_commands")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Call every command that was set for the current active breakpoint\n        (if there is one).\n\n        Returns True if the normal interaction function must be called,\n        False otherwise.")
(NEWLINE)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "currentbp")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "currentbp")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "currentbp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "currentbp")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "currentbp")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "lastcmd_back")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "lastcmd")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "setup")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "[")
(ID "currentbp")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "onecmd")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "lastcmd")
(PUNCT "=")
(ID "lastcmd_back")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "[")
(ID "currentbp")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "print_stack_entry")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "[")
(ID "currentbp")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_cmdloop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "forget")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "user_return")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ",")
(ID "return_value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This function is called when a return trap is set here.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "frame")
(PUNCT ".")
(ID "f_locals")
(PUNCT "[")
(LIT "__return__")
(PUNCT "]")
(PUNCT "=")
(ID "return_value")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "--Return--")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "user_exception")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ",")
(ID "exc_info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This function is called if an exception occurs,\n        but only if we are to stop at or just below this level.")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "exc_type")
(PUNCT ",")
(ID "exc_value")
(PUNCT ",")
(ID "exc_traceback")
(PUNCT "=")
(ID "exc_info")
(NEWLINE)
(ID "frame")
(PUNCT ".")
(ID "f_locals")
(PUNCT "[")
(LIT "__exception__")
(PUNCT "]")
(PUNCT "=")
(ID "exc_type")
(PUNCT ",")
(ID "exc_value")
(NEWLINE)
(ID "prefix")
(PUNCT "=")
(LIT "Internal ")
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "exc_traceback")
(KEYWORD and)
(ID "exc_type")
(KEYWORD is)
(ID "StopIteration")
(PUNCT ")")
(KEYWORD else)
(LIT "")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "%s%s")
(PUNCT "%")
(PUNCT "(")
(ID "prefix")
(PUNCT ",")
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(ID "exc_type")
(PUNCT ",")
(ID "exc_value")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(ID "exc_traceback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_cmdloop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "allow_kbdint")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cmdloop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "allow_kbdint")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyboardInterrupt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "--KeyboardInterrupt--")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "preloop")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "displaying")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "displaying")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "expr")
(PUNCT ",")
(ID "oldvalue")
(KEYWORD in)
(ID "displaying")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newvalue")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_getval_except")
(PUNCT "(")
(ID "expr")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "newvalue")
(KEYWORD is)
(KEYWORD not)
(ID "oldvalue")
(KEYWORD and)
(ID "newvalue")
(PUNCT "!=")
(ID "oldvalue")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "displaying")
(PUNCT "[")
(ID "expr")
(PUNCT "]")
(PUNCT "=")
(ID "newvalue")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "display %s: %r  [old: %r]")
(PUNCT "%")
(PUNCT "(")
(ID "expr")
(PUNCT ",")
(ID "newvalue")
(PUNCT ",")
(ID "oldvalue")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "interaction")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame")
(PUNCT ",")
(ID "traceback")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "setup")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(ID "traceback")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "forget")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "print_stack_entry")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cmdloop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "forget")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "displayhook")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "obj")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Custom displayhook for the exec in default(), which prevents\n        assignment of the _ variable in the builtins.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "obj")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "default")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "!")
(PUNCT ":")
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "locals")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(NEWLINE)
(ID "globals")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "code")
(PUNCT "=")
(ID "compile")
(PUNCT "(")
(ID "line")
(PUNCT "+")
(LIT "\n")
(PUNCT ",")
(LIT "<stdin>")
(PUNCT ",")
(LIT "single")
(PUNCT ")")
(NEWLINE)
(ID "save_stdout")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(ID "save_stdin")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(NEWLINE)
(ID "save_displayhook")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "displayhook")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stdin")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "displayhook")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "displayhook")
(NEWLINE)
(ID "exec")
(PUNCT "(")
(ID "code")
(PUNCT ",")
(ID "globals")
(PUNCT ",")
(ID "locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "save_stdout")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT "=")
(ID "save_stdin")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "displayhook")
(PUNCT "=")
(ID "save_displayhook")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_info")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(PUNCT "*")
(ID "exc_info")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "precmd")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handle alias expansion and ';;' separator.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(ID "args")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT "[")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(ID "ii")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD for)
(ID "tmpArg")
(KEYWORD in)
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "%")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "ii")
(PUNCT ")")
(PUNCT ",")
(ID "tmpArg")
(PUNCT ")")
(NEWLINE)
(ID "ii")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "%*")
(PUNCT ",")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "!=")
(LIT "alias")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "marker")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ";;")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "marker")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "next")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(ID "marker")
(PUNCT "+")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cmdqueue")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "next")
(PUNCT ")")
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(ID "marker")
(PUNCT "]")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "onecmd")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Interpret the argument as though it had been typed in response\n        to the prompt.\n\n        Checks whether this line is typed at the normal prompt or in\n        a breakpoint command list definition.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "commands_defining")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cmd")
(PUNCT ".")
(ID "Cmd")
(PUNCT ".")
(ID "onecmd")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "handle_command_def")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "handle_command_def")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Handles one command line during command list definition.")
(NEWLINE)
(ID "cmd")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "parseline")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "cmd")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "cmd")
(PUNCT "==")
(LIT "silent")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "commands_bnum")
(PUNCT "]")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "cmd")
(PUNCT "==")
(LIT "end")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "cmdqueue")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "cmdlist")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "commands_bnum")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cmdlist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "cmd")
(PUNCT "+")
(LIT " ")
(PUNCT "+")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cmdlist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "cmd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "do_")
(PUNCT "+")
(ID "cmd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "default")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "func")
(PUNCT ".")
(ID "__name__")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "commands_resuming")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "commands_bnum")
(PUNCT "]")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "cmdqueue")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "message")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stdout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "***")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stdout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_complete_location")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "begidx")
(PUNCT ",")
(ID "endidx")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(PUNCT "(")
(LIT ":")
(PUNCT ",")
(LIT ",")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_complete_expression")
(PUNCT "(")
(ID "text")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "begidx")
(PUNCT ",")
(ID "endidx")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "globs")
(PUNCT "=")
(ID "glob")
(PUNCT ".")
(ID "glob")
(PUNCT "(")
(ID "text")
(PUNCT "+")
(LIT "*")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "globs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fn")
(PUNCT "+")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isfile")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(KEYWORD and)
(ID "fn")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(PUNCT "(")
(LIT ".py")
(PUNCT ",")
(LIT ".pyw")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ret")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "fn")
(PUNCT "+")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "ret")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_complete_bpnumber")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "begidx")
(PUNCT ",")
(ID "endidx")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "str")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "bp")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "bdb")
(PUNCT ".")
(ID "Breakpoint")
(PUNCT ".")
(ID "bpbynumber")
(PUNCT ")")
(KEYWORD if)
(ID "bp")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "str")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_complete_expression")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "begidx")
(PUNCT ",")
(ID "endidx")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "ns")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "ns")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT ".")
(KEYWORD in)
(ID "text")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dotted")
(PUNCT "=")
(ID "text")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj")
(PUNCT "=")
(ID "ns")
(PUNCT "[")
(ID "dotted")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "part")
(KEYWORD in)
(ID "dotted")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "obj")
(PUNCT ",")
(ID "part")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "KeyError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "prefix")
(PUNCT "=")
(LIT ".")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dotted")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT "+")
(LIT ".")
(NEWLINE)
(KEYWORD return)
(PUNCT "[")
(ID "prefix")
(PUNCT "+")
(ID "n")
(KEYWORD for)
(ID "n")
(KEYWORD in)
(ID "dir")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(KEYWORD if)
(ID "n")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "dotted")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "n")
(KEYWORD for)
(ID "n")
(KEYWORD in)
(ID "ns")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "n")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "do_commands")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "commands [bpnumber]\n        (com) ...\n        (com) end\n        (Pdb)\n\n        Specify a list of commands for breakpoint number bpnumber.\n        The commands themselves are entered on the following lines.\n        Type a line containing just 'end' to terminate the commands.\n        The commands are executed when the breakpoint is hit.\n\n        To remove all commands from a breakpoint, type commands and\n        follow it immediately with end; that is, give no commands.\n\n        With no bpnumber argument, commands refers to the last\n        breakpoint set.\n\n        You can use breakpoint commands to start your program up\n        again.  Simply use the continue command, or step, or any other\n        command that resumes execution.\n\n        Specifying any command resuming execution (currently continue,\n        step, next, return, jump, quit and their abbreviations)\n        terminates the command list (as if that command was\n        immediately followed by end).  This is because any time you\n        resume execution (even with a simple next or step), you may\n        encounter another breakpoint -- which could have its own\n        command list, leading to ambiguities about which list to\n        execute.\n\n        If you use the 'silent' command in the command list, the usual\n        message about stopping at a breakpoint is not printed.  This\n        may be desirable for breakpoints that are to print a specific\n        message and then continue.  If none of the other commands\n        print anything, you will see no sign that the breakpoint was\n        reached.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bnum")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "bdb")
(PUNCT ".")
(ID "Breakpoint")
(PUNCT ".")
(ID "bpbynumber")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bnum")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Usage: commands [bnum]\n        ...\n        end")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "commands_bnum")
(PUNCT "=")
(ID "bnum")
(NEWLINE)
(KEYWORD if)
(ID "bnum")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "old_command_defs")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "old_command_defs")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "prompt_back")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "prompt")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "prompt")
(PUNCT "=")
(LIT "(com) ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_defining")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "cmdloop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyboardInterrupt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "old_command_defs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT "=")
(ID "old_command_defs")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT "=")
(ID "old_command_defs")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(PUNCT "=")
(ID "old_command_defs")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "commands")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "commands_doprompt")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "commands_silent")
(PUNCT "[")
(ID "bnum")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "command definition aborted, old commands restored")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "commands_defining")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "prompt")
(PUNCT "=")
(ID "prompt_back")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "complete_commands")
(PUNCT "=")
(ID "_complete_bpnumber")
(NEWLINE)
(KEYWORD def)
(ID "do_break")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "temporary")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "b(reak) [ ([filename:]lineno | function) [, condition] ]\n        Without argument, list all breaks.\n\n        With a line number argument, set a break at this line in the\n        current file.  With a function name, set a break at the first\n        executable line of that function.  If a second argument is\n        present, it is a string specifying an expression which must\n        evaluate to true before the breakpoint is honored.\n\n        The line number may be prefixed with a filename and a colon,\n        to specify a breakpoint in another file (probably one that\n        hasn't been loaded yet).  The file is searched for on\n        sys.path; the .py suffix may be omitted.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "breaks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Num Type         Disp Enb   Where")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "bp")
(KEYWORD in)
(ID "bdb")
(PUNCT ".")
(ID "Breakpoint")
(PUNCT ".")
(ID "bpbynumber")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "bp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "bp")
(PUNCT ".")
(ID "bpformat")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "cond")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "comma")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "comma")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cond")
(PUNCT "=")
(ID "arg")
(PUNCT "[")
(ID "comma")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "arg")
(PUNCT "=")
(ID "arg")
(PUNCT "[")
(PUNCT ":")
(ID "comma")
(PUNCT "]")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "colon")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "rfind")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(ID "funcname")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "colon")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "arg")
(PUNCT "[")
(PUNCT ":")
(ID "colon")
(PUNCT "]")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "f")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "lookupmodule")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "%r not found from sys.path")
(PUNCT "%")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "f")
(NEWLINE)
(DEDENT)
(ID "arg")
(PUNCT "=")
(ID "arg")
(PUNCT "[")
(ID "colon")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Bad lineno: %s")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "=")
(ID "eval")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(LIT "__func__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "=")
(ID "func")
(PUNCT ".")
(ID "__func__")
(NEWLINE)
(DEDENT)
(ID "code")
(PUNCT "=")
(ID "func")
(PUNCT ".")
(ID "__code__")
(NEWLINE)
(ID "funcname")
(PUNCT "=")
(ID "code")
(PUNCT ".")
(ID "co_name")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(ID "code")
(PUNCT ".")
(ID "co_firstlineno")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "code")
(PUNCT ".")
(ID "co_filename")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "(")
(ID "ok")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "ln")
(PUNCT ")")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "lineinfo")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "ok")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "The specified object %r is not a function ")
(LIT "or was not found along sys.path.")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "funcname")
(PUNCT "=")
(ID "ok")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "ln")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "filename")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "defaultFile")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "checkline")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "err")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "set_break")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "temporary")
(PUNCT ",")
(ID "cond")
(PUNCT ",")
(ID "funcname")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_breaks")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Breakpoint %d at %s:%d")
(PUNCT "%")
(PUNCT "(")
(ID "bp")
(PUNCT ".")
(ID "number")
(PUNCT ",")
(ID "bp")
(PUNCT ".")
(ID "file")
(PUNCT ",")
(ID "bp")
(PUNCT ".")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "defaultFile")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Produce a reasonable default.")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_filename")
(NEWLINE)
(KEYWORD if)
(ID "filename")
(PUNCT "==")
(LIT "<string>")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "filename")
(NEWLINE)
(DEDENT)
(ID "do_b")
(PUNCT "=")
(ID "do_break")
(NEWLINE)
(ID "complete_break")
(PUNCT "=")
(ID "_complete_location")
(NEWLINE)
(ID "complete_b")
(PUNCT "=")
(ID "_complete_location")
(NEWLINE)
(KEYWORD def)
(ID "do_tbreak")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "tbreak [ ([filename:]lineno | function) [, condition] ]\n        Same arguments as break, but sets a temporary breakpoint: it\n        is automatically deleted when first hit.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "do_break")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "complete_tbreak")
(PUNCT "=")
(ID "_complete_location")
(NEWLINE)
(KEYWORD def)
(ID "lineinfo")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "identifier")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "failed")
(PUNCT "=")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "idstring")
(PUNCT "=")
(ID "identifier")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "'")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "idstring")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "id")
(PUNCT "=")
(ID "idstring")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "idstring")
(PUNCT ")")
(PUNCT "==")
(LIT 3)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "id")
(PUNCT "=")
(ID "idstring")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failed")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "id")
(PUNCT "==")
(LIT "")
(PUNCT ":")
(KEYWORD return)
(ID "failed")
(NEWLINE)
(ID "parts")
(PUNCT "=")
(ID "id")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "failed")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "fname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "defaultFile")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "parts")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "item")
(PUNCT "=")
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "lookupmodule")
(PUNCT "(")
(ID "parts")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fname")
(PUNCT "=")
(ID "f")
(NEWLINE)
(DEDENT)
(ID "item")
(PUNCT "=")
(ID "parts")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "answer")
(PUNCT "=")
(ID "find_function")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(ID "fname")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "answer")
(KEYWORD or)
(ID "failed")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "checkline")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Check whether specified line seems to be executable.\n\n        Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank\n        line or EOF). Warning: testing is not comprehensive.\n        ")
(NEWLINE)
(ID "globs")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "curframe")
(PUNCT ")")
(KEYWORD else)
(KEYWORD None)
(NEWLINE)
(ID "line")
(PUNCT "=")
(ID "linecache")
(PUNCT ".")
(ID "getline")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "globs")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "End of file")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(KEYWORD not)
(ID "line")
(KEYWORD or)
(PUNCT "(")
(ID "line")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "#")
(PUNCT ")")
(KEYWORD or)
(PUNCT "(")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(LIT 3)
(PUNCT "]")
(PUNCT "==")
(LIT "\"\"\"")
(PUNCT ")")
(KEYWORD or)
(ID "line")
(PUNCT "[")
(PUNCT ":")
(LIT 3)
(PUNCT "]")
(PUNCT "==")
(LIT "'''")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Blank or comment")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "lineno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "do_enable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "enable bpnumber [bpnumber ...]\n        Enables the breakpoints given as a space separated list of\n        breakpoint numbers.\n        ")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_bpbynumber")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT ".")
(ID "enable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Enabled %s")
(PUNCT "%")
(ID "bp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "complete_enable")
(PUNCT "=")
(ID "_complete_bpnumber")
(NEWLINE)
(KEYWORD def)
(ID "do_disable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "disable bpnumber [bpnumber ...]\n        Disables the breakpoints given as a space separated list of\n        breakpoint numbers.  Disabling a breakpoint means it cannot\n        cause the program to stop execution, but unlike clearing a\n        breakpoint, it remains in the list of breakpoints and can be\n        (re-)enabled.\n        ")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_bpbynumber")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT ".")
(ID "disable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Disabled %s")
(PUNCT "%")
(ID "bp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "complete_disable")
(PUNCT "=")
(ID "_complete_bpnumber")
(NEWLINE)
(KEYWORD def)
(ID "do_condition")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "condition bpnumber [condition]\n        Set a new condition for the breakpoint, an expression which\n        must evaluate to true before the breakpoint is honored.  If\n        condition is absent, any existing condition is removed; i.e.,\n        the breakpoint is made unconditional.\n        ")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cond")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cond")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_bpbynumber")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Breakpoint number expected")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT ".")
(ID "cond")
(PUNCT "=")
(ID "cond")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "cond")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Breakpoint %d is now unconditional.")
(PUNCT "%")
(ID "bp")
(PUNCT ".")
(ID "number")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "New condition set for breakpoint %d.")
(PUNCT "%")
(ID "bp")
(PUNCT ".")
(ID "number")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "complete_condition")
(PUNCT "=")
(ID "_complete_bpnumber")
(NEWLINE)
(KEYWORD def)
(ID "do_ignore")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "ignore bpnumber [count]\n        Set the ignore count for the given breakpoint number.  If\n        count is omitted, the ignore count is set to 0.  A breakpoint\n        becomes active when the ignore count is zero.  When non-zero,\n        the count is decremented each time the breakpoint is reached\n        and the breakpoint is not disabled and any associated\n        condition evaluates to true.\n        ")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "count")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "count")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_bpbynumber")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Breakpoint number expected")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT ".")
(ID "ignore")
(PUNCT "=")
(ID "count")
(NEWLINE)
(KEYWORD if)
(ID "count")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "count")
(PUNCT ">")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "countstr")
(PUNCT "=")
(LIT "%d crossings")
(PUNCT "%")
(ID "count")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "countstr")
(PUNCT "=")
(LIT "1 crossing")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Will ignore next %s of breakpoint %d.")
(PUNCT "%")
(PUNCT "(")
(ID "countstr")
(PUNCT ",")
(ID "bp")
(PUNCT ".")
(ID "number")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Will stop next time breakpoint %d is reached.")
(PUNCT "%")
(ID "bp")
(PUNCT ".")
(ID "number")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "complete_ignore")
(PUNCT "=")
(ID "_complete_bpnumber")
(NEWLINE)
(KEYWORD def)
(ID "do_clear")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "cl(ear) filename:lineno\ncl(ear) [bpnumber [bpnumber...]]\n        With a space separated list of breakpoint numbers, clear\n        those breakpoints.  Without argument, clear all breaks (but\n        first ask confirmation).  With a filename:lineno argument,\n        clear all breaks at that line in that file.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "reply")
(PUNCT "=")
(ID "input")
(PUNCT "(")
(LIT "Clear all breaks? ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "EOFError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "reply")
(PUNCT "=")
(LIT "no")
(NEWLINE)
(DEDENT)
(ID "reply")
(PUNCT "=")
(ID "reply")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "reply")
(KEYWORD in)
(PUNCT "(")
(LIT "y")
(PUNCT ",")
(LIT "yes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bplist")
(PUNCT "=")
(PUNCT "[")
(ID "bp")
(KEYWORD for)
(ID "bp")
(KEYWORD in)
(ID "bdb")
(PUNCT ".")
(ID "Breakpoint")
(PUNCT ".")
(ID "bpbynumber")
(KEYWORD if)
(ID "bp")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "clear_all_breaks")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "bp")
(KEYWORD in)
(ID "bplist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Deleted %s")
(PUNCT "%")
(ID "bp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT ":")
(KEYWORD in)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "i")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "rfind")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "arg")
(PUNCT "[")
(PUNCT ":")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "arg")
(PUNCT "=")
(ID "arg")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "err")
(PUNCT "=")
(LIT "Invalid line number (%s)")
(PUNCT "%")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bplist")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_breaks")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(ID "err")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "clear_break")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "bp")
(KEYWORD in)
(ID "bplist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Deleted %s")
(PUNCT "%")
(ID "bp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "numberlist")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "numberlist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "bp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_bpbynumber")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "clear_bpbynumber")
(PUNCT "(")
(ID "i")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Deleted %s")
(PUNCT "%")
(ID "bp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "do_cl")
(PUNCT "=")
(ID "do_clear")
(NEWLINE)
(ID "complete_clear")
(PUNCT "=")
(ID "_complete_location")
(NEWLINE)
(ID "complete_cl")
(PUNCT "=")
(ID "_complete_location")
(NEWLINE)
(KEYWORD def)
(ID "do_where")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "w(here)\n        Print a stack trace, with the most recent frame at the bottom.\n        An arrow indicates the \"current frame\", which determines the\n        context of most commands.  'bt' is an alias for this command.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "print_stack_trace")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "do_w")
(PUNCT "=")
(ID "do_where")
(NEWLINE)
(ID "do_bt")
(PUNCT "=")
(ID "do_where")
(NEWLINE)
(KEYWORD def)
(ID "_select_frame")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "number")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(LIT 0)
(PUNCT "<=")
(ID "number")
(PUNCT "<")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "=")
(ID "number")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_locals")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "print_stack_entry")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "do_up")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "u(p) [count]\n        Move the current frame count (default one) levels up in the\n        stack trace (to an older frame).\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Oldest frame")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "count")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(KEYWORD or)
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Invalid frame count (%s)")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "count")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newframe")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newframe")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "-")
(ID "count")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_select_frame")
(PUNCT "(")
(ID "newframe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "do_u")
(PUNCT "=")
(ID "do_up")
(NEWLINE)
(KEYWORD def)
(ID "do_down")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "d(own) [count]\n        Move the current frame count (default one) levels down in the\n        stack trace (to a newer frame).\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "+")
(LIT 1)
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Newest frame")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "count")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(KEYWORD or)
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Invalid frame count (%s)")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "count")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newframe")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "newframe")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ")")
(PUNCT "-")
(LIT 1)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "+")
(ID "count")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_select_frame")
(PUNCT "(")
(ID "newframe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "do_d")
(PUNCT "=")
(ID "do_down")
(NEWLINE)
(KEYWORD def)
(ID "do_until")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "unt(il) [lineno]\n        Without argument, continue execution until the line with a\n        number greater than the current one is reached.  With a line\n        number, continue execution until a line with a number greater\n        or equal to that is reached.  In both cases, also stop when\n        the current frame returns.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Error in argument: %r")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "lineno")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_lineno")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "\"until\" line number is smaller than current ")
(LIT "line number")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "set_until")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "do_unt")
(PUNCT "=")
(ID "do_until")
(NEWLINE)
(KEYWORD def)
(ID "do_step")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "s(tep)\n        Execute the current line, stop at the first possible occasion\n        (either in a function that is called or in the current\n        function).\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_step")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "do_s")
(PUNCT "=")
(ID "do_step")
(NEWLINE)
(KEYWORD def)
(ID "do_next")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "n(ext)\n        Continue execution until the next line in the current function\n        is reached or it returns.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_next")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "do_n")
(PUNCT "=")
(ID "do_next")
(NEWLINE)
(KEYWORD def)
(ID "do_run")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "run [args...]\n        Restart the debugged python program. If a string is supplied\n        it is split with \"shlex\", and the result is used as the new\n        sys.argv.  History, breakpoints, actions and debugger options\n        are preserved.  \"restart\" is an alias for \"run\".\n        ")
(NEWLINE)
(KEYWORD if)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "shlex")
(NEWLINE)
(ID "argv0")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 0)
(PUNCT ":")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "=")
(ID "shlex")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(PUNCT ":")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "argv0")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "Restart")
(NEWLINE)
(DEDENT)
(ID "do_restart")
(PUNCT "=")
(ID "do_run")
(NEWLINE)
(KEYWORD def)
(ID "do_return")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "r(eturn)\n        Continue execution until the current function returns.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_return")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "do_r")
(PUNCT "=")
(ID "do_return")
(NEWLINE)
(KEYWORD def)
(ID "do_continue")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "c(ont(inue))\n        Continue execution, only stop when a breakpoint is encountered.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "nosigint")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_previous_sigint_handler")
(PUNCT "=")
(ID "signal")
(PUNCT ".")
(ID "signal")
(PUNCT "(")
(ID "signal")
(PUNCT ".")
(ID "SIGINT")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "sigint_handler")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "set_continue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "do_c")
(PUNCT "=")
(ID "do_cont")
(PUNCT "=")
(ID "do_continue")
(NEWLINE)
(KEYWORD def)
(ID "do_jump")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "j(ump) lineno\n        Set the next line that will be executed.  Only available in\n        the bottom-most frame.  This lets you jump back and execute\n        code again, or jump forward to skip code that you don't want\n        to run.\n\n        It should be noted that not all jumps are allowed -- for\n        instance it is not possible to jump into the middle of a\n        for loop or out of a finally clause.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "+")
(LIT 1)
(PUNCT "!=")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "You can only jump within the bottom frame")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "arg")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "The 'jump' command requires a line number")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_lineno")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "arg")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "print_stack_entry")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "curindex")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Jump failed: %s")
(PUNCT "%")
(ID "e")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "do_j")
(PUNCT "=")
(ID "do_jump")
(NEWLINE)
(KEYWORD def)
(ID "do_debug")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "debug code\n        Enter a recursive debugger that steps through the code\n        argument (which is an arbitrary expression or statement to be\n        executed in the current environment).\n        ")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "settrace")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(ID "globals")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(NEWLINE)
(ID "locals")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(NEWLINE)
(ID "p")
(PUNCT "=")
(ID "Pdb")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "completekey")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "stdin")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "stdout")
(PUNCT ")")
(NEWLINE)
(ID "p")
(PUNCT ".")
(ID "prompt")
(PUNCT "=")
(LIT "(%s) ")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "prompt")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "ENTERING RECURSIVE DEBUGGER")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "call_tracing")
(PUNCT "(")
(ID "p")
(PUNCT ".")
(ID "run")
(PUNCT ",")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "globals")
(PUNCT ",")
(ID "locals")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "LEAVING RECURSIVE DEBUGGER")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "settrace")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "trace_dispatch")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lastcmd")
(PUNCT "=")
(ID "p")
(PUNCT ".")
(ID "lastcmd")
(NEWLINE)
(DEDENT)
(ID "complete_debug")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(KEYWORD def)
(ID "do_quit")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "q(uit)\nexit\n        Quit from the debugger. The program being executed is aborted.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_user_requested_quit")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_quit")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(ID "do_q")
(PUNCT "=")
(ID "do_quit")
(NEWLINE)
(ID "do_exit")
(PUNCT "=")
(ID "do_quit")
(NEWLINE)
(KEYWORD def)
(ID "do_EOF")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "EOF\n        Handles the receipt of EOF as a command.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_user_requested_quit")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_quit")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "do_args")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a(rgs)\n        Print the argument list of the current function.\n        ")
(NEWLINE)
(ID "co")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_code")
(NEWLINE)
(ID "dict")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_argcount")
(NEWLINE)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_flags")
(PUNCT "&")
(LIT 4)
(PUNCT ":")
(ID "n")
(PUNCT "=")
(ID "n")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "co")
(PUNCT ".")
(ID "co_flags")
(PUNCT "&")
(LIT 8)
(PUNCT ":")
(ID "n")
(PUNCT "=")
(ID "n")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "co")
(PUNCT ".")
(ID "co_varnames")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "name")
(KEYWORD in)
(ID "dict")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "%s = %r")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "dict")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "%s = *** undefined ***")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "do_a")
(PUNCT "=")
(ID "do_args")
(NEWLINE)
(KEYWORD def)
(ID "do_retval")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "retval\n        Print the return value for the last return of a function.\n        ")
(NEWLINE)
(KEYWORD if)
(LIT "__return__")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT "[")
(LIT "__return__")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Not yet returned!")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "do_rv")
(PUNCT "=")
(ID "do_retval")
(NEWLINE)
(KEYWORD def)
(ID "_getval")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "eval")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_info")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(PUNCT "*")
(ID "exc_info")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_getval_except")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "frame")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "frame")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "eval")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "eval")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "frame")
(PUNCT ".")
(ID "f_globals")
(PUNCT ",")
(ID "frame")
(PUNCT ".")
(ID "f_locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc_info")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "err")
(PUNCT "=")
(ID "traceback")
(PUNCT ".")
(ID "format_exception_only")
(PUNCT "(")
(PUNCT "*")
(ID "exc_info")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_rstr")
(PUNCT "(")
(LIT "** raised %s **")
(PUNCT "%")
(ID "err")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "do_p")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "p expression\n        Print the value of the expression.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_getval")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "do_pp")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "pp expression\n        Pretty-print the value of the expression.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "pprint")
(PUNCT ".")
(ID "pformat")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_getval")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "complete_print")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(ID "complete_p")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(ID "complete_pp")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(KEYWORD def)
(ID "do_list")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "l(ist) [first [,last] | .]\n\n        List source code for the current file.  Without arguments,\n        list 11 lines around the current line or continue the previous\n        listing.  With . as argument, list 11 lines around the current\n        line.  With one argument, list 11 lines starting at that line.\n        With two arguments, list the given range; if the second\n        argument is less than the first, it is a count.\n\n        The current line in the current frame is indicated by \"->\".\n        If an exception is being debugged, the line where the\n        exception was originally raised or propagated is indicated by\n        \">>\", if it differs from the current line.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lastcmd")
(PUNCT "=")
(LIT "list")
(NEWLINE)
(ID "last")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "arg")
(KEYWORD and)
(ID "arg")
(PUNCT "!=")
(LIT ".")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT ",")
(KEYWORD in)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT ",")
(ID "last")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ",")
(PUNCT ")")
(NEWLINE)
(ID "first")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "first")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "last")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "last")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "last")
(PUNCT "<")
(ID "first")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last")
(PUNCT "=")
(ID "first")
(PUNCT "+")
(ID "last")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "arg")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "first")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "first")
(PUNCT "-")
(LIT 5)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "Error in argument: %r")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "lineno")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "arg")
(PUNCT "==")
(LIT ".")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_lineno")
(PUNCT "-")
(LIT 5)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "last")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "last")
(PUNCT "=")
(ID "first")
(PUNCT "+")
(LIT 10)
(NEWLINE)
(DEDENT)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_filename")
(NEWLINE)
(ID "breaklist")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_file_breaks")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT "=")
(ID "linecache")
(PUNCT ".")
(ID "getlines")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_print_lines")
(PUNCT "(")
(ID "lines")
(PUNCT "[")
(ID "first")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(ID "last")
(PUNCT "]")
(PUNCT ",")
(ID "first")
(PUNCT ",")
(ID "breaklist")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "last")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(PUNCT "<")
(ID "last")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "[EOF]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "KeyboardInterrupt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "do_l")
(PUNCT "=")
(ID "do_list")
(NEWLINE)
(KEYWORD def)
(ID "do_longlist")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "longlist | ll\n        List the whole source code for the current function or frame.\n        ")
(NEWLINE)
(ID "filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_code")
(PUNCT ".")
(ID "co_filename")
(NEWLINE)
(ID "breaklist")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_file_breaks")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(ID "getsourcelines")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_print_lines")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "breaklist")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "do_ll")
(PUNCT "=")
(ID "do_longlist")
(NEWLINE)
(KEYWORD def)
(ID "do_source")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "source expression\n        Try to get source code for the given object and display it.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "obj")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_getval")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(ID "getsourcelines")
(PUNCT "(")
(ID "obj")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "OSError")
(PUNCT ",")
(ID "TypeError")
(PUNCT ")")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "err")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_print_lines")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "complete_source")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(KEYWORD def)
(ID "_print_lines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lines")
(PUNCT ",")
(ID "start")
(PUNCT ",")
(ID "breaks")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "frame")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Print a range of lines.")
(NEWLINE)
(KEYWORD if)
(ID "frame")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "current_lineno")
(PUNCT "=")
(ID "frame")
(PUNCT ".")
(ID "f_lineno")
(NEWLINE)
(ID "exc_lineno")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "tb_lineno")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "frame")
(PUNCT ",")
(PUNCT "-")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "current_lineno")
(PUNCT "=")
(ID "exc_lineno")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "lineno")
(PUNCT ",")
(ID "line")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "lines")
(PUNCT ",")
(ID "start")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "lineno")
(PUNCT ")")
(PUNCT ".")
(ID "rjust")
(PUNCT "(")
(LIT 3)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT "<")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT " ")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "lineno")
(KEYWORD in)
(ID "breaks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT "B")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT " ")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "lineno")
(PUNCT "==")
(ID "current_lineno")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT "->")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "lineno")
(PUNCT "==")
(ID "exc_lineno")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT ">>")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "s")
(PUNCT "+")
(LIT "\t")
(PUNCT "+")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "do_whatis")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "whatis arg\n        Print the type of the argument.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_getval")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "code")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "code")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "__code__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "code")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Function %s")
(PUNCT "%")
(ID "code")
(PUNCT ".")
(ID "co_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "code")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "__func__")
(PUNCT ".")
(ID "__code__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "code")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Method %s")
(PUNCT "%")
(ID "code")
(PUNCT ".")
(ID "co_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "value")
(PUNCT ".")
(ID "__class__")
(KEYWORD is)
(ID "type")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Class %s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "value")
(PUNCT ".")
(ID "__module__")
(PUNCT ",")
(ID "value")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "type")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "complete_whatis")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(KEYWORD def)
(ID "do_display")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "display [expression]\n\n        Display the value of the expression if it changed, each time execution\n        stops in the current frame.\n\n        Without expression, list all display expressions for the current frame.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "Currently displaying:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "%s: %r")
(PUNCT "%")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "val")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_getval_except")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT ".")
(ID "setdefault")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT "=")
(ID "val")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "display %s: %r")
(PUNCT "%")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "complete_display")
(PUNCT "=")
(ID "_complete_expression")
(NEWLINE)
(KEYWORD def)
(ID "do_undisplay")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "undisplay [expression]\n\n        Do not display the expression any more in the current frame.\n\n        Without expression, clear all display expressions for the current frame.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "not displaying %s")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "complete_undisplay")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "begidx")
(PUNCT ",")
(ID "endidx")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "e")
(KEYWORD for)
(ID "e")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "displaying")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "do_interact")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "interact\n\n        Start an interactive interpreter whose global namespace\n        contains all the (global and local) names found in the current scope.\n        ")
(NEWLINE)
(ID "ns")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ".")
(ID "f_globals")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "ns")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "curframe_locals")
(PUNCT ")")
(NEWLINE)
(ID "code")
(PUNCT ".")
(ID "interact")
(PUNCT "(")
(LIT "*interactive*")
(PUNCT ",")
(ID "local")
(PUNCT "=")
(ID "ns")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "do_alias")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "alias [name [command [parameter parameter ...] ]]\n        Create an alias called 'name' that executes 'command'.  The\n        command must *not* be enclosed in quotes.  Replaceable\n        parameters can be indicated by %1, %2, and so on, while %* is\n        replaced by all the parameters.  If no command is given, the\n        current alias for name is shown. If no name is given, all\n        aliases are listed.\n\n        Aliases may be nested and can contain anything that can be\n        legally typed at the pdb prompt.  Note!  You *can* override\n        internal pdb commands with aliases!  Those internal commands\n        are then hidden until the alias is removed.  Aliasing is\n        recursively applied to the first word of the command line; all\n        other words in the line are left alone.\n\n        As an example, here are two useful aliases (especially when\n        placed in the .pdbrc file):\n\n        # Print instance variables (usage \"pi classInst\")\n        alias pi for k in %1.__dict__.keys(): print(\"%1.\",k,\"=\",%1.__dict__[k])\n        # Print instance variables in self\n        alias ps pi self\n        ")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "keys")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "alias")
(KEYWORD in)
(ID "keys")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "%s = %s")
(PUNCT "%")
(PUNCT "(")
(ID "alias")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT "[")
(ID "alias")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "aliases")
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(LIT "%s = %s")
(PUNCT "%")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT "[")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT "[")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(PUNCT "=")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "args")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "do_unalias")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "unalias name\n        Delete the specified alias.\n        ")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "arg")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(KEYWORD return)
(NEWLINE)
(KEYWORD if)
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "aliases")
(PUNCT "[")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "complete_unalias")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "text")
(PUNCT ",")
(ID "line")
(PUNCT ",")
(ID "begidx")
(PUNCT ",")
(ID "endidx")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(ID "a")
(KEYWORD for)
(ID "a")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "aliases")
(KEYWORD if)
(ID "a")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "text")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "commands_resuming")
(PUNCT "=")
(PUNCT "[")
(LIT "do_continue")
(PUNCT ",")
(LIT "do_step")
(PUNCT ",")
(LIT "do_next")
(PUNCT ",")
(LIT "do_return")
(PUNCT ",")
(LIT "do_quit")
(PUNCT ",")
(LIT "do_jump")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "print_stack_trace")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "frame_lineno")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "print_stack_entry")
(PUNCT "(")
(ID "frame_lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "KeyboardInterrupt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "print_stack_entry")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "frame_lineno")
(PUNCT ",")
(ID "prompt_prefix")
(PUNCT "=")
(ID "line_prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "frame")
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(ID "frame_lineno")
(NEWLINE)
(KEYWORD if)
(ID "frame")
(KEYWORD is)
(ID "self")
(PUNCT ".")
(ID "curframe")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefix")
(PUNCT "=")
(LIT "> ")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefix")
(PUNCT "=")
(LIT "  ")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "prefix")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "format_stack_entry")
(PUNCT "(")
(ID "frame_lineno")
(PUNCT ",")
(ID "prompt_prefix")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "do_help")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "h(elp)\n        Without argument, print the list of available commands.\n        With a command name as argument, print help about that command.\n        \"help pdb\" shows the full pdb documentation.\n        \"help exec\" gives help on the ! command.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "arg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cmd")
(PUNCT ".")
(ID "Cmd")
(PUNCT ".")
(ID "do_help")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "topic")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "help_")
(PUNCT "+")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "topic")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "command")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "do_")
(PUNCT "+")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "No help for %r")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "flags")
(PUNCT ".")
(ID "optimize")
(PUNCT ">=")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(LIT "No help for %r; please do not run Python with -OO ")
(LIT "if you need command help")
(PUNCT "%")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(ID "command")
(PUNCT ".")
(ID "__doc__")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "do_h")
(PUNCT "=")
(ID "do_help")
(NEWLINE)
(KEYWORD def)
(ID "help_exec")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "(!) statement\n        Execute the (one-line) statement in the context of the current\n        stack frame.  The exclamation point can be omitted unless the\n        first word of the statement resembles a debugger command.  To\n        assign to a global variable you must always prefix the command\n        with a 'global' command, e.g.:\n        (Pdb) global list_options; list_options = ['-l']\n        (Pdb)\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "help_exec")
(PUNCT ".")
(ID "__doc__")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "help_pdb")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "help")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "lookupmodule")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper function for break/clear parsing -- may be overridden.\n\n        lookupmodule() translates (possibly incomplete) file or module name\n        into an absolute file name.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isabs")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "filename")
(NEWLINE)
(DEDENT)
(ID "f")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "path")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "canonic")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "f")
(NEWLINE)
(DEDENT)
(ID "root")
(PUNCT ",")
(ID "ext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ext")
(PUNCT "==")
(LIT "")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filename")
(PUNCT "=")
(ID "filename")
(PUNCT "+")
(LIT ".py")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isabs")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "filename")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "dirname")
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "islink")
(PUNCT "(")
(ID "dirname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "readlink")
(PUNCT "(")
(ID "dirname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fullname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dirname")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fullname")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_runscript")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "__main__")
(NEWLINE)
(ID "__main__")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "__main__")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(PUNCT "{")
(LIT "__name__")
(PUNCT ":")
(LIT "__main__")
(PUNCT ",")
(LIT "__file__")
(PUNCT ":")
(ID "filename")
(PUNCT ",")
(LIT "__builtins__")
(PUNCT ":")
(ID "__builtins__")
(PUNCT ",")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_wait_for_mainpyfile")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "canonic")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_user_requested_quit")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(KEYWORD as)
(ID "fp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "statement")
(PUNCT "=")
(LIT "exec(compile(%r, %r, 'exec'))")
(PUNCT "%")
(PUNCT "(")
(ID "fp")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "mainpyfile")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "statement")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "__doc__")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_help_order")
(PUNCT "=")
(PUNCT "[")
(LIT "help")
(PUNCT ",")
(LIT "where")
(PUNCT ",")
(LIT "down")
(PUNCT ",")
(LIT "up")
(PUNCT ",")
(LIT "break")
(PUNCT ",")
(LIT "tbreak")
(PUNCT ",")
(LIT "clear")
(PUNCT ",")
(LIT "disable")
(PUNCT ",")
(LIT "enable")
(PUNCT ",")
(LIT "ignore")
(PUNCT ",")
(LIT "condition")
(PUNCT ",")
(LIT "commands")
(PUNCT ",")
(LIT "step")
(PUNCT ",")
(LIT "next")
(PUNCT ",")
(LIT "until")
(PUNCT ",")
(LIT "jump")
(PUNCT ",")
(LIT "return")
(PUNCT ",")
(LIT "retval")
(PUNCT ",")
(LIT "run")
(PUNCT ",")
(LIT "continue")
(PUNCT ",")
(LIT "list")
(PUNCT ",")
(LIT "longlist")
(PUNCT ",")
(LIT "args")
(PUNCT ",")
(LIT "p")
(PUNCT ",")
(LIT "pp")
(PUNCT ",")
(LIT "whatis")
(PUNCT ",")
(LIT "source")
(PUNCT ",")
(LIT "display")
(PUNCT ",")
(LIT "undisplay")
(PUNCT ",")
(LIT "interact")
(PUNCT ",")
(LIT "alias")
(PUNCT ",")
(LIT "unalias")
(PUNCT ",")
(LIT "debug")
(PUNCT ",")
(LIT "quit")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "_command")
(KEYWORD in)
(ID "_help_order")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__doc__")
(PUNCT "+=")
(ID "getattr")
(PUNCT "(")
(ID "Pdb")
(PUNCT ",")
(LIT "do_")
(PUNCT "+")
(ID "_command")
(PUNCT ")")
(PUNCT ".")
(ID "__doc__")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT "+")
(LIT "\n\n")
(NEWLINE)
(DEDENT)
(ID "__doc__")
(PUNCT "+=")
(ID "Pdb")
(PUNCT ".")
(ID "help_exec")
(PUNCT ".")
(ID "__doc__")
(NEWLINE)
(KEYWORD del)
(ID "_help_order")
(PUNCT ",")
(ID "_command")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "run")
(PUNCT "(")
(ID "statement")
(PUNCT ",")
(ID "globals")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "locals")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Pdb")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "run")
(PUNCT "(")
(ID "statement")
(PUNCT ",")
(ID "globals")
(PUNCT ",")
(ID "locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "runeval")
(PUNCT "(")
(ID "expression")
(PUNCT ",")
(ID "globals")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "locals")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Pdb")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "runeval")
(PUNCT "(")
(ID "expression")
(PUNCT ",")
(ID "globals")
(PUNCT ",")
(ID "locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "runctx")
(PUNCT "(")
(ID "statement")
(PUNCT ",")
(ID "globals")
(PUNCT ",")
(ID "locals")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "run")
(PUNCT "(")
(ID "statement")
(PUNCT ",")
(ID "globals")
(PUNCT ",")
(ID "locals")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "runcall")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Pdb")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "runcall")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_trace")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Pdb")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "set_trace")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "_getframe")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "f_back")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "post_mortem")
(PUNCT "(")
(ID "t")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "t")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "t")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "t")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "A valid traceback must be passed if no ")
(LIT "exception is being handled")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "p")
(PUNCT "=")
(ID "Pdb")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "p")
(PUNCT ".")
(ID "reset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "p")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "t")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pm")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "post_mortem")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "last_traceback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "TESTCMD")
(PUNCT "=")
(LIT "import x; x.main()")
(NEWLINE)
(KEYWORD def)
(ID "test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "run")
(PUNCT "(")
(ID "TESTCMD")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "help")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "pydoc")
(NEWLINE)
(ID "pydoc")
(PUNCT ".")
(ID "pager")
(PUNCT "(")
(ID "__doc__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_usage")
(PUNCT "=")
(LIT "usage: pdb.py [-c command] ... pyfile [arg] ...\n\nDebug the Python program given by pyfile.\n\nInitial commands are read from .pdbrc files in your home directory\nand in the current directory, if they exist.  Commands supplied with\n-c are executed after commands from .pdbrc files.\n\nTo let the script run until an exception occurs, use \"-c continue\".\nTo let the script run up to a given line X in the debugged file, use\n\"-c 'until X'\".")
(NEWLINE)
(KEYWORD def)
(ID "main")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "getopt")
(NEWLINE)
(ID "opts")
(PUNCT ",")
(ID "args")
(PUNCT "=")
(ID "getopt")
(PUNCT ".")
(ID "getopt")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(LIT "hc:")
(PUNCT ",")
(PUNCT "[")
(LIT "--help")
(PUNCT ",")
(LIT "--command=")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "args")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "_usage")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "exit")
(PUNCT "(")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "commands")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "opt")
(PUNCT ",")
(ID "optarg")
(KEYWORD in)
(ID "opts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "opt")
(KEYWORD in)
(PUNCT "[")
(LIT "-h")
(PUNCT ",")
(LIT "--help")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(ID "_usage")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "exit")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "opt")
(KEYWORD in)
(PUNCT "[")
(LIT "-c")
(PUNCT ",")
(LIT "--command")
(PUNCT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "commands")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "optarg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "mainpyfile")
(PUNCT "=")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "mainpyfile")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Error:")
(PUNCT ",")
(ID "mainpyfile")
(PUNCT ",")
(LIT "does not exist")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "exit")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "args")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "path")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "mainpyfile")
(PUNCT ")")
(NEWLINE)
(ID "pdb")
(PUNCT "=")
(ID "Pdb")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "pdb")
(PUNCT ".")
(ID "rcLines")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "commands")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pdb")
(PUNCT ".")
(ID "_runscript")
(PUNCT "(")
(ID "mainpyfile")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "pdb")
(PUNCT ".")
(ID "_user_requested_quit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "The program finished and will be restarted")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "Restart")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Restarting")
(PUNCT ",")
(ID "mainpyfile")
(PUNCT ",")
(LIT "with arguments:")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "\t")
(PUNCT "+")
(LIT " ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "args")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "SystemExit")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "The program exited via sys.exit(). Exit status:")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT " ")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "traceback")
(PUNCT ".")
(ID "print_exc")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Uncaught exception. Entering post mortem debugging")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Running 'cont' or 'step' will restart the program")
(PUNCT ")")
(NEWLINE)
(ID "t")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "exc_info")
(PUNCT "(")
(PUNCT ")")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(ID "pdb")
(PUNCT ".")
(ID "interaction")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(ID "t")
(PUNCT ")")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "Post mortem debugger finished. The ")
(PUNCT "+")
(ID "mainpyfile")
(PUNCT "+")
(LIT " will be restarted")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "pdb")
(NEWLINE)
(ID "pdb")
(PUNCT ".")
(ID "main")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
