(LIT "Utilities to support packages.")
(NEWLINE)
(KEYWORD from)
(ID "functools")
(KEYWORD import)
(ID "singledispatch")
(KEYWORD as)
(ID "simplegeneric")
(NEWLINE)
(KEYWORD import)
(ID "importlib")
(NEWLINE)
(KEYWORD import)
(ID "importlib")
(PUNCT ".")
(ID "util")
(NEWLINE)
(KEYWORD import)
(ID "importlib")
(PUNCT ".")
(ID "machinery")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "os")
(PUNCT ".")
(ID "path")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD from)
(ID "types")
(KEYWORD import)
(ID "ModuleType")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "get_importer")
(PUNCT ",")
(LIT "iter_importers")
(PUNCT ",")
(LIT "get_loader")
(PUNCT ",")
(LIT "find_loader")
(PUNCT ",")
(LIT "walk_packages")
(PUNCT ",")
(LIT "iter_modules")
(PUNCT ",")
(LIT "get_data")
(PUNCT ",")
(LIT "ImpImporter")
(PUNCT ",")
(LIT "ImpLoader")
(PUNCT ",")
(LIT "read_code")
(PUNCT ",")
(LIT "extend_path")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "_get_spec")
(PUNCT "(")
(ID "finder")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the finder-specific module spec.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "find_spec")
(PUNCT "=")
(ID "finder")
(PUNCT ".")
(ID "find_spec")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "loader")
(PUNCT "=")
(ID "finder")
(PUNCT ".")
(ID "find_module")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "loader")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "importlib")
(PUNCT ".")
(ID "util")
(PUNCT ".")
(ID "spec_from_loader")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "loader")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "find_spec")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "read_code")
(PUNCT "(")
(ID "stream")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "marshal")
(NEWLINE)
(ID "magic")
(PUNCT "=")
(ID "stream")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "magic")
(PUNCT "!=")
(ID "importlib")
(PUNCT ".")
(ID "util")
(PUNCT ".")
(ID "MAGIC_NUMBER")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "stream")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 8)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "marshal")
(PUNCT ".")
(ID "load")
(PUNCT "(")
(ID "stream")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "walk_packages")
(PUNCT "(")
(ID "path")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "onerror")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Yields (module_loader, name, ispkg) for all modules recursively\n    on path, or, if path is None, all accessible modules.\n\n    'path' should be either None or a list of paths to look for\n    modules in.\n\n    'prefix' is a string to output on the front of every module name\n    on output.\n\n    Note that this function must import all *packages* (NOT all\n    modules!) on the given path, in order to access the __path__\n    attribute to find submodules.\n\n    'onerror' is a function which gets called with one argument (the\n    name of the package which was being imported) if any exception\n    occurs while trying to import a package.  If no onerror function is\n    supplied, ImportErrors are caught and ignored, while all other\n    exceptions are propagated, terminating the search.\n\n    Examples:\n\n    # list all modules python can access\n    walk_packages()\n\n    # list all submodules of ctypes\n    walk_packages(ctypes.__path__, ctypes.__name__+'.')\n    ")
(NEWLINE)
(KEYWORD def)
(ID "seen")
(PUNCT "(")
(ID "p")
(PUNCT ",")
(ID "m")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "p")
(KEYWORD in)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(ID "m")
(PUNCT "[")
(ID "p")
(PUNCT "]")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "importer")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "ispkg")
(KEYWORD in)
(ID "iter_modules")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "importer")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "ispkg")
(NEWLINE)
(KEYWORD if)
(ID "ispkg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__import__")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "onerror")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "Exception")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "onerror")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "onerror")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT ",")
(LIT "__path__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "path")
(PUNCT "=")
(PUNCT "[")
(ID "p")
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "path")
(KEYWORD if)
(KEYWORD not)
(ID "seen")
(PUNCT "(")
(ID "p")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD yield)
(KEYWORD from)
(ID "walk_packages")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "name")
(PUNCT "+")
(LIT ".")
(PUNCT ",")
(ID "onerror")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "iter_modules")
(PUNCT "(")
(ID "path")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Yields (module_loader, name, ispkg) for all submodules on path,\n    or, if path is None, all top-level modules on sys.path.\n\n    'path' should be either None or a list of paths to look for\n    modules in.\n\n    'prefix' is a string to output on the front of every module name\n    on output.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "path")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "importers")
(PUNCT "=")
(ID "iter_importers")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "importers")
(PUNCT "=")
(ID "map")
(PUNCT "(")
(ID "get_importer")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "yielded")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "importers")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "ispkg")
(KEYWORD in)
(ID "iter_importer_modules")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "name")
(KEYWORD not)
(KEYWORD in)
(ID "yielded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yielded")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "i")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "ispkg")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "simplegeneric")
(NEWLINE)
(KEYWORD def)
(ID "iter_importer_modules")
(PUNCT "(")
(ID "importer")
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "importer")
(PUNCT ",")
(LIT "iter_modules")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "importer")
(PUNCT ".")
(ID "iter_modules")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_iter_file_finder_modules")
(PUNCT "(")
(ID "importer")
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "importer")
(PUNCT ".")
(ID "path")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "importer")
(PUNCT ".")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "yielded")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD import)
(ID "inspect")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filenames")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "importer")
(PUNCT ".")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filenames")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "filenames")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "filenames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "modname")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getmodulename")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "modname")
(PUNCT "==")
(LIT "__init__")
(KEYWORD or)
(ID "modname")
(KEYWORD in)
(ID "yielded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "path")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "importer")
(PUNCT ".")
(ID "path")
(PUNCT ",")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(ID "ispkg")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "modname")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(KEYWORD and)
(LIT ".")
(KEYWORD not)
(KEYWORD in)
(ID "fn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "modname")
(PUNCT "=")
(ID "fn")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dircontents")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dircontents")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "dircontents")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "subname")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getmodulename")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "subname")
(PUNCT "==")
(LIT "__init__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ispkg")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "modname")
(KEYWORD and)
(LIT ".")
(KEYWORD not)
(KEYWORD in)
(ID "modname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yielded")
(PUNCT "[")
(ID "modname")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "prefix")
(PUNCT "+")
(ID "modname")
(PUNCT ",")
(ID "ispkg")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "iter_importer_modules")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "importlib")
(PUNCT ".")
(ID "machinery")
(PUNCT ".")
(ID "FileFinder")
(PUNCT ",")
(ID "_iter_file_finder_modules")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_import_imp")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD global)
(ID "imp")
(NEWLINE)
(KEYWORD with)
(ID "warnings")
(PUNCT ".")
(ID "catch_warnings")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "simplefilter")
(PUNCT "(")
(LIT "ignore")
(PUNCT ",")
(ID "PendingDeprecationWarning")
(PUNCT ")")
(NEWLINE)
(ID "imp")
(PUNCT "=")
(ID "importlib")
(PUNCT ".")
(ID "import_module")
(PUNCT "(")
(LIT "imp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ImpImporter")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "PEP 302 Importer that wraps Python's \"classic\" import algorithm\n\n    ImpImporter(dirname) produces a PEP 302 importer that searches that\n    directory.  ImpImporter(None) produces a PEP 302 importer that searches\n    the current sys.path, plus any modules that are frozen or built-in.\n\n    Note that ImpImporter does not currently support being used by placement\n    on sys.meta_path.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "path")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD global)
(ID "imp")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This emulation is deprecated, use 'importlib' instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ")")
(NEWLINE)
(ID "_import_imp")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "path")
(PUNCT "=")
(ID "path")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "find_module")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "path")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "subname")
(PUNCT "=")
(ID "fullname")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "subname")
(PUNCT "!=")
(ID "fullname")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "path")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "path")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(PUNCT "[")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "realpath")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "path")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "etc")
(PUNCT "=")
(ID "imp")
(PUNCT ".")
(ID "find_module")
(PUNCT "(")
(ID "subname")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "ImpLoader")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "etc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iter_modules")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "path")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "path")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "yielded")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD import)
(ID "inspect")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filenames")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filenames")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "filenames")
(PUNCT ".")
(ID "sort")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "filenames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "modname")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getmodulename")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "modname")
(PUNCT "==")
(LIT "__init__")
(KEYWORD or)
(ID "modname")
(KEYWORD in)
(ID "yielded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "path")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "path")
(PUNCT ",")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(ID "ispkg")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "modname")
(KEYWORD and)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(KEYWORD and)
(LIT ".")
(KEYWORD not)
(KEYWORD in)
(ID "fn")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "modname")
(PUNCT "=")
(ID "fn")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dircontents")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "listdir")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dircontents")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "dircontents")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "subname")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getmodulename")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "subname")
(PUNCT "==")
(LIT "__init__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ispkg")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "modname")
(KEYWORD and)
(LIT ".")
(KEYWORD not)
(KEYWORD in)
(ID "modname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yielded")
(PUNCT "[")
(ID "modname")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "prefix")
(PUNCT "+")
(ID "modname")
(PUNCT ",")
(ID "ispkg")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ImpLoader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "PEP 302 Loader that wraps Python's \"classic\" import algorithm\n    ")
(NEWLINE)
(ID "code")
(PUNCT "=")
(ID "source")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "etc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This emulation is deprecated, use 'importlib' instead")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ")")
(NEWLINE)
(ID "_import_imp")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "file")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "fullname")
(PUNCT "=")
(ID "fullname")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT "=")
(ID "etc")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "load_module")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_reopen")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mod")
(PUNCT "=")
(ID "imp")
(PUNCT ".")
(ID "load_module")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "mod")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_data")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "pathname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "pathname")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(KEYWORD as)
(ID "file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_reopen")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "file")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mod_type")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PY_SOURCE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(LIT "r")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "mod_type")
(KEYWORD in)
(PUNCT "(")
(ID "imp")
(PUNCT ".")
(ID "PY_COMPILED")
(PUNCT ",")
(ID "imp")
(PUNCT ".")
(ID "C_EXTENSION")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_fix_name")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fullname")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fullname")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "fullname")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "fullname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ImportError")
(PUNCT "(")
(LIT "Loader for module %s cannot handle ")
(LIT "module %s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fullname")
(PUNCT ",")
(ID "fullname")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "fullname")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "is_package")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix_name")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PKG_DIRECTORY")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_code")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix_name")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "code")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mod_type")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PY_SOURCE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_source")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "code")
(PUNCT "=")
(ID "compile")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ",")
(LIT "exec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PY_COMPILED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_reopen")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "code")
(PUNCT "=")
(ID "read_code")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PKG_DIRECTORY")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "code")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_delegate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "get_code")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "code")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_source")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix_name")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "source")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mod_type")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PY_SOURCE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_reopen")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PY_COMPILED")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "exists")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(LIT "r")
(PUNCT ")")
(KEYWORD as)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PKG_DIRECTORY")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_delegate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "get_source")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "source")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_delegate")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "finder")
(PUNCT "=")
(ID "ImpImporter")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "spec")
(PUNCT "=")
(ID "_get_spec")
(PUNCT "(")
(ID "finder")
(PUNCT ",")
(LIT "__init__")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "spec")
(PUNCT ".")
(ID "loader")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fullname")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_fix_name")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(ID "mod_type")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "etc")
(PUNCT "[")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "mod_type")
(PUNCT "==")
(ID "imp")
(PUNCT ".")
(ID "PKG_DIRECTORY")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get_delegate")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "get_filename")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "mod_type")
(KEYWORD in)
(PUNCT "(")
(ID "imp")
(PUNCT ".")
(ID "PY_SOURCE")
(PUNCT ",")
(ID "imp")
(PUNCT ".")
(ID "PY_COMPILED")
(PUNCT ",")
(ID "imp")
(PUNCT ".")
(ID "C_EXTENSION")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "filename")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "zipimport")
(NEWLINE)
(KEYWORD from)
(ID "zipimport")
(KEYWORD import)
(ID "zipimporter")
(NEWLINE)
(KEYWORD def)
(ID "iter_zipimport_modules")
(PUNCT "(")
(ID "importer")
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dirlist")
(PUNCT "=")
(ID "sorted")
(PUNCT "(")
(ID "zipimport")
(PUNCT ".")
(ID "_zip_directory_cache")
(PUNCT "[")
(ID "importer")
(PUNCT ".")
(ID "archive")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "_prefix")
(PUNCT "=")
(ID "importer")
(PUNCT ".")
(ID "prefix")
(NEWLINE)
(ID "plen")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "_prefix")
(PUNCT ")")
(NEWLINE)
(ID "yielded")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD import)
(ID "inspect")
(NEWLINE)
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "dirlist")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "fn")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "_prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "fn")
(PUNCT "=")
(ID "fn")
(PUNCT "[")
(ID "plen")
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "sep")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(KEYWORD and)
(ID "fn")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "__init__.py")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fn")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD not)
(KEYWORD in)
(ID "yielded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yielded")
(PUNCT "[")
(ID "fn")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "fn")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "fn")
(PUNCT ")")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "modname")
(PUNCT "=")
(ID "inspect")
(PUNCT ".")
(ID "getmodulename")
(PUNCT "(")
(ID "fn")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "modname")
(PUNCT "==")
(LIT "__init__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "modname")
(KEYWORD and)
(LIT ".")
(KEYWORD not)
(KEYWORD in)
(ID "modname")
(KEYWORD and)
(ID "modname")
(KEYWORD not)
(KEYWORD in)
(ID "yielded")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "yielded")
(PUNCT "[")
(ID "modname")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(KEYWORD yield)
(ID "prefix")
(PUNCT "+")
(ID "modname")
(PUNCT ",")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "iter_importer_modules")
(PUNCT ".")
(ID "register")
(PUNCT "(")
(ID "zipimporter")
(PUNCT ",")
(ID "iter_zipimport_modules")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_importer")
(PUNCT "(")
(ID "path_item")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Retrieve a PEP 302 importer for the given path item\n\n    The returned importer is cached in sys.path_importer_cache\n    if it was newly created by a path hook.\n\n    The cache (or part of it) can be cleared manually if a\n    rescan of sys.path_hooks is necessary.\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "importer")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "path_importer_cache")
(PUNCT "[")
(ID "path_item")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "path_hook")
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "path_hooks")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "importer")
(PUNCT "=")
(ID "path_hook")
(PUNCT "(")
(ID "path_item")
(PUNCT ")")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "path_importer_cache")
(PUNCT ".")
(ID "setdefault")
(PUNCT "(")
(ID "path_item")
(PUNCT ",")
(ID "importer")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "importer")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "importer")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "iter_importers")
(PUNCT "(")
(ID "fullname")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Yield PEP 302 importers for the given module name\n\n    If fullname contains a '.', the importers will be for the package\n    containing fullname, otherwise they will be all registered top level\n    importers (i.e. those on both sys.meta_path and sys.path_hooks).\n\n    If the named module is in a package, that package is imported as a side\n    effect of invoking this function.\n\n    If no module name is specified, all top level importers are produced.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "fullname")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Relative module name {!r} not supported")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "ImportError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT ".")
(KEYWORD in)
(ID "fullname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pkg_name")
(PUNCT "=")
(ID "fullname")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "pkg")
(PUNCT "=")
(ID "importlib")
(PUNCT ".")
(ID "import_module")
(PUNCT "(")
(ID "pkg_name")
(PUNCT ")")
(NEWLINE)
(ID "path")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "pkg")
(PUNCT ",")
(LIT "__path__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "path")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "sys")
(PUNCT ".")
(ID "meta_path")
(NEWLINE)
(ID "path")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "path")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "get_importer")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_loader")
(PUNCT "(")
(ID "module_or_name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get a PEP 302 \"loader\" object for module_or_name\n\n    Returns None if the module cannot be found or imported.\n    If the named module is not already imported, its containing package\n    (if any) is imported, in order to establish the package __path__.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "module_or_name")
(KEYWORD in)
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module_or_name")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "module_or_name")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "module_or_name")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "module_or_name")
(PUNCT ",")
(ID "ModuleType")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "module")
(PUNCT "=")
(ID "module_or_name")
(NEWLINE)
(ID "loader")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__loader__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "loader")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "loader")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "getattr")
(PUNCT "(")
(ID "module")
(PUNCT ",")
(LIT "__spec__")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "fullname")
(PUNCT "=")
(ID "module")
(PUNCT ".")
(ID "__name__")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fullname")
(PUNCT "=")
(ID "module_or_name")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "find_loader")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "find_loader")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Find a PEP 302 \"loader\" object for fullname\n\n    This is a backwards compatibility wrapper around\n    importlib.util.find_spec that converts most failures to ImportError\n    and only returns the loader rather than the full spec\n    ")
(NEWLINE)
(KEYWORD if)
(ID "fullname")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Relative module name {!r} not supported")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(KEYWORD raise)
(ID "ImportError")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spec")
(PUNCT "=")
(ID "importlib")
(PUNCT ".")
(ID "util")
(PUNCT ".")
(ID "find_spec")
(PUNCT "(")
(ID "fullname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "ImportError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ",")
(ID "TypeError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ")")
(KEYWORD as)
(ID "ex")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "Error while finding loader for {!r} ({}: {})")
(NEWLINE)
(KEYWORD raise)
(ID "ImportError")
(PUNCT "(")
(ID "msg")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "fullname")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "ex")
(PUNCT ")")
(PUNCT ",")
(ID "ex")
(PUNCT ")")
(PUNCT ")")
(KEYWORD from)
(ID "ex")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "spec")
(PUNCT ".")
(ID "loader")
(KEYWORD if)
(ID "spec")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD else)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "extend_path")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Extend a package's path.\n\n    Intended use is to place the following code in a package's __init__.py:\n\n        from pkgutil import extend_path\n        __path__ = extend_path(__path__, __name__)\n\n    This will add to the package's __path__ all subdirectories of\n    directories on sys.path named after the package.  This is useful\n    if one wants to distribute different parts of a single logical\n    package as multiple directories.\n\n    It also looks for *.pkg files beginning where * matches the name\n    argument.  This feature is similar to *.pth files (see site.py),\n    except that it doesn't special-case lines starting with 'import'.\n    A *.pkg file is trusted at face value: apart from checking for\n    duplicates, all entries found in a *.pkg file are added to the\n    path, regardless of whether they are exist the filesystem.  (This\n    is a feature.)\n\n    If the input path is not a list (as is the case for frozen\n    packages) it is returned unchanged.  The input path is not\n    modified; an extended copy is returned.  Items are only appended\n    to the copy at the end.\n\n    It is assumed that sys.path is a sequence.  Items of sys.path that\n    are not (unicode or 8-bit) strings referring to existing\n    directories are ignored.  Unicode items of sys.path that cause\n    errors when used as filenames may cause this function to raise an\n    exception (in line with os.path.isdir() behavior).\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "path")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "path")
(NEWLINE)
(DEDENT)
(ID "sname_pkg")
(PUNCT "=")
(ID "name")
(PUNCT "+")
(LIT ".pkg")
(NEWLINE)
(ID "path")
(PUNCT "=")
(ID "path")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "parent_package")
(PUNCT ",")
(ID "_")
(PUNCT ",")
(ID "final_name")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "rpartition")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "parent_package")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "search_path")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT "[")
(ID "parent_package")
(PUNCT "]")
(PUNCT ".")
(ID "__path__")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "KeyError")
(PUNCT ",")
(ID "AttributeError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "path")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "search_path")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "path")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "dir")
(KEYWORD in)
(ID "search_path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "dir")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "finder")
(PUNCT "=")
(ID "get_importer")
(PUNCT "(")
(ID "dir")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "finder")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "portions")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "finder")
(PUNCT ",")
(LIT "find_spec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "spec")
(PUNCT "=")
(ID "finder")
(PUNCT ".")
(ID "find_spec")
(PUNCT "(")
(ID "final_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "spec")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "portions")
(PUNCT "=")
(ID "spec")
(PUNCT ".")
(ID "submodule_search_locations")
(KEYWORD or)
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "hasattr")
(PUNCT "(")
(ID "finder")
(PUNCT ",")
(LIT "find_loader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_")
(PUNCT ",")
(ID "portions")
(PUNCT "=")
(ID "finder")
(PUNCT ".")
(ID "find_loader")
(PUNCT "(")
(ID "final_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "portion")
(KEYWORD in)
(ID "portions")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "portion")
(KEYWORD not)
(KEYWORD in)
(ID "path")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "portion")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "pkgfile")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dir")
(PUNCT ",")
(ID "sname_pkg")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isfile")
(PUNCT "(")
(ID "pkgfile")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "pkgfile")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "msg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "Can't open %s: %s\n")
(PUNCT "%")
(PUNCT "(")
(ID "pkgfile")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(KEYWORD or)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "#")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "path")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "path")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_data")
(PUNCT "(")
(ID "package")
(PUNCT ",")
(ID "resource")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get a resource from a package.\n\n    This is a wrapper round the PEP 302 loader get_data API. The package\n    argument should be the name of a package, in standard module format\n    (foo.bar). The resource argument should be in the form of a relative\n    filename, using '/' as the path separator. The parent directory name '..'\n    is not allowed, and nor is a rooted name (starting with a '/').\n\n    The function returns a binary string, which is the contents of the\n    specified resource.\n\n    For packages located in the filesystem, which have already been imported,\n    this is the rough equivalent of\n\n        d = os.path.dirname(sys.modules[package].__file__)\n        data = open(os.path.join(d, resource), 'rb').read()\n\n    If the package cannot be located or loaded, or it uses a PEP 302 loader\n    which does not support get_data(), then None is returned.\n    ")
(NEWLINE)
(ID "spec")
(PUNCT "=")
(ID "importlib")
(PUNCT ".")
(ID "util")
(PUNCT ".")
(ID "find_spec")
(PUNCT "(")
(ID "package")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "spec")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "loader")
(PUNCT "=")
(ID "spec")
(PUNCT ".")
(ID "loader")
(NEWLINE)
(KEYWORD if)
(ID "loader")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "loader")
(PUNCT ",")
(LIT "get_data")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "mod")
(PUNCT "=")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "modules")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "package")
(PUNCT ")")
(KEYWORD or)
(ID "importlib")
(PUNCT ".")
(ID "_bootstrap")
(PUNCT ".")
(ID "_SpecMethods")
(PUNCT "(")
(ID "spec")
(PUNCT ")")
(PUNCT ".")
(ID "load")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "mod")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "mod")
(PUNCT ",")
(LIT "__file__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "parts")
(PUNCT "=")
(ID "resource")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(ID "parts")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "mod")
(PUNCT ".")
(ID "__file__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "resource_name")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "*")
(ID "parts")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "loader")
(PUNCT ".")
(ID "get_data")
(PUNCT "(")
(ID "resource_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
