(LIT "Base class for fixers (optional, but recommended).")
(NEWLINE)
(KEYWORD import)
(ID "logging")
(NEWLINE)
(KEYWORD import)
(ID "itertools")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "patcomp")
(KEYWORD import)
(ID "PatternCompiler")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(KEYWORD import)
(ID "pygram")
(NEWLINE)
(KEYWORD from)
(PUNCT ".")
(ID "fixer_util")
(KEYWORD import)
(ID "does_tree_import")
(NEWLINE)
(KEYWORD class)
(ID "BaseFix")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Optional base class for fixers.\n\n    The subclass name must be FixFooBar where FooBar is the result of\n    removing underscores and capitalizing the words of the fix name.\n    For example, the class name for a fixer named 'has_key' should be\n    FixHasKey.\n    ")
(NEWLINE)
(ID "PATTERN")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "pattern")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "pattern_tree")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "options")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "numbers")
(PUNCT "=")
(ID "itertools")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "used_names")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "order")
(PUNCT "=")
(LIT "post")
(NEWLINE)
(ID "explicit")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "run_order")
(PUNCT "=")
(LIT 5)
(NEWLINE)
(ID "_accept_type")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "keep_line_order")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "BM_compatible")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "syms")
(PUNCT "=")
(ID "pygram")
(PUNCT ".")
(ID "python_symbols")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "options")
(PUNCT ",")
(ID "log")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Initializer.  Subclass may override.\n\n        Args:\n            options: an dict containing the options passed to RefactoringTool\n            that could be used to customize the fixer through the command line.\n            log: a list to append warnings and other messages to.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT "=")
(ID "options")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT "=")
(ID "log")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "compile_pattern")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "compile_pattern")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compiles self.PATTERN into self.pattern.\n\n        Subclass may override if it doesn't want to use\n        self.{pattern,PATTERN} in .match().\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "PATTERN")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "PC")
(PUNCT "=")
(ID "PatternCompiler")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "pattern")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "pattern_tree")
(PUNCT "=")
(ID "PC")
(PUNCT ".")
(ID "compile_pattern")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "PATTERN")
(PUNCT ",")
(ID "with_tree")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set_filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set the filename.\n\n        The main refactoring tool should call this.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns match for a given parse tree node.\n\n        Should return a true or false object (not necessarily a bool).\n        It may return a non-empty dict of matching sub-nodes as\n        returned by a matching pattern.\n\n        Subclass may override.\n        ")
(NEWLINE)
(ID "results")
(PUNCT "=")
(PUNCT "{")
(LIT "node")
(PUNCT ":")
(ID "node")
(PUNCT "}")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "pattern")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(KEYWORD and)
(ID "results")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "transform")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Returns the transformation for a given parse tree node.\n\n        Args:\n          node: the root of the parse tree that matched the fixer.\n          results: a dict mapping symbolic names to part of the match.\n\n        Returns:\n          None, or a node that is a modified copy of the\n          argument node.  The node argument may also be modified in-place to\n          effect the same change.\n\n        Subclass *must* override.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "new_name")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "template")
(PUNCT "=")
(LIT "xxx_todo_changeme")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a string suitable for use as an identifier\n\n        The new name is guaranteed not to conflict with other identifiers.\n        ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "template")
(NEWLINE)
(KEYWORD while)
(ID "name")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "used_names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "template")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "next")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "numbers")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "used_names")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log_message")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "message")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "first_log")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "first_log")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "### In file %s ###")
(PUNCT "%")
(ID "self")
(PUNCT ".")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "log")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "message")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "cannot_convert")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "reason")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Warn the user that a given chunk of code is not valid Python 3,\n        but that it cannot be converted automatically.\n\n        First argument is the top-level node for the code in question.\n        Optional second argument is why it can't be converted.\n        ")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(ID "node")
(PUNCT ".")
(ID "get_lineno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "for_output")
(PUNCT "=")
(ID "node")
(PUNCT ".")
(ID "clone")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "for_output")
(PUNCT ".")
(ID "prefix")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "msg")
(PUNCT "=")
(LIT "Line %d: could not convert: %s")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(ID "msg")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "for_output")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "reason")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(ID "reason")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "warning")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "reason")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Used for warning the user about possible uncertainty in the\n        translation.\n\n        First argument is the top-level node for the code in question.\n        Optional second argument is why it can't be converted.\n        ")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(ID "node")
(PUNCT ".")
(ID "get_lineno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "log_message")
(PUNCT "(")
(LIT "Line %d: %s")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "reason")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "start_tree")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tree")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Some fixers need to maintain tree-wide state.\n        This method is called once, at the start of tree fix-up.\n\n        tree - the root node of the tree to be processed.\n        filename - the name of the file the tree came from.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "used_names")
(PUNCT "=")
(ID "tree")
(PUNCT ".")
(ID "used_names")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set_filename")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "numbers")
(PUNCT "=")
(ID "itertools")
(PUNCT ".")
(ID "count")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "first_log")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "finish_tree")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "tree")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Some fixers need to maintain tree-wide state.\n        This method is called once, at the conclusion of tree fix-up.\n\n        tree - the root node of the tree to be processed.\n        filename - the name of the file the tree came from.\n        ")
(NEWLINE)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ConditionalFix")
(PUNCT "(")
(ID "BaseFix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " Base class for fixers which not execute if an import is found. ")
(NEWLINE)
(ID "skip_on")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "start_tree")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(ID "ConditionalFix")
(PUNCT ",")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "start_tree")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_should_skip")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "should_skip")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_should_skip")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_should_skip")
(NEWLINE)
(DEDENT)
(ID "pkg")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "skip_on")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "pkg")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "pkg")
(PUNCT "=")
(LIT ".")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "pkg")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_should_skip")
(PUNCT "=")
(ID "does_tree_import")
(PUNCT "(")
(ID "pkg")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "node")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_should_skip")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
