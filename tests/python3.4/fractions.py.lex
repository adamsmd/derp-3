(LIT "Fraction, infinite-precision, real numbers.")
(NEWLINE)
(KEYWORD from)
(ID "decimal")
(KEYWORD import)
(ID "Decimal")
(NEWLINE)
(KEYWORD import)
(ID "math")
(NEWLINE)
(KEYWORD import)
(ID "numbers")
(NEWLINE)
(KEYWORD import)
(ID "operator")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Fraction")
(PUNCT ",")
(LIT "gcd")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "gcd")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Calculate the Greatest Common Divisor of a and b.\n\n    Unless b==0, the result will have the same sign as b (so that when\n    b is divided by it, the result comes out positive).\n    ")
(NEWLINE)
(KEYWORD while)
(ID "b")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT "=")
(ID "b")
(PUNCT ",")
(ID "a")
(PUNCT "%")
(ID "b")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "a")
(NEWLINE)
(DEDENT)
(ID "_PyHASH_MODULUS")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "hash_info")
(PUNCT ".")
(ID "modulus")
(NEWLINE)
(ID "_PyHASH_INF")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "hash_info")
(PUNCT ".")
(ID "inf")
(NEWLINE)
(ID "_RATIONAL_FORMAT")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\n    \\A\\s*                      # optional whitespace at the start, then\n    (?P<sign>[-+]?)            # an optional sign, then\n    (?=\\d|\\.\\d)                # lookahead for digit or .digit\n    (?P<num>\\d*)               # numerator (possibly empty)\n    (?:                        # followed by\n       (?:/(?P<denom>\\d+))?    # an optional denominator\n    |                          # or\n       (?:\\.(?P<decimal>\\d*))? # an optional fractional part\n       (?:E(?P<exp>[-+]?\\d+))? # and optional exponent\n    )\n    \\s*\\Z                      # and optional whitespace to finish\n")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT "|")
(ID "re")
(PUNCT ".")
(ID "IGNORECASE")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Fraction")
(PUNCT "(")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "This class implements rational numbers.\n\n    In the two-argument form of the constructor, Fraction(8, 6) will\n    produce a rational number equivalent to 4/3. Both arguments must\n    be Rational. The numerator defaults to 0 and the denominator\n    defaults to 1 so that Fraction(3) == 3 and Fraction() == 0.\n\n    Fractions can also be constructed from:\n\n      - numeric strings similar to those accepted by the\n        float constructor (for example, '-2.3' or '1e10')\n\n      - strings of the form '123/456'\n\n      - float and Decimal instances\n\n      - other Rational instances (including integers)\n\n    ")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "_numerator")
(PUNCT ",")
(LIT "_denominator")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "numerator")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "denominator")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructs a Rational.\n\n        Takes a string like '3/2' or '1.5', another Rational instance, a\n        numerator/denominator pair, or a float.\n\n        Examples\n        --------\n\n        >>> Fraction(10, -8)\n        Fraction(-5, 4)\n        >>> Fraction(Fraction(1, 7), 5)\n        Fraction(1, 35)\n        >>> Fraction(Fraction(1, 7), Fraction(2, 3))\n        Fraction(3, 14)\n        >>> Fraction('314')\n        Fraction(314, 1)\n        >>> Fraction('-35/4')\n        Fraction(-35, 4)\n        >>> Fraction('3.1415') # conversion from numeric string\n        Fraction(6283, 2000)\n        >>> Fraction('-47e-2') # string may include a decimal exponent\n        Fraction(-47, 100)\n        >>> Fraction(1.47)  # direct construction from float (exact conversion)\n        Fraction(6620291452234629, 4503599627370496)\n        >>> Fraction(2.25)\n        Fraction(9, 4)\n        >>> Fraction(Decimal('1.47'))\n        Fraction(147, 100)\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT "=")
(ID "super")
(PUNCT "(")
(ID "Fraction")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "denominator")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "numerator")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT "=")
(ID "numerator")
(PUNCT ".")
(ID "numerator")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "=")
(ID "numerator")
(PUNCT ".")
(ID "denominator")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "numerator")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "Fraction")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_numerator")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_denominator")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "numerator")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "Fraction")
(PUNCT ".")
(ID "from_decimal")
(PUNCT "(")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_numerator")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "_denominator")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "numerator")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "_RATIONAL_FORMAT")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid literal for Fraction: %r")
(PUNCT "%")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "numerator")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "num")
(PUNCT ")")
(KEYWORD or)
(LIT "0")
(PUNCT ")")
(NEWLINE)
(ID "denom")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "denom")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "denom")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "denominator")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "denom")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "denominator")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "decimal")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "decimal")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "decimal")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "scale")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(ID "len")
(PUNCT "(")
(ID "decimal")
(PUNCT ")")
(NEWLINE)
(ID "numerator")
(PUNCT "=")
(ID "numerator")
(PUNCT "*")
(ID "scale")
(PUNCT "+")
(ID "int")
(PUNCT "(")
(ID "decimal")
(PUNCT ")")
(NEWLINE)
(ID "denominator")
(PUNCT "*=")
(ID "scale")
(NEWLINE)
(DEDENT)
(ID "exp")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "exp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exp")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "numerator")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(ID "exp")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "denominator")
(PUNCT "*=")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "exp")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "sign")
(PUNCT ")")
(PUNCT "==")
(LIT "-")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "numerator")
(PUNCT "=")
(PUNCT "-")
(ID "numerator")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "argument should be a string ")
(LIT "or a Rational instance")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(PUNCT "(")
(ID "isinstance")
(PUNCT "(")
(ID "numerator")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "denominator")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "numerator")
(PUNCT ",")
(ID "denominator")
(PUNCT "=")
(PUNCT "(")
(ID "numerator")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "denominator")
(PUNCT ".")
(ID "denominator")
(PUNCT ",")
(ID "denominator")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "numerator")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "both arguments should be ")
(LIT "Rational instances")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "denominator")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ZeroDivisionError")
(PUNCT "(")
(LIT "Fraction(%s, 0)")
(PUNCT "%")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "g")
(PUNCT "=")
(ID "gcd")
(PUNCT "(")
(ID "numerator")
(PUNCT ",")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT "=")
(ID "numerator")
(PUNCT "//")
(ID "g")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "=")
(ID "denominator")
(PUNCT "//")
(ID "g")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "from_float")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Converts a finite float to a rational number, exactly.\n\n        Beware that Fraction.from_float(0.3) != Fraction(3, 10).\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Integral")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s.from_float() only takes floats, not %r (%s)")
(PUNCT "%")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "f")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "math")
(PUNCT ".")
(ID "isnan")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot convert %r to %s.")
(PUNCT "%")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "math")
(PUNCT ".")
(ID "isinf")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OverflowError")
(PUNCT "(")
(LIT "Cannot convert %r to %s.")
(PUNCT "%")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(PUNCT "*")
(ID "f")
(PUNCT ".")
(ID "as_integer_ratio")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "from_decimal")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "dec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Converts a finite Decimal instance to a rational number, exactly.")
(NEWLINE)
(KEYWORD from)
(ID "decimal")
(KEYWORD import)
(ID "Decimal")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "dec")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Integral")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dec")
(PUNCT "=")
(ID "Decimal")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "dec")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "dec")
(PUNCT ",")
(ID "Decimal")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "%s.from_decimal() only takes Decimals, not %r (%s)")
(PUNCT "%")
(PUNCT "(")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "dec")
(PUNCT ",")
(ID "type")
(PUNCT "(")
(ID "dec")
(PUNCT ")")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "dec")
(PUNCT ".")
(ID "is_infinite")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OverflowError")
(PUNCT "(")
(LIT "Cannot convert %s to %s.")
(PUNCT "%")
(PUNCT "(")
(ID "dec")
(PUNCT ",")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "dec")
(PUNCT ".")
(ID "is_nan")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot convert %s to %s.")
(PUNCT "%")
(PUNCT "(")
(ID "dec")
(PUNCT ",")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sign")
(PUNCT ",")
(ID "digits")
(PUNCT ",")
(ID "exp")
(PUNCT "=")
(ID "dec")
(PUNCT ".")
(ID "as_tuple")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "digits")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "digits")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sign")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "digits")
(PUNCT "=")
(PUNCT "-")
(ID "digits")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "exp")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "digits")
(PUNCT "*")
(LIT 10)
(PUNCT "**")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "cls")
(PUNCT "(")
(ID "digits")
(PUNCT ",")
(LIT 10)
(PUNCT "**")
(PUNCT "-")
(ID "exp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "limit_denominator")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "max_denominator")
(PUNCT "=")
(LIT 1000000)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Closest Fraction to self with denominator at most max_denominator.\n\n        >>> Fraction('3.141592653589793').limit_denominator(10)\n        Fraction(22, 7)\n        >>> Fraction('3.141592653589793').limit_denominator(100)\n        Fraction(311, 99)\n        >>> Fraction(4321, 8765).limit_denominator(10000)\n        Fraction(4321, 8765)\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "max_denominator")
(PUNCT "<")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "max_denominator should be at least 1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "<=")
(ID "max_denominator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "p0")
(PUNCT ",")
(ID "q0")
(PUNCT ",")
(ID "p1")
(PUNCT ",")
(ID "q1")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT 1)
(PUNCT ",")
(LIT 0)
(NEWLINE)
(ID "n")
(PUNCT ",")
(ID "d")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(NEWLINE)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "a")
(PUNCT "=")
(ID "n")
(PUNCT "//")
(ID "d")
(NEWLINE)
(ID "q2")
(PUNCT "=")
(ID "q0")
(PUNCT "+")
(ID "a")
(PUNCT "*")
(ID "q1")
(NEWLINE)
(KEYWORD if)
(ID "q2")
(PUNCT ">")
(ID "max_denominator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(ID "p0")
(PUNCT ",")
(ID "q0")
(PUNCT ",")
(ID "p1")
(PUNCT ",")
(ID "q1")
(PUNCT "=")
(ID "p1")
(PUNCT ",")
(ID "q1")
(PUNCT ",")
(ID "p0")
(PUNCT "+")
(ID "a")
(PUNCT "*")
(ID "p1")
(PUNCT ",")
(ID "q2")
(NEWLINE)
(ID "n")
(PUNCT ",")
(ID "d")
(PUNCT "=")
(ID "d")
(PUNCT ",")
(ID "n")
(PUNCT "-")
(ID "a")
(PUNCT "*")
(ID "d")
(NEWLINE)
(DEDENT)
(ID "k")
(PUNCT "=")
(PUNCT "(")
(ID "max_denominator")
(PUNCT "-")
(ID "q0")
(PUNCT ")")
(PUNCT "//")
(ID "q1")
(NEWLINE)
(ID "bound1")
(PUNCT "=")
(ID "Fraction")
(PUNCT "(")
(ID "p0")
(PUNCT "+")
(ID "k")
(PUNCT "*")
(ID "p1")
(PUNCT ",")
(ID "q0")
(PUNCT "+")
(ID "k")
(PUNCT "*")
(ID "q1")
(PUNCT ")")
(NEWLINE)
(ID "bound2")
(PUNCT "=")
(ID "Fraction")
(PUNCT "(")
(ID "p1")
(PUNCT ",")
(ID "q1")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "abs")
(PUNCT "(")
(ID "bound2")
(PUNCT "-")
(ID "self")
(PUNCT ")")
(PUNCT "<=")
(ID "abs")
(PUNCT "(")
(ID "bound1")
(PUNCT "-")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bound2")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "bound1")
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "numerator")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_numerator")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "denominator")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_denominator")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "repr(self)")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(LIT "Fraction(%s, %s)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "str(self)")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s/%s")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_operator_fallbacks")
(PUNCT "(")
(ID "monomorphic_operator")
(PUNCT ",")
(ID "fallback_operator")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generates forward and reverse operators given a purely-rational\n        operator and a function from the operator module.\n\n        Use this like:\n        __op__, __rop__ = _operator_fallbacks(just_rational_op, operator.op)\n\n        In general, we want to implement the arithmetic operations so\n        that mixed-mode operations either call an implementation whose\n        author knew about the types of both arguments, or convert both\n        to the nearest built in type and do the operation there. In\n        Fraction, that means that we define __add__ and __radd__ as:\n\n            def __add__(self, other):\n                # Both types have numerators/denominator attributes,\n                # so do the operation directly\n                if isinstance(other, (int, Fraction)):\n                    return Fraction(self.numerator * other.denominator +\n                                    other.numerator * self.denominator,\n                                    self.denominator * other.denominator)\n                # float and complex don't have those operations, but we\n                # know about those types, so special case them.\n                elif isinstance(other, float):\n                    return float(self) + other\n                elif isinstance(other, complex):\n                    return complex(self) + other\n                # Let the other type take over.\n                return NotImplemented\n\n            def __radd__(self, other):\n                # radd handles more types than add because there's\n                # nothing left to fall back to.\n                if isinstance(other, numbers.Rational):\n                    return Fraction(self.numerator * other.denominator +\n                                    other.numerator * self.denominator,\n                                    self.denominator * other.denominator)\n                elif isinstance(other, Real):\n                    return float(other) + float(self)\n                elif isinstance(other, Complex):\n                    return complex(other) + complex(self)\n                return NotImplemented\n\n\n        There are 5 different cases for a mixed-type addition on\n        Fraction. I'll refer to all of the above code that doesn't\n        refer to Fraction, float, or complex as \"boilerplate\". 'r'\n        will be an instance of Fraction, which is a subtype of\n        Rational (r : Fraction <: Rational), and b : B <:\n        Complex. The first three involve 'r + b':\n\n            1. If B <: Fraction, int, float, or complex, we handle\n               that specially, and all is well.\n            2. If Fraction falls back to the boilerplate code, and it\n               were to return a value from __add__, we'd miss the\n               possibility that B defines a more intelligent __radd__,\n               so the boilerplate should return NotImplemented from\n               __add__. In particular, we don't handle Rational\n               here, even though we could get an exact answer, in case\n               the other type wants to do something special.\n            3. If B <: Fraction, Python tries B.__radd__ before\n               Fraction.__add__. This is ok, because it was\n               implemented with knowledge of Fraction, so it can\n               handle those instances before delegating to Real or\n               Complex.\n\n        The next two situations describe 'b + r'. We assume that b\n        didn't know about Fraction in its implementation, and that it\n        uses similar boilerplate code:\n\n            4. If B <: Rational, then __radd_ converts both to the\n               builtin rational type (hey look, that's us) and\n               proceeds.\n            5. Otherwise, __radd__ tries to find the nearest common\n               base ABC, and fall back to its builtin type. Since this\n               class doesn't subclass a concrete type, there's no\n               implementation to fall back to, so we need to try as\n               hard as possible to return an actual value, or the user\n               will get a TypeError.\n\n        ")
(NEWLINE)
(KEYWORD def)
(ID "forward")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "Fraction")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "monomorphic_operator")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback_operator")
(PUNCT "(")
(ID "float")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "complex")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback_operator")
(PUNCT "(")
(ID "complex")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "forward")
(PUNCT ".")
(ID "__name__")
(PUNCT "=")
(LIT "__")
(PUNCT "+")
(ID "fallback_operator")
(PUNCT ".")
(ID "__name__")
(PUNCT "+")
(LIT "__")
(NEWLINE)
(ID "forward")
(PUNCT ".")
(ID "__doc__")
(PUNCT "=")
(ID "monomorphic_operator")
(PUNCT ".")
(ID "__doc__")
(NEWLINE)
(KEYWORD def)
(ID "reverse")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "monomorphic_operator")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Real")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback_operator")
(PUNCT "(")
(ID "float")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ",")
(ID "float")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "isinstance")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Complex")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback_operator")
(PUNCT "(")
(ID "complex")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ",")
(ID "complex")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "reverse")
(PUNCT ".")
(ID "__name__")
(PUNCT "=")
(LIT "__r")
(PUNCT "+")
(ID "fallback_operator")
(PUNCT ".")
(ID "__name__")
(PUNCT "+")
(LIT "__")
(NEWLINE)
(ID "reverse")
(PUNCT ".")
(ID "__doc__")
(PUNCT "=")
(ID "monomorphic_operator")
(PUNCT ".")
(ID "__doc__")
(NEWLINE)
(KEYWORD return)
(ID "forward")
(PUNCT ",")
(ID "reverse")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_add")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a + b")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT "+")
(ID "b")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__add__")
(PUNCT ",")
(ID "__radd__")
(PUNCT "=")
(ID "_operator_fallbacks")
(PUNCT "(")
(ID "_add")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "add")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_sub")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a - b")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT "-")
(ID "b")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__sub__")
(PUNCT ",")
(ID "__rsub__")
(PUNCT "=")
(ID "_operator_fallbacks")
(PUNCT "(")
(ID "_sub")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "sub")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_mul")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a * b")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "numerator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__mul__")
(PUNCT ",")
(ID "__rmul__")
(PUNCT "=")
(ID "_operator_fallbacks")
(PUNCT "(")
(ID "_mul")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "mul")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_div")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a / b")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT "*")
(ID "b")
(PUNCT ".")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__truediv__")
(PUNCT ",")
(ID "__rtruediv__")
(PUNCT "=")
(ID "_operator_fallbacks")
(PUNCT "(")
(ID "_div")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "truediv")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__floordiv__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a // b")
(NEWLINE)
(KEYWORD return)
(ID "math")
(PUNCT ".")
(ID "floor")
(PUNCT "(")
(ID "a")
(PUNCT "/")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rfloordiv__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a // b")
(NEWLINE)
(KEYWORD return)
(ID "math")
(PUNCT ".")
(ID "floor")
(PUNCT "(")
(ID "a")
(PUNCT "/")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__mod__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a % b")
(NEWLINE)
(ID "div")
(PUNCT "=")
(ID "a")
(PUNCT "//")
(ID "b")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT "-")
(ID "b")
(PUNCT "*")
(ID "div")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__rmod__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a % b")
(NEWLINE)
(ID "div")
(PUNCT "=")
(ID "a")
(PUNCT "//")
(ID "b")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT "-")
(ID "b")
(PUNCT "*")
(ID "div")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__pow__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a ** b\n\n        If b is not an integer, the result will be a float or complex\n        since roots are generally irrational. If b is an integer, the\n        result will be rational.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "power")
(PUNCT "=")
(ID "b")
(PUNCT ".")
(ID "numerator")
(NEWLINE)
(KEYWORD if)
(ID "power")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "**")
(ID "power")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT "**")
(ID "power")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT "**")
(PUNCT "-")
(ID "power")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "**")
(PUNCT "-")
(ID "power")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "float")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT "**")
(ID "float")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "float")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT "**")
(ID "b")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__rpow__")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a ** b")
(NEWLINE)
(KEYWORD if)
(ID "b")
(PUNCT ".")
(ID "_denominator")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "b")
(PUNCT ".")
(ID "_numerator")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT "**")
(ID "b")
(PUNCT ".")
(ID "_numerator")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(PUNCT "**")
(ID "b")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "b")
(PUNCT ".")
(ID "_denominator")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT "**")
(ID "b")
(PUNCT ".")
(ID "_numerator")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "a")
(PUNCT "**")
(ID "float")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__pos__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "+a: Coerces a subclass instance to Fraction")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__neg__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "-a")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(PUNCT "-")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__abs__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "abs(a)")
(NEWLINE)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "abs")
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT ")")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__trunc__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "trunc(a)")
(NEWLINE)
(KEYWORD if)
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(PUNCT "(")
(PUNCT "-")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "//")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "//")
(ID "a")
(PUNCT ".")
(ID "_denominator")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__floor__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Will be math.floor(a) in 3.0.")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT "//")
(ID "a")
(PUNCT ".")
(ID "denominator")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ceil__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Will be math.ceil(a) in 3.0.")
(NEWLINE)
(KEYWORD return)
(PUNCT "-")
(PUNCT "(")
(PUNCT "-")
(ID "a")
(PUNCT ".")
(ID "numerator")
(PUNCT "//")
(ID "a")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__round__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "ndigits")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Will be round(self, ndigits) in 3.0.\n\n        Rounds half toward even.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "ndigits")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "floor")
(PUNCT ",")
(ID "remainder")
(PUNCT "=")
(ID "divmod")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "numerator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "remainder")
(PUNCT "*")
(LIT 2)
(PUNCT "<")
(ID "self")
(PUNCT ".")
(ID "denominator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "floor")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "remainder")
(PUNCT "*")
(LIT 2)
(PUNCT ">")
(ID "self")
(PUNCT ".")
(ID "denominator")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "floor")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "floor")
(PUNCT "%")
(LIT 2)
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "floor")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "floor")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "shift")
(PUNCT "=")
(LIT 10)
(PUNCT "**")
(ID "abs")
(PUNCT "(")
(ID "ndigits")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "ndigits")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "round")
(PUNCT "(")
(ID "self")
(PUNCT "*")
(ID "shift")
(PUNCT ")")
(PUNCT ",")
(ID "shift")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Fraction")
(PUNCT "(")
(ID "round")
(PUNCT "(")
(ID "self")
(PUNCT "/")
(ID "shift")
(PUNCT ")")
(PUNCT "*")
(ID "shift")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__hash__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "hash(self)")
(NEWLINE)
(ID "dinv")
(PUNCT "=")
(ID "pow")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT ",")
(ID "_PyHASH_MODULUS")
(PUNCT "-")
(LIT 2)
(PUNCT ",")
(ID "_PyHASH_MODULUS")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dinv")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hash_")
(PUNCT "=")
(ID "_PyHASH_INF")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hash_")
(PUNCT "=")
(ID "abs")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ")")
(PUNCT "*")
(ID "dinv")
(PUNCT "%")
(ID "_PyHASH_MODULUS")
(NEWLINE)
(DEDENT)
(ID "result")
(PUNCT "=")
(ID "hash_")
(KEYWORD if)
(ID "self")
(PUNCT ">=")
(LIT 0)
(KEYWORD else)
(PUNCT "-")
(ID "hash_")
(NEWLINE)
(KEYWORD return)
(PUNCT "-")
(LIT 2)
(KEYWORD if)
(ID "result")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(KEYWORD else)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a == b")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "==")
(ID "b")
(PUNCT ".")
(ID "numerator")
(KEYWORD and)
(ID "a")
(PUNCT ".")
(ID "_denominator")
(PUNCT "==")
(ID "b")
(PUNCT ".")
(ID "denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Complex")
(PUNCT ")")
(KEYWORD and)
(ID "b")
(PUNCT ".")
(ID "imag")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "b")
(PUNCT "=")
(ID "b")
(PUNCT ".")
(ID "real")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "math")
(PUNCT ".")
(ID "isnan")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(KEYWORD or)
(ID "math")
(PUNCT ".")
(ID "isinf")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0.0)
(PUNCT "==")
(ID "b")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "a")
(PUNCT "==")
(ID "a")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_richcmp")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ",")
(ID "op")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper for comparison operators, for internal use only.\n\n        Implement comparison between a Rational instance `self`, and\n        either another Rational instance or a float `other`.  If\n        `other` is not a Rational instance or a float, return\n        NotImplemented. `op` should be one of the six standard\n        comparison operators.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "numbers")
(PUNCT ".")
(ID "Rational")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "op")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT "*")
(ID "other")
(PUNCT ".")
(ID "denominator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT "*")
(ID "other")
(PUNCT ".")
(ID "numerator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "other")
(PUNCT ",")
(ID "float")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "math")
(PUNCT ".")
(ID "isnan")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(KEYWORD or)
(ID "math")
(PUNCT ".")
(ID "isinf")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "op")
(PUNCT "(")
(LIT 0.0)
(PUNCT ",")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "op")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "from_float")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__lt__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a < b")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_richcmp")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "lt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__gt__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a > b")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_richcmp")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "gt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__le__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a <= b")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_richcmp")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "le")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ge__")
(PUNCT "(")
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a >= b")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_richcmp")
(PUNCT "(")
(ID "b")
(PUNCT ",")
(ID "operator")
(PUNCT ".")
(ID "ge")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__bool__")
(PUNCT "(")
(ID "a")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "a != 0")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ".")
(ID "_numerator")
(PUNCT "!=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reduce__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ",")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__copy__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "==")
(ID "Fraction")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__deepcopy__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "memo")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "==")
(ID "Fraction")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_numerator")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_denominator")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
