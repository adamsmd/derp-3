(LIT "Filename matching with shell patterns.\n\nfnmatch(FILENAME, PATTERN) matches according to the local convention.\nfnmatchcase(FILENAME, PATTERN) always takes case in account.\n\nThe functions operate by translating the pattern into a regular\nexpression.  They cache the compiled regular expressions for speed.\n\nThe function translate(PATTERN) returns a regular expression\ncorresponding to PATTERN.  (It does not compile it.)\n")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "posixpath")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "functools")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "filter")
(PUNCT ",")
(LIT "fnmatch")
(PUNCT ",")
(LIT "fnmatchcase")
(PUNCT ",")
(LIT "translate")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "fnmatch")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test whether FILENAME matches PATTERN.\n\n    Patterns are Unix shell style:\n\n    *       matches everything\n    ?       matches any single character\n    [seq]   matches any character in seq\n    [!seq]  matches any char not in seq\n\n    An initial period in FILENAME is not special.\n    Both FILENAME and PATTERN are first case-normalized\n    if the operating system requires it.\n    If you don't want this, use fnmatchcase(FILENAME, PATTERN).\n    ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "pat")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "fnmatchcase")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "functools")
(PUNCT ".")
(ID "lru_cache")
(PUNCT "(")
(ID "maxsize")
(PUNCT "=")
(LIT 256)
(PUNCT ",")
(ID "typed")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_compile_pattern")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pat_str")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "pat")
(PUNCT ",")
(LIT "ISO-8859-1")
(PUNCT ")")
(NEWLINE)
(ID "res_str")
(PUNCT "=")
(ID "translate")
(PUNCT "(")
(ID "pat_str")
(PUNCT ")")
(NEWLINE)
(ID "res")
(PUNCT "=")
(ID "bytes")
(PUNCT "(")
(ID "res_str")
(PUNCT ",")
(LIT "ISO-8859-1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "translate")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "res")
(PUNCT ")")
(PUNCT ".")
(ID "match")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "filter")
(PUNCT "(")
(ID "names")
(PUNCT ",")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the subset of the list NAMES that match PAT.")
(NEWLINE)
(ID "result")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "pat")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(ID "match")
(PUNCT "=")
(ID "_compile_pattern")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "path")
(KEYWORD is)
(ID "posixpath")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "match")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "names")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "match")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "normcase")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "result")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "result")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fnmatchcase")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Test whether FILENAME matches PATTERN, including case.\n\n    This is a version of fnmatch() which doesn't case-normalize\n    its arguments.\n    ")
(NEWLINE)
(ID "match")
(PUNCT "=")
(ID "_compile_pattern")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "match")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "translate")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Translate a shell PATTERN to a regular expression.\n\n    There is no way to quote meta-characters.\n    ")
(NEWLINE)
(ID "i")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "pat")
(PUNCT ")")
(NEWLINE)
(ID "res")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD while)
(ID "i")
(PUNCT "<")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "c")
(PUNCT "=")
(ID "pat")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "i")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT "*")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "res")
(PUNCT "+")
(LIT ".*")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "c")
(PUNCT "==")
(LIT "?")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "res")
(PUNCT "+")
(LIT ".")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "c")
(PUNCT "==")
(LIT "[")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "j")
(PUNCT "=")
(ID "i")
(NEWLINE)
(KEYWORD if)
(ID "j")
(PUNCT "<")
(ID "n")
(KEYWORD and)
(ID "pat")
(PUNCT "[")
(ID "j")
(PUNCT "]")
(PUNCT "==")
(LIT "!")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "j")
(PUNCT "=")
(ID "j")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "j")
(PUNCT "<")
(ID "n")
(KEYWORD and)
(ID "pat")
(PUNCT "[")
(ID "j")
(PUNCT "]")
(PUNCT "==")
(LIT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "j")
(PUNCT "=")
(ID "j")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "j")
(PUNCT "<")
(ID "n")
(KEYWORD and)
(ID "pat")
(PUNCT "[")
(ID "j")
(PUNCT "]")
(PUNCT "!=")
(LIT "]")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "j")
(PUNCT "=")
(ID "j")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "j")
(PUNCT ">=")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "res")
(PUNCT "+")
(LIT "\\[")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stuff")
(PUNCT "=")
(ID "pat")
(PUNCT "[")
(ID "i")
(PUNCT ":")
(ID "j")
(PUNCT "]")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\\")
(PUNCT ",")
(LIT "\\\\")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "j")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "stuff")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "!")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stuff")
(PUNCT "=")
(LIT "^")
(PUNCT "+")
(ID "stuff")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "stuff")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "^")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stuff")
(PUNCT "=")
(LIT "\\")
(PUNCT "+")
(ID "stuff")
(NEWLINE)
(DEDENT)
(ID "res")
(PUNCT "=")
(LIT "%s[%s]")
(PUNCT "%")
(PUNCT "(")
(ID "res")
(PUNCT ",")
(ID "stuff")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "res")
(PUNCT "=")
(ID "res")
(PUNCT "+")
(ID "re")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "res")
(PUNCT "+")
(LIT "\\Z(?ms)")
(NEWLINE)
(DEDENT)
(ENDMARKER)
