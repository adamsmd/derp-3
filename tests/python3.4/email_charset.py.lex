(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "Charset")
(PUNCT ",")
(LIT "add_alias")
(PUNCT ",")
(LIT "add_charset")
(PUNCT ",")
(LIT "add_codec")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD from)
(ID "functools")
(KEYWORD import)
(ID "partial")
(NEWLINE)
(KEYWORD import)
(ID "email")
(PUNCT ".")
(ID "base64mime")
(NEWLINE)
(KEYWORD import)
(ID "email")
(PUNCT ".")
(ID "quoprimime")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "errors")
(NEWLINE)
(KEYWORD from)
(ID "email")
(PUNCT ".")
(ID "encoders")
(KEYWORD import)
(ID "encode_7or8bit")
(NEWLINE)
(ID "QP")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "BASE64")
(PUNCT "=")
(LIT 2)
(NEWLINE)
(ID "SHORTEST")
(PUNCT "=")
(LIT 3)
(NEWLINE)
(ID "RFC2047_CHROME_LEN")
(PUNCT "=")
(LIT 7)
(NEWLINE)
(ID "DEFAULT_CHARSET")
(PUNCT "=")
(LIT "us-ascii")
(NEWLINE)
(ID "UNKNOWN8BIT")
(PUNCT "=")
(LIT "unknown-8bit")
(NEWLINE)
(ID "EMPTYSTRING")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "CHARSETS")
(PUNCT "=")
(PUNCT "{")
(LIT "iso-8859-1")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-2")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-3")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-4")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-9")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-10")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-13")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-14")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-15")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "iso-8859-16")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "windows-1252")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "viscii")
(PUNCT ":")
(PUNCT "(")
(ID "QP")
(PUNCT ",")
(ID "QP")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "us-ascii")
(PUNCT ":")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "big5")
(PUNCT ":")
(PUNCT "(")
(ID "BASE64")
(PUNCT ",")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "gb2312")
(PUNCT ":")
(PUNCT "(")
(ID "BASE64")
(PUNCT ",")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "euc-jp")
(PUNCT ":")
(PUNCT "(")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT "iso-2022-jp")
(PUNCT ")")
(PUNCT ",")
(LIT "shift_jis")
(PUNCT ":")
(PUNCT "(")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(LIT "iso-2022-jp")
(PUNCT ")")
(PUNCT ",")
(LIT "iso-2022-jp")
(PUNCT ":")
(PUNCT "(")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "koi8-r")
(PUNCT ":")
(PUNCT "(")
(ID "BASE64")
(PUNCT ",")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(LIT "utf-8")
(PUNCT ":")
(PUNCT "(")
(ID "SHORTEST")
(PUNCT ",")
(ID "BASE64")
(PUNCT ",")
(LIT "utf-8")
(PUNCT ")")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "ALIASES")
(PUNCT "=")
(PUNCT "{")
(LIT "latin_1")
(PUNCT ":")
(LIT "iso-8859-1")
(PUNCT ",")
(LIT "latin-1")
(PUNCT ":")
(LIT "iso-8859-1")
(PUNCT ",")
(LIT "latin_2")
(PUNCT ":")
(LIT "iso-8859-2")
(PUNCT ",")
(LIT "latin-2")
(PUNCT ":")
(LIT "iso-8859-2")
(PUNCT ",")
(LIT "latin_3")
(PUNCT ":")
(LIT "iso-8859-3")
(PUNCT ",")
(LIT "latin-3")
(PUNCT ":")
(LIT "iso-8859-3")
(PUNCT ",")
(LIT "latin_4")
(PUNCT ":")
(LIT "iso-8859-4")
(PUNCT ",")
(LIT "latin-4")
(PUNCT ":")
(LIT "iso-8859-4")
(PUNCT ",")
(LIT "latin_5")
(PUNCT ":")
(LIT "iso-8859-9")
(PUNCT ",")
(LIT "latin-5")
(PUNCT ":")
(LIT "iso-8859-9")
(PUNCT ",")
(LIT "latin_6")
(PUNCT ":")
(LIT "iso-8859-10")
(PUNCT ",")
(LIT "latin-6")
(PUNCT ":")
(LIT "iso-8859-10")
(PUNCT ",")
(LIT "latin_7")
(PUNCT ":")
(LIT "iso-8859-13")
(PUNCT ",")
(LIT "latin-7")
(PUNCT ":")
(LIT "iso-8859-13")
(PUNCT ",")
(LIT "latin_8")
(PUNCT ":")
(LIT "iso-8859-14")
(PUNCT ",")
(LIT "latin-8")
(PUNCT ":")
(LIT "iso-8859-14")
(PUNCT ",")
(LIT "latin_9")
(PUNCT ":")
(LIT "iso-8859-15")
(PUNCT ",")
(LIT "latin-9")
(PUNCT ":")
(LIT "iso-8859-15")
(PUNCT ",")
(LIT "latin_10")
(PUNCT ":")
(LIT "iso-8859-16")
(PUNCT ",")
(LIT "latin-10")
(PUNCT ":")
(LIT "iso-8859-16")
(PUNCT ",")
(LIT "cp949")
(PUNCT ":")
(LIT "ks_c_5601-1987")
(PUNCT ",")
(LIT "euc_jp")
(PUNCT ":")
(LIT "euc-jp")
(PUNCT ",")
(LIT "euc_kr")
(PUNCT ":")
(LIT "euc-kr")
(PUNCT ",")
(LIT "ascii")
(PUNCT ":")
(LIT "us-ascii")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(ID "CODEC_MAP")
(PUNCT "=")
(PUNCT "{")
(LIT "gb2312")
(PUNCT ":")
(LIT "eucgb2312_cn")
(PUNCT ",")
(LIT "big5")
(PUNCT ":")
(LIT "big5_tw")
(PUNCT ",")
(LIT "us-ascii")
(PUNCT ":")
(KEYWORD None)
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "add_charset")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "header_enc")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "body_enc")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "output_charset")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add character set properties to the global registry.\n\n    charset is the input character set, and must be the canonical name of a\n    character set.\n\n    Optional header_enc and body_enc is either Charset.QP for\n    quoted-printable, Charset.BASE64 for base64 encoding, Charset.SHORTEST for\n    the shortest of qp or base64 encoding, or None for no encoding.  SHORTEST\n    is only valid for header_enc.  It describes how message headers and\n    message bodies in the input charset are to be encoded.  Default is no\n    encoding.\n\n    Optional output_charset is the character set that the output should be\n    in.  Conversions will proceed from input charset, to Unicode, to the\n    output charset when the method Charset.convert() is called.  The default\n    is to output in the same character set as the input.\n\n    Both input_charset and output_charset must have Unicode codec entries in\n    the module's charset-to-codec mapping; use add_codec(charset, codecname)\n    to add codecs the module does not know about.  See the codecs module's\n    documentation for more information.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "body_enc")
(PUNCT "==")
(ID "SHORTEST")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "SHORTEST not allowed for body_enc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "CHARSETS")
(PUNCT "[")
(ID "charset")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "header_enc")
(PUNCT ",")
(ID "body_enc")
(PUNCT ",")
(ID "output_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_alias")
(PUNCT "(")
(ID "alias")
(PUNCT ",")
(ID "canonical")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add a character set alias.\n\n    alias is the alias name, e.g. latin-1\n    canonical is the character set's canonical name, e.g. iso-8859-1\n    ")
(NEWLINE)
(ID "ALIASES")
(PUNCT "[")
(ID "alias")
(PUNCT "]")
(PUNCT "=")
(ID "canonical")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_codec")
(PUNCT "(")
(ID "charset")
(PUNCT ",")
(ID "codecname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Add a codec that map characters in the given charset to/from Unicode.\n\n    charset is the canonical name of a character set.  codecname is the name\n    of a Python codec, as appropriate for the second argument to the unicode()\n    built-in, or to the encode() method of a Unicode string.\n    ")
(NEWLINE)
(ID "CODEC_MAP")
(PUNCT "[")
(ID "charset")
(PUNCT "]")
(PUNCT "=")
(ID "codecname")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_encode")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "codec")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "codec")
(PUNCT "==")
(ID "UNKNOWN8BIT")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ",")
(LIT "surrogateescape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Charset")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Map character sets to their email properties.\n\n    This class provides information about the requirements imposed on email\n    for a specific character set.  It also provides convenience routines for\n    converting between character sets, given the availability of the\n    applicable codecs.  Given a character set, it will do its best to provide\n    information on how to use that character set in an email in an\n    RFC-compliant way.\n\n    Certain character sets must be encoded with quoted-printable or base64\n    when used in email headers or bodies.  Certain character sets must be\n    converted outright, and are not allowed in email.  Instances of this\n    module expose the following information about a character set:\n\n    input_charset: The initial character set specified.  Common aliases\n                   are converted to their `official' email names (e.g. latin_1\n                   is converted to iso-8859-1).  Defaults to 7-bit us-ascii.\n\n    header_encoding: If the character set must be encoded before it can be\n                     used in an email header, this attribute will be set to\n                     Charset.QP (for quoted-printable), Charset.BASE64 (for\n                     base64 encoding), or Charset.SHORTEST for the shortest of\n                     QP or BASE64 encoding.  Otherwise, it will be None.\n\n    body_encoding: Same as header_encoding, but describes the encoding for the\n                   mail message's body, which indeed may be different than the\n                   header encoding.  Charset.SHORTEST is not allowed for\n                   body_encoding.\n\n    output_charset: Some character sets must be converted before they can be\n                    used in email headers or bodies.  If the input_charset is\n                    one of them, this attribute will contain the name of the\n                    charset output will be converted to.  Otherwise, it will\n                    be None.\n\n    input_codec: The name of the Python codec used to convert the\n                 input_charset to Unicode.  If no conversion codec is\n                 necessary, this attribute will be None.\n\n    output_codec: The name of the Python codec used to convert Unicode\n                  to the output_charset.  If no conversion codec is necessary,\n                  this attribute will have the same value as the input_codec.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "input_charset")
(PUNCT "=")
(ID "DEFAULT_CHARSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "input_charset")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "input_charset")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "input_charset")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "input_charset")
(PUNCT ",")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "UnicodeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "errors")
(PUNCT ".")
(ID "CharsetError")
(PUNCT "(")
(ID "input_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "input_charset")
(PUNCT "=")
(ID "input_charset")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "input_charset")
(PUNCT "=")
(ID "ALIASES")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "input_charset")
(PUNCT ",")
(ID "input_charset")
(PUNCT ")")
(NEWLINE)
(ID "henc")
(PUNCT ",")
(ID "benc")
(PUNCT ",")
(ID "conv")
(PUNCT "=")
(ID "CHARSETS")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "input_charset")
(PUNCT ",")
(PUNCT "(")
(ID "SHORTEST")
(PUNCT ",")
(ID "BASE64")
(PUNCT ",")
(KEYWORD None)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "conv")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "conv")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "input_charset")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "header_encoding")
(PUNCT "=")
(ID "henc")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "body_encoding")
(PUNCT "=")
(ID "benc")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "output_charset")
(PUNCT "=")
(ID "ALIASES")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "conv")
(PUNCT ",")
(ID "conv")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "input_codec")
(PUNCT "=")
(ID "CODEC_MAP")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "input_charset")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "input_charset")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "output_codec")
(PUNCT "=")
(ID "CODEC_MAP")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "output_charset")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "output_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "input_charset")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__repr__")
(PUNCT "=")
(ID "__str__")
(NEWLINE)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT "==")
(ID "str")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__ne__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "__eq__")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_body_encoding")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the content-transfer-encoding used for body encoding.\n\n        This is either the string `quoted-printable' or `base64' depending on\n        the encoding used, or it is a function in which case you should call\n        the function with a single argument, the Message object being\n        encoded.  The function should then set the Content-Transfer-Encoding\n        header itself to whatever is appropriate.\n\n        Returns \"quoted-printable\" if self.body_encoding is QP.\n        Returns \"base64\" if self.body_encoding is BASE64.\n        Returns conversion function otherwise.\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "body_encoding")
(PUNCT "!=")
(ID "SHORTEST")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "body_encoding")
(PUNCT "==")
(ID "QP")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "quoted-printable")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "body_encoding")
(PUNCT "==")
(ID "BASE64")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "base64")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "encode_7or8bit")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get_output_charset")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the output character set.\n\n        This is self.output_charset if that is not None, otherwise it is\n        self.input_charset.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "output_charset")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "input_charset")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_encode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Header-encode a string by converting it first to bytes.\n\n        The type of encoding (base64 or quoted-printable) will be based on\n        this charset's `header_encoding`.\n\n        :param string: A unicode string for the header.  It must be possible\n            to encode this string to bytes using the character set's\n            output codec.\n        :return: The encoded string, with RFC 2047 chrome.\n        ")
(NEWLINE)
(ID "codec")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "output_codec")
(KEYWORD or)
(LIT "us-ascii")
(NEWLINE)
(ID "header_bytes")
(PUNCT "=")
(ID "_encode")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(ID "encoder_module")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_encoder")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "encoder_module")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "string")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "encoder_module")
(PUNCT ".")
(ID "header_encode")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ",")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "header_encode_lines")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ",")
(ID "maxlengths")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Header-encode a string by converting it first to bytes.\n\n        This is similar to `header_encode()` except that the string is fit\n        into maximum line lengths as given by the argument.\n\n        :param string: A unicode string for the header.  It must be possible\n            to encode this string to bytes using the character set's\n            output codec.\n        :param maxlengths: Maximum line length iterator.  Each element\n            returned from this iterator will provide the next maximum line\n            length.  This parameter is used as an argument to built-in next()\n            and should never be exhausted.  The maximum line lengths should\n            not count the RFC 2047 chrome.  These line lengths are only a\n            hint; the splitter does the best it can.\n        :return: Lines of encoded strings, each with RFC 2047 chrome.\n        ")
(NEWLINE)
(ID "codec")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "output_codec")
(KEYWORD or)
(LIT "us-ascii")
(NEWLINE)
(ID "header_bytes")
(PUNCT "=")
(ID "_encode")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(ID "encoder_module")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_get_encoder")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ")")
(NEWLINE)
(ID "encoder")
(PUNCT "=")
(ID "partial")
(PUNCT "(")
(ID "encoder_module")
(PUNCT ".")
(ID "header_encode")
(PUNCT ",")
(ID "charset")
(PUNCT "=")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(ID "charset")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "get_output_charset")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "extra")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "charset")
(PUNCT ")")
(PUNCT "+")
(ID "RFC2047_CHROME_LEN")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "current_line")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "maxlen")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "maxlengths")
(PUNCT ")")
(PUNCT "-")
(ID "extra")
(NEWLINE)
(KEYWORD for)
(ID "character")
(KEYWORD in)
(ID "string")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "current_line")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "character")
(PUNCT ")")
(NEWLINE)
(ID "this_line")
(PUNCT "=")
(ID "EMPTYSTRING")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "current_line")
(PUNCT ")")
(NEWLINE)
(ID "length")
(PUNCT "=")
(ID "encoder_module")
(PUNCT ".")
(ID "header_length")
(PUNCT "(")
(ID "_encode")
(PUNCT "(")
(ID "this_line")
(PUNCT ",")
(ID "charset")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "length")
(PUNCT ">")
(ID "maxlen")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "current_line")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "lines")
(KEYWORD and)
(KEYWORD not)
(ID "current_line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "separator")
(PUNCT "=")
(PUNCT "(")
(LIT " ")
(KEYWORD if)
(ID "lines")
(KEYWORD else)
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "joined_line")
(PUNCT "=")
(ID "EMPTYSTRING")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "current_line")
(PUNCT ")")
(NEWLINE)
(ID "header_bytes")
(PUNCT "=")
(ID "_encode")
(PUNCT "(")
(ID "joined_line")
(PUNCT ",")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "encoder")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "current_line")
(PUNCT "=")
(PUNCT "[")
(ID "character")
(PUNCT "]")
(NEWLINE)
(ID "maxlen")
(PUNCT "=")
(ID "next")
(PUNCT "(")
(ID "maxlengths")
(PUNCT ")")
(PUNCT "-")
(ID "extra")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "joined_line")
(PUNCT "=")
(ID "EMPTYSTRING")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "current_line")
(PUNCT ")")
(NEWLINE)
(ID "header_bytes")
(PUNCT "=")
(ID "_encode")
(PUNCT "(")
(ID "joined_line")
(PUNCT ",")
(ID "codec")
(PUNCT ")")
(NEWLINE)
(ID "lines")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "encoder")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "lines")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_get_encoder")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "header_bytes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "header_encoding")
(PUNCT "==")
(ID "BASE64")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "email")
(PUNCT ".")
(ID "base64mime")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "header_encoding")
(PUNCT "==")
(ID "QP")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "email")
(PUNCT ".")
(ID "quoprimime")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "header_encoding")
(PUNCT "==")
(ID "SHORTEST")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "len64")
(PUNCT "=")
(ID "email")
(PUNCT ".")
(ID "base64mime")
(PUNCT ".")
(ID "header_length")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ")")
(NEWLINE)
(ID "lenqp")
(PUNCT "=")
(ID "email")
(PUNCT ".")
(ID "quoprimime")
(PUNCT ".")
(ID "header_length")
(PUNCT "(")
(ID "header_bytes")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len64")
(PUNCT "<")
(ID "lenqp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "email")
(PUNCT ".")
(ID "base64mime")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "email")
(PUNCT ".")
(ID "quoprimime")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "body_encode")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Body-encode a string by converting it first to bytes.\n\n        The type of encoding (base64 or quoted-printable) will be based on\n        self.body_encoding.  If body_encoding is None, we assume the\n        output charset is a 7bit encoding, so re-encoding the decoded\n        string using the ascii codec produces the correct string version\n        of the content.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "string")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "string")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "body_encoding")
(KEYWORD is)
(ID "BASE64")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "output_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "email")
(PUNCT ".")
(ID "base64mime")
(PUNCT ".")
(ID "body_encode")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "body_encoding")
(KEYWORD is)
(ID "QP")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "output_charset")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "latin1")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "email")
(PUNCT ".")
(ID "quoprimime")
(PUNCT ".")
(ID "body_encode")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "string")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "string")
(PUNCT "=")
(ID "string")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "output_charset")
(PUNCT ")")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "string")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
