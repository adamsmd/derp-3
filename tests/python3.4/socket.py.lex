(LIT "This module provides socket operations and some related functions.\nOn Unix, it supports IP (Internet Protocol) and Unix domain sockets.\nOn other systems, it only supports IP. Functions specific for a\nsocket are available as methods of the socket object.\n\nFunctions:\n\nsocket() -- create a new socket object\nsocketpair() -- create a pair of new socket objects [*]\nfromfd() -- create a socket object from an open file descriptor [*]\nfromshare() -- create a socket object from data received from socket.share() [*]\ngethostname() -- return the current hostname\ngethostbyname() -- map a hostname to its IP number\ngethostbyaddr() -- map an IP number or hostname to DNS info\ngetservbyname() -- map a service name and a protocol name to a port number\ngetprotobyname() -- map a protocol name (e.g. 'tcp') to a number\nntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order\nhtons(), htonl() -- convert 16, 32 bit int from host to network byte order\ninet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format\ninet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)\nsocket.getdefaulttimeout() -- get the default timeout value\nsocket.setdefaulttimeout() -- set the default timeout value\ncreate_connection() -- connects to an address, with an optional timeout and\n                       optional source address.\n\n [*] not available on all platforms!\n\nSpecial objects:\n\nSocketType -- type object for socket objects\nerror -- exception raised for I/O errors\nhas_ipv6 -- boolean value indicating if IPv6 is supported\n\nIntEnum constants:\n\nAF_INET, AF_UNIX -- socket domains (first argument to socket() call)\nSOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)\n\nInteger constants:\n\nMany other constants may be defined; these may be used in calls to\nthe setsockopt() and getsockopt() methods.\n")
(NEWLINE)
(KEYWORD import)
(ID "_socket")
(NEWLINE)
(KEYWORD from)
(ID "_socket")
(KEYWORD import)
(PUNCT "*")
(NEWLINE)
(KEYWORD import)
(ID "os")
(PUNCT ",")
(ID "sys")
(PUNCT ",")
(ID "io")
(NEWLINE)
(KEYWORD from)
(ID "enum")
(KEYWORD import)
(ID "IntEnum")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "errno")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errno")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "EBADF")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "errno")
(PUNCT ",")
(LIT "EBADF")
(PUNCT ",")
(LIT 9)
(PUNCT ")")
(NEWLINE)
(ID "EAGAIN")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "errno")
(PUNCT ",")
(LIT "EAGAIN")
(PUNCT ",")
(LIT 11)
(PUNCT ")")
(NEWLINE)
(ID "EWOULDBLOCK")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "errno")
(PUNCT ",")
(LIT "EWOULDBLOCK")
(PUNCT ",")
(LIT 11)
(PUNCT ")")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "fromfd")
(PUNCT ",")
(LIT "getfqdn")
(PUNCT ",")
(LIT "create_connection")
(PUNCT ",")
(LIT "AddressFamily")
(PUNCT ",")
(LIT "SocketKind")
(PUNCT "]")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "_get_exports_list")
(PUNCT "(")
(ID "_socket")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "AddressFamily")
(PUNCT "=")
(ID "IntEnum")
(PUNCT "(")
(LIT "AddressFamily")
(PUNCT ",")
(PUNCT "{")
(ID "name")
(PUNCT ":")
(ID "value")
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "isupper")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "AF_")
(PUNCT ")")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "AddressFamily")
(PUNCT ".")
(ID "__members__")
(PUNCT ")")
(NEWLINE)
(ID "SocketKind")
(PUNCT "=")
(ID "IntEnum")
(PUNCT "(")
(LIT "SocketKind")
(PUNCT ",")
(PUNCT "{")
(ID "name")
(PUNCT ":")
(ID "value")
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "name")
(PUNCT ".")
(ID "isupper")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(ID "name")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "SOCK_")
(PUNCT ")")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(ID "globals")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "SocketKind")
(PUNCT ".")
(ID "__members__")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_intenum_converter")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "enum_klass")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert a numeric family value to an IntEnum member.\n\n    If it's not a known member, return the numeric value itself.\n    ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "enum_klass")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_realsocket")
(PUNCT "=")
(ID "socket")
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "platform")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "win")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errorTab")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10004)
(PUNCT "]")
(PUNCT "=")
(LIT "The operation was interrupted.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10009)
(PUNCT "]")
(PUNCT "=")
(LIT "A bad file handle was passed.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10013)
(PUNCT "]")
(PUNCT "=")
(LIT "Permission denied.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10014)
(PUNCT "]")
(PUNCT "=")
(LIT "A fault occurred on the network??")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10022)
(PUNCT "]")
(PUNCT "=")
(LIT "An invalid operation was attempted.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10035)
(PUNCT "]")
(PUNCT "=")
(LIT "The socket operation would block")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10036)
(PUNCT "]")
(PUNCT "=")
(LIT "A blocking operation is already in progress.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10048)
(PUNCT "]")
(PUNCT "=")
(LIT "The network address is in use.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10054)
(PUNCT "]")
(PUNCT "=")
(LIT "The connection has been reset.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10058)
(PUNCT "]")
(PUNCT "=")
(LIT "The network has been shut down.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10060)
(PUNCT "]")
(PUNCT "=")
(LIT "The operation timed out.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10061)
(PUNCT "]")
(PUNCT "=")
(LIT "Connection refused.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10063)
(PUNCT "]")
(PUNCT "=")
(LIT "The name is too long.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10064)
(PUNCT "]")
(PUNCT "=")
(LIT "The host is down.")
(NEWLINE)
(ID "errorTab")
(PUNCT "[")
(LIT 10065)
(PUNCT "]")
(PUNCT "=")
(LIT "The host is unreachable.")
(NEWLINE)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "errorTab")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "socket")
(PUNCT "(")
(ID "_socket")
(PUNCT ".")
(ID "socket")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A subclass of _socket.socket adding the makefile() method.")
(NEWLINE)
(ID "__slots__")
(PUNCT "=")
(PUNCT "[")
(LIT "__weakref__")
(PUNCT ",")
(LIT "_io_refs")
(PUNCT ",")
(LIT "_closed")
(PUNCT "]")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "family")
(PUNCT "=")
(ID "AF_INET")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "SOCK_STREAM")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "fileno")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_socket")
(PUNCT ".")
(ID "socket")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "fileno")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_io_refs")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_closed")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Wrap __repr__() to reveal the real class name and socket\n        address(es).\n        ")
(NEWLINE)
(ID "closed")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "_closed")
(PUNCT ",")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(LIT "<%s.%s%s fd=%i, family=%s, type=%s, proto=%i")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__module__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(LIT " [closed]")
(KEYWORD if)
(ID "closed")
(KEYWORD else)
(LIT "")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "family")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "proto")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "laddr")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "getsockname")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "laddr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT ", laddr=%s")
(PUNCT "%")
(ID "str")
(PUNCT "(")
(ID "laddr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "raddr")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "getpeername")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "raddr")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "+=")
(LIT ", raddr=%s")
(PUNCT "%")
(ID "str")
(PUNCT "(")
(ID "raddr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "s")
(PUNCT "+=")
(LIT ">")
(NEWLINE)
(KEYWORD return)
(ID "s")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getstate__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "Cannot serialize socket object")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "dup")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "dup() -> socket object\n\n        Duplicate the socket. Return a new socket object connected to the same\n        system resource. The new socket is non-inheritable.\n        ")
(NEWLINE)
(ID "fd")
(PUNCT "=")
(ID "dup")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "sock")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "family")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "proto")
(PUNCT ",")
(ID "fileno")
(PUNCT "=")
(ID "fd")
(PUNCT ")")
(NEWLINE)
(ID "sock")
(PUNCT ".")
(ID "settimeout")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "gettimeout")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "sock")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "accept")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "accept() -> (socket object, address info)\n\n        Wait for an incoming connection.  Return a new socket\n        representing the connection, and the address of the client.\n        For IP sockets, the address info is a pair (hostaddr, port).\n        ")
(NEWLINE)
(ID "fd")
(PUNCT ",")
(ID "addr")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_accept")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "sock")
(PUNCT "=")
(ID "socket")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "family")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "proto")
(PUNCT ",")
(ID "fileno")
(PUNCT "=")
(ID "fd")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "getdefaulttimeout")
(PUNCT "(")
(PUNCT ")")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "gettimeout")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sock")
(PUNCT ".")
(ID "setblocking")
(PUNCT "(")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "sock")
(PUNCT ",")
(ID "addr")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "makefile")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT "r")
(PUNCT ",")
(ID "buffering")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "errors")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "newline")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "makefile(...) -> an I/O stream connected to the socket\n\n        The arguments are as for io.open() after the filename,\n        except the only mode characters supported are 'r', 'w' and 'b'.\n        The semantics are similar too.  (XXX refactor to share code?)\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "set")
(PUNCT "(")
(ID "mode")
(PUNCT ")")
(PUNCT "<=")
(PUNCT "{")
(LIT "r")
(PUNCT ",")
(LIT "w")
(PUNCT ",")
(LIT "b")
(PUNCT "}")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid mode %r (only r, w, b allowed)")
(PUNCT "%")
(PUNCT "(")
(ID "mode")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "writing")
(PUNCT "=")
(LIT "w")
(KEYWORD in)
(ID "mode")
(NEWLINE)
(ID "reading")
(PUNCT "=")
(LIT "r")
(KEYWORD in)
(ID "mode")
(KEYWORD or)
(KEYWORD not)
(ID "writing")
(NEWLINE)
(KEYWORD assert)
(ID "reading")
(KEYWORD or)
(ID "writing")
(NEWLINE)
(ID "binary")
(PUNCT "=")
(LIT "b")
(KEYWORD in)
(ID "mode")
(NEWLINE)
(ID "rawmode")
(PUNCT "=")
(LIT "")
(NEWLINE)
(KEYWORD if)
(ID "reading")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rawmode")
(PUNCT "+=")
(LIT "r")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "writing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rawmode")
(PUNCT "+=")
(LIT "w")
(NEWLINE)
(DEDENT)
(ID "raw")
(PUNCT "=")
(ID "SocketIO")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "rawmode")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_io_refs")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "buffering")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffering")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "buffering")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffering")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "DEFAULT_BUFFER_SIZE")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "buffering")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "binary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unbuffered streams must be binary")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "raw")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "reading")
(KEYWORD and)
(ID "writing")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffer")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BufferedRWPair")
(PUNCT "(")
(ID "raw")
(PUNCT ",")
(ID "raw")
(PUNCT ",")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "reading")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "buffer")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BufferedReader")
(PUNCT "(")
(ID "raw")
(PUNCT ",")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "writing")
(NEWLINE)
(ID "buffer")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BufferedWriter")
(PUNCT "(")
(ID "raw")
(PUNCT ",")
(ID "buffering")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "binary")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "buffer")
(NEWLINE)
(DEDENT)
(ID "text")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "TextIOWrapper")
(PUNCT "(")
(ID "buffer")
(PUNCT ",")
(ID "encoding")
(PUNCT ",")
(ID "errors")
(PUNCT ",")
(ID "newline")
(PUNCT ")")
(NEWLINE)
(ID "text")
(PUNCT ".")
(ID "mode")
(PUNCT "=")
(ID "mode")
(NEWLINE)
(KEYWORD return)
(ID "text")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_decref_socketios")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_io_refs")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_io_refs")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_real_close")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "_ss")
(PUNCT "=")
(ID "_socket")
(PUNCT ".")
(ID "socket")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_ss")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_closed")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_io_refs")
(PUNCT "<=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_real_close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "detach")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "detach() -> file descriptor\n\n        Close the socket object without closing the underlying file descriptor.\n        The object cannot be used after this call, but the file descriptor\n        can be reused for other purposes.  The file descriptor is returned.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_closed")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD return)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "detach")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "family")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read-only access to the address family for this socket.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "_intenum_converter")
(PUNCT "(")
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "family")
(PUNCT ",")
(ID "AddressFamily")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read-only access to the socket type.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "_intenum_converter")
(PUNCT "(")
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "SocketKind")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "get_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "get_handle_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "inheritable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "set_handle_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "inheritable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "get_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "get_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "set_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "inheritable")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "set_inheritable")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "inheritable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "get_inheritable")
(PUNCT ".")
(ID "__doc__")
(PUNCT "=")
(LIT "Get the inheritable flag of the socket")
(NEWLINE)
(ID "set_inheritable")
(PUNCT ".")
(ID "__doc__")
(PUNCT "=")
(LIT "Set the inheritable flag of the socket")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fromfd")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " fromfd(fd, family, type[, proto]) -> socket object\n\n    Create a socket object from a duplicate of the given file\n    descriptor.  The remaining arguments are the same as for socket().\n    ")
(NEWLINE)
(ID "nfd")
(PUNCT "=")
(ID "dup")
(PUNCT "(")
(ID "fd")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "socket")
(PUNCT "(")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "nfd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "_socket")
(PUNCT ".")
(ID "socket")
(PUNCT ",")
(LIT "share")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "fromshare")
(PUNCT "(")
(ID "info")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT " fromshare(info) -> socket object\n\n        Create a socket object from the bytes object returned by\n        socket.share(pid).\n        ")
(NEWLINE)
(KEYWORD return)
(ID "socket")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "info")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__all__")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "fromshare")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "_socket")
(PUNCT ",")
(LIT "socketpair")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "socketpair")
(PUNCT "(")
(ID "family")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "SOCK_STREAM")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "socketpair([family[, type[, proto]]]) -> (socket object, socket object)\n\n        Create a pair of socket objects from the sockets returned by the platform\n        socketpair() function.\n        The arguments are the same as for socket() except the default family is\n        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "family")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "family")
(PUNCT "=")
(ID "AF_UNIX")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NameError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "family")
(PUNCT "=")
(ID "AF_INET")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "a")
(PUNCT ",")
(ID "b")
(PUNCT "=")
(ID "_socket")
(PUNCT ".")
(ID "socketpair")
(PUNCT "(")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT ")")
(NEWLINE)
(ID "a")
(PUNCT "=")
(ID "socket")
(PUNCT "(")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "a")
(PUNCT ".")
(ID "detach")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "b")
(PUNCT "=")
(ID "socket")
(PUNCT "(")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "b")
(PUNCT ".")
(ID "detach")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "a")
(PUNCT ",")
(ID "b")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_blocking_errnos")
(PUNCT "=")
(PUNCT "{")
(ID "EAGAIN")
(PUNCT ",")
(ID "EWOULDBLOCK")
(PUNCT "}")
(NEWLINE)
(KEYWORD class)
(ID "SocketIO")
(PUNCT "(")
(ID "io")
(PUNCT ".")
(ID "RawIOBase")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raw I/O implementation for stream sockets.\n\n    This class supports the makefile() method on sockets.  It provides\n    the raw I/O interface on top of a socket object.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sock")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "mode")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "r")
(PUNCT ",")
(LIT "w")
(PUNCT ",")
(LIT "rw")
(PUNCT ",")
(LIT "rb")
(PUNCT ",")
(LIT "wb")
(PUNCT ",")
(LIT "rwb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid mode: %r")
(PUNCT "%")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "io")
(PUNCT ".")
(ID "RawIOBase")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sock")
(PUNCT "=")
(ID "sock")
(NEWLINE)
(KEYWORD if)
(LIT "b")
(KEYWORD not)
(KEYWORD in)
(ID "mode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "+=")
(LIT "b")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_mode")
(PUNCT "=")
(ID "mode")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_reading")
(PUNCT "=")
(LIT "r")
(KEYWORD in)
(ID "mode")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_writing")
(PUNCT "=")
(LIT "w")
(KEYWORD in)
(ID "mode")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_timeout_occurred")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readinto")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n\n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkReadable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_timeout_occurred")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "OSError")
(PUNCT "(")
(LIT "cannot read from timed out object")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_sock")
(PUNCT ".")
(ID "recv_into")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "timeout")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_timeout_occurred")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "InterruptedError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "error")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD in)
(ID "_blocking_errnos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "b")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write the given bytes or bytearray object *b* to the socket\n        and return the number of bytes written.  This can be less than\n        len(b) if not all data could be written.  If the socket is\n        non-blocking and no bytes could be written None is returned.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkWritable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_sock")
(PUNCT ".")
(ID "send")
(PUNCT "(")
(ID "b")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "error")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "e")
(PUNCT ".")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(KEYWORD in)
(ID "_blocking_errnos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "readable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "True if the SocketIO is open for reading.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed socket.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_reading")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "writable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "True if the SocketIO is open for writing.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed socket.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_writing")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "seekable")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "True if the SocketIO is open for seeking.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "I/O operation on closed socket.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "seekable")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the file descriptor of the underlying socket.\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_checkClosed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_sock")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "mode")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_mode")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Close the SocketIO object.  This doesn't close the underlying\n        socket, except if all references to it have disappeared.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "closed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "io")
(PUNCT ".")
(ID "RawIOBase")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sock")
(PUNCT ".")
(ID "_decref_socketios")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getfqdn")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get fully qualified domain name from name.\n\n    An empty argument is interpreted as meaning the local host.\n\n    First the hostname returned by gethostbyaddr() is checked, then\n    possibly existing aliases. In case no FQDN is available, hostname\n    from gethostname() is returned.\n    ")
(NEWLINE)
(ID "name")
(PUNCT "=")
(ID "name")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "name")
(KEYWORD or)
(ID "name")
(PUNCT "==")
(LIT "0.0.0.0")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "gethostname")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "hostname")
(PUNCT ",")
(ID "aliases")
(PUNCT ",")
(ID "ipaddrs")
(PUNCT "=")
(ID "gethostbyaddr")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "error")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "aliases")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(ID "hostname")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "aliases")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT ".")
(KEYWORD in)
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "name")
(PUNCT "=")
(ID "hostname")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "name")
(NEWLINE)
(DEDENT)
(ID "_GLOBAL_DEFAULT_TIMEOUT")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "create_connection")
(PUNCT "(")
(ID "address")
(PUNCT ",")
(ID "timeout")
(PUNCT "=")
(ID "_GLOBAL_DEFAULT_TIMEOUT")
(PUNCT ",")
(ID "source_address")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.\n    ")
(NEWLINE)
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT "=")
(ID "address")
(NEWLINE)
(ID "err")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "res")
(KEYWORD in)
(ID "getaddrinfo")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT ",")
(LIT 0)
(PUNCT ",")
(ID "SOCK_STREAM")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "af")
(PUNCT ",")
(ID "socktype")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "canonname")
(PUNCT ",")
(ID "sa")
(PUNCT "=")
(ID "res")
(NEWLINE)
(ID "sock")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sock")
(PUNCT "=")
(ID "socket")
(PUNCT "(")
(ID "af")
(PUNCT ",")
(ID "socktype")
(PUNCT ",")
(ID "proto")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "timeout")
(KEYWORD is)
(KEYWORD not)
(ID "_GLOBAL_DEFAULT_TIMEOUT")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sock")
(PUNCT ".")
(ID "settimeout")
(PUNCT "(")
(ID "timeout")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "source_address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sock")
(PUNCT ".")
(ID "bind")
(PUNCT "(")
(ID "source_address")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "sock")
(PUNCT ".")
(ID "connect")
(PUNCT "(")
(ID "sa")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "sock")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "error")
(KEYWORD as)
(ID "_")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "err")
(PUNCT "=")
(ID "_")
(NEWLINE)
(KEYWORD if)
(ID "sock")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sock")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "err")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "err")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "error")
(PUNCT "(")
(LIT "getaddrinfo returns an empty list")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getaddrinfo")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT ",")
(ID "family")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "type")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "flags")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Resolve host and port into list of address info entries.\n\n    Translate the host/port argument into a sequence of 5-tuples that contain\n    all the necessary arguments for creating a socket connected to that service.\n    host is a domain name, a string representation of an IPv4/v6 address or\n    None. port is a string service name such as 'http', a numeric port number or\n    None. By passing None as the value of host and port, you can pass NULL to\n    the underlying C API.\n\n    The family, type and proto arguments can be optionally specified in order to\n    narrow the list of addresses returned. Passing zero as a value for each of\n    these arguments selects the full range of results.\n    ")
(NEWLINE)
(ID "addrlist")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "res")
(KEYWORD in)
(ID "_socket")
(PUNCT ".")
(ID "getaddrinfo")
(PUNCT "(")
(ID "host")
(PUNCT ",")
(ID "port")
(PUNCT ",")
(ID "family")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "flags")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "af")
(PUNCT ",")
(ID "socktype")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "canonname")
(PUNCT ",")
(ID "sa")
(PUNCT "=")
(ID "res")
(NEWLINE)
(ID "addrlist")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "_intenum_converter")
(PUNCT "(")
(ID "af")
(PUNCT ",")
(ID "AddressFamily")
(PUNCT ")")
(PUNCT ",")
(ID "_intenum_converter")
(PUNCT "(")
(ID "socktype")
(PUNCT ",")
(ID "SocketKind")
(PUNCT ")")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "canonname")
(PUNCT ",")
(ID "sa")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "addrlist")
(NEWLINE)
(DEDENT)
(ENDMARKER)
