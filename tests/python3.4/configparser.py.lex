(LIT "Configuration file parser.\n\nA configuration file consists of sections, lead by a \"[section]\" header,\nand followed by \"name: value\" entries, with continuations and such in\nthe style of RFC 822.\n\nIntrinsic defaults can be specified by passing them into the\nConfigParser constructor as a dictionary.\n\nclass:\n\nConfigParser -- responsible for parsing a list of\n                    configuration files, and managing the parsed database.\n\n    methods:\n\n    __init__(defaults=None, dict_type=_default_dict, allow_no_value=False,\n             delimiters=('=', ':'), comment_prefixes=('#', ';'),\n             inline_comment_prefixes=None, strict=True,\n             empty_lines_in_values=True):\n        Create the parser. When `defaults' is given, it is initialized into the\n        dictionary or intrinsic defaults. The keys must be strings, the values\n        must be appropriate for %()s string interpolation.\n\n        When `dict_type' is given, it will be used to create the dictionary\n        objects for the list of sections, for the options within a section, and\n        for the default values.\n\n        When `delimiters' is given, it will be used as the set of substrings\n        that divide keys from values.\n\n        When `comment_prefixes' is given, it will be used as the set of\n        substrings that prefix comments in empty lines. Comments can be\n        indented.\n\n        When `inline_comment_prefixes' is given, it will be used as the set of\n        substrings that prefix comments in non-empty lines.\n\n        When `strict` is True, the parser won't allow for any section or option\n        duplicates while reading from a single source (file, string or\n        dictionary). Default is True.\n\n        When `empty_lines_in_values' is False (default: True), each empty line\n        marks the end of an option. Otherwise, internal empty lines of\n        a multiline option are kept as part of the value.\n\n        When `allow_no_value' is True (default: False), options without\n        values are accepted; the value presented for these is None.\n\n    sections()\n        Return all the configuration section names, sans DEFAULT.\n\n    has_section(section)\n        Return whether the given section exists.\n\n    has_option(section, option)\n        Return whether the given option exists in the given section.\n\n    options(section)\n        Return list of configuration options for the named section.\n\n    read(filenames, encoding=None)\n        Read and parse the list of named configuration files, given by\n        name.  A single filename is also allowed.  Non-existing files\n        are ignored.  Return list of successfully read files.\n\n    read_file(f, filename=None)\n        Read and parse one configuration file, given as a file object.\n        The filename defaults to f.name; it is only used in error\n        messages (if f has no `name' attribute, the string `<???>' is used).\n\n    read_string(string)\n        Read configuration from a given string.\n\n    read_dict(dictionary)\n        Read configuration from a dictionary. Keys are section names,\n        values are dictionaries with keys and values that should be present\n        in the section. If the used dictionary type preserves order, sections\n        and their keys will be added in order. Values are automatically\n        converted to strings.\n\n    get(section, option, raw=False, vars=None, fallback=_UNSET)\n        Return a string value for the named option.  All % interpolations are\n        expanded in the return values, based on the defaults passed into the\n        constructor and the DEFAULT section.  Additional substitutions may be\n        provided using the `vars' argument, which must be a dictionary whose\n        contents override any pre-existing defaults. If `option' is a key in\n        `vars', the value from `vars' is used.\n\n    getint(section, options, raw=False, vars=None, fallback=_UNSET)\n        Like get(), but convert value to an integer.\n\n    getfloat(section, options, raw=False, vars=None, fallback=_UNSET)\n        Like get(), but convert value to a float.\n\n    getboolean(section, options, raw=False, vars=None, fallback=_UNSET)\n        Like get(), but convert value to a boolean (currently case\n        insensitively defined as 0, false, no, off for False, and 1, true,\n        yes, on for True).  Returns False or True.\n\n    items(section=_UNSET, raw=False, vars=None)\n        If section is given, return a list of tuples with (name, value) for\n        each option in the section. Otherwise, return a list of tuples with\n        (section_name, section_proxy) for each section, including DEFAULTSECT.\n\n    remove_section(section)\n        Remove the given file section and all its options.\n\n    remove_option(section, option)\n        Remove the given option from the given section.\n\n    set(section, option, value)\n        Set the given option.\n\n    write(fp, space_around_delimiters=True)\n        Write the configuration state in .ini format. If\n        `space_around_delimiters' is True (the default), delimiters\n        between keys and values are surrounded by spaces.\n")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(PUNCT ".")
(ID "abc")
(KEYWORD import)
(ID "MutableMapping")
(NEWLINE)
(KEYWORD from)
(ID "collections")
(KEYWORD import)
(ID "OrderedDict")
(KEYWORD as)
(ID "_default_dict")
(PUNCT ",")
(ID "ChainMap")
(KEYWORD as)
(ID "_ChainMap")
(NEWLINE)
(KEYWORD import)
(ID "functools")
(NEWLINE)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD import)
(ID "itertools")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "NoSectionError")
(PUNCT ",")
(LIT "DuplicateOptionError")
(PUNCT ",")
(LIT "DuplicateSectionError")
(PUNCT ",")
(LIT "NoOptionError")
(PUNCT ",")
(LIT "InterpolationError")
(PUNCT ",")
(LIT "InterpolationDepthError")
(PUNCT ",")
(LIT "InterpolationSyntaxError")
(PUNCT ",")
(LIT "ParsingError")
(PUNCT ",")
(LIT "MissingSectionHeaderError")
(PUNCT ",")
(LIT "ConfigParser")
(PUNCT ",")
(LIT "SafeConfigParser")
(PUNCT ",")
(LIT "RawConfigParser")
(PUNCT ",")
(LIT "DEFAULTSECT")
(PUNCT ",")
(LIT "MAX_INTERPOLATION_DEPTH")
(PUNCT "]")
(NEWLINE)
(ID "DEFAULTSECT")
(PUNCT "=")
(LIT "DEFAULT")
(NEWLINE)
(ID "MAX_INTERPOLATION_DEPTH")
(PUNCT "=")
(LIT 10)
(NEWLINE)
(KEYWORD class)
(ID "Error")
(PUNCT "(")
(ID "Exception")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for ConfigParser exceptions.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "=")
(ID "msg")
(NEWLINE)
(ID "Exception")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "message")
(NEWLINE)
(DEDENT)
(ID "__str__")
(PUNCT "=")
(ID "__repr__")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "NoSectionError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when no section matches a requested option.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "No section: %r")
(PUNCT "%")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "section")
(PUNCT "=")
(ID "section")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DuplicateSectionError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when a section is repeated in an input source.\n\n    Possible repetitions that raise this exception are: multiple creation\n    using the API or in strict parsers when a section is found more than once\n    in a single input file, string or dictionary.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "[")
(ID "repr")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(PUNCT ",")
(LIT " already exists")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "source")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "message")
(PUNCT "=")
(PUNCT "[")
(LIT "While reading from ")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "lineno")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "message")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT " [line {0:2d}]")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "lineno")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "message")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT ": section ")
(PUNCT ")")
(NEWLINE)
(ID "message")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "msg")
(PUNCT "=")
(ID "message")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "Section ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "section")
(PUNCT "=")
(ID "section")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "source")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "DuplicateOptionError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised by strict parsers when an option is repeated in an input source.\n\n    Current implementation raises this exception only when an option is found\n    more than once in a single file, string or dictionary.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "lineno")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "[")
(ID "repr")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(PUNCT ",")
(LIT " in section ")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(PUNCT ",")
(LIT " already exists")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "source")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "message")
(PUNCT "=")
(PUNCT "[")
(LIT "While reading from ")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "source")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "lineno")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "message")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT " [line {0:2d}]")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "lineno")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "message")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT ": option ")
(PUNCT ")")
(NEWLINE)
(ID "message")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "msg")
(PUNCT "=")
(ID "message")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 0)
(PUNCT ",")
(LIT "Option ")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "section")
(PUNCT "=")
(ID "section")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "option")
(PUNCT "=")
(ID "option")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "source")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "source")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "NoOptionError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A requested option was not found.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "No option %r in section: %r")
(PUNCT "%")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "option")
(PUNCT "=")
(ID "option")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "section")
(PUNCT "=")
(ID "section")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "InterpolationError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for interpolation-related exceptions.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "option")
(PUNCT "=")
(ID "option")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "section")
(PUNCT "=")
(ID "section")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "InterpolationMissingOptionError")
(PUNCT "(")
(ID "InterpolationError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A string substitution required a setting which was not available.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rawval")
(PUNCT ",")
(ID "reference")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "(")
(LIT "Bad value substitution:\n")
(LIT "\tsection: [%s]\n")
(LIT "\toption : %s\n")
(LIT "\tkey    : %s\n")
(LIT "\trawval : %s\n")
(PUNCT "%")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "reference")
(PUNCT ",")
(ID "rawval")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "InterpolationError")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "reference")
(PUNCT "=")
(ID "reference")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rawval")
(PUNCT ",")
(ID "reference")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "InterpolationSyntaxError")
(PUNCT "(")
(ID "InterpolationError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when the source text contains invalid syntax.\n\n    Current implementation raises this exception when the source text into\n    which substitutions are made does not conform to the required syntax.\n    ")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "InterpolationDepthError")
(PUNCT "(")
(ID "InterpolationError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when substitutions are nested too deeply.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rawval")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "(")
(LIT "Value interpolation too deeply recursive:\n")
(LIT "\tsection: [%s]\n")
(LIT "\toption : %s\n")
(LIT "\trawval : %s\n")
(PUNCT "%")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "rawval")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "InterpolationError")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rawval")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ParsingError")
(PUNCT "(")
(ID "Error")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when a configuration file does not follow legal syntax.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "filename")
(KEYWORD and)
(ID "source")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot specify both `filename' and `source'. ")
(LIT "Use `source'.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "filename")
(KEYWORD and)
(KEYWORD not)
(ID "source")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Required argument `source' not given.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "filename")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(DEDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "Source contains parsing errors: %r")
(PUNCT "%")
(ID "source")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "source")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "source")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "filename")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deprecated, use `source'.")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The 'filename' attribute will be removed in future versions.  ")
(LIT "Use 'source' instead.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "source")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "filename")
(PUNCT ".")
(ID "setter")
(NEWLINE)
(KEYWORD def)
(ID "filename")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deprecated, user `source'.")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The 'filename' attribute will be removed in future versions.  ")
(LIT "Use 'source' instead.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "append")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "errors")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "message")
(PUNCT "+=")
(LIT "\n\t[line %2d]: %s")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "MissingSectionHeaderError")
(PUNCT "(")
(ID "ParsingError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raised when a key-value pair is found before any section header.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "Error")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(LIT "File contains no section headers.\nfile: %r, line: %d\n%r")
(PUNCT "%")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "source")
(PUNCT "=")
(ID "filename")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT "=")
(ID "lineno")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "line")
(PUNCT "=")
(ID "line")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "args")
(PUNCT "=")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_UNSET")
(PUNCT "=")
(ID "object")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "Interpolation")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Dummy interpolation that passes the value through with no changes.")
(NEWLINE)
(KEYWORD def)
(ID "before_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "defaults")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "before_set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "before_read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "before_write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BasicInterpolation")
(PUNCT "(")
(ID "Interpolation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Interpolation as implemented in the classic ConfigParser.\n\n    The option values can contain format strings which refer to other values in\n    the same section, or values in the special default section.\n\n    For example:\n\n        something: %(dir)s/whatever\n\n    would resolve the \"%(dir)s\" to the value of dir.  All reference\n    expansions are done late, on demand. If a user needs to use a bare % in\n    a configuration file, she can escape it by writing %%. Other % usage\n    is considered a user error and raises `InterpolationSyntaxError'.")
(NEWLINE)
(ID "_KEYCRE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "%\\(([^)]+)\\)s")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "before_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "defaults")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "L")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_interpolate_some")
(PUNCT "(")
(ID "parser")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "L")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "defaults")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "L")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "before_set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tmp_value")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "%%")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "tmp_value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_KEYCRE")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(ID "tmp_value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "%")
(KEYWORD in)
(ID "tmp_value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid interpolation syntax in %r at ")
(LIT "position %d")
(PUNCT "%")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "tmp_value")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "%")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_interpolate_some")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "accum")
(PUNCT ",")
(ID "rest")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "map")
(PUNCT ",")
(ID "depth")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "depth")
(PUNCT ">")
(ID "MAX_INTERPOLATION_DEPTH")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationDepthError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "rest")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "p")
(PUNCT "=")
(ID "rest")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "%")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "p")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "p")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "rest")
(PUNCT "[")
(PUNCT ":")
(ID "p")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(ID "p")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT "%")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "%")
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "c")
(PUNCT "==")
(LIT "(")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_KEYCRE")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationSyntaxError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(LIT "bad interpolation variable reference %r")
(PUNCT "%")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "var")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "v")
(PUNCT "=")
(ID "map")
(PUNCT "[")
(ID "var")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationMissingOptionError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rest")
(PUNCT ",")
(ID "var")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "%")
(KEYWORD in)
(ID "v")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_interpolate_some")
(PUNCT "(")
(ID "parser")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "accum")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "map")
(PUNCT ",")
(ID "depth")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationSyntaxError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(LIT "'%%' must be followed by '%%' or '(', ")
(LIT "found: %r")
(PUNCT "%")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ExtendedInterpolation")
(PUNCT "(")
(ID "Interpolation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Advanced variant of interpolation, supports the syntax used by\n    `zc.buildout'. Enables interpolation between sections.")
(NEWLINE)
(ID "_KEYCRE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\\$\\{([^}]+)\\}")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "before_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "defaults")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "L")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_interpolate_some")
(PUNCT "(")
(ID "parser")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "L")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "defaults")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "L")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "before_set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "tmp_value")
(PUNCT "=")
(ID "value")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "$$")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "tmp_value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_KEYCRE")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "")
(PUNCT ",")
(ID "tmp_value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "$")
(KEYWORD in)
(ID "tmp_value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid interpolation syntax in %r at ")
(LIT "position %d")
(PUNCT "%")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "tmp_value")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "$")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_interpolate_some")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "accum")
(PUNCT ",")
(ID "rest")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "map")
(PUNCT ",")
(ID "depth")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "depth")
(PUNCT ">")
(ID "MAX_INTERPOLATION_DEPTH")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationDepthError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "rest")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "p")
(PUNCT "=")
(ID "rest")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT "$")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "p")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "p")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "rest")
(PUNCT "[")
(PUNCT ":")
(ID "p")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(ID "p")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "c")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(LIT 2)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(LIT "$")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "$")
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "c")
(PUNCT "==")
(LIT "{")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_KEYCRE")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationSyntaxError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(LIT "bad interpolation variable reference %r")
(PUNCT "%")
(ID "rest")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "path")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT ":")
(PUNCT ")")
(NEWLINE)
(ID "rest")
(PUNCT "=")
(ID "rest")
(PUNCT "[")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "sect")
(PUNCT "=")
(ID "section")
(NEWLINE)
(ID "opt")
(PUNCT "=")
(ID "option")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opt")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "path")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "v")
(PUNCT "=")
(ID "map")
(PUNCT "[")
(ID "opt")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sect")
(PUNCT "=")
(ID "path")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "opt")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "path")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "v")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "sect")
(PUNCT ",")
(ID "opt")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationSyntaxError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(LIT "More than one ':' found: %r")
(PUNCT "%")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "KeyError")
(PUNCT ",")
(ID "NoSectionError")
(PUNCT ",")
(ID "NoOptionError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationMissingOptionError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rest")
(PUNCT ",")
(LIT ":")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "path")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "$")
(KEYWORD in)
(ID "v")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_interpolate_some")
(PUNCT "(")
(ID "parser")
(PUNCT ",")
(ID "opt")
(PUNCT ",")
(ID "accum")
(PUNCT ",")
(ID "v")
(PUNCT ",")
(ID "sect")
(PUNCT ",")
(ID "dict")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(ID "sect")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "depth")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "accum")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "v")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationSyntaxError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(LIT "'$' must be followed by '$' or '{', ")
(LIT "found: %r")
(PUNCT "%")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "LegacyInterpolation")
(PUNCT "(")
(ID "Interpolation")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deprecated interpolation used in old versions of ConfigParser.\n    Use BasicInterpolation or ExtendedInterpolation instead.")
(NEWLINE)
(ID "_KEYCRE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "%\\(([^)]*)\\)s|.")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "before_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "vars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "rawval")
(PUNCT "=")
(ID "value")
(NEWLINE)
(ID "depth")
(PUNCT "=")
(ID "MAX_INTERPOLATION_DEPTH")
(NEWLINE)
(KEYWORD while)
(ID "depth")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "depth")
(PUNCT "-=")
(LIT 1)
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD and)
(LIT "%(")
(KEYWORD in)
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "replace")
(PUNCT "=")
(ID "functools")
(PUNCT ".")
(ID "partial")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_interpolation_replace")
(PUNCT ",")
(ID "parser")
(PUNCT "=")
(ID "parser")
(PUNCT ")")
(NEWLINE)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_KEYCRE")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(ID "replace")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "value")
(PUNCT "%")
(ID "vars")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(KEYWORD as)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationMissingOptionError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rawval")
(PUNCT ",")
(ID "e")
(PUNCT ".")
(ID "args")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "value")
(KEYWORD and)
(LIT "%(")
(KEYWORD in)
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "InterpolationDepthError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "rawval")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "before_set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "staticmethod")
(NEWLINE)
(KEYWORD def)
(ID "_interpolation_replace")
(PUNCT "(")
(ID "match")
(PUNCT ",")
(ID "parser")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%%(%s)s")
(PUNCT "%")
(ID "parser")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "RawConfigParser")
(PUNCT "(")
(ID "MutableMapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "ConfigParser that does not do interpolation.")
(NEWLINE)
(ID "_SECT_TMPL")
(PUNCT "=")
(LIT "\n        \\[                                 # [\n        (?P<header>[^]]+)                  # very permissive!\n        \\]                                 # ]\n        ")
(NEWLINE)
(ID "_OPT_TMPL")
(PUNCT "=")
(LIT "\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?P<vi>{delim})\\s*              # any number of space/tab,\n                                           # followed by any of the\n                                           # allowed delimiters,\n                                           # followed by any space/tab\n        (?P<value>.*)$                     # everything up to eol\n        ")
(NEWLINE)
(ID "_OPT_NV_TMPL")
(PUNCT "=")
(LIT "\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P<vi>{delim})\\s*                 # optionally followed by\n                                           # any of the allowed\n                                           # delimiters, followed by any\n                                           # space/tab\n        (?P<value>.*))?$                   # everything up to eol\n        ")
(NEWLINE)
(ID "_DEFAULT_INTERPOLATION")
(PUNCT "=")
(ID "Interpolation")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "SECTCRE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "_SECT_TMPL")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT ")")
(NEWLINE)
(ID "OPTCRE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "_OPT_TMPL")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "delim")
(PUNCT "=")
(LIT "=|:")
(PUNCT ")")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT ")")
(NEWLINE)
(ID "OPTCRE_NV")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "_OPT_NV_TMPL")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "delim")
(PUNCT "=")
(LIT "=|:")
(PUNCT ")")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT ")")
(NEWLINE)
(ID "NONSPACECRE")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\\S")
(PUNCT ")")
(NEWLINE)
(ID "BOOLEAN_STATES")
(PUNCT "=")
(PUNCT "{")
(LIT "1")
(PUNCT ":")
(KEYWORD True)
(PUNCT ",")
(LIT "yes")
(PUNCT ":")
(KEYWORD True)
(PUNCT ",")
(LIT "true")
(PUNCT ":")
(KEYWORD True)
(PUNCT ",")
(LIT "on")
(PUNCT ":")
(KEYWORD True)
(PUNCT ",")
(LIT "0")
(PUNCT ":")
(KEYWORD False)
(PUNCT ",")
(LIT "no")
(PUNCT ":")
(KEYWORD False)
(PUNCT ",")
(LIT "false")
(PUNCT ":")
(KEYWORD False)
(PUNCT ",")
(LIT "off")
(PUNCT ":")
(KEYWORD False)
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "defaults")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "dict_type")
(PUNCT "=")
(ID "_default_dict")
(PUNCT ",")
(ID "allow_no_value")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "delimiters")
(PUNCT "=")
(PUNCT "(")
(LIT "=")
(PUNCT ",")
(LIT ":")
(PUNCT ")")
(PUNCT ",")
(ID "comment_prefixes")
(PUNCT "=")
(PUNCT "(")
(LIT "#")
(PUNCT ",")
(LIT ";")
(PUNCT ")")
(PUNCT ",")
(ID "inline_comment_prefixes")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "strict")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "empty_lines_in_values")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "default_section")
(PUNCT "=")
(ID "DEFAULTSECT")
(PUNCT ",")
(ID "interpolation")
(PUNCT "=")
(ID "_UNSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_dict")
(PUNCT "=")
(ID "dict_type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_proxies")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_proxies")
(PUNCT "[")
(ID "default_section")
(PUNCT "]")
(PUNCT "=")
(ID "SectionProxy")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "default_section")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "defaults")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "defaults")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_delimiters")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "delimiters")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "delimiters")
(PUNCT "==")
(PUNCT "(")
(LIT "=")
(PUNCT ",")
(LIT ":")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_optcre")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "OPTCRE_NV")
(KEYWORD if)
(ID "allow_no_value")
(KEYWORD else)
(ID "self")
(PUNCT ".")
(ID "OPTCRE")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT "=")
(LIT "|")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "re")
(PUNCT ".")
(ID "escape")
(PUNCT "(")
(ID "d")
(PUNCT ")")
(KEYWORD for)
(ID "d")
(KEYWORD in)
(ID "delimiters")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "allow_no_value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_optcre")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_OPT_NV_TMPL")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "delim")
(PUNCT "=")
(ID "d")
(PUNCT ")")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_optcre")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_OPT_TMPL")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "delim")
(PUNCT "=")
(ID "d")
(PUNCT ")")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "VERBOSE")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_comment_prefixes")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "comment_prefixes")
(KEYWORD or)
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_inline_comment_prefixes")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "inline_comment_prefixes")
(KEYWORD or)
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_strict")
(PUNCT "=")
(ID "strict")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_allow_no_value")
(PUNCT "=")
(ID "allow_no_value")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_empty_lines_in_values")
(PUNCT "=")
(ID "empty_lines_in_values")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT "=")
(ID "default_section")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT "=")
(ID "interpolation")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_DEFAULT_INTERPOLATION")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT "=")
(ID "Interpolation")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "defaults")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "sections")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of section names, excluding [DEFAULT]")
(NEWLINE)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_section")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a new section in the configuration.\n\n        Raise DuplicateSectionError if a section by the specified name\n        already exists. Raise ValueError if name is DEFAULT.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "section")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid section name: %r")
(PUNCT "%")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "section")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DuplicateSectionError")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_proxies")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(PUNCT "=")
(ID "SectionProxy")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "has_section")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Indicate whether the named section is present in the configuration.\n\n        The DEFAULT section is not acknowledged.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "section")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "options")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of option names for the given section name.")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opts")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NoSectionError")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "opts")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "list")
(PUNCT "(")
(ID "opts")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filenames")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read and parse a filename or a list of filenames.\n\n        Files that cannot be opened are silently ignored; this is\n        designed so that you can specify a list of potential\n        configuration file locations (e.g. current directory, user's\n        home directory, systemwide directory), and all existing\n        configuration files in the list will be read.  A single\n        filename may also be given.\n\n        Return list of successfully read files.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "filenames")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filenames")
(PUNCT "=")
(PUNCT "[")
(ID "filenames")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "read_ok")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "filename")
(KEYWORD in)
(ID "filenames")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD with)
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(KEYWORD as)
(ID "fp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_read")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "read_ok")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "read_ok")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_file")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "f")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Like read() but the argument must be a file-like object.\n\n        The `f' argument must be iterable, returning one line at a time.\n        Optional second argument is the `source' specifying the name of the\n        file being read. If not given, it is taken from f.name. If `f' has no\n        `name' attribute, `<???>' is used.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "source")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "AttributeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "source")
(PUNCT "=")
(LIT "<???>")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_read")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "source")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_string")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "string")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(LIT "<string>")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read configuration from a given string.")
(NEWLINE)
(ID "sfile")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "StringIO")
(PUNCT "(")
(ID "string")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "read_file")
(PUNCT "(")
(ID "sfile")
(PUNCT ",")
(ID "source")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_dict")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "dictionary")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(LIT "<dict>")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Read configuration from a dictionary.\n\n        Keys are section names, values are dictionaries with keys and values\n        that should be present in the section. If the used dictionary type\n        preserves order, sections and their keys will be added in order.\n\n        All types held in the dictionary are converted to strings during\n        reading, including section names, option names and keys.\n\n        Optional second argument is the `source' specifying the name of the\n        dictionary being read.\n        ")
(NEWLINE)
(ID "elements_added")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "section")
(PUNCT ",")
(ID "keys")
(KEYWORD in)
(ID "dictionary")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "section")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "add_section")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "DuplicateSectionError")
(PUNCT ",")
(ID "ValueError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_strict")
(KEYWORD and)
(ID "section")
(KEYWORD in)
(ID "elements_added")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "elements_added")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "keys")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "key")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_strict")
(KEYWORD and)
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(KEYWORD in)
(ID "elements_added")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DuplicateOptionError")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "source")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "elements_added")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "readfp")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fp")
(PUNCT ",")
(ID "filename")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Deprecated, use read_file instead.")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "This method will be removed in future versions.  ")
(LIT "Use 'parser.read_file()' instead.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "read_file")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "source")
(PUNCT "=")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "_UNSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Get an option value for a given section.\n\n        If `vars' is provided, it must be a dictionary. The option is looked up\n        in `vars' (if provided), `section', and in `DEFAULTSECT' in that order.\n        If the key is not found and `fallback' is provided, it is used as\n        a fallback value. `None' can be provided as a `fallback' value.\n\n        If interpolation is enabled and the optional argument `raw' is False,\n        all interpolations are expanded in the return values.\n\n        Arguments `raw', `vars', and `fallback' are keyword only.\n\n        The section DEFAULT is special.\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_unify_values")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "vars")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "NoSectionError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fallback")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "option")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "d")
(PUNCT "[")
(ID "option")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fallback")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NoOptionError")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "raw")
(KEYWORD or)
(ID "value")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT ".")
(ID "before_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "conv")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "conv")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getint")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "_UNSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "int")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "NoSectionError")
(PUNCT ",")
(ID "NoOptionError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fallback")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getfloat")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "_UNSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "float")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "NoSectionError")
(PUNCT ",")
(ID "NoOptionError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fallback")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "getboolean")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "_UNSET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_get")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_convert_to_boolean")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(PUNCT "(")
(ID "NoSectionError")
(PUNCT ",")
(ID "NoOptionError")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "fallback")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "fallback")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "items")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT "=")
(ID "_UNSET")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a list of (name, value) tuples for each option in a section.\n\n        All % interpolations are expanded in the return values, based on the\n        defaults passed into the constructor, unless the optional argument\n        `raw' is true.  Additional substitutions may be provided using the\n        `vars' argument, which must be a dictionary whose contents overrides\n        any pre-existing defaults.\n\n        The section DEFAULT is special.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "section")
(KEYWORD is)
(ID "_UNSET")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "d")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "section")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NoSectionError")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "vars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "vars")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "value_getter")
(PUNCT "=")
(KEYWORD lambda)
(ID "option")
(PUNCT ":")
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT ".")
(ID "before_get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "d")
(PUNCT "[")
(ID "option")
(PUNCT "]")
(PUNCT ",")
(ID "d")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "raw")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value_getter")
(PUNCT "=")
(KEYWORD lambda)
(ID "option")
(PUNCT ":")
(ID "d")
(PUNCT "[")
(ID "option")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "[")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "value_getter")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(PUNCT ")")
(KEYWORD for)
(ID "option")
(KEYWORD in)
(ID "d")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "popitem")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove a section from the parser and return it as\n        a (section_name, section_proxy) tuple. If no section is present, raise\n        KeyError.\n\n        The section DEFAULT is never returned because it cannot be removed.\n        ")
(NEWLINE)
(KEYWORD for)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "sections")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "key")
(PUNCT ",")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "KeyError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "optionxform")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "optionstr")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "optionstr")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "has_option")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Check for the existence of a given option in a given section.\n        If the specified `section' is None or an empty string, DEFAULT is\n        assumed. If the specified `section' does not exist, returns False.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "section")
(KEYWORD or)
(ID "section")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "option")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "option")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "section")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "option")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "option")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(KEYWORD or)
(ID "option")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set an option.")
(NEWLINE)
(KEYWORD if)
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT ".")
(ID "before_set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "section")
(KEYWORD or)
(ID "section")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sectdict")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sectdict")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NoSectionError")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "sectdict")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fp")
(PUNCT ",")
(ID "space_around_delimiters")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write an .ini-format representation of the configuration state.\n\n        If `space_around_delimiters' is True (the default), delimiters\n        between keys and values are surrounded by spaces.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "space_around_delimiters")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT "=")
(LIT " {} ")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_delimiters")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "d")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_delimiters")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_write_section")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "section")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_write_section")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "d")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_write_section")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fp")
(PUNCT ",")
(ID "section_name")
(PUNCT ",")
(ID "section_items")
(PUNCT ",")
(ID "delimiter")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Write a single section to the specified `fp'.")
(NEWLINE)
(ID "fp")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "[{}]\n")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "section_name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "section_items")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT ".")
(ID "before_write")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section_name")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD or)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_allow_no_value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "delimiter")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(LIT "\n\t")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(LIT "")
(NEWLINE)
(DEDENT)
(ID "fp")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "{}{}\n")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "fp")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remove_option")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove an option.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "section")
(KEYWORD or)
(ID "section")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sectdict")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sectdict")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NoSectionError")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "option")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "option")
(PUNCT ")")
(NEWLINE)
(ID "existed")
(PUNCT "=")
(ID "option")
(KEYWORD in)
(ID "sectdict")
(NEWLINE)
(KEYWORD if)
(ID "existed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "sectdict")
(PUNCT "[")
(ID "option")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "existed")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remove_section")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Remove a file section.")
(NEWLINE)
(ID "existed")
(PUNCT "=")
(ID "section")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(NEWLINE)
(KEYWORD if)
(ID "existed")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "_proxies")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "existed")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "default_section")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "has_section")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_proxies")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "key")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "key")
(PUNCT "]")
(PUNCT ".")
(ID "clear")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "read_dict")
(PUNCT "(")
(PUNCT "{")
(ID "key")
(PUNCT ":")
(ID "value")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "key")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Cannot remove the default section.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "has_section")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "remove_section")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "key")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(KEYWORD or)
(ID "self")
(PUNCT ".")
(ID "has_section")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ")")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "itertools")
(PUNCT ".")
(ID "chain")
(PUNCT "(")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ",")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ".")
(ID "keys")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "fp")
(PUNCT ",")
(ID "fpname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse a sectioned configuration file.\n\n        Each section in a configuration file contains a header, indicated by\n        a name in square brackets (`[]'), plus key/value options, indicated by\n        `name' and `value' delimited with a specific substring (`=' or `:' by\n        default).\n\n        Values can span multiple lines, as long as they are indented deeper\n        than the first line of the value. Depending on the parser's mode, blank\n        lines may be treated as parts of multiline values or ignored.\n\n        Configuration files may include comments, prefixed by specific\n        characters (`#' and `;' by default). Comments may appear on their own\n        in an otherwise empty line or may be entered in lines holding values or\n        section names.\n        ")
(NEWLINE)
(ID "elements_added")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cursect")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "sectname")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "optname")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "indent_level")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "e")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "lineno")
(PUNCT ",")
(ID "line")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "fp")
(PUNCT ",")
(ID "start")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "comment_start")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(NEWLINE)
(ID "inline_prefixes")
(PUNCT "=")
(PUNCT "{")
(ID "p")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(KEYWORD for)
(ID "p")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_inline_comment_prefixes")
(PUNCT "}")
(NEWLINE)
(KEYWORD while)
(ID "comment_start")
(PUNCT "==")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(KEYWORD and)
(ID "inline_prefixes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "next_prefixes")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "prefix")
(PUNCT ",")
(ID "index")
(KEYWORD in)
(ID "inline_prefixes")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "index")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "prefix")
(PUNCT ",")
(ID "index")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "index")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "next_prefixes")
(PUNCT "[")
(ID "prefix")
(PUNCT "]")
(PUNCT "=")
(ID "index")
(NEWLINE)
(KEYWORD if)
(ID "index")
(PUNCT "==")
(LIT 0)
(KEYWORD or)
(PUNCT "(")
(ID "index")
(PUNCT ">")
(LIT 0)
(KEYWORD and)
(ID "line")
(PUNCT "[")
(ID "index")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ".")
(ID "isspace")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "comment_start")
(PUNCT "=")
(ID "min")
(PUNCT "(")
(ID "comment_start")
(PUNCT ",")
(ID "index")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "inline_prefixes")
(PUNCT "=")
(ID "next_prefixes")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "prefix")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_comment_prefixes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "comment_start")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "comment_start")
(PUNCT "==")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "comment_start")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(ID "value")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(ID "comment_start")
(PUNCT "]")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_empty_lines_in_values")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(PUNCT "(")
(ID "comment_start")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "cursect")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "optname")
(KEYWORD and)
(ID "cursect")
(PUNCT "[")
(ID "optname")
(PUNCT "]")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cursect")
(PUNCT "[")
(ID "optname")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indent_level")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(NEWLINE)
(DEDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "first_nonspace")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "NONSPACECRE")
(PUNCT ".")
(ID "search")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "cur_indent_level")
(PUNCT "=")
(ID "first_nonspace")
(PUNCT ".")
(ID "start")
(PUNCT "(")
(PUNCT ")")
(KEYWORD if)
(ID "first_nonspace")
(KEYWORD else)
(LIT 0)
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "cursect")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "optname")
(KEYWORD and)
(ID "cur_indent_level")
(PUNCT ">")
(ID "indent_level")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cursect")
(PUNCT "[")
(ID "optname")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "indent_level")
(PUNCT "=")
(ID "cur_indent_level")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "SECTCRE")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "mo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sectname")
(PUNCT "=")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "header")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "sectname")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_strict")
(KEYWORD and)
(ID "sectname")
(KEYWORD in)
(ID "elements_added")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DuplicateSectionError")
(PUNCT "(")
(ID "sectname")
(PUNCT ",")
(ID "fpname")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "cursect")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "sectname")
(PUNCT "]")
(NEWLINE)
(ID "elements_added")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "sectname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "sectname")
(PUNCT "==")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cursect")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cursect")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_dict")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "sectname")
(PUNCT "]")
(PUNCT "=")
(ID "cursect")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_proxies")
(PUNCT "[")
(ID "sectname")
(PUNCT "]")
(PUNCT "=")
(ID "SectionProxy")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "sectname")
(PUNCT ")")
(NEWLINE)
(ID "elements_added")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "sectname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "optname")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "cursect")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "MissingSectionHeaderError")
(PUNCT "(")
(ID "fpname")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mo")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_optcre")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "mo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "optname")
(PUNCT ",")
(ID "vi")
(PUNCT ",")
(ID "optval")
(PUNCT "=")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT "option")
(PUNCT ",")
(LIT "vi")
(PUNCT ",")
(LIT "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "optname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "e")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_handle_error")
(PUNCT "(")
(ID "e")
(PUNCT ",")
(ID "fpname")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "optname")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "optname")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_strict")
(KEYWORD and)
(PUNCT "(")
(ID "sectname")
(PUNCT ",")
(ID "optname")
(PUNCT ")")
(KEYWORD in)
(ID "elements_added")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DuplicateOptionError")
(PUNCT "(")
(ID "sectname")
(PUNCT ",")
(ID "optname")
(PUNCT ",")
(ID "fpname")
(PUNCT ",")
(ID "lineno")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "elements_added")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(PUNCT "(")
(ID "sectname")
(PUNCT ",")
(ID "optname")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "optval")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "optval")
(PUNCT "=")
(ID "optval")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "cursect")
(PUNCT "[")
(ID "optname")
(PUNCT "]")
(PUNCT "=")
(PUNCT "[")
(ID "optval")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cursect")
(PUNCT "[")
(ID "optname")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "e")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_handle_error")
(PUNCT "(")
(ID "e")
(PUNCT ",")
(ID "fpname")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "e")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "e")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_join_multiline_values")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_join_multiline_values")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "defaults")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(NEWLINE)
(ID "all_sections")
(PUNCT "=")
(ID "itertools")
(PUNCT ".")
(ID "chain")
(PUNCT "(")
(PUNCT "(")
(ID "defaults")
(PUNCT ",")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "section")
(PUNCT ",")
(ID "options")
(KEYWORD in)
(ID "all_sections")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "options")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "val")
(PUNCT "=")
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(PUNCT ".")
(ID "rstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "options")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_interpolation")
(PUNCT ".")
(ID "before_read")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "val")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_handle_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "exc")
(PUNCT ",")
(ID "fpname")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "exc")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "exc")
(PUNCT "=")
(ID "ParsingError")
(PUNCT "(")
(ID "fpname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "exc")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "exc")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_unify_values")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "vars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a sequence of lookups with 'vars' taking priority over\n        the 'section' which takes priority over the DEFAULTSECT.\n\n        ")
(NEWLINE)
(ID "sectiondict")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sectiondict")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_sections")
(PUNCT "[")
(ID "section")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "section")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "NoSectionError")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "vardict")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "vars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "key")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "vars")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "vardict")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "optionxform")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "_ChainMap")
(PUNCT "(")
(ID "vardict")
(PUNCT ",")
(ID "sectiondict")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_defaults")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_convert_to_boolean")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a boolean value translating from other types if necessary.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "value")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "BOOLEAN_STATES")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Not a boolean: %s")
(PUNCT "%")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "BOOLEAN_STATES")
(PUNCT "[")
(ID "value")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_validate_value_types")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "section")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "option")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(LIT "")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Raises a TypeError for non-string values.\n\n        The only legal non-string value if we allow valueless\n        options is None, so we need to check if the value is a\n        string if:\n        - we do not allow valueless options, or\n        - we allow valueless options but the value is not None\n\n        For compatibility reasons this method is not used in classic set()\n        for RawConfigParsers. It is invoked in every case for mapping protocol\n        access and in ConfigParser.set().\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "section names must be strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "option")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "option keys must be strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_allow_no_value")
(KEYWORD or)
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "option values must be strings")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ConfigParser")
(PUNCT "(")
(ID "RawConfigParser")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "ConfigParser implementing interpolation.")
(NEWLINE)
(ID "_DEFAULT_INTERPOLATION")
(PUNCT "=")
(ID "BasicInterpolation")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Set an option.  Extends RawConfigParser.set by validating type and\n        interpolation syntax on the value.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_validate_value_types")
(PUNCT "(")
(ID "option")
(PUNCT "=")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(ID "section")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "add_section")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "section")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a new section in the configuration.  Extends\n        RawConfigParser.add_section by validating if the section name is\n        a string.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_validate_value_types")
(PUNCT "(")
(ID "section")
(PUNCT "=")
(ID "section")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "add_section")
(PUNCT "(")
(ID "section")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "SafeConfigParser")
(PUNCT "(")
(ID "ConfigParser")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "ConfigParser alias for backwards compatibility purposes.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__init__")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwargs")
(PUNCT ")")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "The SafeConfigParser class has been renamed to ConfigParser ")
(LIT "in Python 3.2. This alias will be removed in future versions.")
(LIT " Use ConfigParser directly instead.")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(ID "stacklevel")
(PUNCT "=")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "SectionProxy")
(PUNCT "(")
(ID "MutableMapping")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A proxy for a single section from a parser.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "parser")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Creates a view on a section of the specified `name` in `parser`.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT "=")
(ID "parser")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<Section: {}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "has_option")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__setitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "_validate_value_types")
(PUNCT "(")
(ID "option")
(PUNCT "=")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "key")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__delitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "has_option")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "remove_option")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "KeyError")
(PUNCT "(")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__contains__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "has_option")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "key")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__len__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_options")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_options")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "__iter__")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_options")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "default_section")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "options")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "defaults")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "fallback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getint")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "getint")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "fallback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getfloat")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "getfloat")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "fallback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "getboolean")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(PUNCT ".")
(ID "getboolean")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT ",")
(ID "option")
(PUNCT ",")
(ID "raw")
(PUNCT "=")
(ID "raw")
(PUNCT ",")
(ID "vars")
(PUNCT "=")
(ID "vars")
(PUNCT ",")
(ID "fallback")
(PUNCT "=")
(ID "fallback")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "parser")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_parser")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_name")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
