(LIT "Representing and manipulating email headers via custom objects.\n\nThis module provides an implementation of the HeaderRegistry API.\nThe implementation is designed to flexibly follow RFC5322 rules.\n\nEventually HeaderRegistry will be a public API, but it isn't yet,\nand will probably change some before that happens.\n\n")
(NEWLINE)
(KEYWORD from)
(ID "types")
(KEYWORD import)
(ID "MappingProxyType")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "utils")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "errors")
(NEWLINE)
(KEYWORD from)
(ID "email")
(KEYWORD import)
(ID "_header_value_parser")
(KEYWORD as)
(ID "parser")
(NEWLINE)
(KEYWORD class)
(ID "Address")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "display_name")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "username")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "domain")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "addr_spec")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create an object represeting a full email address.\n\n        An address can have a 'display_name', a 'username', and a 'domain'.  In\n        addition to specifying the username and domain separately, they may be\n        specified together by using the addr_spec keyword *instead of* the\n        username and domain keywords.  If an addr_spec string is specified it\n        must be properly quoted according to RFC 5322 rules; an error will be\n        raised if it is not.\n\n        An Address object has display_name, username, domain, and addr_spec\n        attributes, all of which are read-only.  The addr_spec and the string\n        value of the object are both quoted according to RFC5322 rules, but\n        without any Content Transfer Encoding.\n\n        ")
(NEWLINE)
(KEYWORD if)
(ID "addr_spec")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "username")
(KEYWORD or)
(ID "domain")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "TypeError")
(PUNCT "(")
(LIT "addrspec specified when username and/or ")
(LIT "domain also specified")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "a_s")
(PUNCT ",")
(ID "rest")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "get_addr_spec")
(PUNCT "(")
(ID "addr_spec")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "rest")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "Invalid addr_spec; only '{}' ")
(LIT "could be parsed from '{}'")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "a_s")
(PUNCT ",")
(ID "addr_spec")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "a_s")
(PUNCT ".")
(ID "all_defects")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "a_s")
(PUNCT ".")
(ID "all_defects")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "username")
(PUNCT "=")
(ID "a_s")
(PUNCT ".")
(ID "local_part")
(NEWLINE)
(ID "domain")
(PUNCT "=")
(ID "a_s")
(PUNCT ".")
(ID "domain")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_display_name")
(PUNCT "=")
(ID "display_name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_username")
(PUNCT "=")
(ID "username")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_domain")
(PUNCT "=")
(ID "domain")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "display_name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_display_name")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "username")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_username")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "domain")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_domain")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "addr_spec")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "The addr_spec (username@domain) portion of the address, quoted\n        according to RFC 5322 rules, but with no Content Transfer Encoding.\n        ")
(NEWLINE)
(ID "nameset")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "username")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nameset")
(PUNCT ")")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "nameset")
(PUNCT "-")
(ID "parser")
(PUNCT ".")
(ID "DOT_ATOM_ENDS")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lp")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "quote_string")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "username")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "username")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "domain")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "lp")
(PUNCT "+")
(LIT "@")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "domain")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "lp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "<>")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "lp")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Address(display_name={!r}, username={!r}, domain={!r})")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "display_name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "username")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "domain")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nameset")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "display_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nameset")
(PUNCT ")")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "nameset")
(PUNCT "-")
(ID "parser")
(PUNCT ".")
(ID "SPECIALS")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "disp")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "quote_string")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "display_name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "disp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "display_name")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "disp")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "addr_spec")
(PUNCT "=")
(LIT "")
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "addr_spec")
(PUNCT "==")
(LIT "<>")
(KEYWORD else)
(ID "self")
(PUNCT ".")
(ID "addr_spec")
(NEWLINE)
(KEYWORD return)
(LIT "{} <{}>")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "disp")
(PUNCT ",")
(ID "addr_spec")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "addr_spec")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "!=")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "display_name")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "display_name")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "username")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "username")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "domain")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "domain")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Group")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "display_name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "addresses")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create an object representing an address group.\n\n        An address group consists of a display_name followed by colon and an\n        list of addresses (see Address) terminated by a semi-colon.  The Group\n        is created by specifying a display_name and a possibly empty list of\n        Address objects.  A Group can also be used to represent a single\n        address that is not in a group, which is convenient when manipulating\n        lists that are a combination of Groups and individual Addresses.  In\n        this case the display_name should be set to None.  In particular, the\n        string representation of a Group whose display_name is None is the same\n        as the Address object, if there is one and only one Address object in\n        the addresses list.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_display_name")
(PUNCT "=")
(ID "display_name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_addresses")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "addresses")
(PUNCT ")")
(KEYWORD if)
(ID "addresses")
(KEYWORD else)
(ID "tuple")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "display_name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_display_name")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "addresses")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_addresses")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "Group(display_name={!r}, addresses={!r}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "display_name")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "display_name")
(KEYWORD is)
(KEYWORD None)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "disp")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "display_name")
(NEWLINE)
(KEYWORD if)
(ID "disp")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "nameset")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(ID "disp")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nameset")
(PUNCT ")")
(PUNCT ">")
(ID "len")
(PUNCT "(")
(ID "nameset")
(PUNCT "-")
(ID "parser")
(PUNCT ".")
(ID "SPECIALS")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "disp")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "quote_string")
(PUNCT "(")
(ID "disp")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "adrstr")
(PUNCT "=")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "str")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT ")")
(NEWLINE)
(ID "adrstr")
(PUNCT "=")
(LIT " ")
(PUNCT "+")
(ID "adrstr")
(KEYWORD if)
(ID "adrstr")
(KEYWORD else)
(ID "adrstr")
(NEWLINE)
(KEYWORD return)
(LIT "{}:{};")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "disp")
(PUNCT ",")
(ID "adrstr")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(PUNCT "!=")
(ID "type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "display_name")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "display_name")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT "==")
(ID "other")
(PUNCT ".")
(ID "addresses")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BaseHeader")
(PUNCT "(")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Base class for message headers.\n\n    Implements generic behavior and provides tools for subclasses.\n\n    A subclass must define a classmethod named 'parse' that takes an unfolded\n    value string and a dictionary as its arguments.  The dictionary will\n    contain one key, 'defects', initialized to an empty list.  After the call\n    the dictionary must contain two additional keys: parse_tree, set to the\n    parse tree obtained from parsing the header, and 'decoded', set to the\n    string value of the idealized representation of the data from the value.\n    (That is, encoded words are decoded, and values that have canonical\n    representations are so represented.)\n\n    The defects key is intended to collect parsing defects, which the message\n    parser will subsequently dispose of as appropriate.  The parser should not,\n    insofar as practical, raise any errors.  Defects should be added to the\n    list instead.  The standard header parsers register defects for RFC\n    compliance issues, for obsolete RFC syntax, and for unrecoverable parsing\n    errors.\n\n    The parse method may add additional keys to the dictionary.  In this case\n    the subclass must define an 'init' method, which will be passed the\n    dictionary as its keyword arguments.  The method should use (usually by\n    setting them as the value of similarly named attributes) and remove all the\n    extra keys added by its parse method, and then use super to call its parent\n    class with the remaining arguments and keywords.\n\n    The subclass should also make sure that a 'max_count' attribute is defined\n    that is either None or 1. XXX: need to better define this API.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "=")
(PUNCT "{")
(LIT "defects")
(PUNCT ":")
(PUNCT "[")
(PUNCT "]")
(PUNCT "}")
(NEWLINE)
(ID "cls")
(PUNCT ".")
(ID "parse")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "utils")
(PUNCT ".")
(ID "_has_surrogates")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT "=")
(ID "str")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "parse_tree")
(PUNCT ",")
(ID "defects")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_parse_tree")
(PUNCT "=")
(ID "parse_tree")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_defects")
(PUNCT "=")
(ID "defects")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "name")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_name")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "defects")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "tuple")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_defects")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__reduce__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "(")
(ID "_reconstruct_header")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__bases__")
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ",")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "__dict__")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "_reconstruct")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fold")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(PUNCT ",")
(ID "policy")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Fold header according to policy.\n\n        The parsed representation of the header is folded according to\n        RFC5322 rules, as modified by the policy.  If the parse tree\n        contains surrogateescaped bytes, the bytes are CTE encoded using\n        the charset 'unknown-8bit\".\n\n        Any non-ASCII characters in the parse tree are CTE encoded using\n        charset utf-8. XXX: make this a policy setting.\n\n        The returned value is an ASCII-only string possibly containing linesep\n        characters, and ending with a linesep character.  The string includes\n        the header name and the ': ' separator.\n\n        ")
(NEWLINE)
(ID "header")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "Header")
(PUNCT "(")
(PUNCT "[")
(ID "parser")
(PUNCT ".")
(ID "HeaderLabel")
(PUNCT "(")
(PUNCT "[")
(ID "parser")
(PUNCT ".")
(ID "ValueTerminal")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(LIT "header-name")
(PUNCT ")")
(PUNCT ",")
(ID "parser")
(PUNCT ".")
(ID "ValueTerminal")
(PUNCT "(")
(LIT ":")
(PUNCT ",")
(LIT "header-sep")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(ID "parser")
(PUNCT ".")
(ID "CFWSList")
(PUNCT "(")
(PUNCT "[")
(ID "parser")
(PUNCT ".")
(ID "WhiteSpaceTerminal")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT "fws")
(PUNCT ")")
(PUNCT "]")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_parse_tree")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "header")
(PUNCT ".")
(ID "fold")
(PUNCT "(")
(ID "policy")
(PUNCT "=")
(ID "policy")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_reconstruct_header")
(PUNCT "(")
(ID "cls_name")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "type")
(PUNCT "(")
(ID "cls_name")
(PUNCT ",")
(ID "bases")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(PUNCT ".")
(ID "_reconstruct")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "UnstructuredHeader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "value_parser")
(PUNCT "=")
(ID "staticmethod")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "get_unstructured")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "UniqueUnstructuredHeader")
(PUNCT "(")
(ID "UnstructuredHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "DateHeader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Header whose value consists of a single timestamp.\n\n    Provides an additional attribute, datetime, which is either an aware\n    datetime using a timezone, or a naive datetime if the timezone\n    in the input string is -0000.  Also accepts a datetime as input.\n    The 'value' attribute is the normalized form of the timestamp,\n    which means it is the output of format_datetime on the datetime.\n    ")
(NEWLINE)
(ID "max_count")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "value_parser")
(PUNCT "=")
(ID "staticmethod")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "get_unstructured")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "value")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "defects")
(PUNCT "]")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "errors")
(PUNCT ".")
(ID "HeaderMissingRequiredValue")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "datetime")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "TokenList")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "parsedate_to_datetime")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "kwds")
(PUNCT "[")
(LIT "datetime")
(PUNCT "]")
(PUNCT "=")
(ID "value")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "format_datetime")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "datetime")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_datetime")
(PUNCT "=")
(ID "kw")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "datetime")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "datetime")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_datetime")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "UniqueDateHeader")
(PUNCT "(")
(ID "DateHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "AddressHeader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(PUNCT "@")
(ID "staticmethod")
(NEWLINE)
(KEYWORD def)
(ID "value_parser")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "address_list")
(PUNCT ",")
(ID "value")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "get_address_list")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(KEYWORD not)
(ID "value")
(PUNCT ",")
(LIT "this should not happen")
(NEWLINE)
(KEYWORD return)
(ID "address_list")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "address_list")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "groups")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "addr")
(KEYWORD in)
(ID "address_list")
(PUNCT ".")
(ID "addresses")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "groups")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "Group")
(PUNCT "(")
(ID "addr")
(PUNCT ".")
(ID "display_name")
(PUNCT ",")
(PUNCT "[")
(ID "Address")
(PUNCT "(")
(ID "mb")
(PUNCT ".")
(ID "display_name")
(KEYWORD or)
(LIT "")
(PUNCT ",")
(ID "mb")
(PUNCT ".")
(ID "local_part")
(KEYWORD or)
(LIT "")
(PUNCT ",")
(ID "mb")
(PUNCT ".")
(ID "domain")
(KEYWORD or)
(LIT "")
(PUNCT ")")
(KEYWORD for)
(ID "mb")
(KEYWORD in)
(ID "addr")
(PUNCT ".")
(ID "all_mailboxes")
(PUNCT "]")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "defects")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "address_list")
(PUNCT ".")
(ID "all_defects")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "value")
(PUNCT ",")
(LIT "__iter__")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value")
(PUNCT "=")
(PUNCT "[")
(ID "value")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "groups")
(PUNCT "=")
(PUNCT "[")
(ID "Group")
(PUNCT "(")
(KEYWORD None)
(PUNCT ",")
(PUNCT "[")
(ID "item")
(PUNCT "]")
(PUNCT ")")
(KEYWORD if)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(LIT "addresses")
(PUNCT ")")
(KEYWORD else)
(ID "item")
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "value")
(PUNCT "]")
(NEWLINE)
(ID "defects")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "kwds")
(PUNCT "[")
(LIT "groups")
(PUNCT "]")
(PUNCT "=")
(ID "groups")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "defects")
(PUNCT "]")
(PUNCT "=")
(ID "defects")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "[")
(ID "str")
(PUNCT "(")
(ID "item")
(PUNCT ")")
(KEYWORD for)
(ID "item")
(KEYWORD in)
(ID "groups")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT "parse_tree")
(KEYWORD not)
(KEYWORD in)
(ID "kwds")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_groups")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "kw")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "groups")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_addresses")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "groups")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_groups")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "addresses")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_addresses")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_addresses")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(PUNCT "[")
(ID "address")
(KEYWORD for)
(ID "group")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_groups")
(KEYWORD for)
(ID "address")
(KEYWORD in)
(ID "group")
(PUNCT ".")
(ID "addresses")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_addresses")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "UniqueAddressHeader")
(PUNCT "(")
(ID "AddressHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "SingleAddressHeader")
(PUNCT "(")
(ID "AddressHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "address")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT ")")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(PUNCT "(")
(LIT "value of single address header {} is not ")
(LIT "a single address")
(PUNCT ")")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "addresses")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "UniqueSingleAddressHeader")
(PUNCT "(")
(ID "SingleAddressHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "MIMEVersionHeader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "value_parser")
(PUNCT "=")
(ID "staticmethod")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "parse_mime_version")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "parse_tree")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "parse_tree")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "defects")
(PUNCT "]")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "parse_tree")
(PUNCT ".")
(ID "all_defects")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "major")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(KEYWORD if)
(ID "parse_tree")
(PUNCT ".")
(ID "minor")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "parse_tree")
(PUNCT ".")
(ID "major")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "minor")
(PUNCT "]")
(PUNCT "=")
(ID "parse_tree")
(PUNCT ".")
(ID "minor")
(NEWLINE)
(KEYWORD if)
(ID "parse_tree")
(PUNCT ".")
(ID "minor")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "version")
(PUNCT "]")
(PUNCT "=")
(LIT "{}.{}")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "kwds")
(PUNCT "[")
(LIT "major")
(PUNCT "]")
(PUNCT ",")
(ID "kwds")
(PUNCT "[")
(LIT "minor")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "version")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_version")
(PUNCT "=")
(ID "kw")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "version")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_major")
(PUNCT "=")
(ID "kw")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "major")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_minor")
(PUNCT "=")
(ID "kw")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "minor")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "major")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_major")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "minor")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_minor")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "version")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_version")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ParameterizedMIMEHeader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "parse_tree")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "parse_tree")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "defects")
(PUNCT "]")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "parse_tree")
(PUNCT ".")
(ID "all_defects")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "parse_tree")
(PUNCT ".")
(ID "params")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "params")
(PUNCT "]")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "params")
(PUNCT "]")
(PUNCT "=")
(PUNCT "{")
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "name")
(PUNCT ")")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "value")
(KEYWORD in)
(ID "parse_tree")
(PUNCT ".")
(ID "params")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_params")
(PUNCT "=")
(ID "kw")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(LIT "params")
(PUNCT ")")
(NEWLINE)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "params")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "MappingProxyType")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_params")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ContentTypeHeader")
(PUNCT "(")
(ID "ParameterizedMIMEHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value_parser")
(PUNCT "=")
(ID "staticmethod")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "parse_content_type_header")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_maintype")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_parse_tree")
(PUNCT ".")
(ID "maintype")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_subtype")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_parse_tree")
(PUNCT ".")
(ID "subtype")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "maintype")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_maintype")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "subtype")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_subtype")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "content_type")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "maintype")
(PUNCT "+")
(LIT "/")
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "subtype")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ContentDispositionHeader")
(PUNCT "(")
(ID "ParameterizedMIMEHeader")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "value_parser")
(PUNCT "=")
(ID "staticmethod")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "parse_content_disposition_header")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(ID "cd")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_parse_tree")
(PUNCT ".")
(ID "content_disposition")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_content_disposition")
(PUNCT "=")
(ID "cd")
(KEYWORD if)
(ID "cd")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "cd")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "content_disposition")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_content_disposition")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "ContentTransferEncodingHeader")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "max_count")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(ID "value_parser")
(PUNCT "=")
(ID "staticmethod")
(PUNCT "(")
(ID "parser")
(PUNCT ".")
(ID "parse_content_transfer_encoding_header")
(PUNCT ")")
(NEWLINE)
(PUNCT "@")
(ID "classmethod")
(NEWLINE)
(KEYWORD def)
(ID "parse")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "kwds")
(PUNCT "[")
(LIT "parse_tree")
(PUNCT "]")
(PUNCT "=")
(ID "parse_tree")
(PUNCT "=")
(ID "cls")
(PUNCT ".")
(ID "value_parser")
(PUNCT "(")
(ID "value")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "decoded")
(PUNCT "]")
(PUNCT "=")
(ID "str")
(PUNCT "(")
(ID "parse_tree")
(PUNCT ")")
(NEWLINE)
(ID "kwds")
(PUNCT "[")
(LIT "defects")
(PUNCT "]")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "parse_tree")
(PUNCT ".")
(ID "all_defects")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "init")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "super")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "init")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_cte")
(PUNCT "=")
(ID "utils")
(PUNCT ".")
(ID "_sanitize")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_parse_tree")
(PUNCT ".")
(ID "cte")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "cte")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_cte")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_default_header_map")
(PUNCT "=")
(PUNCT "{")
(LIT "subject")
(PUNCT ":")
(ID "UniqueUnstructuredHeader")
(PUNCT ",")
(LIT "date")
(PUNCT ":")
(ID "UniqueDateHeader")
(PUNCT ",")
(LIT "resent-date")
(PUNCT ":")
(ID "DateHeader")
(PUNCT ",")
(LIT "orig-date")
(PUNCT ":")
(ID "UniqueDateHeader")
(PUNCT ",")
(LIT "sender")
(PUNCT ":")
(ID "UniqueSingleAddressHeader")
(PUNCT ",")
(LIT "resent-sender")
(PUNCT ":")
(ID "SingleAddressHeader")
(PUNCT ",")
(LIT "to")
(PUNCT ":")
(ID "UniqueAddressHeader")
(PUNCT ",")
(LIT "resent-to")
(PUNCT ":")
(ID "AddressHeader")
(PUNCT ",")
(LIT "cc")
(PUNCT ":")
(ID "UniqueAddressHeader")
(PUNCT ",")
(LIT "resent-cc")
(PUNCT ":")
(ID "AddressHeader")
(PUNCT ",")
(LIT "bcc")
(PUNCT ":")
(ID "UniqueAddressHeader")
(PUNCT ",")
(LIT "resent-bcc")
(PUNCT ":")
(ID "AddressHeader")
(PUNCT ",")
(LIT "from")
(PUNCT ":")
(ID "UniqueAddressHeader")
(PUNCT ",")
(LIT "resent-from")
(PUNCT ":")
(ID "AddressHeader")
(PUNCT ",")
(LIT "reply-to")
(PUNCT ":")
(ID "UniqueAddressHeader")
(PUNCT ",")
(LIT "mime-version")
(PUNCT ":")
(ID "MIMEVersionHeader")
(PUNCT ",")
(LIT "content-type")
(PUNCT ":")
(ID "ContentTypeHeader")
(PUNCT ",")
(LIT "content-disposition")
(PUNCT ":")
(ID "ContentDispositionHeader")
(PUNCT ",")
(LIT "content-transfer-encoding")
(PUNCT ":")
(ID "ContentTransferEncodingHeader")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD class)
(ID "HeaderRegistry")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "A header_factory and header registry.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "base_class")
(PUNCT "=")
(ID "BaseHeader")
(PUNCT ",")
(ID "default_class")
(PUNCT "=")
(ID "UnstructuredHeader")
(PUNCT ",")
(ID "use_default_map")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a header_factory that works with the Policy API.\n\n        base_class is the class that will be the last class in the created\n        header class's __bases__ list.  default_class is the class that will be\n        used if \"name\" (see __call__) does not appear in the registry.\n        use_default_map controls whether or not the default mapping of names to\n        specialized classes is copied in to the registry when the factory is\n        created.  The default is True.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "registry")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "base_class")
(PUNCT "=")
(ID "base_class")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "default_class")
(PUNCT "=")
(ID "default_class")
(NEWLINE)
(KEYWORD if)
(ID "use_default_map")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "registry")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "_default_header_map")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "map_to_type")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "cls")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Register cls as the specialized class for handling \"name\" headers.\n\n        ")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "registry")
(PUNCT "[")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "cls")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cls")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "registry")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "name")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "default_class")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "type")
(PUNCT "(")
(LIT "_")
(PUNCT "+")
(ID "cls")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "base_class")
(PUNCT ")")
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__call__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create a header instance for header 'name' from 'value'.\n\n        Creates a header instance by creating a specialized class for parsing\n        and representing the specified header by combining the factory\n        base_class with a specialized class from the registry or the\n        default_class, and passing the name and value to the constructed\n        class's constructor.\n\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT "[")
(ID "name")
(PUNCT "]")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
