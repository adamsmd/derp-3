(LIT "\"Executable documentation\" for the pickle module.\n\nExtensive comments about the pickle protocols and pickle-machine opcodes\ncan be found here.  Some functions meant for external use:\n\ngenops(pickle)\n   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.\n\ndis(pickle, out=None, memo=None, indentlevel=4)\n   Print a symbolic disassembly of a pickle.\n")
(NEWLINE)
(KEYWORD import)
(ID "codecs")
(NEWLINE)
(KEYWORD import)
(ID "io")
(NEWLINE)
(KEYWORD import)
(ID "pickle")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "dis")
(PUNCT ",")
(LIT "genops")
(PUNCT ",")
(LIT "optimize")
(PUNCT "]")
(NEWLINE)
(ID "bytes_types")
(PUNCT "=")
(ID "pickle")
(PUNCT ".")
(ID "bytes_types")
(NEWLINE)
(ID "UP_TO_NEWLINE")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT "=")
(PUNCT "-")
(LIT 2)
(NEWLINE)
(ID "TAKEN_FROM_ARGUMENT4")
(PUNCT "=")
(PUNCT "-")
(LIT 3)
(NEWLINE)
(ID "TAKEN_FROM_ARGUMENT4U")
(PUNCT "=")
(PUNCT "-")
(LIT 4)
(NEWLINE)
(ID "TAKEN_FROM_ARGUMENT8U")
(PUNCT "=")
(PUNCT "-")
(LIT 5)
(NEWLINE)
(KEYWORD class)
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "name")
(PUNCT ",")
(LIT "n")
(PUNCT ",")
(LIT "reader")
(PUNCT ",")
(LIT "doc")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "n")
(PUNCT ",")
(ID "reader")
(PUNCT ",")
(ID "doc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(KEYWORD and)
(PUNCT "(")
(ID "n")
(PUNCT ">=")
(LIT 0)
(KEYWORD or)
(ID "n")
(KEYWORD in)
(PUNCT "(")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT ",")
(ID "TAKEN_FROM_ARGUMENT4")
(PUNCT ",")
(ID "TAKEN_FROM_ARGUMENT4U")
(PUNCT ",")
(ID "TAKEN_FROM_ARGUMENT8U")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "n")
(PUNCT "=")
(ID "n")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "reader")
(PUNCT "=")
(ID "reader")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "doc")
(PUNCT "=")
(ID "doc")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD from)
(ID "struct")
(KEYWORD import)
(ID "unpack")
(KEYWORD as)
(ID "_unpack")
(NEWLINE)
(KEYWORD def)
(ID "read_uint1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_uint1(io.BytesIO(b'\\xff'))\n    255\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "data")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read uint1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "uint1")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "uint1")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_uint1")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "One-byte unsigned integer.")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_uint2")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_uint2(io.BytesIO(b'\\xff\\x00'))\n    255\n    >>> read_uint2(io.BytesIO(b'\\xff\\xff'))\n    65535\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_unpack")
(PUNCT "(")
(LIT "<H")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read uint2")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "uint2")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "uint2")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_uint2")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Two-byte unsigned integer, little-endian.")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_int4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_int4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n    255\n    >>> read_int4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == -(2**31)\n    True\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_unpack")
(PUNCT "(")
(LIT "<i")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read int4")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "int4")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "int4")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_int4")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Four-byte signed integer, little-endian, 2's complement.")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_uint4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_uint4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n    255\n    >>> read_uint4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == 2**31\n    True\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 4)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_unpack")
(PUNCT "(")
(LIT "<I")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read uint4")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "uint4")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "uint4")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_uint4")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Four-byte unsigned integer, little-endian.")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_uint8")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_uint8(io.BytesIO(b'\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n    255\n    >>> read_uint8(io.BytesIO(b'\\xff' * 8)) == 2**64-1\n    True\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 8)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(LIT 8)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_unpack")
(PUNCT "(")
(LIT "<Q")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read uint8")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "uint8")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "uint8")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 8)
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_uint8")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Eight-byte unsigned integer, little-endian.")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_stringnl")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "decode")
(PUNCT "=")
(KEYWORD True)
(PUNCT ",")
(ID "stripquotes")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_stringnl(io.BytesIO(b\"'abcd'\\nefg\\n\"))\n    'abcd'\n\n    >>> read_stringnl(io.BytesIO(b\"\\n\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: no string quotes around b''\n\n    >>> read_stringnl(io.BytesIO(b\"\\n\"), stripquotes=False)\n    ''\n\n    >>> read_stringnl(io.BytesIO(b\"''\\n\"))\n    ''\n\n    >>> read_stringnl(io.BytesIO(b'\"abcd\"'))\n    Traceback (most recent call last):\n    ...\n    ValueError: no newline found when trying to read stringnl\n\n    Embedded escapes are undone in the result.\n    >>> read_stringnl(io.BytesIO(br\"'a\\n\\\\b\\x00c\\td'\" + b\"\\n'e'\"))\n    'a\\n\\\\b\\x00c\\td'\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "no newline found when trying to read stringnl")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "data")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "stripquotes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "q")
(KEYWORD in)
(PUNCT "(")
(LIT #"\"")
(PUNCT ",")
(LIT #"'")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "data")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(ID "q")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(ID "q")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "strinq quote %r not found at both ")
(LIT "ends of %r")
(PUNCT "%")
(PUNCT "(")
(ID "q")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "data")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "no string quotes around %r")
(PUNCT "%")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "decode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "codecs")
(PUNCT ".")
(ID "escape_decode")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(ID "stringnl")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "stringnl")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_stringnl")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A newline-terminated string.\n\n                   This is a repr-style string, with embedded escapes, and\n                   bracketing quotes.\n                   ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_stringnl_noescape")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "read_stringnl")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "stripquotes")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "stringnl_noescape")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "stringnl_noescape")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_stringnl_noescape")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A newline-terminated string.\n\n                        This is a str-style string, without embedded escapes,\n                        or bracketing quotes.  It should consist solely of\n                        printable ASCII characters.\n                        ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_stringnl_noescape_pair")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_stringnl_noescape_pair(io.BytesIO(b\"Queue\\nEmpty\\njunk\"))\n    'Queue Empty'\n    ")
(NEWLINE)
(KEYWORD return)
(LIT "%s %s")
(PUNCT "%")
(PUNCT "(")
(ID "read_stringnl_noescape")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ",")
(ID "read_stringnl_noescape")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "stringnl_noescape_pair")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "stringnl_noescape_pair")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_stringnl_noescape_pair")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A pair of newline-terminated strings.\n\n                             These are str-style strings, without embedded\n                             escapes, or bracketing quotes.  They should\n                             consist solely of printable ASCII characters.\n                             The pair is returned as a single string, with\n                             a single blank separating the two strings.\n                             ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_string1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_string1(io.BytesIO(b\"\\x00\"))\n    ''\n    >>> read_string1(io.BytesIO(b\"\\x03abcdef\"))\n    'abc'\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "latin-1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a string1, but only %d remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "string1")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "string1")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_string1")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted string.\n\n              The first argument is a 1-byte unsigned int giving the number\n              of bytes in the string, and the second argument is that many\n              bytes.\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_string4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\n    ''\n    >>> read_string4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\n    'abc'\n    >>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: expected 50331648 bytes in a string4, but only 6 remain\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_int4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "string4 byte count < 0: %d")
(PUNCT "%")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "latin-1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a string4, but only %d remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "string4")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "string4")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT4")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_string4")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted string.\n\n              The first argument is a 4-byte little-endian signed int giving\n              the number of bytes in the string, and the second argument is\n              that many bytes.\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_bytes1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_bytes1(io.BytesIO(b\"\\x00\"))\n    b''\n    >>> read_bytes1(io.BytesIO(b\"\\x03abcdef\"))\n    b'abc'\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a bytes1, but only %d remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bytes1")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bytes1")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_bytes1")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted bytes string.\n\n              The first argument is a 1-byte unsigned int giving the number\n              of bytes in the string, and the second argument is that many\n              bytes.\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_bytes1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_bytes1(io.BytesIO(b\"\\x00\"))\n    b''\n    >>> read_bytes1(io.BytesIO(b\"\\x03abcdef\"))\n    b'abc'\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a bytes1, but only %d remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bytes1")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bytes1")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_bytes1")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted bytes string.\n\n              The first argument is a 1-byte unsigned int giving the number\n              of bytes, and the second argument is that many bytes.\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_bytes4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_bytes4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\n    b''\n    >>> read_bytes4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\n    b'abc'\n    >>> read_bytes4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: expected 50331648 bytes in a bytes4, but only 6 remain\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "bytes4 byte count > sys.maxsize: %d")
(PUNCT "%")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a bytes4, but only %d remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bytes4")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bytes4")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT4U")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_bytes4")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted bytes string.\n\n              The first argument is a 4-byte little-endian unsigned int giving\n              the number of bytes, and the second argument is that many bytes.\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_bytes8")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io, struct, sys\n    >>> read_bytes8(io.BytesIO(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00abc\"))\n    b''\n    >>> read_bytes8(io.BytesIO(b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcdef\"))\n    b'abc'\n    >>> bigsize8 = struct.pack(\"<Q\", sys.maxsize//3)\n    >>> read_bytes8(io.BytesIO(bigsize8 + b\"abcdef\"))  #doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    ValueError: expected ... bytes in a bytes8, but only 6 remain\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint8")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "bytes8 byte count > sys.maxsize: %d")
(PUNCT "%")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "data")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a bytes8, but only %d remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "bytes8")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bytes8")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT8U")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_bytes8")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted bytes string.\n\n              The first argument is a 8-byte little-endian unsigned int giving\n              the number of bytes, and the second argument is that many bytes.\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_unicodestringnl")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_unicodestringnl(io.BytesIO(b\"abc\\\\uabcd\\njunk\")) == 'abc\\uabcd'\n    True\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "data")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT #"\n")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "no newline found when trying to read ")
(LIT "unicodestringnl")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "data")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(LIT "raw-unicode-escape")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "unicodestringnl")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "unicodestringnl")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_unicodestringnl")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A newline-terminated Unicode string.\n\n                      This is raw-unicode-escape encoded, so consists of\n                      printable ASCII characters, and may contain embedded\n                      escape sequences.\n                      ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_unicodestring1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> s = 'abcd\\uabcd'\n    >>> enc = s.encode('utf-8')\n    >>> enc\n    b'abcd\\xea\\xaf\\x8d'\n    >>> n = bytes([len(enc)])  # little-endian 1-byte length\n    >>> t = read_unicodestring1(io.BytesIO(n + enc + b'junk'))\n    >>> s == t\n    True\n\n    >>> read_unicodestring1(io.BytesIO(n + enc[:-1]))\n    Traceback (most recent call last):\n    ...\n    ValueError: expected 7 bytes in a unicodestring1, but only 6 remain\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(LIT "utf-8")
(PUNCT ",")
(LIT "surrogatepass")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a unicodestring1, but only %d ")
(LIT "remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "unicodestring1")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "unicodestring1")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_unicodestring1")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted Unicode string.\n\n                    The first argument is a 1-byte little-endian signed int\n                    giving the number of bytes in the string, and the second\n                    argument-- the UTF-8 encoding of the Unicode string --\n                    contains that many bytes.\n                    ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_unicodestring4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> s = 'abcd\\uabcd'\n    >>> enc = s.encode('utf-8')\n    >>> enc\n    b'abcd\\xea\\xaf\\x8d'\n    >>> n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length\n    >>> t = read_unicodestring4(io.BytesIO(n + enc + b'junk'))\n    >>> s == t\n    True\n\n    >>> read_unicodestring4(io.BytesIO(n + enc[:-1]))\n    Traceback (most recent call last):\n    ...\n    ValueError: expected 7 bytes in a unicodestring4, but only 6 remain\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unicodestring4 byte count > sys.maxsize: %d")
(PUNCT "%")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(LIT "utf-8")
(PUNCT ",")
(LIT "surrogatepass")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a unicodestring4, but only %d ")
(LIT "remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "unicodestring4")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "unicodestring4")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT4U")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_unicodestring4")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted Unicode string.\n\n                    The first argument is a 4-byte little-endian signed int\n                    giving the number of bytes in the string, and the second\n                    argument-- the UTF-8 encoding of the Unicode string --\n                    contains that many bytes.\n                    ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_unicodestring8")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> s = 'abcd\\uabcd'\n    >>> enc = s.encode('utf-8')\n    >>> enc\n    b'abcd\\xea\\xaf\\x8d'\n    >>> n = bytes([len(enc)]) + bytes(7)  # little-endian 8-byte length\n    >>> t = read_unicodestring8(io.BytesIO(n + enc + b'junk'))\n    >>> s == t\n    True\n\n    >>> read_unicodestring8(io.BytesIO(n + enc[:-1]))\n    Traceback (most recent call last):\n    ...\n    ValueError: expected 7 bytes in a unicodestring8, but only 6 remain\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint8")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "n")
(PUNCT ">=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT ">")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "unicodestring8 byte count > sys.maxsize: %d")
(PUNCT "%")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(LIT "utf-8")
(PUNCT ",")
(LIT "surrogatepass")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "expected %d bytes in a unicodestring8, but only %d ")
(LIT "remain")
(PUNCT "%")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "unicodestring8")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "unicodestring8")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT8U")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_unicodestring8")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A counted Unicode string.\n\n                    The first argument is a 8-byte little-endian signed int\n                    giving the number of bytes in the string, and the second\n                    argument-- the UTF-8 encoding of the Unicode string --\n                    contains that many bytes.\n                    ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_decimalnl_short")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_decimalnl_short(io.BytesIO(b\"1234\\n56\"))\n    1234\n\n    >>> read_decimalnl_short(io.BytesIO(b\"1234L\\n56\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: invalid literal for int() with base 10: b'1234L'\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "read_stringnl")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "decode")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "stripquotes")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "==")
(LIT #"00")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT "==")
(LIT #"01")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "read_decimalnl_long")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n\n    >>> read_decimalnl_long(io.BytesIO(b\"1234L\\n56\"))\n    1234\n\n    >>> read_decimalnl_long(io.BytesIO(b\"123456789012345678901234L\\n6\"))\n    123456789012345678901234\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "read_stringnl")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "decode")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "stripquotes")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT #"L")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "int")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "decimalnl_short")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "decimalnl_short")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_decimalnl_short")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A newline-terminated decimal integer literal.\n\n                          This never has a trailing 'L', and the integer fit\n                          in a short Python int on the box where the pickle\n                          was written -- but there's no guarantee it will fit\n                          in a short Python int on the box where the pickle\n                          is read.\n                          ")
(PUNCT ")")
(NEWLINE)
(ID "decimalnl_long")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "decimalnl_long")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_decimalnl_long")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A newline-terminated decimal integer literal.\n\n                         This has a trailing 'L', and can represent integers\n                         of any size.\n                         ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_floatnl")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_floatnl(io.BytesIO(b\"-1.25\\n6\"))\n    -1.25\n    ")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "read_stringnl")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "decode")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "stripquotes")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "float")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "floatnl")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "floatnl")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "UP_TO_NEWLINE")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_floatnl")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A newline-terminated decimal floating literal.\n\n              In general this requires 17 significant digits for roundtrip\n              identity, and pickling then unpickling infinities, NaNs, and\n              minus zero doesn't work across boxes, or on some boxes even\n              on itself (e.g., Windows can't read the strings it produces\n              for infinities or NaNs).\n              ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_float8")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io, struct\n    >>> raw = struct.pack(\">d\", -1.25)\n    >>> raw\n    b'\\xbf\\xf4\\x00\\x00\\x00\\x00\\x00\\x00'\n    >>> read_float8(io.BytesIO(raw + b\"\\n\"))\n    -1.25\n    ")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 8)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "==")
(LIT 8)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "_unpack")
(PUNCT "(")
(LIT ">d")
(PUNCT ",")
(ID "data")
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read float8")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "float8")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "float8")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(LIT 8)
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_float8")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "An 8-byte binary representation of a float, big-endian.\n\n             The format is unique to Python, and shared with the struct\n             module (format string '>d') \"in theory\" (the struct and pickle\n             implementations don't share the code -- they should).  It's\n             strongly related to the IEEE-754 double format, and, in normal\n             cases, is in fact identical to the big-endian 754 double format.\n             On other boxes the dynamic range is limited to that of a 754\n             double, and \"add a half and chop\" rounding is used to reduce\n             the precision to 53 bits.  However, even on a 754 box,\n             infinities, NaNs, and minus zero may not be handled correctly\n             (may not survive roundtrip pickling intact).\n             ")
(PUNCT ")")
(NEWLINE)
(KEYWORD from)
(ID "pickle")
(KEYWORD import)
(ID "decode_long")
(NEWLINE)
(KEYWORD def)
(ID "read_long1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_long1(io.BytesIO(b\"\\x00\"))\n    0\n    >>> read_long1(io.BytesIO(b\"\\x02\\xff\\x00\"))\n    255\n    >>> read_long1(io.BytesIO(b\"\\x02\\xff\\x7f\"))\n    32767\n    >>> read_long1(io.BytesIO(b\"\\x02\\x00\\xff\"))\n    -256\n    >>> read_long1(io.BytesIO(b\"\\x02\\x00\\x80\"))\n    -32768\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_uint1")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "!=")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read long1")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "decode_long")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "long1")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "long1")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT1")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_long1")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A binary long, little-endian, using 1-byte size.\n\n    This first reads one byte as an unsigned size, then reads that\n    many bytes and interprets them as a little-endian 2's-complement long.\n    If the size is 0, that's taken as a shortcut for the long 0L.\n    ")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "read_long4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    >>> import io\n    >>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x00\"))\n    255\n    >>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x7f\"))\n    32767\n    >>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\xff\"))\n    -256\n    >>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\x80\"))\n    -32768\n    >>> read_long1(io.BytesIO(b\"\\x00\\x00\\x00\\x00\"))\n    0\n    ")
(NEWLINE)
(ID "n")
(PUNCT "=")
(ID "read_int4")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "n")
(PUNCT "<")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "long4 byte count < 0: %d")
(PUNCT "%")
(ID "n")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(ID "n")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(PUNCT "!=")
(ID "n")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "not enough data in stream to read long4")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "decode_long")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "long4")
(PUNCT "=")
(ID "ArgumentDescriptor")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "long4")
(PUNCT ",")
(ID "n")
(PUNCT "=")
(ID "TAKEN_FROM_ARGUMENT4")
(PUNCT ",")
(ID "reader")
(PUNCT "=")
(ID "read_long4")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A binary representation of a long, little-endian.\n\n    This first reads four bytes as a signed size (but requires the\n    size to be >= 0), then reads that many bytes and interprets them\n    as a little-endian 2's-complement long.  If the size is 0, that's taken\n    as a shortcut for the int 0, although LONG1 should really be used\n    then instead (and in any case where # of bytes < 256).\n    ")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "StackObject")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "name")
(PUNCT ",")
(LIT "obtype")
(PUNCT ",")
(LIT "doc")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "obtype")
(PUNCT ",")
(ID "doc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "obtype")
(PUNCT ",")
(ID "type")
(PUNCT ")")
(KEYWORD or)
(ID "isinstance")
(PUNCT "(")
(ID "obtype")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "obtype")
(PUNCT ",")
(ID "tuple")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "contained")
(KEYWORD in)
(ID "obtype")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "contained")
(PUNCT ",")
(ID "type")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "obtype")
(PUNCT "=")
(ID "obtype")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "doc")
(PUNCT "=")
(ID "doc")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "pyint")
(PUNCT "=")
(ID "pylong")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "int")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "int")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python integer object.")
(PUNCT ")")
(NEWLINE)
(ID "pyinteger_or_bool")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "int_or_bool")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "bool")
(PUNCT ")")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python integer or boolean object.")
(PUNCT ")")
(NEWLINE)
(ID "pybool")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bool")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "bool")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python boolean object.")
(PUNCT ")")
(NEWLINE)
(ID "pyfloat")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "float")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "float")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python float object.")
(PUNCT ")")
(NEWLINE)
(ID "pybytes_or_str")
(PUNCT "=")
(ID "pystring")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bytes_or_str")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(PUNCT "(")
(ID "bytes")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python bytes or (Unicode) string object.")
(PUNCT ")")
(NEWLINE)
(ID "pybytes")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "bytes")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "bytes")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python bytes object.")
(PUNCT ")")
(NEWLINE)
(ID "pyunicode")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "str")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "str")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python (Unicode) string object.")
(PUNCT ")")
(NEWLINE)
(ID "pynone")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "None")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "type")
(PUNCT "(")
(KEYWORD None)
(PUNCT ")")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "The Python None object.")
(PUNCT ")")
(NEWLINE)
(ID "pytuple")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "tuple")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "tuple")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python tuple object.")
(PUNCT ")")
(NEWLINE)
(ID "pylist")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "list")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "list")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python list object.")
(PUNCT ")")
(NEWLINE)
(ID "pydict")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "dict")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "dict")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python dict object.")
(PUNCT ")")
(NEWLINE)
(ID "pyset")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "set")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "set")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python set object.")
(PUNCT ")")
(NEWLINE)
(ID "pyfrozenset")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "frozenset")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "set")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "A Python frozenset object.")
(PUNCT ")")
(NEWLINE)
(ID "anyobject")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "any")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "object")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Any kind of object whatsoever.")
(PUNCT ")")
(NEWLINE)
(ID "markobject")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "mark")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "StackObject")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "'The mark' is a unique object.\n\nOpcodes that operate on a variable number of objects\ngenerally don't embed the count of objects in the opcode,\nor pull it off the stack.  Instead the MARK opcode is used\nto push a special marker object on the stack, and then\nsome other opcodes grab all the objects from the top of\nthe stack down to (but not including) the topmost marker\nobject.\n")
(PUNCT ")")
(NEWLINE)
(ID "stackslice")
(PUNCT "=")
(ID "StackObject")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "stackslice")
(PUNCT ",")
(ID "obtype")
(PUNCT "=")
(ID "StackObject")
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "An object representing a contiguous slice of the stack.\n\nThis is used in conjunction with markobject, to represent all\nof the stack following the topmost markobject.  For example,\nthe POP_MARK opcode changes the stack from\n\n    [..., markobject, stackslice]\nto\n    [...]\n\nNo matter how many object are on the stack after the topmost\nmarkobject, POP_MARK gets rid of all of them (including the\ntopmost markobject too).\n")
(PUNCT ")")
(NEWLINE)
(KEYWORD class)
(ID "OpcodeInfo")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__slots__")
(PUNCT "=")
(PUNCT "(")
(LIT "name")
(PUNCT ",")
(LIT "code")
(PUNCT ",")
(LIT "arg")
(PUNCT ",")
(LIT "stack_before")
(PUNCT ",")
(LIT "stack_after")
(PUNCT ",")
(LIT "proto")
(PUNCT ",")
(LIT "doc")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "code")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "stack_before")
(PUNCT ",")
(ID "stack_after")
(PUNCT ",")
(ID "proto")
(PUNCT ",")
(ID "doc")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "code")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "code")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "code")
(PUNCT "=")
(ID "code")
(NEWLINE)
(KEYWORD assert)
(ID "arg")
(KEYWORD is)
(KEYWORD None)
(KEYWORD or)
(ID "isinstance")
(PUNCT "(")
(ID "arg")
(PUNCT ",")
(ID "ArgumentDescriptor")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "arg")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "stack_before")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "stack_before")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "StackObject")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "stack_before")
(PUNCT "=")
(ID "stack_before")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "stack_after")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "stack_after")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "StackObject")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "stack_after")
(PUNCT "=")
(ID "stack_after")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "proto")
(PUNCT ",")
(ID "int")
(PUNCT ")")
(KEYWORD and)
(LIT 0)
(PUNCT "<=")
(ID "proto")
(PUNCT "<=")
(ID "pickle")
(PUNCT ".")
(ID "HIGHEST_PROTOCOL")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "proto")
(PUNCT "=")
(ID "proto")
(NEWLINE)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "doc")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "doc")
(PUNCT "=")
(ID "doc")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "I")
(PUNCT "=")
(ID "OpcodeInfo")
(NEWLINE)
(ID "opcodes")
(PUNCT "=")
(PUNCT "[")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "INT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "I")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "decimalnl_short")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyinteger_or_bool")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an integer or bool.\n\n      The argument is a newline-terminated decimal literal string.\n\n      The intent may have been that this always fit in a short Python int,\n      but INT can be generated in pickles written on a 64-bit box that\n      require a Python long on a 32-bit box.  The difference between this\n      and LONG then is that INT skips a trailing 'L', and produces a short\n      int whenever possible.\n\n      Another difference is due to that, when bool was introduced as a\n      distinct type in 2.3, builtin names True and False were also added to\n      2.2.2, mapping to ints 1 and 0.  For compatibility in both directions,\n      True gets pickled as INT + \"I01\\n\", and False as INT + \"I00\\n\".\n      Leading zeroes are never produced for a genuine integer.  The 2.3\n      (and later) unpicklers special-case these and return bool instead;\n      earlier unpicklers ignore the leading \"0\" and return the int.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BININT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "J")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "int4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyint")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a four-byte signed integer.\n\n      This handles the full range of Python (short) integers on a 32-bit\n      box, directly as binary bytes (1 for the opcode and 4 for the integer).\n      If the integer is non-negative and fits in 1 or 2 bytes, pickling via\n      BININT1 or BININT2 saves space.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BININT1")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "K")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyint")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a one-byte unsigned integer.\n\n      This is a space optimization for pickling very small non-negative ints,\n      in range(256).\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BININT2")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "M")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint2")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyint")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a two-byte unsigned integer.\n\n      This is a space optimization for pickling small positive ints, in\n      range(256, 2**16).  Integers in range(256) can also be pickled via\n      BININT2, but BININT1 instead saves a byte.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "LONG")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "L")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "decimalnl_long")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyint")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a long integer.\n\n      The same as INT, except that the literal ends with 'L', and always\n      unpickles to a Python long.  There doesn't seem a real purpose to the\n      trailing 'L'.\n\n      Note that LONG takes time quadratic in the number of digits when\n      unpickling (this is simply due to the nature of decimal->binary\n      conversion).  Proto 2 added linear-time (in C; still quadratic-time\n      in Python) LONG1 and LONG4 opcodes.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "LONG1")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u008A")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "long1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyint")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Long integer using one-byte length.\n\n      A more efficient encoding of a Python long; the long1 encoding\n      says it all.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "LONG4")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u008B")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "long4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyint")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Long integer using found-byte length.\n\n      A more efficient encoding of a Python long; the long4 encoding\n      says it all.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "STRING")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "S")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "stringnl")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybytes_or_str")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python string object.\n\n      The argument is a repr-style string, with bracketing quote characters,\n      and perhaps embedded escapes.  The argument extends until the next\n      newline character.  These are usually decoded into a str instance\n      using the encoding given to the Unpickler constructor. or the default,\n      'ASCII'.  If the encoding given was 'bytes' however, they will be\n      decoded as bytes object instead.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINSTRING")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "T")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "string4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybytes_or_str")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python string object.\n\n      There are two arguments: the first is a 4-byte little-endian\n      signed int giving the number of bytes in the string, and the\n      second is that many bytes, which are taken literally as the string\n      content.  These are usually decoded into a str instance using the\n      encoding given to the Unpickler constructor. or the default,\n      'ASCII'.  If the encoding given was 'bytes' however, they will be\n      decoded as bytes object instead.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "SHORT_BINSTRING")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "U")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "string1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybytes_or_str")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python string object.\n\n      There are two arguments: the first is a 1-byte unsigned int giving\n      the number of bytes in the string, and the second is that many\n      bytes, which are taken literally as the string content.  These are\n      usually decoded into a str instance using the encoding given to\n      the Unpickler constructor. or the default, 'ASCII'.  If the\n      encoding given was 'bytes' however, they will be decoded as bytes\n      object instead.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINBYTES")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "B")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "bytes4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybytes")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 3)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python bytes object.\n\n      There are two arguments:  the first is a 4-byte little-endian unsigned int\n      giving the number of bytes, and the second is that many bytes, which are\n      taken literally as the bytes content.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "SHORT_BINBYTES")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "C")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "bytes1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybytes")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 3)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python bytes object.\n\n      There are two arguments:  the first is a 1-byte unsigned int giving\n      the number of bytes, and the second is that many bytes, which are taken\n      literally as the string content.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINBYTES8")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u008E")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "bytes8")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybytes")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python bytes object.\n\n      There are two arguments:  the first is a 8-byte unsigned int giving\n      the number of bytes in the string, and the second is that many bytes,\n      which are taken literally as the string content.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "NONE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "N")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pynone")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push None on the stack.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "NEWTRUE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0088")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybool")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "True.\n\n      Push True onto the stack.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "NEWFALSE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0089")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pybool")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "True.\n\n      Push False onto the stack.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "UNICODE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "V")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "unicodestringnl")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyunicode")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python Unicode string object.\n\n      The argument is a raw-unicode-escape encoding of a Unicode string,\n      and so may contain embedded escape sequences.  The argument extends\n      until the next newline character.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "SHORT_BINUNICODE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u008C")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "unicodestring1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyunicode")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python Unicode string object.\n\n      There are two arguments:  the first is a 1-byte little-endian signed int\n      giving the number of bytes in the string.  The second is that many\n      bytes, and is the UTF-8 encoding of the Unicode string.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINUNICODE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "X")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "unicodestring4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyunicode")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python Unicode string object.\n\n      There are two arguments:  the first is a 4-byte little-endian unsigned int\n      giving the number of bytes in the string.  The second is that many\n      bytes, and is the UTF-8 encoding of the Unicode string.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINUNICODE8")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u008D")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "unicodestring8")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyunicode")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a Python Unicode string object.\n\n      There are two arguments:  the first is a 8-byte little-endian signed int\n      giving the number of bytes in the string.  The second is that many\n      bytes, and is the UTF-8 encoding of the Unicode string.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "FLOAT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "F")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "floatnl")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyfloat")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Newline-terminated decimal float literal.\n\n      The argument is repr(a_float), and in general requires 17 significant\n      digits for roundtrip conversion to be an identity (this is so for\n      IEEE-754 double precision values, which is what Python float maps to\n      on most boxes).\n\n      In general, FLOAT cannot be used to transport infinities, NaNs, or\n      minus zero across boxes (or even on a single box, if the platform C\n      library can't read the strings it produces for such things -- Windows\n      is like that), but may do less damage than BINFLOAT on boxes with\n      greater precision or dynamic range than IEEE-754 double.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINFLOAT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "G")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "float8")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyfloat")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Float stored in binary form, with 8 bytes of data.\n\n      This generally requires less than half the space of FLOAT encoding.\n      In general, BINFLOAT cannot be used to transport infinities, NaNs, or\n      minus zero, raises an exception if the exponent exceeds the range of\n      an IEEE-754 double, and retains no more than 53 bits of precision (if\n      there are more than that, \"add a half and chop\" rounding is used to\n      cut it back to 53 significant bits).\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EMPTY_LIST")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "]")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pylist")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an empty list.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "APPEND")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "a")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "pylist")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pylist")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Append an object to a list.\n\n      Stack before:  ... pylist anyobject\n      Stack after:   ... pylist+[anyobject]\n\n      although pylist is really extended in-place.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "APPENDS")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "e")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "pylist")
(PUNCT ",")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pylist")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Extend a list by a slice of stack objects.\n\n      Stack before:  ... pylist markobject stackslice\n      Stack after:   ... pylist+stackslice\n\n      although pylist is really extended in-place.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "LIST")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "l")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pylist")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a list out of the topmost stack slice, after markobject.\n\n      All the stack entries following the topmost markobject are placed into\n      a single Python list, which single list object replaces all of the\n      stack from the topmost markobject onward.  For example,\n\n      Stack before: ... markobject 1 2 3 'abc'\n      Stack after:  ... [1, 2, 3, 'abc']\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EMPTY_TUPLE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT ")")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pytuple")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an empty tuple.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "TUPLE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "t")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pytuple")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a tuple out of the topmost stack slice, after markobject.\n\n      All the stack entries following the topmost markobject are placed into\n      a single Python tuple, which single tuple object replaces all of the\n      stack from the topmost markobject onward.  For example,\n\n      Stack before: ... markobject 1 2 3 'abc'\n      Stack after:  ... (1, 2, 3, 'abc')\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "TUPLE1")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0085")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pytuple")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a one-tuple out of the topmost item on the stack.\n\n      This code pops one value off the stack and pushes a tuple of\n      length 1 whose one item is that value back onto it.  In other\n      words:\n\n          stack[-1] = tuple(stack[-1:])\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "TUPLE2")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0086")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pytuple")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a two-tuple out of the top two items on the stack.\n\n      This code pops two values off the stack and pushes a tuple of\n      length 2 whose items are those values back onto it.  In other\n      words:\n\n          stack[-2:] = [tuple(stack[-2:])]\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "TUPLE3")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0087")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pytuple")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a three-tuple out of the top three items on the stack.\n\n      This code pops three values off the stack and pushes a tuple of\n      length 3 whose items are those values back onto it.  In other\n      words:\n\n          stack[-3:] = [tuple(stack[-3:])]\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EMPTY_DICT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "}")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pydict")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an empty dict.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "DICT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "d")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pydict")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a dict out of the topmost stack slice, after markobject.\n\n      All the stack entries following the topmost markobject are placed into\n      a single Python dict, which single dict object replaces all of the\n      stack from the topmost markobject onward.  The stack slice alternates\n      key, value, key, value, ....  For example,\n\n      Stack before: ... markobject 1 2 3 'abc'\n      Stack after:  ... {1: 2, 3: 'abc'}\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "SETITEM")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "s")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "pydict")
(PUNCT ",")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pydict")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Add a key+value pair to an existing dict.\n\n      Stack before:  ... pydict key value\n      Stack after:   ... pydict\n\n      where pydict has been modified via pydict[key] = value.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "SETITEMS")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "u")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "pydict")
(PUNCT ",")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pydict")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Add an arbitrary number of key+value pairs to an existing dict.\n\n      The slice of the stack following the topmost markobject is taken as\n      an alternating sequence of keys and values, added to the dict\n      immediately under the topmost markobject.  Everything at and after the\n      topmost markobject is popped, leaving the mutated dict at the top\n      of the stack.\n\n      Stack before:  ... pydict markobject key_1 value_1 ... key_n value_n\n      Stack after:   ... pydict\n\n      where pydict has been modified via pydict[key_i] = value_i for i in\n      1, 2, ..., n, and in that order.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EMPTY_SET")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u008F")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyset")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an empty set.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "ADDITEMS")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0090")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "pyset")
(PUNCT ",")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyset")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Add an arbitrary number of items to an existing set.\n\n      The slice of the stack following the topmost markobject is taken as\n      a sequence of items, added to the set immediately under the topmost\n      markobject.  Everything at and after the topmost markobject is popped,\n      leaving the mutated set at the top of the stack.\n\n      Stack before:  ... pyset markobject item_1 ... item_n\n      Stack after:   ... pyset\n\n      where pyset has been modified via pyset.add(item_i) = item_i for i in\n      1, 2, ..., n, and in that order.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "FROZENSET")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0091")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "pyfrozenset")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a frozenset out of the topmost slice, after markobject.\n\n      All the stack entries following the topmost markobject are placed into\n      a single Python frozenset, which single frozenset object replaces all\n      of the stack from the topmost markobject onward.  For example,\n\n      Stack before: ... markobject 1 2 3\n      Stack after:  ... frozenset({1, 2, 3})\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "POP")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "0")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Discard the top stack item, shrinking the stack by one item.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "DUP")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "2")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push the top stack item onto the stack again, duplicating it.")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "MARK")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "(")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push markobject onto the stack.\n\n      markobject is a unique object, used by other opcodes to identify a\n      region of the stack containing a variable number of objects for them\n      to work on.  See markobject.doc for more detail.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "POP_MARK")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "1")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Pop all the stack objects at and above the topmost markobject.\n\n      When an opcode using a variable number of stack objects is done,\n      POP_MARK is used to remove those objects, and to remove the markobject\n      that delimited their starting position on the stack.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "GET")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "g")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "decimalnl_short")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Read an object from the memo and push it on the stack.\n\n      The index of the memo object to push is given by the newline-terminated\n      decimal string following.  BINGET and LONG_BINGET are space-optimized\n      versions.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINGET")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "h")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Read an object from the memo and push it on the stack.\n\n      The index of the memo object to push is given by the 1-byte unsigned\n      integer following.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "LONG_BINGET")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "j")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Read an object from the memo and push it on the stack.\n\n      The index of the memo object to push is given by the 4-byte unsigned\n      little-endian integer following.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "PUT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "p")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "decimalnl_short")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Store the stack top into the memo.  The stack is not popped.\n\n      The index of the memo location to write into is given by the newline-\n      terminated decimal string following.  BINPUT and LONG_BINPUT are\n      space-optimized versions.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINPUT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "q")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Store the stack top into the memo.  The stack is not popped.\n\n      The index of the memo location to write into is given by the 1-byte\n      unsigned integer following.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "LONG_BINPUT")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "r")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Store the stack top into the memo.  The stack is not popped.\n\n      The index of the memo location to write into is given by the 4-byte\n      unsigned little-endian integer following.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "MEMOIZE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0094")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Store the stack top into the memo.  The stack is not popped.\n\n      The index of the memo location to write is the number of\n      elements currently present in the memo.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EXT1")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0082")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Extension code.\n\n      This code and the similar EXT2 and EXT4 allow using a registry\n      of popular objects that are pickled by name, typically classes.\n      It is envisioned that through a global negotiation and\n      registration process, third parties can set up a mapping between\n      ints and object names.\n\n      In order to guarantee pickle interchangeability, the extension\n      code registry ought to be global, although a range of codes may\n      be reserved for private use.\n\n      EXT1 has a 1-byte integer argument.  This is used to index into the\n      extension registry, and the object at that index is pushed on the stack.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EXT2")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0083")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint2")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Extension code.\n\n      See EXT1.  EXT2 has a two-byte integer argument.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "EXT4")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0084")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "int4")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Extension code.\n\n      See EXT1.  EXT4 has a four-byte integer argument.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "GLOBAL")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "c")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "stringnl_noescape_pair")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a global object (module.attr) on the stack.\n\n      Two newline-terminated strings follow the GLOBAL opcode.  The first is\n      taken as a module name, and the second as a class name.  The class\n      object module.class is pushed on the stack.  More accurately, the\n      object returned by self.find_class(module, class) is pushed on the\n      stack, so unpickling subclasses can override this form of lookup.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "STACK_GLOBAL")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0093")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "pyunicode")
(PUNCT ",")
(ID "pyunicode")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push a global object (module.attr) on the stack.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "REDUCE")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "R")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an object built from a callable and an argument tuple.\n\n      The opcode is named to remind of the __reduce__() method.\n\n      Stack before: ... callable pytuple\n      Stack after:  ... callable(*pytuple)\n\n      The callable and the argument tuple are the first two items returned\n      by a __reduce__ method.  Applying the callable to the argtuple is\n      supposed to reproduce the original object, or at least get it started.\n      If the __reduce__ method returns a 3-tuple, the last component is an\n      argument to be passed to the object's __setstate__, and then the REDUCE\n      opcode is followed by code to create setstate's argument, and then a\n      BUILD opcode to apply  __setstate__ to that argument.\n\n      If not isinstance(callable, type), REDUCE complains unless the\n      callable has been registered with the copyreg module's\n      safe_constructors dict, or the callable has a magic\n      '__safe_for_unpickling__' attribute with a true value.  I'm not sure\n      why it does this, but I've sure seen this complaint often enough when\n      I didn't want to <wink>.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BUILD")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "b")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Finish building an object, via __setstate__ or dict update.\n\n      Stack before: ... anyobject argument\n      Stack after:  ... anyobject\n\n      where anyobject may have been mutated, as follows:\n\n      If the object has a __setstate__ method,\n\n          anyobject.__setstate__(argument)\n\n      is called.\n\n      Else the argument must be a dict, the object must have a __dict__, and\n      the object is updated via\n\n          anyobject.__dict__.update(argument)\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "INST")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "i")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "stringnl_noescape_pair")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a class instance.\n\n      This is the protocol 0 version of protocol 1's OBJ opcode.\n      INST is followed by two newline-terminated strings, giving a\n      module and class name, just as for the GLOBAL opcode (and see\n      GLOBAL for more details about that).  self.find_class(module, name)\n      is used to get a class object.\n\n      In addition, all the objects on the stack following the topmost\n      markobject are gathered into a tuple and popped (along with the\n      topmost markobject), just as for the TUPLE opcode.\n\n      Now it gets complicated.  If all of these are true:\n\n        + The argtuple is empty (markobject was at the top of the stack\n          at the start).\n\n        + The class object does not have a __getinitargs__ attribute.\n\n      then we want to create an old-style class instance without invoking\n      its __init__() method (pickle has waffled on this over the years; not\n      calling __init__() is current wisdom).  In this case, an instance of\n      an old-style dummy class is created, and then we try to rebind its\n      __class__ attribute to the desired class object.  If this succeeds,\n      the new instance object is pushed on the stack, and we're done.\n\n      Else (the argtuple is not empty, it's not an old-style class object,\n      or the class object does have a __getinitargs__ attribute), the code\n      first insists that the class object have a __safe_for_unpickling__\n      attribute.  Unlike as for the __safe_for_unpickling__ check in REDUCE,\n      it doesn't matter whether this attribute has a true or false value, it\n      only matters whether it exists (XXX this is a bug).  If\n      __safe_for_unpickling__ doesn't exist, UnpicklingError is raised.\n\n      Else (the class object does have a __safe_for_unpickling__ attr),\n      the class object obtained from INST's arguments is applied to the\n      argtuple obtained from the stack, and the resulting instance object\n      is pushed on the stack.\n\n      NOTE:  checks for __safe_for_unpickling__ went away in Python 2.3.\n      NOTE:  the distinction between old-style and new-style classes does\n             not make sense in Python 3.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "OBJ")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "o")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "markobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT ",")
(ID "stackslice")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build a class instance.\n\n      This is the protocol 1 version of protocol 0's INST opcode, and is\n      very much like it.  The major difference is that the class object\n      is taken off the stack, allowing it to be retrieved from the memo\n      repeatedly if several instances of the same class are created.  This\n      can be much more efficient (in both time and space) than repeatedly\n      embedding the module and class names in INST opcodes.\n\n      Unlike INST, OBJ takes no arguments from the opcode stream.  Instead\n      the class object is taken off the stack, immediately above the\n      topmost markobject:\n\n      Stack before: ... markobject classobject stackslice\n      Stack after:  ... new_instance_object\n\n      As for INST, the remainder of the stack above the markobject is\n      gathered into an argument tuple, and then the logic seems identical,\n      except that no __safe_for_unpickling__ check is done (XXX this is\n      a bug).  See INST for the gory details.\n\n      NOTE:  In Python 2.3, INST and OBJ are identical except for how they\n      get the class object.  That was always the intent; the implementations\n      had diverged for accidental reasons.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "NEWOBJ")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0081")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build an object instance.\n\n      The stack before should be thought of as containing a class\n      object followed by an argument tuple (the tuple being the stack\n      top).  Call these cls and args.  They are popped off the stack,\n      and the value returned by cls.__new__(cls, *args) is pushed back\n      onto the stack.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "NEWOBJ_EX")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0092")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT ",")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Build an object instance.\n\n      The stack before should be thought of as containing a class\n      object followed by an argument tuple and by a keyword argument dict\n      (the dict being the stack top).  Call these cls and args.  They are\n      popped off the stack, and the value returned by\n      cls.__new__(cls, *args, *kwargs) is  pushed back  onto the stack.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "PROTO")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0080")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint1")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 2)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Protocol version indicator.\n\n      For protocol 2 and above, a pickle must start with this opcode.\n      The argument is the protocol version, an int in range(2, 256).\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "STOP")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT ".")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Stop the unpickling machine.\n\n      Every pickle ends with this opcode.  The object at the top of the stack\n      is popped, and that's the result of unpickling.  The stack should be\n      empty then.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "FRAME")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "\u0095")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "uint8")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Indicate the beginning of a new frame.\n\n      The unpickler may use this opcode to safely prefetch data from its\n      underlying stream.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "PERSID")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "P")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(ID "stringnl_noescape")
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an object identified by a persistent ID.\n\n      The pickle module doesn't define what a persistent ID means.  PERSID's\n      argument is a newline-terminated str-style (no embedded escapes, no\n      bracketing quote characters) string, which *is* \"the persistent ID\".\n      The unpickler passes this string to self.persistent_load().  Whatever\n      object that returns is pushed on the stack.  There is no implementation\n      of persistent_load() in Python's unpickler:  it must be supplied by an\n      unpickler subclass.\n      ")
(PUNCT ")")
(PUNCT ",")
(ID "I")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(LIT "BINPERSID")
(PUNCT ",")
(ID "code")
(PUNCT "=")
(LIT "Q")
(PUNCT ",")
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "stack_before")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "stack_after")
(PUNCT "=")
(PUNCT "[")
(ID "anyobject")
(PUNCT "]")
(PUNCT ",")
(ID "proto")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "doc")
(PUNCT "=")
(LIT "Push an object identified by a persistent ID.\n\n      Like PERSID, except the persistent ID is popped off the stack (instead\n      of being a string embedded in the opcode bytestream).  The persistent\n      ID is passed to self.persistent_load(), and whatever object that\n      returns is pushed on the stack.  See PERSID for more detail.\n      ")
(PUNCT ")")
(PUNCT ",")
(PUNCT "]")
(NEWLINE)
(KEYWORD del)
(ID "I")
(NEWLINE)
(ID "name2i")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "code2i")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "d")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "opcodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "d")
(PUNCT ".")
(ID "name")
(KEYWORD in)
(ID "name2i")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "repeated name %r at indices %d and %d")
(PUNCT "%")
(PUNCT "(")
(ID "d")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "name2i")
(PUNCT "[")
(ID "d")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "d")
(PUNCT ".")
(ID "code")
(KEYWORD in)
(ID "code2i")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "repeated code %r at indices %d and %d")
(PUNCT "%")
(PUNCT "(")
(ID "d")
(PUNCT ".")
(ID "code")
(PUNCT ",")
(ID "code2i")
(PUNCT "[")
(ID "d")
(PUNCT ".")
(ID "code")
(PUNCT "]")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "name2i")
(PUNCT "[")
(ID "d")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "i")
(NEWLINE)
(ID "code2i")
(PUNCT "[")
(ID "d")
(PUNCT ".")
(ID "code")
(PUNCT "]")
(PUNCT "=")
(ID "i")
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "name2i")
(PUNCT ",")
(ID "code2i")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "d")
(NEWLINE)
(ID "code2op")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "d")
(KEYWORD in)
(ID "opcodes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "code2op")
(PUNCT "[")
(ID "d")
(PUNCT ".")
(ID "code")
(PUNCT "]")
(PUNCT "=")
(ID "d")
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "d")
(NEWLINE)
(KEYWORD def)
(ID "assure_pickle_consistency")
(PUNCT "(")
(ID "verbose")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "copy")
(PUNCT "=")
(ID "code2op")
(PUNCT ".")
(ID "copy")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "name")
(KEYWORD in)
(ID "pickle")
(PUNCT ".")
(ID "__all__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "[A-Z][A-Z0-9_]+$")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "skipping %r: it doesn't look like an opcode name")
(PUNCT "%")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "picklecode")
(PUNCT "=")
(ID "getattr")
(PUNCT "(")
(ID "pickle")
(PUNCT ",")
(ID "name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "picklecode")
(PUNCT ",")
(ID "bytes")
(PUNCT ")")
(KEYWORD or)
(ID "len")
(PUNCT "(")
(ID "picklecode")
(PUNCT ")")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(PUNCT "(")
(LIT "skipping %r: value %r doesn't look like a pickle ")
(LIT "code")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "picklecode")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "picklecode")
(PUNCT "=")
(ID "picklecode")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "latin-1")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "picklecode")
(KEYWORD in)
(ID "copy")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "verbose")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "checking name %r w/ code %r for consistency")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "picklecode")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "d")
(PUNCT "=")
(ID "copy")
(PUNCT "[")
(ID "picklecode")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "d")
(PUNCT ".")
(ID "name")
(PUNCT "!=")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "for pickle code %r, pickle.py uses name %r ")
(LIT "but we're using name %r")
(PUNCT "%")
(PUNCT "(")
(ID "picklecode")
(PUNCT ",")
(ID "name")
(PUNCT ",")
(ID "d")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD del)
(ID "copy")
(PUNCT "[")
(ID "picklecode")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "pickle.py appears to have a pickle opcode with ")
(LIT "name %r and code %r, but we don't")
(PUNCT "%")
(PUNCT "(")
(ID "name")
(PUNCT ",")
(ID "picklecode")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "copy")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(PUNCT "[")
(LIT "we appear to have pickle opcodes that pickle.py doesn't have:")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "code")
(PUNCT ",")
(ID "d")
(KEYWORD in)
(ID "copy")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(LIT "    name %r with code %r")
(PUNCT "%")
(PUNCT "(")
(ID "d")
(PUNCT ".")
(ID "name")
(PUNCT ",")
(ID "code")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "assure_pickle_consistency")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "assure_pickle_consistency")
(NEWLINE)
(KEYWORD def)
(ID "_genops")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(ID "yield_end_pos")
(PUNCT "=")
(KEYWORD False)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(ID "bytes_types")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BytesIO")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "data")
(PUNCT ",")
(LIT "tell")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "getpos")
(PUNCT "=")
(ID "data")
(PUNCT ".")
(ID "tell")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "getpos")
(PUNCT "=")
(KEYWORD lambda)
(PUNCT ":")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD while)
(KEYWORD True)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pos")
(PUNCT "=")
(ID "getpos")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "code")
(PUNCT "=")
(ID "data")
(PUNCT ".")
(ID "read")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(ID "opcode")
(PUNCT "=")
(ID "code2op")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "code")
(PUNCT ".")
(ID "decode")
(PUNCT "(")
(LIT "latin-1")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "opcode")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "code")
(PUNCT "==")
(LIT #"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "pickle exhausted before seeing STOP")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "at position %s, opcode %r unknown")
(PUNCT "%")
(PUNCT "(")
(LIT "<unknown>")
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD None)
(KEYWORD else)
(ID "pos")
(PUNCT ",")
(ID "code")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "opcode")
(PUNCT ".")
(ID "arg")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "arg")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "arg")
(PUNCT "=")
(ID "opcode")
(PUNCT ".")
(ID "arg")
(PUNCT ".")
(ID "reader")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "yield_end_pos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "opcode")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "getpos")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "opcode")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "pos")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "code")
(PUNCT "==")
(LIT #".")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "STOP")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "genops")
(PUNCT "(")
(ID "pickle")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Generate all the opcodes in a pickle.\n\n    'pickle' is a file-like object, or string, containing the pickle.\n\n    Each opcode in the pickle is generated, from the current pickle position,\n    stopping after a STOP opcode is delivered.  A triple is generated for\n    each opcode:\n\n        opcode, arg, pos\n\n    opcode is an OpcodeInfo record, describing the current opcode.\n\n    If the opcode has an argument embedded in the pickle, arg is its decoded\n    value, as a Python object.  If the opcode doesn't have an argument, arg\n    is None.\n\n    If the pickle has a tell() method, pos was the value of pickle.tell()\n    before reading the current opcode.  If the pickle is a bytes object,\n    it's wrapped in a BytesIO object, and the latter's tell() result is\n    used.  Else (the pickle doesn't have a tell(), and it's not obvious how\n    to query its current position) pos is None.\n    ")
(NEWLINE)
(KEYWORD return)
(ID "_genops")
(PUNCT "(")
(ID "pickle")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "optimize")
(PUNCT "(")
(ID "p")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Optimize a pickle string by removing unused PUT opcodes")
(NEWLINE)
(ID "put")
(PUNCT "=")
(LIT "PUT")
(NEWLINE)
(ID "get")
(PUNCT "=")
(LIT "GET")
(NEWLINE)
(ID "oldids")
(PUNCT "=")
(ID "set")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "newids")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "opcodes")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "proto")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "protoheader")
(PUNCT "=")
(LIT #"")
(NEWLINE)
(KEYWORD for)
(ID "opcode")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "pos")
(PUNCT ",")
(ID "end_pos")
(KEYWORD in)
(ID "_genops")
(PUNCT "(")
(ID "p")
(PUNCT ",")
(ID "yield_end_pos")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(LIT "PUT")
(KEYWORD in)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "oldids")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(ID "opcodes")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "put")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "MEMOIZE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "idx")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "oldids")
(PUNCT ")")
(NEWLINE)
(ID "oldids")
(PUNCT ".")
(ID "add")
(PUNCT "(")
(ID "idx")
(PUNCT ")")
(NEWLINE)
(ID "opcodes")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "put")
(PUNCT ",")
(ID "idx")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(LIT "FRAME")
(KEYWORD in)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(LIT "GET")
(KEYWORD in)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "opcode")
(PUNCT ".")
(ID "proto")
(PUNCT ">")
(ID "proto")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "proto")
(PUNCT "=")
(ID "opcode")
(PUNCT ".")
(ID "proto")
(NEWLINE)
(DEDENT)
(ID "newids")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "opcodes")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "get")
(PUNCT ",")
(ID "arg")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "PROTO")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "arg")
(PUNCT ">")
(ID "proto")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "proto")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pos")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "protoheader")
(PUNCT "=")
(ID "p")
(PUNCT "[")
(ID "pos")
(PUNCT ":")
(ID "end_pos")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opcodes")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "pos")
(PUNCT ",")
(ID "end_pos")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "opcodes")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "pos")
(PUNCT ",")
(ID "end_pos")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD del)
(ID "oldids")
(NEWLINE)
(ID "out")
(PUNCT "=")
(ID "io")
(PUNCT ".")
(ID "BytesIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "out")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "protoheader")
(PUNCT ")")
(NEWLINE)
(ID "pickler")
(PUNCT "=")
(ID "pickle")
(PUNCT ".")
(ID "_Pickler")
(PUNCT "(")
(ID "out")
(PUNCT ",")
(ID "proto")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "proto")
(PUNCT ">=")
(LIT 4)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "pickler")
(PUNCT ".")
(ID "framer")
(PUNCT ".")
(ID "start_framing")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "idx")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "op")
(PUNCT ",")
(ID "arg")
(KEYWORD in)
(ID "opcodes")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "op")
(KEYWORD is)
(ID "put")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "arg")
(KEYWORD not)
(KEYWORD in)
(ID "newids")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(ID "data")
(PUNCT "=")
(ID "pickler")
(PUNCT ".")
(ID "put")
(PUNCT "(")
(ID "idx")
(PUNCT ")")
(NEWLINE)
(ID "newids")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT "=")
(ID "idx")
(NEWLINE)
(ID "idx")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "op")
(KEYWORD is)
(ID "get")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "pickler")
(PUNCT ".")
(ID "get")
(PUNCT "(")
(ID "newids")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "data")
(PUNCT "=")
(ID "p")
(PUNCT "[")
(ID "op")
(PUNCT ":")
(ID "arg")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "pickler")
(PUNCT ".")
(ID "framer")
(PUNCT ".")
(ID "commit_frame")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "pickler")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "data")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "pickler")
(PUNCT ".")
(ID "framer")
(PUNCT ".")
(ID "end_framing")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "out")
(PUNCT ".")
(ID "getvalue")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "dis")
(PUNCT "(")
(ID "pickle")
(PUNCT ",")
(ID "out")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "memo")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "indentlevel")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "annotate")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Produce a symbolic disassembly of a pickle.\n\n    'pickle' is a file-like object, or string, containing a (at least one)\n    pickle.  The pickle is disassembled from the current position, through\n    the first STOP opcode encountered.\n\n    Optional arg 'out' is a file-like object to which the disassembly is\n    printed.  It defaults to sys.stdout.\n\n    Optional arg 'memo' is a Python dict, used as the pickle's memo.  It\n    may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.\n    Passing the same memo object to another dis() call then allows disassembly\n    to proceed across multiple pickles that were all created by the same\n    pickler with the same memo.  Ordinarily you don't need to worry about this.\n\n    Optional arg 'indentlevel' is the number of blanks by which to indent\n    a new MARK level.  It defaults to 4.\n\n    Optional arg 'annotate' if nonzero instructs dis() to add short\n    description of the opcode on each line of disassembled output.\n    The value given to 'annotate' must be an integer and is used as a\n    hint for the column where annotation should start.  The default\n    value is 0, meaning no annotations.\n\n    In addition to printing the disassembly, some sanity checks are made:\n\n    + All embedded opcode arguments \"make sense\".\n\n    + Explicit and implicit pop operations have enough items on the stack.\n\n    + When an opcode implicitly refers to a markobject, a markobject is\n      actually on the stack.\n\n    + A memo entry isn't referenced before it's defined.\n\n    + The markobject isn't stored in the memo.\n\n    + A memo entry isn't redefined.\n    ")
(NEWLINE)
(ID "stack")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "memo")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "memo")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(ID "maxproto")
(PUNCT "=")
(PUNCT "-")
(LIT 1)
(NEWLINE)
(ID "markstack")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "indentchunk")
(PUNCT "=")
(LIT " ")
(PUNCT "*")
(ID "indentlevel")
(NEWLINE)
(ID "errormsg")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "annocol")
(PUNCT "=")
(ID "annotate")
(NEWLINE)
(KEYWORD for)
(ID "opcode")
(PUNCT ",")
(ID "arg")
(PUNCT ",")
(ID "pos")
(KEYWORD in)
(ID "genops")
(PUNCT "(")
(ID "pickle")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "pos")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "%5d:")
(PUNCT "%")
(ID "pos")
(PUNCT ",")
(ID "end")
(PUNCT "=")
(LIT " ")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "out")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(LIT "%-4s %s%s")
(PUNCT "%")
(PUNCT "(")
(ID "repr")
(PUNCT "(")
(ID "opcode")
(PUNCT ".")
(ID "code")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT ",")
(ID "indentchunk")
(PUNCT "*")
(ID "len")
(PUNCT "(")
(ID "markstack")
(PUNCT ")")
(PUNCT ",")
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "maxproto")
(PUNCT "=")
(ID "max")
(PUNCT "(")
(ID "maxproto")
(PUNCT ",")
(ID "opcode")
(PUNCT ".")
(ID "proto")
(PUNCT ")")
(NEWLINE)
(ID "before")
(PUNCT "=")
(ID "opcode")
(PUNCT ".")
(ID "stack_before")
(NEWLINE)
(ID "after")
(PUNCT "=")
(ID "opcode")
(PUNCT ".")
(ID "stack_after")
(NEWLINE)
(ID "numtopop")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "before")
(PUNCT ")")
(NEWLINE)
(ID "markmsg")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "markobject")
(KEYWORD in)
(ID "before")
(KEYWORD or)
(PUNCT "(")
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "POP")
(KEYWORD and)
(ID "stack")
(KEYWORD and)
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(ID "markobject")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "markobject")
(KEYWORD not)
(KEYWORD in)
(ID "after")
(NEWLINE)
(KEYWORD if)
(ID "__debug__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "markobject")
(KEYWORD in)
(ID "before")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "before")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(ID "stackslice")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "markstack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "markpos")
(PUNCT "=")
(ID "markstack")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "markpos")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "markmsg")
(PUNCT "=")
(LIT "(MARK at unknown opcode offset)")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "markmsg")
(PUNCT "=")
(LIT "(MARK at %d)")
(PUNCT "%")
(ID "markpos")
(NEWLINE)
(DEDENT)
(KEYWORD while)
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(KEYWORD not)
(ID "markobject")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "stack")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "stack")
(PUNCT ".")
(ID "pop")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "numtopop")
(PUNCT "=")
(ID "before")
(PUNCT ".")
(ID "index")
(PUNCT "(")
(ID "markobject")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "POP")
(NEWLINE)
(ID "numtopop")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errormsg")
(PUNCT "=")
(ID "markmsg")
(PUNCT "=")
(LIT "no MARK exists on stack")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "opcode")
(PUNCT ".")
(ID "name")
(KEYWORD in)
(PUNCT "(")
(LIT "PUT")
(PUNCT ",")
(LIT "BINPUT")
(PUNCT ",")
(LIT "LONG_BINPUT")
(PUNCT ",")
(LIT "MEMOIZE")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "MEMOIZE")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "memo_idx")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "memo")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "arg")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(ID "memo_idx")
(PUNCT "=")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "memo_idx")
(KEYWORD in)
(ID "memo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errormsg")
(PUNCT "=")
(LIT "memo key %r already defined")
(PUNCT "%")
(ID "arg")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(KEYWORD not)
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errormsg")
(PUNCT "=")
(LIT "stack is empty -- can't store into memo")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(ID "markobject")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errormsg")
(PUNCT "=")
(LIT "can't store markobject in the memo")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "memo")
(PUNCT "[")
(ID "memo_idx")
(PUNCT "]")
(PUNCT "=")
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "opcode")
(PUNCT ".")
(ID "name")
(KEYWORD in)
(PUNCT "(")
(LIT "GET")
(PUNCT ",")
(LIT "BINGET")
(PUNCT ",")
(LIT "LONG_BINGET")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "arg")
(KEYWORD in)
(ID "memo")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "after")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(ID "after")
(PUNCT "=")
(PUNCT "[")
(ID "memo")
(PUNCT "[")
(ID "arg")
(PUNCT "]")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "errormsg")
(PUNCT "=")
(LIT "memo key %r has never been stored into")
(PUNCT "%")
(ID "arg")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "arg")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD or)
(ID "markmsg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "+=")
(LIT " ")
(PUNCT "*")
(PUNCT "(")
(LIT 10)
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "opcode")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "arg")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "+=")
(LIT " ")
(PUNCT "+")
(ID "repr")
(PUNCT "(")
(ID "arg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "markmsg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "+=")
(LIT " ")
(PUNCT "+")
(ID "markmsg")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "annotate")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "+=")
(LIT " ")
(PUNCT "*")
(PUNCT "(")
(ID "annocol")
(PUNCT "-")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "annocol")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "annocol")
(PUNCT ">")
(LIT 50)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "annocol")
(PUNCT "=")
(ID "annotate")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "+=")
(LIT " ")
(PUNCT "+")
(ID "opcode")
(PUNCT ".")
(ID "doc")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ",")
(LIT 1)
(PUNCT ")")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(ID "line")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "out")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "errormsg")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(ID "errormsg")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "stack")
(PUNCT ")")
(PUNCT "<")
(ID "numtopop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "tries to pop %d items from stack with ")
(LIT "only %d items")
(PUNCT "%")
(PUNCT "(")
(ID "numtopop")
(PUNCT ",")
(ID "len")
(PUNCT "(")
(ID "stack")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "numtopop")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "stack")
(PUNCT "[")
(PUNCT "-")
(ID "numtopop")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "markobject")
(KEYWORD in)
(ID "after")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "markobject")
(KEYWORD not)
(KEYWORD in)
(ID "before")
(NEWLINE)
(ID "markstack")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "stack")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "after")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "highest protocol among opcodes =")
(PUNCT ",")
(ID "maxproto")
(PUNCT ",")
(ID "file")
(PUNCT "=")
(ID "out")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "stack")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "stack not empty after STOP: %r")
(PUNCT "%")
(ID "stack")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "_Example")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_dis_test")
(PUNCT "=")
(LIT "\n>>> import pickle\n>>> x = [1, 2, (3, 4), {b'abc': \"def\"}]\n>>> pkl0 = pickle.dumps(x, 0)\n>>> dis(pkl0)\n    0: (    MARK\n    1: l        LIST       (MARK at 0)\n    2: p    PUT        0\n    5: L    LONG       1\n    9: a    APPEND\n   10: L    LONG       2\n   14: a    APPEND\n   15: (    MARK\n   16: L        LONG       3\n   20: L        LONG       4\n   24: t        TUPLE      (MARK at 15)\n   25: p    PUT        1\n   28: a    APPEND\n   29: (    MARK\n   30: d        DICT       (MARK at 29)\n   31: p    PUT        2\n   34: c    GLOBAL     '_codecs encode'\n   50: p    PUT        3\n   53: (    MARK\n   54: V        UNICODE    'abc'\n   59: p        PUT        4\n   62: V        UNICODE    'latin1'\n   70: p        PUT        5\n   73: t        TUPLE      (MARK at 53)\n   74: p    PUT        6\n   77: R    REDUCE\n   78: p    PUT        7\n   81: V    UNICODE    'def'\n   86: p    PUT        8\n   89: s    SETITEM\n   90: a    APPEND\n   91: .    STOP\nhighest protocol among opcodes = 0\n\nTry again with a \"binary\" pickle.\n\n>>> pkl1 = pickle.dumps(x, 1)\n>>> dis(pkl1)\n    0: ]    EMPTY_LIST\n    1: q    BINPUT     0\n    3: (    MARK\n    4: K        BININT1    1\n    6: K        BININT1    2\n    8: (        MARK\n    9: K            BININT1    3\n   11: K            BININT1    4\n   13: t            TUPLE      (MARK at 8)\n   14: q        BINPUT     1\n   16: }        EMPTY_DICT\n   17: q        BINPUT     2\n   19: c        GLOBAL     '_codecs encode'\n   35: q        BINPUT     3\n   37: (        MARK\n   38: X            BINUNICODE 'abc'\n   46: q            BINPUT     4\n   48: X            BINUNICODE 'latin1'\n   59: q            BINPUT     5\n   61: t            TUPLE      (MARK at 37)\n   62: q        BINPUT     6\n   64: R        REDUCE\n   65: q        BINPUT     7\n   67: X        BINUNICODE 'def'\n   75: q        BINPUT     8\n   77: s        SETITEM\n   78: e        APPENDS    (MARK at 3)\n   79: .    STOP\nhighest protocol among opcodes = 1\n\nExercise the INST/OBJ/BUILD family.\n\n>>> import pickletools\n>>> dis(pickle.dumps(pickletools.dis, 0))\n    0: c    GLOBAL     'pickletools dis'\n   17: p    PUT        0\n   20: .    STOP\nhighest protocol among opcodes = 0\n\n>>> from pickletools import _Example\n>>> x = [_Example(42)] * 2\n>>> dis(pickle.dumps(x, 0))\n    0: (    MARK\n    1: l        LIST       (MARK at 0)\n    2: p    PUT        0\n    5: c    GLOBAL     'copy_reg _reconstructor'\n   30: p    PUT        1\n   33: (    MARK\n   34: c        GLOBAL     'pickletools _Example'\n   56: p        PUT        2\n   59: c        GLOBAL     '__builtin__ object'\n   79: p        PUT        3\n   82: N        NONE\n   83: t        TUPLE      (MARK at 33)\n   84: p    PUT        4\n   87: R    REDUCE\n   88: p    PUT        5\n   91: (    MARK\n   92: d        DICT       (MARK at 91)\n   93: p    PUT        6\n   96: V    UNICODE    'value'\n  103: p    PUT        7\n  106: L    LONG       42\n  111: s    SETITEM\n  112: b    BUILD\n  113: a    APPEND\n  114: g    GET        5\n  117: a    APPEND\n  118: .    STOP\nhighest protocol among opcodes = 0\n\n>>> dis(pickle.dumps(x, 1))\n    0: ]    EMPTY_LIST\n    1: q    BINPUT     0\n    3: (    MARK\n    4: c        GLOBAL     'copy_reg _reconstructor'\n   29: q        BINPUT     1\n   31: (        MARK\n   32: c            GLOBAL     'pickletools _Example'\n   54: q            BINPUT     2\n   56: c            GLOBAL     '__builtin__ object'\n   76: q            BINPUT     3\n   78: N            NONE\n   79: t            TUPLE      (MARK at 31)\n   80: q        BINPUT     4\n   82: R        REDUCE\n   83: q        BINPUT     5\n   85: }        EMPTY_DICT\n   86: q        BINPUT     6\n   88: X        BINUNICODE 'value'\n   98: q        BINPUT     7\n  100: K        BININT1    42\n  102: s        SETITEM\n  103: b        BUILD\n  104: h        BINGET     5\n  106: e        APPENDS    (MARK at 3)\n  107: .    STOP\nhighest protocol among opcodes = 1\n\nTry \"the canonical\" recursive-object test.\n\n>>> L = []\n>>> T = L,\n>>> L.append(T)\n>>> L[0] is T\nTrue\n>>> T[0] is L\nTrue\n>>> L[0][0] is L\nTrue\n>>> T[0][0] is T\nTrue\n>>> dis(pickle.dumps(L, 0))\n    0: (    MARK\n    1: l        LIST       (MARK at 0)\n    2: p    PUT        0\n    5: (    MARK\n    6: g        GET        0\n    9: t        TUPLE      (MARK at 5)\n   10: p    PUT        1\n   13: a    APPEND\n   14: .    STOP\nhighest protocol among opcodes = 0\n\n>>> dis(pickle.dumps(L, 1))\n    0: ]    EMPTY_LIST\n    1: q    BINPUT     0\n    3: (    MARK\n    4: h        BINGET     0\n    6: t        TUPLE      (MARK at 3)\n    7: q    BINPUT     1\n    9: a    APPEND\n   10: .    STOP\nhighest protocol among opcodes = 1\n\nNote that, in the protocol 0 pickle of the recursive tuple, the disassembler\nhas to emulate the stack in order to realize that the POP opcode at 16 gets\nrid of the MARK at 0.\n\n>>> dis(pickle.dumps(T, 0))\n    0: (    MARK\n    1: (        MARK\n    2: l            LIST       (MARK at 1)\n    3: p        PUT        0\n    6: (        MARK\n    7: g            GET        0\n   10: t            TUPLE      (MARK at 6)\n   11: p        PUT        1\n   14: a        APPEND\n   15: 0        POP\n   16: 0        POP        (MARK at 0)\n   17: g    GET        1\n   20: .    STOP\nhighest protocol among opcodes = 0\n\n>>> dis(pickle.dumps(T, 1))\n    0: (    MARK\n    1: ]        EMPTY_LIST\n    2: q        BINPUT     0\n    4: (        MARK\n    5: h            BINGET     0\n    7: t            TUPLE      (MARK at 4)\n    8: q        BINPUT     1\n   10: a        APPEND\n   11: 1        POP_MARK   (MARK at 0)\n   12: h    BINGET     1\n   14: .    STOP\nhighest protocol among opcodes = 1\n\nTry protocol 2.\n\n>>> dis(pickle.dumps(L, 2))\n    0: \\x80 PROTO      2\n    2: ]    EMPTY_LIST\n    3: q    BINPUT     0\n    5: h    BINGET     0\n    7: \\x85 TUPLE1\n    8: q    BINPUT     1\n   10: a    APPEND\n   11: .    STOP\nhighest protocol among opcodes = 2\n\n>>> dis(pickle.dumps(T, 2))\n    0: \\x80 PROTO      2\n    2: ]    EMPTY_LIST\n    3: q    BINPUT     0\n    5: h    BINGET     0\n    7: \\x85 TUPLE1\n    8: q    BINPUT     1\n   10: a    APPEND\n   11: 0    POP\n   12: h    BINGET     1\n   14: .    STOP\nhighest protocol among opcodes = 2\n\nTry protocol 3 with annotations:\n\n>>> dis(pickle.dumps(T, 3), annotate=1)\n    0: \\x80 PROTO      3 Protocol version indicator.\n    2: ]    EMPTY_LIST   Push an empty list.\n    3: q    BINPUT     0 Store the stack top into the memo.  The stack is not popped.\n    5: h    BINGET     0 Read an object from the memo and push it on the stack.\n    7: \\x85 TUPLE1       Build a one-tuple out of the topmost item on the stack.\n    8: q    BINPUT     1 Store the stack top into the memo.  The stack is not popped.\n   10: a    APPEND       Append an object to a list.\n   11: 0    POP          Discard the top stack item, shrinking the stack by one item.\n   12: h    BINGET     1 Read an object from the memo and push it on the stack.\n   14: .    STOP         Stop the unpickling machine.\nhighest protocol among opcodes = 2\n\n")
(NEWLINE)
(ID "_memo_test")
(PUNCT "=")
(LIT "\n>>> import pickle\n>>> import io\n>>> f = io.BytesIO()\n>>> p = pickle.Pickler(f, 2)\n>>> x = [1, 2, 3]\n>>> p.dump(x)\n>>> p.dump(x)\n>>> f.seek(0)\n0\n>>> memo = {}\n>>> dis(f, memo=memo)\n    0: \\x80 PROTO      2\n    2: ]    EMPTY_LIST\n    3: q    BINPUT     0\n    5: (    MARK\n    6: K        BININT1    1\n    8: K        BININT1    2\n   10: K        BININT1    3\n   12: e        APPENDS    (MARK at 5)\n   13: .    STOP\nhighest protocol among opcodes = 2\n>>> dis(f, memo=memo)\n   14: \\x80 PROTO      2\n   16: h    BINGET     0\n   18: .    STOP\nhighest protocol among opcodes = 2\n")
(NEWLINE)
(ID "__test__")
(PUNCT "=")
(PUNCT "{")
(LIT "disassembler_test")
(PUNCT ":")
(ID "_dis_test")
(PUNCT ",")
(LIT "disassembler_memo_test")
(PUNCT ":")
(ID "_memo_test")
(PUNCT ",")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "doctest")
(NEWLINE)
(KEYWORD return)
(ID "doctest")
(PUNCT ".")
(ID "testmod")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "argparse")
(NEWLINE)
(ID "parser")
(PUNCT "=")
(ID "argparse")
(PUNCT ".")
(ID "ArgumentParser")
(PUNCT "(")
(ID "description")
(PUNCT "=")
(LIT "disassemble one or more pickle files")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "pickle_file")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "argparse")
(PUNCT ".")
(ID "FileType")
(PUNCT "(")
(LIT "br")
(PUNCT ")")
(PUNCT ",")
(ID "nargs")
(PUNCT "=")
(LIT "*")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "the pickle file")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-o")
(PUNCT ",")
(LIT "--output")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "argparse")
(PUNCT ".")
(ID "FileType")
(PUNCT "(")
(LIT "w")
(PUNCT ")")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "the file where the output should be written")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-m")
(PUNCT ",")
(LIT "--memo")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "store_true")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "preserve memo between disassemblies")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-l")
(PUNCT ",")
(LIT "--indentlevel")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(LIT 4)
(PUNCT ",")
(ID "type")
(PUNCT "=")
(ID "int")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "the number of blanks by which to indent a new MARK level")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-a")
(PUNCT ",")
(LIT "--annotate")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "store_true")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "annotate each line with a short opcode description")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-p")
(PUNCT ",")
(LIT "--preamble")
(PUNCT ",")
(ID "default")
(PUNCT "=")
(LIT "==> {name} <==")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "if more than one pickle file is specified, print this before")
(LIT " each disassembly")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-t")
(PUNCT ",")
(LIT "--test")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "store_true")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "run self-test suite")
(PUNCT ")")
(NEWLINE)
(ID "parser")
(PUNCT ".")
(ID "add_argument")
(PUNCT "(")
(LIT "-v")
(PUNCT ",")
(ID "action")
(PUNCT "=")
(LIT "store_true")
(PUNCT ",")
(ID "help")
(PUNCT "=")
(LIT "run verbosely; only affects self-test run")
(PUNCT ")")
(NEWLINE)
(ID "args")
(PUNCT "=")
(ID "parser")
(PUNCT ".")
(ID "parse_args")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "args")
(PUNCT ".")
(ID "test")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "annotate")
(PUNCT "=")
(LIT 30)
(KEYWORD if)
(ID "args")
(PUNCT ".")
(ID "annotate")
(KEYWORD else)
(LIT 0)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "args")
(PUNCT ".")
(ID "pickle_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "parser")
(PUNCT ".")
(ID "print_help")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "len")
(PUNCT "(")
(ID "args")
(PUNCT ".")
(ID "pickle_file")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dis")
(PUNCT "(")
(ID "args")
(PUNCT ".")
(ID "pickle_file")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "args")
(PUNCT ".")
(ID "output")
(PUNCT ",")
(KEYWORD None)
(PUNCT ",")
(ID "args")
(PUNCT ".")
(ID "indentlevel")
(PUNCT ",")
(ID "annotate")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "memo")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(KEYWORD if)
(ID "args")
(PUNCT ".")
(ID "memo")
(KEYWORD else)
(KEYWORD None)
(NEWLINE)
(KEYWORD for)
(ID "f")
(KEYWORD in)
(ID "args")
(PUNCT ".")
(ID "pickle_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "preamble")
(PUNCT "=")
(ID "args")
(PUNCT ".")
(ID "preamble")
(PUNCT ".")
(ID "format")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(ID "f")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(NEWLINE)
(ID "args")
(PUNCT ".")
(ID "output")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(ID "preamble")
(PUNCT "+")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(ID "dis")
(PUNCT "(")
(ID "f")
(PUNCT ",")
(ID "args")
(PUNCT ".")
(ID "output")
(PUNCT ",")
(ID "memo")
(PUNCT ",")
(ID "args")
(PUNCT ".")
(ID "indentlevel")
(PUNCT ",")
(ID "annotate")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
