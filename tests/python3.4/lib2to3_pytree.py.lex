(LIT "\nPython parse tree definitions.\n\nThis is a very concrete parse tree; we need to keep every token and\neven the comments and whitespace between tokens.\n\nThere's also a pattern matching implementation here.\n")
(NEWLINE)
(ID "__author__")
(PUNCT "=")
(LIT "Guido van Rossum <guido@python.org>")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(KEYWORD from)
(ID "io")
(KEYWORD import)
(ID "StringIO")
(NEWLINE)
(ID "HUGE")
(PUNCT "=")
(LIT 2147483647)
(NEWLINE)
(ID "_type_reprs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD def)
(ID "type_repr")
(PUNCT "(")
(ID "type_num")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD global)
(ID "_type_reprs")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_type_reprs")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(PUNCT ".")
(ID "pygram")
(KEYWORD import)
(ID "python_symbols")
(NEWLINE)
(KEYWORD for)
(ID "name")
(PUNCT ",")
(ID "val")
(KEYWORD in)
(ID "python_symbols")
(PUNCT ".")
(ID "__dict__")
(PUNCT ".")
(ID "items")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(PUNCT "==")
(ID "int")
(PUNCT ":")
(ID "_type_reprs")
(PUNCT "[")
(ID "val")
(PUNCT "]")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "_type_reprs")
(PUNCT ".")
(ID "setdefault")
(PUNCT "(")
(ID "type_num")
(PUNCT ",")
(ID "type_num")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Base")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Abstract base class for Node and Leaf.\n\n    This provides some default functionality and boilerplate using the\n    template pattern.\n\n    A node may be a subnode of at most one parent.\n    ")
(NEWLINE)
(ID "type")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "parent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "children")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "was_changed")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "was_checked")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor that prevents Base from being instantiated.")
(NEWLINE)
(KEYWORD assert)
(ID "cls")
(KEYWORD is)
(KEYWORD not)
(ID "Base")
(PUNCT ",")
(LIT "Cannot instantiate Base")
(NEWLINE)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__eq__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Compare two nodes for equality.\n\n        This calls the method _eq().\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "__class__")
(KEYWORD is)
(KEYWORD not)
(ID "other")
(PUNCT ".")
(ID "__class__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NotImplemented")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_eq")
(PUNCT "(")
(ID "other")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "__hash__")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "_eq")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Compare two nodes for equality.\n\n        This is called by __eq__ and __ne__.  It is only called if the two nodes\n        have the same type.  This must be implemented by the concrete subclass.\n        Nodes should be considered equal if they have the same structure,\n        ignoring the prefix string and other context information.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clone")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a cloned (deep) copy of self.\n\n        This must be implemented by the concrete subclass.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "post_order")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a post-order iterator for the tree.\n\n        This must be implemented by the concrete subclass.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pre_order")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a pre-order iterator for the tree.\n\n        This must be implemented by the concrete subclass.\n        ")
(NEWLINE)
(KEYWORD raise)
(ID "NotImplementedError")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "replace")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "new")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Replace this node with a new one in the parent.")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "parent")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ",")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "new")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "new")
(PUNCT ",")
(ID "list")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new")
(PUNCT "=")
(PUNCT "[")
(ID "new")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(ID "l_children")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "found")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD for)
(ID "ch")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "ch")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "found")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT ",")
(ID "self")
(PUNCT ",")
(ID "new")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "new")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "l_children")
(PUNCT ".")
(ID "extend")
(PUNCT "(")
(ID "new")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "found")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "l_children")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "ch")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD assert)
(ID "found")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ",")
(ID "self")
(PUNCT ",")
(ID "new")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT "=")
(ID "l_children")
(NEWLINE)
(KEYWORD for)
(ID "x")
(KEYWORD in)
(ID "new")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "x")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "parent")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_lineno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return the line number which generated the invocant node.")
(NEWLINE)
(ID "node")
(PUNCT "=")
(ID "self")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "node")
(PUNCT ",")
(ID "Leaf")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "node")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(ID "node")
(PUNCT "=")
(ID "node")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "node")
(PUNCT ".")
(ID "lineno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "changed")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "was_changed")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "remove")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Remove the node from the tree. Returns the position of the node in its\n        parent's children before it was removed.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "node")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "node")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD del)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD return)
(ID "i")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "next_sibling")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        The node immediately following the invocant in their parent's children\n        list. If the invocant does not have a next sibling, it is None\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "parent")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "child")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "child")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(PUNCT "@")
(ID "property")
(NEWLINE)
(KEYWORD def)
(ID "prev_sibling")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        The node immediately preceding the invocant in their parent's children\n        list. If the invocant does not have a previous sibling, it is None.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "parent")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "child")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "child")
(KEYWORD is)
(ID "self")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "i")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(ID "i")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "leaves")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "child")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "child")
(PUNCT ".")
(ID "leaves")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "depth")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "parent")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT 1)
(PUNCT "+")
(ID "self")
(PUNCT ".")
(ID "parent")
(PUNCT ".")
(ID "depth")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "get_suffix")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return the string immediately following the invocant node. This is\n        effectively equivalent to node.next_sibling.prefix\n        ")
(NEWLINE)
(ID "next_sib")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "next_sibling")
(NEWLINE)
(KEYWORD if)
(ID "next_sib")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "next_sib")
(PUNCT ".")
(ID "prefix")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "version_info")
(PUNCT "<")
(PUNCT "(")
(LIT 3)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__str__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ".")
(ID "encode")
(PUNCT "(")
(LIT "ascii")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Node")
(PUNCT "(")
(ID "Base")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Concrete implementation for interior nodes.")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "children")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fixers_applied")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializer.\n\n        Takes a type constant (a symbol number >= 256), a sequence of\n        child nodes, and an optional context keyword argument.\n\n        As a side effect, the parent pointers of the children are updated.\n        ")
(NEWLINE)
(KEYWORD assert)
(ID "type")
(PUNCT ">=")
(LIT 256)
(PUNCT ",")
(ID "type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT "=")
(ID "type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "children")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "ch")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "ch")
(PUNCT ".")
(ID "parent")
(KEYWORD is)
(KEYWORD None)
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "ch")
(PUNCT ")")
(NEWLINE)
(ID "ch")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "prefix")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "prefix")
(PUNCT "=")
(ID "prefix")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "fixers_applied")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT "=")
(ID "fixers_applied")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a canonical string representation.")
(NEWLINE)
(KEYWORD return)
(LIT "%s(%s, %r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "type_repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__unicode__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        ")
(NEWLINE)
(KEYWORD return)
(LIT "")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "str")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "version_info")
(PUNCT ">")
(PUNCT "(")
(LIT 3)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__str__")
(PUNCT "=")
(ID "__unicode__")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_eq")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compare two nodes for equality.")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clone")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a cloned (deep) copy of self.")
(NEWLINE)
(KEYWORD return)
(ID "Node")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(PUNCT "[")
(ID "ch")
(PUNCT ".")
(ID "clone")
(PUNCT "(")
(PUNCT ")")
(KEYWORD for)
(ID "ch")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT "]")
(PUNCT ",")
(ID "fixers_applied")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "post_order")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a post-order iterator for the tree.")
(NEWLINE)
(KEYWORD for)
(ID "child")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "child")
(PUNCT ".")
(ID "post_order")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pre_order")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a pre-order iterator for the tree.")
(NEWLINE)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(KEYWORD for)
(ID "child")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(KEYWORD from)
(ID "child")
(PUNCT ".")
(ID "pre_order")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_prefix_getter")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        The whitespace and comments preceding this node in the input.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "prefix")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prefix_setter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "prefix")
(PUNCT "=")
(ID "prefix")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "prefix")
(PUNCT "=")
(ID "property")
(PUNCT "(")
(ID "_prefix_getter")
(PUNCT ",")
(ID "_prefix_setter")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "set_child")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "child")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Equivalent to 'node.children[i] = child'. This method also sets the\n        child's parent attribute appropriately.\n        ")
(NEWLINE)
(ID "child")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT "[")
(ID "i")
(PUNCT "]")
(PUNCT "=")
(ID "child")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "insert_child")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "i")
(PUNCT ",")
(ID "child")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Equivalent to 'node.children.insert(i, child)'. This method also sets\n        the child's parent attribute appropriately.\n        ")
(NEWLINE)
(ID "child")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "child")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "append_child")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "child")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Equivalent to 'node.children.append(child)'. This method also sets the\n        child's parent attribute appropriately.\n        ")
(NEWLINE)
(ID "child")
(PUNCT ".")
(ID "parent")
(PUNCT "=")
(ID "self")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "children")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "child")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "Leaf")
(PUNCT "(")
(ID "Base")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Concrete implementation for leaf nodes.")
(NEWLINE)
(ID "_prefix")
(PUNCT "=")
(LIT "")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "column")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fixers_applied")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializer.\n\n        Takes a type constant (a token number < 256), a string value, and an\n        optional context keyword argument.\n        ")
(NEWLINE)
(KEYWORD assert)
(LIT 0)
(PUNCT "<=")
(ID "type")
(PUNCT "<")
(LIT 256)
(PUNCT ",")
(ID "type")
(NEWLINE)
(KEYWORD if)
(ID "context")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "column")
(PUNCT ")")
(PUNCT "=")
(ID "context")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT "=")
(ID "type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT "=")
(ID "value")
(NEWLINE)
(KEYWORD if)
(ID "prefix")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT "=")
(ID "prefix")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT "=")
(ID "fixers_applied")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a canonical string representation.")
(NEWLINE)
(KEYWORD return)
(LIT "%s(%r, %r)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__unicode__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "prefix")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "version_info")
(PUNCT ">")
(PUNCT "(")
(LIT 3)
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "__str__")
(PUNCT "=")
(ID "__unicode__")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_eq")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "other")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Compare two nodes for equality.")
(NEWLINE)
(KEYWORD return)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(PUNCT "==")
(PUNCT "(")
(ID "other")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "other")
(PUNCT ".")
(ID "value")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "clone")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a cloned (deep) copy of self.")
(NEWLINE)
(KEYWORD return)
(ID "Leaf")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "value")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "prefix")
(PUNCT ",")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "lineno")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "column")
(PUNCT ")")
(PUNCT ")")
(PUNCT ",")
(ID "fixers_applied")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "fixers_applied")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "leaves")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "post_order")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a post-order iterator for the tree.")
(NEWLINE)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "pre_order")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a pre-order iterator for the tree.")
(NEWLINE)
(KEYWORD yield)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prefix_getter")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        The whitespace and comments preceding this token in the input.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_prefix")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_prefix_setter")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "changed")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_prefix")
(PUNCT "=")
(ID "prefix")
(NEWLINE)
(DEDENT)
(ID "prefix")
(PUNCT "=")
(ID "property")
(PUNCT "(")
(ID "_prefix_getter")
(PUNCT ",")
(ID "_prefix_setter")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "convert")
(PUNCT "(")
(ID "gr")
(PUNCT ",")
(ID "raw_node")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Convert raw node information to a Node or Leaf instance.\n\n    This is passed to the parser driver which calls it whenever a reduction of a\n    grammar rule produces a new complete node, so that the tree is build\n    strictly bottom-up.\n    ")
(NEWLINE)
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT ",")
(ID "children")
(PUNCT "=")
(ID "raw_node")
(NEWLINE)
(KEYWORD if)
(ID "children")
(KEYWORD or)
(ID "type")
(KEYWORD in)
(ID "gr")
(PUNCT ".")
(ID "number2symbol")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "children")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "children")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "Node")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "children")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "Leaf")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "context")
(PUNCT "=")
(ID "context")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "BasePattern")
(PUNCT "(")
(ID "object")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A pattern is a tree matching pattern.\n\n    It looks for a specific node type (token or symbol), and\n    optionally for a specific content.\n\n    This is an abstract base class.  There are three concrete\n    subclasses:\n\n    - LeafPattern matches a single leaf node;\n    - NodePattern matches a single node (usually non-leaf);\n    - WildcardPattern matches a sequence of nodes of variable length.\n    ")
(NEWLINE)
(ID "type")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "content")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "name")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kwds")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Constructor that prevents BasePattern from being instantiated.")
(NEWLINE)
(KEYWORD assert)
(ID "cls")
(KEYWORD is)
(KEYWORD not)
(ID "BasePattern")
(PUNCT ",")
(LIT "Cannot instantiate BasePattern")
(NEWLINE)
(KEYWORD return)
(ID "object")
(PUNCT ".")
(ID "__new__")
(PUNCT "(")
(ID "cls")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__repr__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "args")
(PUNCT "=")
(PUNCT "[")
(ID "type_repr")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "args")
(KEYWORD and)
(ID "args")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD del)
(ID "args")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "%s(%s)")
(PUNCT "%")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "__class__")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(LIT ", ")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "repr")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "optimize")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        A subclass can define this as a hook for optimizations.\n\n        Returns either self or another node with the same effect.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Does this pattern exactly match a node?\n\n        Returns True if it matches, False if not.\n\n        If results is not None, it must be a dict which will be\n        updated with the nodes matching named subpatterns.\n\n        Default implementation for non-wildcard patterns.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "type")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "node")
(PUNCT ".")
(ID "type")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "results")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_submatch")
(PUNCT "(")
(ID "node")
(PUNCT ",")
(ID "r")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "r")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "results")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "results")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "results")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "node")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match_seq")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Does this pattern exactly match a sequence of nodes?\n\n        Default implementation for non-wildcard patterns.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT "!=")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "nodes")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "generate_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Generator yielding all matches for this pattern.\n\n        Default implementation for non-wildcard patterns.\n        ")
(NEWLINE)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "nodes")
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "nodes")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "r")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT 1)
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "LeafPattern")
(PUNCT "(")
(ID "BasePattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "content")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializer.  Takes optional type, content, and name.\n\n        The type, if given must be a token type (< 256).  If not given,\n        this matches any *leaf* node; the content may still be required.\n\n        The content, if given, must be a string.\n\n        If a name is given, the matching node is stored in the results\n        dict under that key.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "type")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(LIT 0)
(PUNCT "<=")
(ID "type")
(PUNCT "<")
(LIT 256)
(PUNCT ",")
(ID "type")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "content")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT "=")
(ID "type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "=")
(ID "content")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Override match() to insist on a leaf node.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "node")
(PUNCT ",")
(ID "Leaf")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "BasePattern")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_submatch")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Match the pattern's content to the node's children.\n\n        This assumes the node type matches and self.content is not None.\n\n        Returns True if it matches, False if not.\n\n        If results is not None, it must be a dict which will be\n        updated with the nodes matching named subpatterns.\n\n        When returning False, the results dict may still be updated.\n        ")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "==")
(ID "node")
(PUNCT ".")
(ID "value")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "NodePattern")
(PUNCT "(")
(ID "BasePattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "wildcards")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "content")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializer.  Takes optional type, content, and name.\n\n        The type, if given, must be a symbol type (>= 256).  If the\n        type is None this matches *any* single node (leaf or not),\n        except if content is not None, in which it only matches\n        non-leaf nodes that also match the content pattern.\n\n        The content, if not None, must be a sequence of Patterns that\n        must match the node's children exactly.  If the content is\n        given, the type must not be None.\n\n        If a name is given, the matching node is stored in the results\n        dict under that key.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "type")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "type")
(PUNCT ">=")
(LIT 256)
(PUNCT ",")
(ID "type")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(KEYWORD not)
(ID "isinstance")
(PUNCT "(")
(ID "content")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(NEWLINE)
(ID "content")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "item")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(ID "BasePattern")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "item")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "item")
(PUNCT ",")
(ID "WildcardPattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "wildcards")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "type")
(PUNCT "=")
(ID "type")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "=")
(ID "content")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_submatch")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Match the pattern's content to the node's children.\n\n        This assumes the node type matches and self.content is not None.\n\n        Returns True if it matches, False if not.\n\n        If results is not None, it must be a dict which will be\n        updated with the nodes matching named subpatterns.\n\n        When returning False, the results dict may still be updated.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "wildcards")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c")
(PUNCT ",")
(ID "r")
(KEYWORD in)
(ID "generate_matches")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ",")
(ID "node")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "node")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "results")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "results")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ")")
(PUNCT "!=")
(ID "len")
(PUNCT "(")
(ID "node")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "subpattern")
(PUNCT ",")
(ID "child")
(KEYWORD in)
(ID "zip")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ",")
(ID "node")
(PUNCT ".")
(ID "children")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "subpattern")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "child")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "WildcardPattern")
(PUNCT "(")
(ID "BasePattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    A wildcard pattern can match zero or more nodes.\n\n    This has all the flexibility needed to implement patterns like:\n\n    .*      .+      .?      .{m,n}\n    (a b c | d e | f)\n    (...)*  (...)+  (...)?  (...){m,n}\n\n    except it always uses non-greedy matching.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "content")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "min")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "max")
(PUNCT "=")
(ID "HUGE")
(PUNCT ",")
(ID "name")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializer.\n\n        Args:\n            content: optional sequence of subsequences of patterns;\n                     if absent, matches one node;\n                     if present, each subsequence is an alternative [*]\n            min: optional minimum number of times to match, default 0\n            max: optional maximum number of times to match, default HUGE\n            name: optional name assigned to this match\n\n        [*] Thus, if content is [[a, b, c], [d, e], [f, g, h]] this is\n            equivalent to (a b c | d e | f g h); if content is None,\n            this is equivalent to '.' in regular expression terms.\n            The min and max parameters work as follows:\n                min=0, max=maxint: .*\n                min=1, max=maxint: .+\n                min=0, max=1: .?\n                min=1, max=1: .\n            If content is not None, replace the dot with the parenthesized\n            list of alternatives, e.g. (a b c | d e | f g h)*\n        ")
(NEWLINE)
(KEYWORD assert)
(LIT 0)
(PUNCT "<=")
(ID "min")
(PUNCT "<=")
(ID "max")
(PUNCT "<=")
(ID "HUGE")
(PUNCT ",")
(PUNCT "(")
(ID "min")
(PUNCT ",")
(ID "max")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "content")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "tuple")
(PUNCT ",")
(ID "content")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "alt")
(KEYWORD in)
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "len")
(PUNCT "(")
(ID "alt")
(PUNCT ")")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "alt")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "=")
(ID "content")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT "=")
(ID "min")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "max")
(PUNCT "=")
(ID "max")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "=")
(ID "name")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "optimize")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Optimize certain stacked wildcard patterns.")
(NEWLINE)
(ID "subpattern")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT "==")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "subpattern")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT "==")
(LIT 1)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "max")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "content")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "NodePattern")
(PUNCT "(")
(ID "name")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "subpattern")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "subpattern")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "subpattern")
(PUNCT ".")
(ID "optimize")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT "<=")
(LIT 1)
(KEYWORD and)
(ID "isinstance")
(PUNCT "(")
(ID "subpattern")
(PUNCT ",")
(ID "WildcardPattern")
(PUNCT ")")
(KEYWORD and)
(ID "subpattern")
(PUNCT ".")
(ID "min")
(PUNCT "<=")
(LIT 1)
(KEYWORD and)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(ID "subpattern")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "WildcardPattern")
(PUNCT "(")
(ID "subpattern")
(PUNCT ".")
(ID "content")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT "*")
(ID "subpattern")
(PUNCT ".")
(ID "min")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "max")
(PUNCT "*")
(ID "subpattern")
(PUNCT ".")
(ID "max")
(PUNCT ",")
(ID "subpattern")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Does this pattern exactly match a node?")
(NEWLINE)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "match_seq")
(PUNCT "(")
(PUNCT "[")
(ID "node")
(PUNCT "]")
(PUNCT ",")
(ID "results")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match_seq")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ",")
(ID "results")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Does this pattern exactly match a sequence of nodes?")
(NEWLINE)
(KEYWORD for)
(ID "c")
(PUNCT ",")
(ID "r")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "generate_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "results")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "results")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "results")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "generate_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Generator yielding matches for a sequence of nodes.\n\n        Args:\n            nodes: sequence of nodes\n\n        Yields:\n            (count, results) tuples where:\n            count: the match comprises nodes[:count];\n            results: dict containing named submatches.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "content")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "count")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT ",")
(LIT 1)
(PUNCT "+")
(ID "min")
(PUNCT "(")
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "max")
(PUNCT ")")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "nodes")
(PUNCT "[")
(PUNCT ":")
(ID "count")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "count")
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "bare_name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "self")
(PUNCT ".")
(ID "_bare_name_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "sys")
(PUNCT ",")
(LIT "getrefcount")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "save_stderr")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stderr")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT "=")
(ID "StringIO")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "count")
(PUNCT ",")
(ID "r")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_recursive_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT ",")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "nodes")
(PUNCT "[")
(PUNCT ":")
(ID "count")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "count")
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "RuntimeError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "count")
(PUNCT ",")
(ID "r")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_iterative_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "nodes")
(PUNCT "[")
(PUNCT ":")
(ID "count")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(ID "count")
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "sys")
(PUNCT ",")
(LIT "getrefcount")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stderr")
(PUNCT "=")
(ID "save_stderr")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_iterative_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to iteratively yield the matches.")
(NEWLINE)
(ID "nodelen")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(LIT 0)
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT 0)
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(ID "results")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "alt")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c")
(PUNCT ",")
(ID "r")
(KEYWORD in)
(ID "generate_matches")
(PUNCT "(")
(ID "alt")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "c")
(PUNCT ",")
(ID "r")
(NEWLINE)
(ID "results")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "c")
(PUNCT ",")
(ID "r")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD while)
(ID "results")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "new_results")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "c0")
(PUNCT ",")
(ID "r0")
(KEYWORD in)
(ID "results")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c0")
(PUNCT "<")
(ID "nodelen")
(KEYWORD and)
(ID "c0")
(PUNCT "<=")
(ID "self")
(PUNCT ".")
(ID "max")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "alt")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c1")
(PUNCT ",")
(ID "r1")
(KEYWORD in)
(ID "generate_matches")
(PUNCT "(")
(ID "alt")
(PUNCT ",")
(ID "nodes")
(PUNCT "[")
(ID "c0")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "c1")
(PUNCT ">")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r0")
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r1")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "c0")
(PUNCT "+")
(ID "c1")
(PUNCT ",")
(ID "r")
(NEWLINE)
(ID "new_results")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "c0")
(PUNCT "+")
(ID "c1")
(PUNCT ",")
(ID "r")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "results")
(PUNCT "=")
(ID "new_results")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "_bare_name_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Special optimized matcher for bare_name.")
(NEWLINE)
(ID "count")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "done")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "max")
(PUNCT "=")
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(KEYWORD not)
(ID "done")
(KEYWORD and)
(ID "count")
(PUNCT "<")
(ID "max")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "done")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD for)
(ID "leaf")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "leaf")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "nodes")
(PUNCT "[")
(ID "count")
(PUNCT "]")
(PUNCT ",")
(ID "r")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "count")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "done")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "r")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "name")
(PUNCT "]")
(PUNCT "=")
(ID "nodes")
(PUNCT "[")
(PUNCT ":")
(ID "count")
(PUNCT "]")
(NEWLINE)
(KEYWORD return)
(ID "count")
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_recursive_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ",")
(ID "count")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Helper to recursively yield the matches.")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "count")
(PUNCT ">=")
(ID "self")
(PUNCT ".")
(ID "min")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT 0)
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "count")
(PUNCT "<")
(ID "self")
(PUNCT ".")
(ID "max")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "alt")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c0")
(PUNCT ",")
(ID "r0")
(KEYWORD in)
(ID "generate_matches")
(PUNCT "(")
(ID "alt")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c1")
(PUNCT ",")
(ID "r1")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_recursive_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT "[")
(ID "c0")
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(ID "count")
(PUNCT "+")
(LIT 1)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r0")
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r1")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "c0")
(PUNCT "+")
(ID "c1")
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD class)
(ID "NegatedPattern")
(PUNCT "(")
(ID "BasePattern")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "content")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n        Initializer.\n\n        The argument is either a pattern or None.  If it is None, this\n        only matches an empty sequence (effectively '$' in regex\n        lingo).  If it is not None, this matches whenever the argument\n        pattern doesn't have any matches.\n        ")
(NEWLINE)
(KEYWORD if)
(ID "content")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(ID "isinstance")
(PUNCT "(")
(ID "content")
(PUNCT ",")
(ID "BasePattern")
(PUNCT ")")
(PUNCT ",")
(ID "repr")
(PUNCT "(")
(ID "content")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT "=")
(ID "content")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "node")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "match_seq")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "generate_matches")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "content")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "len")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT "==")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT 0)
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c")
(PUNCT ",")
(ID "r")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "content")
(PUNCT ".")
(ID "generate_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD yield)
(LIT 0)
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "generate_matches")
(PUNCT "(")
(ID "patterns")
(PUNCT ",")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Generator yielding matches for a sequence of patterns and nodes.\n\n    Args:\n        patterns: a sequence of patterns\n        nodes: a sequence of nodes\n\n    Yields:\n        (count, results) tuples where:\n        count: the entire sequence of patterns matches nodes[:count];\n        results: dict containing named submatches.\n        ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "patterns")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(LIT 0)
(PUNCT ",")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "p")
(PUNCT ",")
(ID "rest")
(PUNCT "=")
(ID "patterns")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ",")
(ID "patterns")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "c0")
(PUNCT ",")
(ID "r0")
(KEYWORD in)
(ID "p")
(PUNCT ".")
(ID "generate_matches")
(PUNCT "(")
(ID "nodes")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "rest")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD yield)
(ID "c0")
(PUNCT ",")
(ID "r0")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "c1")
(PUNCT ",")
(ID "r1")
(KEYWORD in)
(ID "generate_matches")
(PUNCT "(")
(ID "rest")
(PUNCT ",")
(ID "nodes")
(PUNCT "[")
(ID "c0")
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "r")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r0")
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "update")
(PUNCT "(")
(ID "r1")
(PUNCT ")")
(NEWLINE)
(KEYWORD yield)
(ID "c0")
(PUNCT "+")
(ID "c1")
(PUNCT ",")
(ID "r")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
