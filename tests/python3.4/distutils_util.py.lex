(LIT "distutils.util\n\nMiscellaneous utility functions -- anything that doesn't fit into\none of the other *util.py modules.\n")
(NEWLINE)
(KEYWORD import)
(ID "os")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD import)
(ID "importlib")
(PUNCT ".")
(ID "util")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(NEWLINE)
(KEYWORD import)
(ID "string")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "errors")
(KEYWORD import)
(ID "DistutilsPlatformError")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "dep_util")
(KEYWORD import)
(ID "newer")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "spawn")
(KEYWORD import)
(ID "spawn")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(KEYWORD import)
(ID "log")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "errors")
(KEYWORD import)
(ID "DistutilsByteCompileError")
(NEWLINE)
(KEYWORD def)
(ID "get_platform")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a string that identifies the current platform.  This is used\n    mainly to distinguish platform-specific build directories and\n    platform-specific built distributions.  Typically includes the OS name\n    and version and the architecture (as supplied by 'os.uname()'),\n    although the exact information included depends on the OS; eg. for IRIX\n    the architecture isn't particularly important (IRIX only runs on SGI\n    hardware), but for Linux the kernel version isn't particularly\n    important.\n\n    Examples of returned values:\n       linux-i586\n       linux-alpha (?)\n       solaris-2.6-sun4u\n       irix-5.3\n       irix64-6.2\n\n    Windows will return one of:\n       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)\n       win-ia64 (64bit Windows on Itanium)\n       win32 (all others - specifically, sys.platform is returned)\n\n    For other non-POSIX platforms, currently just returns 'sys.platform'.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "prefix")
(PUNCT "=")
(LIT " bit (")
(NEWLINE)
(ID "i")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "version")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "i")
(PUNCT "==")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "platform")
(NEWLINE)
(DEDENT)
(ID "j")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "version")
(PUNCT ".")
(ID "find")
(PUNCT "(")
(LIT ")")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(NEWLINE)
(ID "look")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "version")
(PUNCT "[")
(ID "i")
(PUNCT "+")
(ID "len")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(ID "j")
(PUNCT "]")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "look")
(PUNCT "==")
(LIT "amd64")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "win-amd64")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "look")
(PUNCT "==")
(LIT "itanium")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "win-ia64")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "platform")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "_PYTHON_HOST_PLATFORM")
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(LIT "_PYTHON_HOST_PLATFORM")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "!=")
(LIT "posix")
(KEYWORD or)
(KEYWORD not)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "uname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "sys")
(PUNCT ".")
(ID "platform")
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "osname")
(PUNCT ",")
(ID "host")
(PUNCT ",")
(ID "release")
(PUNCT ",")
(ID "version")
(PUNCT ",")
(ID "machine")
(PUNCT ")")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "uname")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "osname")
(PUNCT "=")
(ID "osname")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "/")
(PUNCT ",")
(LIT "")
(PUNCT ")")
(NEWLINE)
(ID "machine")
(PUNCT "=")
(ID "machine")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT " ")
(PUNCT ",")
(LIT "_")
(PUNCT ")")
(NEWLINE)
(ID "machine")
(PUNCT "=")
(ID "machine")
(PUNCT ".")
(ID "replace")
(PUNCT "(")
(LIT "/")
(PUNCT ",")
(LIT "-")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "osname")
(PUNCT "[")
(PUNCT ":")
(LIT 5)
(PUNCT "]")
(PUNCT "==")
(LIT "linux")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s-%s")
(PUNCT "%")
(PUNCT "(")
(ID "osname")
(PUNCT ",")
(ID "machine")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "osname")
(PUNCT "[")
(PUNCT ":")
(LIT 5)
(PUNCT "]")
(PUNCT "==")
(LIT "sunos")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "release")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ">=")
(LIT "5")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "osname")
(PUNCT "=")
(LIT "solaris")
(NEWLINE)
(ID "release")
(PUNCT "=")
(LIT "%d.%s")
(PUNCT "%")
(PUNCT "(")
(ID "int")
(PUNCT "(")
(ID "release")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT ")")
(PUNCT "-")
(LIT 3)
(PUNCT ",")
(ID "release")
(PUNCT "[")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "bitness")
(PUNCT "=")
(PUNCT "{")
(LIT 2147483647)
(PUNCT ":")
(LIT "32bit")
(PUNCT ",")
(LIT 9223372036854775807)
(PUNCT ":")
(LIT "64bit")
(PUNCT "}")
(NEWLINE)
(ID "machine")
(PUNCT "+=")
(LIT ".%s")
(PUNCT "%")
(ID "bitness")
(PUNCT "[")
(ID "sys")
(PUNCT ".")
(ID "maxsize")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "osname")
(PUNCT "[")
(PUNCT ":")
(LIT 4)
(PUNCT "]")
(PUNCT "==")
(LIT "irix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s-%s")
(PUNCT "%")
(PUNCT "(")
(ID "osname")
(PUNCT ",")
(ID "release")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "osname")
(PUNCT "[")
(PUNCT ":")
(LIT 3)
(PUNCT "]")
(PUNCT "==")
(LIT "aix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "%s-%s.%s")
(PUNCT "%")
(PUNCT "(")
(ID "osname")
(PUNCT ",")
(ID "version")
(PUNCT ",")
(ID "release")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "osname")
(PUNCT "[")
(PUNCT ":")
(LIT 6)
(PUNCT "]")
(PUNCT "==")
(LIT "cygwin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "osname")
(PUNCT "=")
(LIT "cygwin")
(NEWLINE)
(ID "rel_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "[\\d.]+")
(PUNCT ",")
(ID "re")
(PUNCT ".")
(ID "ASCII")
(PUNCT ")")
(NEWLINE)
(ID "m")
(PUNCT "=")
(ID "rel_re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "release")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "m")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "release")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "osname")
(PUNCT "[")
(PUNCT ":")
(LIT 6)
(PUNCT "]")
(PUNCT "==")
(LIT "darwin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "_osx_support")
(PUNCT ",")
(ID "distutils")
(PUNCT ".")
(ID "sysconfig")
(NEWLINE)
(ID "osname")
(PUNCT ",")
(ID "release")
(PUNCT ",")
(ID "machine")
(PUNCT "=")
(ID "_osx_support")
(PUNCT ".")
(ID "get_platform_osx")
(PUNCT "(")
(ID "distutils")
(PUNCT ".")
(ID "sysconfig")
(PUNCT ".")
(ID "get_config_vars")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "osname")
(PUNCT ",")
(ID "release")
(PUNCT ",")
(ID "machine")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(LIT "%s-%s-%s")
(PUNCT "%")
(PUNCT "(")
(ID "osname")
(PUNCT ",")
(ID "release")
(PUNCT ",")
(ID "machine")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "convert_path")
(PUNCT "(")
(ID "pathname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return 'pathname' as a name that will work on the native filesystem,\n    i.e. split it on '/' and put it back together again using the current\n    directory separator.  Needed because filenames in the setup script are\n    always supplied in Unix style, and have to be converted to the local\n    convention before we can actually use them in the filesystem.  Raises\n    ValueError on non-Unix-ish systems if 'pathname' either starts or\n    ends with a slash.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "sep")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "pathname")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "pathname")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "pathname")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pathname")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "path '%s' cannot be absolute")
(PUNCT "%")
(ID "pathname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pathname")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "==")
(LIT "/")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "path '%s' cannot end with '/'")
(PUNCT "%")
(ID "pathname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "paths")
(PUNCT "=")
(ID "pathname")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "/")
(PUNCT ")")
(NEWLINE)
(KEYWORD while)
(LIT ".")
(KEYWORD in)
(ID "paths")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "paths")
(PUNCT ".")
(ID "remove")
(PUNCT "(")
(LIT ".")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "paths")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "curdir")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(PUNCT "*")
(ID "paths")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "change_root")
(PUNCT "(")
(ID "new_root")
(PUNCT ",")
(ID "pathname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return 'pathname' with 'new_root' prepended.  If 'pathname' is\n    relative, this is equivalent to \"os.path.join(new_root,pathname)\".\n    Otherwise, it requires making 'pathname' relative and then joining the\n    two, which is tricky on DOS/Windows and Mac OS.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "posix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "isabs")
(PUNCT "(")
(ID "pathname")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "new_root")
(PUNCT ",")
(ID "pathname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "new_root")
(PUNCT ",")
(ID "pathname")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD elif)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "nt")
(PUNCT ":")
(NEWLINE)
(INDENT)
(PUNCT "(")
(ID "drive")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitdrive")
(PUNCT "(")
(ID "pathname")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "path")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(PUNCT "==")
(LIT "\\")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "path")
(PUNCT "=")
(ID "path")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "new_root")
(PUNCT ",")
(ID "path")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DistutilsPlatformError")
(PUNCT "(")
(LIT "nothing known about platform '%s'")
(PUNCT "%")
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "_environ_checked")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD def)
(ID "check_environ")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Ensure that 'os.environ' has all the environment variables we\n    guarantee that users can use in config files, command-line options,\n    etc.  Currently this includes:\n      HOME - user's home directory (Unix only)\n      PLAT - description of the current platform, including hardware\n             and OS (see 'get_platform()')\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_environ_checked")
(NEWLINE)
(KEYWORD if)
(ID "_environ_checked")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "os")
(PUNCT ".")
(ID "name")
(PUNCT "==")
(LIT "posix")
(KEYWORD and)
(LIT "HOME")
(KEYWORD not)
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "pwd")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(LIT "HOME")
(PUNCT "]")
(PUNCT "=")
(ID "pwd")
(PUNCT ".")
(ID "getpwuid")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "getuid")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT "[")
(LIT 5)
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "PLAT")
(KEYWORD not)
(KEYWORD in)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(LIT "PLAT")
(PUNCT "]")
(PUNCT "=")
(ID "get_platform")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_environ_checked")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "subst_vars")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "local_vars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Perform shell/Perl-style variable substitution on 'string'.  Every\n    occurrence of '$' followed by a name is considered a variable, and\n    variable is substituted by the value found in the 'local_vars'\n    dictionary, or in 'os.environ' if it's not in 'local_vars'.\n    'os.environ' is first checked/augmented to guarantee that it contains\n    certain values: see 'check_environ()'.  Raise ValueError for any\n    variables not found in either 'local_vars' or 'os.environ'.\n    ")
(NEWLINE)
(ID "check_environ")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD def)
(ID "_subst")
(PUNCT "(")
(ID "match")
(PUNCT ",")
(ID "local_vars")
(PUNCT "=")
(ID "local_vars")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "var_name")
(PUNCT "=")
(ID "match")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "var_name")
(KEYWORD in)
(ID "local_vars")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "str")
(PUNCT "(")
(ID "local_vars")
(PUNCT "[")
(ID "var_name")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "os")
(PUNCT ".")
(ID "environ")
(PUNCT "[")
(ID "var_name")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "re")
(PUNCT ".")
(ID "sub")
(PUNCT "(")
(LIT "\\$([a-zA-Z_][a-zA-Z_0-9]*)")
(PUNCT ",")
(ID "_subst")
(PUNCT ",")
(ID "s")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "KeyError")
(KEYWORD as)
(ID "var")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid variable '$%s'")
(PUNCT "%")
(ID "var")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "grok_environment_error")
(PUNCT "(")
(ID "exc")
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(LIT "error: ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "prefix")
(PUNCT "+")
(ID "str")
(PUNCT "(")
(ID "exc")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_wordchars_re")
(PUNCT "=")
(ID "_squote_re")
(PUNCT "=")
(ID "_dquote_re")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "_init_regex")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD global)
(ID "_wordchars_re")
(PUNCT ",")
(ID "_squote_re")
(PUNCT ",")
(ID "_dquote_re")
(NEWLINE)
(ID "_wordchars_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "[^\\\\\\'\\\"%s ]*")
(PUNCT "%")
(ID "string")
(PUNCT ".")
(ID "whitespace")
(PUNCT ")")
(NEWLINE)
(ID "_squote_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "'(?:[^'\\\\]|\\\\.)*'")
(PUNCT ")")
(NEWLINE)
(ID "_dquote_re")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "compile")
(PUNCT "(")
(LIT "\"(?:[^\"\\\\]|\\\\.)*\"")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "split_quoted")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Split a string up according to Unix shell-like rules for quotes and\n    backslashes.  In short: words are delimited by spaces, as long as those\n    spaces are not escaped by a backslash, or inside a quoted string.\n    Single and double quotes are equivalent, and the quote characters can\n    be backslash-escaped.  The backslash is stripped from any two-character\n    escape sequence, leaving only the escaped character.  The quote\n    characters are stripped from any quoted string.  Returns a list of\n    words.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "_wordchars_re")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(ID "_init_regex")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "words")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD while)
(ID "s")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "_wordchars_re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "pos")
(PUNCT ")")
(NEWLINE)
(ID "end")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "end")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "words")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(KEYWORD in)
(ID "string")
(PUNCT ".")
(ID "whitespace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "words")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(PUNCT "]")
(PUNCT ".")
(ID "lstrip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(PUNCT "==")
(LIT "\\")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(ID "end")
(PUNCT "]")
(PUNCT "+")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "end")
(PUNCT "+")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(PUNCT "==")
(LIT "'")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "_squote_re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(PUNCT "==")
(LIT "\"")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "m")
(PUNCT "=")
(ID "_dquote_re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(ID "s")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "this can't happen (bad char '%c')")
(PUNCT "%")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "m")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "bad string (mismatched %s quotes?)")
(PUNCT "%")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT "]")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(PUNCT "(")
(ID "beg")
(PUNCT ",")
(ID "end")
(PUNCT ")")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "span")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT "=")
(ID "s")
(PUNCT "[")
(PUNCT ":")
(ID "beg")
(PUNCT "]")
(PUNCT "+")
(ID "s")
(PUNCT "[")
(ID "beg")
(PUNCT "+")
(LIT 1)
(PUNCT ":")
(ID "end")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(PUNCT "+")
(ID "s")
(PUNCT "[")
(ID "end")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "pos")
(PUNCT "=")
(ID "m")
(PUNCT ".")
(ID "end")
(PUNCT "(")
(PUNCT ")")
(PUNCT "-")
(LIT 2)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "pos")
(PUNCT ">=")
(ID "len")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "words")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "s")
(PUNCT ")")
(NEWLINE)
(KEYWORD break)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(ID "words")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "execute")
(PUNCT "(")
(ID "func")
(PUNCT ",")
(ID "args")
(PUNCT ",")
(ID "msg")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Perform some action that affects the outside world (eg.  by\n    writing to the filesystem).  Such actions are special because they\n    are disabled by the 'dry_run' flag.  This method takes care of all\n    that bureaucracy for you; all you have to do is supply the\n    function to call and an argument tuple for it (to embody the\n    \"external action\" being performed), and an optional message to\n    print.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "msg")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(LIT "%s%r")
(PUNCT "%")
(PUNCT "(")
(ID "func")
(PUNCT ".")
(ID "__name__")
(PUNCT ",")
(ID "args")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "msg")
(PUNCT "[")
(PUNCT "-")
(LIT 2)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT ",)")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "msg")
(PUNCT "=")
(ID "msg")
(PUNCT "[")
(LIT 0)
(PUNCT ":")
(PUNCT "-")
(LIT 2)
(PUNCT "]")
(PUNCT "+")
(LIT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "log")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(ID "msg")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "func")
(PUNCT "(")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "strtobool")
(PUNCT "(")
(ID "val")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Convert a string representation of truth to true (1) or false (0).\n\n    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n    'val' is anything else.\n    ")
(NEWLINE)
(ID "val")
(PUNCT "=")
(ID "val")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "val")
(KEYWORD in)
(PUNCT "(")
(LIT "y")
(PUNCT ",")
(LIT "yes")
(PUNCT ",")
(LIT "t")
(PUNCT ",")
(LIT "true")
(PUNCT ",")
(LIT "on")
(PUNCT ",")
(LIT "1")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "val")
(KEYWORD in)
(PUNCT "(")
(LIT "n")
(PUNCT ",")
(LIT "no")
(PUNCT ",")
(LIT "f")
(PUNCT ",")
(LIT "false")
(PUNCT ",")
(LIT "off")
(PUNCT ",")
(LIT "0")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid truth value %r")
(PUNCT "%")
(PUNCT "(")
(ID "val")
(PUNCT ",")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "byte_compile")
(PUNCT "(")
(ID "py_files")
(PUNCT ",")
(ID "optimize")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "force")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "prefix")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "base_dir")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "verbose")
(PUNCT "=")
(LIT 1)
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "direct")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Byte-compile a collection of Python source files to either .pyc\n    or .pyo files in a __pycache__ subdirectory.  'py_files' is a list\n    of files to compile; any files that don't end in \".py\" are silently\n    skipped.  'optimize' must be one of the following:\n      0 - don't optimize (generate .pyc)\n      1 - normal optimization (like \"python -O\")\n      2 - extra optimization (like \"python -OO\")\n    If 'force' is true, all files are recompiled regardless of\n    timestamps.\n\n    The source filename encoded in each bytecode file defaults to the\n    filenames listed in 'py_files'; you can modify these with 'prefix' and\n    'basedir'.  'prefix' is a string that will be stripped off of each\n    source filename, and 'base_dir' is a directory name that will be\n    prepended (after 'prefix' is stripped).  You can supply either or both\n    (or neither) of 'prefix' and 'base_dir', as you wish.\n\n    If 'dry_run' is true, doesn't actually do anything that would\n    affect the filesystem.\n\n    Byte-compilation is either done directly in this interpreter process\n    with the standard py_compile module, or indirectly by writing a\n    temporary script and executing it.  Normally, you should let\n    'byte_compile()' figure out to use direct compilation or not (see\n    the source for details).  The 'direct' flag is used by the script\n    generated in indirect mode; unless you know what you're doing, leave\n    it set to None.\n    ")
(NEWLINE)
(KEYWORD if)
(ID "sys")
(PUNCT ".")
(ID "dont_write_bytecode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "DistutilsByteCompileError")
(PUNCT "(")
(LIT "byte-compiling is disabled.")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "direct")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "direct")
(PUNCT "=")
(PUNCT "(")
(ID "__debug__")
(KEYWORD and)
(ID "optimize")
(PUNCT "==")
(LIT 0)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "direct")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "tempfile")
(KEYWORD import)
(ID "mkstemp")
(NEWLINE)
(PUNCT "(")
(ID "script_fd")
(PUNCT ",")
(ID "script_name")
(PUNCT ")")
(PUNCT "=")
(ID "mkstemp")
(PUNCT "(")
(LIT ".py")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ImportError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "tempfile")
(KEYWORD import)
(ID "mktemp")
(NEWLINE)
(PUNCT "(")
(ID "script_fd")
(PUNCT ",")
(ID "script_name")
(PUNCT ")")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "mktemp")
(PUNCT "(")
(LIT ".py")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "log")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "writing byte-compilation script '%s'")
(PUNCT ",")
(ID "script_name")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "script_fd")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "script")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fdopen")
(PUNCT "(")
(ID "script_fd")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "script")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "script_name")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "script")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "from distutils.util import byte_compile\nfiles = [\n")
(PUNCT ")")
(NEWLINE)
(ID "script")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT ",\n")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "repr")
(PUNCT ",")
(ID "py_files")
(PUNCT ")")
(PUNCT ")")
(PUNCT "+")
(LIT "]\n")
(PUNCT ")")
(NEWLINE)
(ID "script")
(PUNCT ".")
(ID "write")
(PUNCT "(")
(LIT "\nbyte_compile(files, optimize=%r, force=%r,\n             prefix=%r, base_dir=%r,\n             verbose=%r, dry_run=0,\n             direct=1)\n")
(PUNCT "%")
(PUNCT "(")
(ID "optimize")
(PUNCT ",")
(ID "force")
(PUNCT ",")
(ID "prefix")
(PUNCT ",")
(ID "base_dir")
(PUNCT ",")
(ID "verbose")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "script")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "cmd")
(PUNCT "=")
(PUNCT "[")
(ID "sys")
(PUNCT ".")
(ID "executable")
(PUNCT ",")
(ID "script_name")
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "optimize")
(PUNCT "==")
(LIT 1)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cmd")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT "-O")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "optimize")
(PUNCT "==")
(LIT 2)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cmd")
(PUNCT ".")
(ID "insert")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT "-OO")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "spawn")
(PUNCT "(")
(ID "cmd")
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(ID "execute")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "remove")
(PUNCT ",")
(PUNCT "(")
(ID "script_name")
(PUNCT ",")
(PUNCT ")")
(PUNCT ",")
(LIT "removing %s")
(PUNCT "%")
(ID "script_name")
(PUNCT ",")
(ID "dry_run")
(PUNCT "=")
(ID "dry_run")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD from)
(ID "py_compile")
(KEYWORD import)
(ID "compile")
(NEWLINE)
(KEYWORD for)
(ID "file")
(KEYWORD in)
(ID "py_files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "file")
(PUNCT "[")
(PUNCT "-")
(LIT 3)
(PUNCT ":")
(PUNCT "]")
(PUNCT "!=")
(LIT ".py")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD continue)
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "optimize")
(PUNCT ">=")
(LIT 0)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cfile")
(PUNCT "=")
(ID "importlib")
(PUNCT ".")
(ID "util")
(PUNCT ".")
(ID "cache_from_source")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "debug_override")
(PUNCT "=")
(KEYWORD not)
(ID "optimize")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "cfile")
(PUNCT "=")
(ID "importlib")
(PUNCT ".")
(ID "util")
(PUNCT ".")
(ID "cache_from_source")
(PUNCT "(")
(ID "file")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "dfile")
(PUNCT "=")
(ID "file")
(NEWLINE)
(KEYWORD if)
(ID "prefix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "file")
(PUNCT "[")
(PUNCT ":")
(ID "len")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT "]")
(PUNCT "!=")
(ID "prefix")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "invalid prefix: filename %r doesn't start with %r")
(PUNCT "%")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "prefix")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "dfile")
(PUNCT "=")
(ID "dfile")
(PUNCT "[")
(ID "len")
(PUNCT "(")
(ID "prefix")
(PUNCT ")")
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "base_dir")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "dfile")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "base_dir")
(PUNCT ",")
(ID "dfile")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "cfile_base")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "basename")
(PUNCT "(")
(ID "cfile")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "direct")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "force")
(KEYWORD or)
(ID "newer")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "cfile")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(LIT "byte-compiling %s to %s")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "cfile_base")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "dry_run")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "compile")
(PUNCT "(")
(ID "file")
(PUNCT ",")
(ID "cfile")
(PUNCT ",")
(ID "dfile")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(LIT "skipping byte-compilation of %s to %s")
(PUNCT ",")
(ID "file")
(PUNCT ",")
(ID "cfile_base")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "rfc822_escape")
(PUNCT "(")
(ID "header")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return a version of the string escaped for inclusion in an\n    RFC-822 header, by ensuring there are 8 spaces space after each newline.\n    ")
(NEWLINE)
(ID "lines")
(PUNCT "=")
(ID "header")
(PUNCT ".")
(ID "split")
(PUNCT "(")
(LIT "\n")
(PUNCT ")")
(NEWLINE)
(ID "sep")
(PUNCT "=")
(LIT "\n")
(PUNCT "+")
(LIT 8)
(PUNCT "*")
(LIT " ")
(NEWLINE)
(KEYWORD return)
(ID "sep")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "lines")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "run_2to3")
(PUNCT "(")
(ID "files")
(PUNCT ",")
(ID "fixer_names")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "options")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "explicit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Invoke 2to3 on a list of Python files.\n    The files should all come from the build area, as the\n    modification is done in-place. To reduce the build time,\n    only files modified since the last invocation of this\n    function should be passed in the files argument.")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(NEWLINE)
(DEDENT)
(KEYWORD from)
(ID "lib2to3")
(PUNCT ".")
(ID "refactor")
(KEYWORD import)
(ID "RefactoringTool")
(PUNCT ",")
(ID "get_fixers_from_package")
(NEWLINE)
(KEYWORD class)
(ID "DistutilsRefactoringTool")
(PUNCT "(")
(ID "RefactoringTool")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "log_error")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ",")
(PUNCT "**")
(ID "kw")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT ".")
(ID "error")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log_message")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT ".")
(ID "info")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "log_debug")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "log")
(PUNCT ".")
(ID "debug")
(PUNCT "(")
(ID "msg")
(PUNCT ",")
(PUNCT "*")
(ID "args")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD if)
(ID "fixer_names")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "fixer_names")
(PUNCT "=")
(ID "get_fixers_from_package")
(PUNCT "(")
(LIT "lib2to3.fixes")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "r")
(PUNCT "=")
(ID "DistutilsRefactoringTool")
(PUNCT "(")
(ID "fixer_names")
(PUNCT ",")
(ID "options")
(PUNCT "=")
(ID "options")
(PUNCT ")")
(NEWLINE)
(ID "r")
(PUNCT ".")
(ID "refactor")
(PUNCT "(")
(ID "files")
(PUNCT ",")
(ID "write")
(PUNCT "=")
(KEYWORD True)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "copydir_run_2to3")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "dest")
(PUNCT ",")
(ID "template")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "fixer_names")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "options")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "explicit")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Recursively copy a directory, only copying new and changed files,\n    running run_2to3 over all newly copied Python modules afterward.\n\n    If you give a template string, it's parsed like a MANIFEST.in.\n    ")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "dir_util")
(KEYWORD import)
(ID "mkpath")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "file_util")
(KEYWORD import)
(ID "copy_file")
(NEWLINE)
(KEYWORD from)
(ID "distutils")
(PUNCT ".")
(ID "filelist")
(KEYWORD import)
(ID "FileList")
(NEWLINE)
(ID "filelist")
(PUNCT "=")
(ID "FileList")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "curdir")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "getcwd")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "os")
(PUNCT ".")
(ID "chdir")
(PUNCT "(")
(ID "src")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "filelist")
(PUNCT ".")
(ID "findall")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD finally)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "chdir")
(PUNCT "(")
(ID "curdir")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "filelist")
(PUNCT ".")
(ID "files")
(PUNCT "[")
(PUNCT ":")
(PUNCT "]")
(PUNCT "=")
(ID "filelist")
(PUNCT ".")
(ID "allfiles")
(NEWLINE)
(KEYWORD if)
(ID "template")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "template")
(PUNCT ".")
(ID "splitlines")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(KEYWORD continue)
(NEWLINE)
(ID "filelist")
(PUNCT ".")
(ID "process_template_line")
(PUNCT "(")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "copied")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "filename")
(KEYWORD in)
(ID "filelist")
(PUNCT ".")
(ID "files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "outname")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "dest")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(ID "mkpath")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "dirname")
(PUNCT "(")
(ID "outname")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "res")
(PUNCT "=")
(ID "copy_file")
(PUNCT "(")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "join")
(PUNCT "(")
(ID "src")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ",")
(ID "outname")
(PUNCT ",")
(ID "update")
(PUNCT "=")
(LIT 1)
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "res")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(PUNCT ":")
(ID "copied")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "outname")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "run_2to3")
(PUNCT "(")
(PUNCT "[")
(ID "fn")
(KEYWORD for)
(ID "fn")
(KEYWORD in)
(ID "copied")
(KEYWORD if)
(ID "fn")
(PUNCT ".")
(ID "lower")
(PUNCT "(")
(PUNCT ")")
(PUNCT ".")
(ID "endswith")
(PUNCT "(")
(LIT ".py")
(PUNCT ")")
(PUNCT "]")
(PUNCT ",")
(ID "fixer_names")
(PUNCT "=")
(ID "fixer_names")
(PUNCT ",")
(ID "options")
(PUNCT "=")
(ID "options")
(PUNCT ",")
(ID "explicit")
(PUNCT "=")
(ID "explicit")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "copied")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "Mixin2to3")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Mixin class for commands that run 2to3.\n    To configure 2to3, setup scripts may either change\n    the class variables, or inherit from individual commands\n    to override how 2to3 is invoked.")
(NEWLINE)
(ID "fixer_names")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "options")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "explicit")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD def)
(ID "run_2to3")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "files")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "run_2to3")
(PUNCT "(")
(ID "files")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "fixer_names")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "options")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "explicit")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ENDMARKER)
