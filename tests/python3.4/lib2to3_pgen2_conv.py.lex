(LIT "Convert graminit.[ch] spit out by pgen to Python code.\n\nPgen is the Python parser generator.  It is useful to quickly create a\nparser from a grammar file in Python's grammar notation.  But I don't\nwant my parsers to be written in C (yet), so I'm translating the\nparsing tables to Python data structures and writing a Python parse\nengine.\n\nNote that the token numbers are constants determined by the standard\nPython tokenizer.  The standard token module defines these numbers and\ntheir names (the names are not used much).  The token numbers are\nhardcoded into the Python tokenizer and into pgen.  A Python\nimplementation of the Python tokenizer is also available, in the\nstandard tokenize module.\n\nOn the other hand, symbol numbers (representing the grammar's\nnon-terminals) are assigned by pgen based on the actual grammar\ninput.\n\nNote: this module is pretty much obsolete; the pgen module generates\nequivalent grammar tables directly from the Grammar.txt input file\nwithout having to invoke the Python pgen C program.\n\n")
(NEWLINE)
(KEYWORD import)
(ID "re")
(NEWLINE)
(KEYWORD from)
(ID "pgen2")
(KEYWORD import)
(ID "grammar")
(PUNCT ",")
(ID "token")
(NEWLINE)
(KEYWORD class)
(ID "Converter")
(PUNCT "(")
(ID "grammar")
(PUNCT ".")
(ID "Grammar")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Grammar subclass that reads classic pgen output files.\n\n    The run() method reads the tables as produced by the pgen parser\n    generator, typically contained in two C files, graminit.h and\n    graminit.c.  The other methods are for internal use only.\n\n    See the base class for more documentation.\n\n    ")
(NEWLINE)
(KEYWORD def)
(ID "run")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "graminit_h")
(PUNCT ",")
(ID "graminit_c")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Load the grammar tables from the text files written by pgen.")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_graminit_h")
(PUNCT "(")
(ID "graminit_h")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "parse_graminit_c")
(PUNCT "(")
(ID "graminit_c")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "finish_off")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_graminit_h")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse the .h file written by pgen.  (Internal)\n\n        This file is a sequence of #define statements defining the\n        nonterminals of the grammar as numbers.  We build two tables\n        mapping the numbers to names and back.\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Can't open %s: %s")
(PUNCT "%")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "symbol2number")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "number2symbol")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "f")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "^#define\\s+(\\w+)\\s+(\\d+)$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "mo")
(KEYWORD and)
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "%s(%s): can't parse %s")
(PUNCT "%")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ".")
(ID "strip")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "symbol")
(PUNCT ",")
(ID "number")
(PUNCT "=")
(ID "mo")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "number")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "number")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "symbol")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "symbol2number")
(NEWLINE)
(KEYWORD assert)
(ID "number")
(KEYWORD not)
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "number2symbol")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "symbol2number")
(PUNCT "[")
(ID "symbol")
(PUNCT "]")
(PUNCT "=")
(ID "number")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "number2symbol")
(PUNCT "[")
(ID "number")
(PUNCT "]")
(PUNCT "=")
(ID "symbol")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD return)
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "parse_graminit_c")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "filename")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Parse the .c file written by pgen.  (Internal)\n\n        The file looks as follows.  The first two lines are always this:\n\n        #include \"pgenheaders.h\"\n        #include \"grammar.h\"\n\n        After that come four blocks:\n\n        1) one or more state definitions\n        2) a table defining dfas\n        3) a table defining labels\n        4) a struct defining the grammar\n\n        A state definition has the following form:\n        - one or more arc arrays, each of the form:\n          static arc arcs_<n>_<m>[<k>] = {\n                  {<i>, <j>},\n                  ...\n          };\n        - followed by a state array, of the form:\n          static state states_<s>[<t>] = {\n                  {<k>, arcs_<n>_<m>},\n                  ...\n          };\n\n        ")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "f")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(KEYWORD as)
(ID "err")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "print")
(PUNCT "(")
(LIT "Can't open %s: %s")
(PUNCT "%")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "err")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(KEYWORD False)
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "#include \"pgenheaders.h\"\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "#include \"grammar.h\"\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "allarcs")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "states")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD while)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "static arc ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD while)
(ID "line")
(PUNCT ".")
(ID "startswith")
(PUNCT "(")
(LIT "static arc ")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "static arc arcs_(\\d+)_(\\d+)\\[(\\d+)\\] = {$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "n")
(PUNCT ",")
(ID "m")
(PUNCT ",")
(ID "k")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "mo")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "arcs")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "_")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "k")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+{(\\d+), (\\d+)},$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "i")
(PUNCT ",")
(ID "j")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "mo")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "arcs")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "i")
(PUNCT ",")
(ID "j")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "};\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "allarcs")
(PUNCT "[")
(PUNCT "(")
(ID "n")
(PUNCT ",")
(ID "m")
(PUNCT ")")
(PUNCT "]")
(PUNCT "=")
(ID "arcs")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "static state states_(\\d+)\\[(\\d+)\\] = {$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "s")
(PUNCT ",")
(ID "t")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "mo")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "s")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "states")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "state")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(KEYWORD for)
(ID "_")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "t")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+{(\\d+), arcs_(\\d+)_(\\d+)},$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "k")
(PUNCT ",")
(ID "n")
(PUNCT ",")
(ID "m")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "mo")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(ID "arcs")
(PUNCT "=")
(ID "allarcs")
(PUNCT "[")
(ID "n")
(PUNCT ",")
(ID "m")
(PUNCT "]")
(NEWLINE)
(KEYWORD assert)
(ID "k")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "arcs")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "state")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "arcs")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "states")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(ID "state")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "};\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "states")
(PUNCT "=")
(ID "states")
(NEWLINE)
(ID "dfas")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "static dfa dfas\\[(\\d+)\\] = {$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "ndfas")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "ndfas")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+{(\\d+), \"(\\w+)\", (\\d+), (\\d+), states_(\\d+),$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "symbol")
(PUNCT "=")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(ID "number")
(PUNCT ",")
(ID "x")
(PUNCT ",")
(ID "y")
(PUNCT ",")
(ID "z")
(PUNCT "=")
(ID "list")
(PUNCT "(")
(ID "map")
(PUNCT "(")
(ID "int")
(PUNCT ",")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ",")
(LIT 3)
(PUNCT ",")
(LIT 4)
(PUNCT ",")
(LIT 5)
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "symbol2number")
(PUNCT "[")
(ID "symbol")
(PUNCT "]")
(PUNCT "==")
(ID "number")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "self")
(PUNCT ".")
(ID "number2symbol")
(PUNCT "[")
(ID "number")
(PUNCT "]")
(PUNCT "==")
(ID "symbol")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "x")
(PUNCT "==")
(LIT 0)
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "state")
(PUNCT "=")
(ID "states")
(PUNCT "[")
(ID "z")
(PUNCT "]")
(NEWLINE)
(KEYWORD assert)
(ID "y")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "state")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+(\"(?:\\\\\\d\\d\\d)*\")},$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "first")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "rawbitset")
(PUNCT "=")
(ID "eval")
(PUNCT "(")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(PUNCT ",")
(ID "c")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "rawbitset")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "byte")
(PUNCT "=")
(ID "ord")
(PUNCT "(")
(ID "c")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "j")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(LIT 8)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "byte")
(PUNCT "&")
(PUNCT "(")
(LIT 1)
(PUNCT "<<")
(ID "j")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "first")
(PUNCT "[")
(ID "i")
(PUNCT "*")
(LIT 8)
(PUNCT "+")
(ID "j")
(PUNCT "]")
(PUNCT "=")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "dfas")
(PUNCT "[")
(ID "number")
(PUNCT "]")
(PUNCT "=")
(PUNCT "(")
(ID "state")
(PUNCT ",")
(ID "first")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "};\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "dfas")
(PUNCT "=")
(ID "dfas")
(NEWLINE)
(ID "labels")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "static label labels\\[(\\d+)\\] = {$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "nlabels")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "i")
(KEYWORD in)
(ID "range")
(PUNCT "(")
(ID "nlabels")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+{(\\d+), (0|\"\\w+\")},$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "x")
(PUNCT ",")
(ID "y")
(PUNCT "=")
(ID "mo")
(PUNCT ".")
(ID "groups")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "x")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "x")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(ID "y")
(PUNCT "==")
(LIT "0")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "y")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "y")
(PUNCT "=")
(ID "eval")
(PUNCT "(")
(ID "y")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "labels")
(PUNCT ".")
(ID "append")
(PUNCT "(")
(PUNCT "(")
(ID "x")
(PUNCT ",")
(ID "y")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "};\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "labels")
(PUNCT "=")
(ID "labels")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "grammar _PyParser_Grammar = {\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+(\\d+),$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "ndfas")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "ndfas")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "dfas")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "\tdfas,\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+{(\\d+), labels},$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "nlabels")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "nlabels")
(PUNCT "==")
(ID "len")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "labels")
(PUNCT ")")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(ID "mo")
(PUNCT "=")
(ID "re")
(PUNCT ".")
(ID "match")
(PUNCT "(")
(LIT "\\s+(\\d+)$")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "mo")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "start")
(PUNCT "=")
(ID "int")
(PUNCT "(")
(ID "mo")
(PUNCT ".")
(ID "group")
(PUNCT "(")
(LIT 1)
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "start")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "number2symbol")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "start")
(PUNCT "=")
(ID "start")
(NEWLINE)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(KEYWORD assert)
(ID "line")
(PUNCT "==")
(LIT "};\n")
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT "=")
(ID "lineno")
(PUNCT "+")
(LIT 1)
(PUNCT ",")
(ID "next")
(PUNCT "(")
(ID "f")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD assert)
(LIT 0)
(PUNCT ",")
(PUNCT "(")
(ID "lineno")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "finish_off")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Create additional useful structures.  (Internal).")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "tokens")
(PUNCT "=")
(PUNCT "{")
(PUNCT "}")
(NEWLINE)
(KEYWORD for)
(ID "ilabel")
(PUNCT ",")
(PUNCT "(")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ")")
(KEYWORD in)
(ID "enumerate")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "labels")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "type")
(PUNCT "==")
(ID "token")
(PUNCT ".")
(ID "NAME")
(KEYWORD and)
(ID "value")
(KEYWORD is)
(KEYWORD not)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "keywords")
(PUNCT "[")
(ID "value")
(PUNCT "]")
(PUNCT "=")
(ID "ilabel")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "value")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "tokens")
(PUNCT "[")
(ID "type")
(PUNCT "]")
(PUNCT "=")
(ID "ilabel")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ENDMARKER)
