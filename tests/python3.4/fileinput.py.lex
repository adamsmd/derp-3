(LIT "Helper class to quickly write a loop over all standard input files.\n\nTypical use is:\n\n    import fileinput\n    for line in fileinput.input():\n        process(line)\n\nThis iterates over the lines of all files listed in sys.argv[1:],\ndefaulting to sys.stdin if the list is empty.  If a filename is '-' it\nis also replaced by sys.stdin.  To specify an alternative list of\nfilenames, pass it as the argument to input().  A single file name is\nalso allowed.\n\nFunctions filename(), lineno() return the filename and cumulative line\nnumber of the line that has just been read; filelineno() returns its\nline number in the current file; isfirstline() returns true iff the\nline just read is the first line of its file; isstdin() returns true\niff the line was read from sys.stdin.  Function nextfile() closes the\ncurrent file so that the next iteration will read the first line from\nthe next file (if any); lines not read from the file will not count\ntowards the cumulative line count; the filename is not changed until\nafter the first line of the next file has been read.  Function close()\ncloses the sequence.\n\nBefore any lines have been read, filename() returns None and both line\nnumbers are zero; nextfile() has no effect.  After all lines have been\nread, filename() and the line number functions return the values\npertaining to the last line read; nextfile() has no effect.\n\nAll files are opened in text mode by default, you can override this by\nsetting the mode parameter to input() or FileInput.__init__().\nIf an I/O error occurs during opening or reading a file, the OSError\nexception is raised.\n\nIf sys.stdin is used more than once, the second and further use will\nreturn no lines, except perhaps for interactive use, or if it has been\nexplicitly reset (e.g. using sys.stdin.seek(0)).\n\nEmpty files are opened and immediately closed; the only time their\npresence in the list of filenames is noticeable at all is when the\nlast file opened is empty.\n\nIt is possible that the last line of a file doesn't end in a newline\ncharacter; otherwise lines are returned including the trailing\nnewline.\n\nClass FileInput is the implementation; its methods filename(),\nlineno(), fileline(), isfirstline(), isstdin(), nextfile() and close()\ncorrespond to the functions in the module.  In addition it has a\nreadline() method which returns the next input line, and a\n__getitem__() method which implements the sequence behavior.  The\nsequence must be accessed in strictly sequential order; sequence\naccess and readline() cannot be mixed.\n\nOptional in-place filtering: if the keyword argument inplace=1 is\npassed to input() or to the FileInput constructor, the file is moved\nto a backup file and standard output is directed to the input file.\nThis makes it possible to write a filter that rewrites its input file\nin place.  If the keyword argument backup=\".<some extension>\" is also\ngiven, it specifies the extension for the backup file, and the backup\nfile remains around; by default, the extension is \".bak\" and it is\ndeleted when the output file is closed.  In-place filtering is\ndisabled when standard input is read.  XXX The current implementation\ndoes not work for MS-DOS 8+3 filesystems.\n\nPerformance: this module is unfortunately one of the slower ways of\nprocessing large numbers of input lines.  Nevertheless, a significant\nspeed-up has been obtained by using readlines(bufsize) instead of\nreadline().  A new keyword argument, bufsize=N, is present on the\ninput() function and the FileInput() class to override the default\nbuffer size.\n\nXXX Possible additions:\n\n- optional getopt argument processing\n- isatty()\n- read(), read(size), even readlines()\n\n")
(NEWLINE)
(KEYWORD import)
(ID "sys")
(PUNCT ",")
(ID "os")
(NEWLINE)
(ID "__all__")
(PUNCT "=")
(PUNCT "[")
(LIT "input")
(PUNCT ",")
(LIT "close")
(PUNCT ",")
(LIT "nextfile")
(PUNCT ",")
(LIT "filename")
(PUNCT ",")
(LIT "lineno")
(PUNCT ",")
(LIT "filelineno")
(PUNCT ",")
(LIT "isfirstline")
(PUNCT ",")
(LIT "isstdin")
(PUNCT ",")
(LIT "FileInput")
(PUNCT "]")
(NEWLINE)
(ID "_state")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "DEFAULT_BUFSIZE")
(PUNCT "=")
(LIT 8)
(PUNCT "*")
(LIT 1024)
(NEWLINE)
(KEYWORD def)
(ID "input")
(PUNCT "(")
(ID "files")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "inplace")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "backup")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "bufsize")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT "r")
(PUNCT ",")
(ID "openhook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Return an instance of the FileInput class, which can be iterated.\n\n    The parameters are passed to the constructor of the FileInput class.\n    The returned instance, in addition to being an iterator,\n    keeps global state for the functions of this module,.\n    ")
(NEWLINE)
(KEYWORD global)
(ID "_state")
(NEWLINE)
(KEYWORD if)
(ID "_state")
(KEYWORD and)
(ID "_state")
(PUNCT ".")
(ID "_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "input() already active")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "_state")
(PUNCT "=")
(ID "FileInput")
(PUNCT "(")
(ID "files")
(PUNCT ",")
(ID "inplace")
(PUNCT ",")
(ID "backup")
(PUNCT ",")
(ID "bufsize")
(PUNCT ",")
(ID "mode")
(PUNCT ",")
(ID "openhook")
(PUNCT ")")
(NEWLINE)
(KEYWORD return)
(ID "_state")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "Close the sequence.")
(NEWLINE)
(KEYWORD global)
(ID "_state")
(NEWLINE)
(ID "state")
(PUNCT "=")
(ID "_state")
(NEWLINE)
(ID "_state")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(KEYWORD if)
(ID "state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "state")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "nextfile")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Close the current file so that the next iteration will read the first\n    line from the next file (if any); lines not read from the file will\n    not count towards the cumulative line count. The filename is not\n    changed until after the first line of the next file has been read.\n    Before the first line has been read, this function has no effect;\n    it cannot be used to skip the first file. After the last line of the\n    last file has been read, this function has no effect.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "nextfile")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "filename")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the name of the file currently being read.\n    Before the first line has been read, returns None.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "filename")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "lineno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the cumulative line number of the line that has just been read.\n    Before the first line has been read, returns 0. After the last line\n    of the last file has been read, returns the line number of that line.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "lineno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "filelineno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the line number in the current file. Before the first line\n    has been read, returns 0. After the last line of the last file has\n    been read, returns the line number of that line within the file.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "filelineno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Return the file number of the current file. When no file is currently\n    opened, returns -1.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isfirstline")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Returns true the line just read is the first line of its file,\n    otherwise returns false.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "isfirstline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isstdin")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "\n    Returns true if the last line was read from sys.stdin,\n    otherwise returns false.\n    ")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "_state")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "no active input()")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "_state")
(PUNCT ".")
(ID "isstdin")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD class)
(ID "FileInput")
(PUNCT ":")
(NEWLINE)
(INDENT)
(LIT "FileInput([files[, inplace[, backup[, bufsize, [, mode[, openhook]]]]]])\n\n    Class FileInput is the implementation of the module; its methods\n    filename(), lineno(), fileline(), isfirstline(), isstdin(), fileno(),\n    nextfile() and close() correspond to the functions of the same name\n    in the module.\n    In addition it has a readline() method which returns the next\n    input line, and a __getitem__() method which implements the\n    sequence behavior. The sequence must be accessed in strictly\n    sequential order; random access and readline() cannot be mixed.\n    ")
(NEWLINE)
(KEYWORD def)
(ID "__init__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "files")
(PUNCT "=")
(KEYWORD None)
(PUNCT ",")
(ID "inplace")
(PUNCT "=")
(KEYWORD False)
(PUNCT ",")
(ID "backup")
(PUNCT "=")
(LIT "")
(PUNCT ",")
(ID "bufsize")
(PUNCT "=")
(LIT 0)
(PUNCT ",")
(ID "mode")
(PUNCT "=")
(LIT "r")
(PUNCT ",")
(ID "openhook")
(PUNCT "=")
(KEYWORD None)
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "isinstance")
(PUNCT "(")
(ID "files")
(PUNCT ",")
(ID "str")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(PUNCT "(")
(ID "files")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "files")
(KEYWORD is)
(KEYWORD None)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(PUNCT "(")
(LIT "-")
(PUNCT ",")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "files")
(PUNCT "=")
(ID "tuple")
(PUNCT "(")
(ID "files")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_files")
(PUNCT "=")
(ID "files")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_inplace")
(PUNCT "=")
(ID "inplace")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_backup")
(PUNCT "=")
(ID "backup")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_bufsize")
(PUNCT "=")
(ID "bufsize")
(KEYWORD or)
(ID "DEFAULT_BUFSIZE")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_savestdout")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_output")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_lineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_filelineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_isstdin")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "mode")
(KEYWORD not)
(KEYWORD in)
(PUNCT "(")
(LIT "r")
(PUNCT ",")
(LIT "rU")
(PUNCT ",")
(LIT "U")
(PUNCT ",")
(LIT "rb")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "FileInput opening mode must be one of ")
(LIT "'r', 'rU', 'U' and 'rb'")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(LIT "U")
(KEYWORD in)
(ID "mode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "warnings")
(NEWLINE)
(ID "warnings")
(PUNCT ".")
(ID "warn")
(PUNCT "(")
(LIT "'U' mode is deprecated")
(PUNCT ",")
(ID "DeprecationWarning")
(PUNCT ",")
(LIT 2)
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_mode")
(PUNCT "=")
(ID "mode")
(NEWLINE)
(KEYWORD if)
(ID "openhook")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "inplace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "FileInput cannot use an opening hook in inplace mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "callable")
(PUNCT "(")
(ID "openhook")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "ValueError")
(PUNCT "(")
(LIT "FileInput openhook must be callable")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_openhook")
(PUNCT "=")
(ID "openhook")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__del__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "close")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "nextfile")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_files")
(PUNCT "=")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__enter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__exit__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "type")
(PUNCT ",")
(ID "value")
(PUNCT ",")
(ID "traceback")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__iter__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__next__")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_lineno")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_filelineno")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "line")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "StopIteration")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "__getitem__")
(PUNCT "(")
(ID "self")
(PUNCT ",")
(ID "i")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "i")
(PUNCT "!=")
(ID "self")
(PUNCT ".")
(ID "_lineno")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "RuntimeError")
(PUNCT "(")
(LIT "accessing lines out of order")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "__next__")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "StopIteration")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD raise)
(ID "IndexError")
(PUNCT "(")
(LIT "end of input reached")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "nextfile")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "savestdout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_savestdout")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_savestdout")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "savestdout")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "savestdout")
(NEWLINE)
(DEDENT)
(ID "output")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_output")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_output")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "output")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "output")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_file")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "file")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_isstdin")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "file")
(PUNCT ".")
(ID "close")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "backupfilename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "backupfilename")
(KEYWORD and)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_backup")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT "(")
(ID "backupfilename")
(PUNCT ")")
(NEWLINE)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_isstdin")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "=")
(PUNCT "[")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "readline")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "line")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "[")
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "]")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "IndexError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_lineno")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_filelineno")
(PUNCT "+=")
(LIT 1)
(NEWLINE)
(KEYWORD return)
(ID "line")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_files")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(LIT "")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_files")
(PUNCT "[")
(LIT 0)
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_files")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_files")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_filelineno")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(KEYWORD None)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_isstdin")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT "==")
(LIT "-")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT "=")
(LIT "<stdin>")
(NEWLINE)
(KEYWORD if)
(LIT "b")
(KEYWORD in)
(ID "self")
(PUNCT ".")
(ID "_mode")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(PUNCT ".")
(ID "buffer")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdin")
(NEWLINE)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_isstdin")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_inplace")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT "=")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT "+")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_backup")
(KEYWORD or)
(LIT ".bak")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "unlink")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(ID "os")
(PUNCT ".")
(ID "rename")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_backupfilename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_mode")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "perm")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fstat")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ".")
(ID "st_mode")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_output")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "O_CREAT")
(PUNCT "|")
(ID "os")
(PUNCT ".")
(ID "O_WRONLY")
(PUNCT "|")
(ID "os")
(PUNCT ".")
(ID "O_TRUNC")
(NEWLINE)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "O_BINARY")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "mode")
(PUNCT "|=")
(ID "os")
(PUNCT ".")
(ID "O_BINARY")
(NEWLINE)
(DEDENT)
(ID "fd")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT ",")
(ID "mode")
(PUNCT ",")
(ID "perm")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_output")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "fdopen")
(PUNCT "(")
(ID "fd")
(PUNCT ",")
(LIT "w")
(PUNCT ")")
(NEWLINE)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "hasattr")
(PUNCT "(")
(ID "os")
(PUNCT ",")
(LIT "chmod")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "os")
(PUNCT ".")
(ID "chmod")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT ",")
(ID "perm")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD except)
(ID "OSError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD pass)
(NEWLINE)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_savestdout")
(PUNCT "=")
(ID "sys")
(PUNCT ".")
(ID "stdout")
(NEWLINE)
(ID "sys")
(PUNCT ".")
(ID "stdout")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_output")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_openhook")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_openhook")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT "=")
(ID "open")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_filename")
(PUNCT ",")
(ID "self")
(PUNCT ".")
(ID "_mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(DEDENT)
(DEDENT)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT "=")
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ".")
(ID "readlines")
(PUNCT "(")
(ID "self")
(PUNCT ".")
(ID "_bufsize")
(PUNCT ")")
(NEWLINE)
(ID "self")
(PUNCT ".")
(ID "_bufindex")
(PUNCT "=")
(LIT 0)
(NEWLINE)
(KEYWORD if)
(KEYWORD not)
(ID "self")
(PUNCT ".")
(ID "_buffer")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "self")
(PUNCT ".")
(ID "nextfile")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "readline")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "filename")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_filename")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "lineno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_lineno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "filelineno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_filelineno")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "fileno")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD try)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_file")
(PUNCT ".")
(ID "fileno")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD except)
(ID "ValueError")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(PUNCT "-")
(LIT 1)
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "isfirstline")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_filelineno")
(PUNCT "==")
(LIT 1)
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "isstdin")
(PUNCT "(")
(ID "self")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "self")
(PUNCT ".")
(ID "_isstdin")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "hook_compressed")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "ext")
(PUNCT "=")
(ID "os")
(PUNCT ".")
(ID "path")
(PUNCT ".")
(ID "splitext")
(PUNCT "(")
(ID "filename")
(PUNCT ")")
(PUNCT "[")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "ext")
(PUNCT "==")
(LIT ".gz")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "gzip")
(NEWLINE)
(KEYWORD return)
(ID "gzip")
(PUNCT ".")
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD elif)
(ID "ext")
(PUNCT "==")
(LIT ".bz2")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "bz2")
(NEWLINE)
(KEYWORD return)
(ID "bz2")
(PUNCT ".")
(ID "BZ2File")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD else)
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(DEDENT)
(KEYWORD def)
(ID "hook_encoded")
(PUNCT "(")
(ID "encoding")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD def)
(ID "openhook")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD return)
(ID "open")
(PUNCT "(")
(ID "filename")
(PUNCT ",")
(ID "mode")
(PUNCT ",")
(ID "encoding")
(PUNCT "=")
(ID "encoding")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD return)
(ID "openhook")
(NEWLINE)
(DEDENT)
(KEYWORD def)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD import)
(ID "getopt")
(NEWLINE)
(ID "inplace")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "backup")
(PUNCT "=")
(KEYWORD False)
(NEWLINE)
(ID "opts")
(PUNCT ",")
(ID "args")
(PUNCT "=")
(ID "getopt")
(PUNCT ".")
(ID "getopt")
(PUNCT "(")
(ID "sys")
(PUNCT ".")
(ID "argv")
(PUNCT "[")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT ",")
(LIT "ib:")
(PUNCT ")")
(NEWLINE)
(KEYWORD for)
(ID "o")
(PUNCT ",")
(ID "a")
(KEYWORD in)
(ID "opts")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "o")
(PUNCT "==")
(LIT "-i")
(PUNCT ":")
(ID "inplace")
(PUNCT "=")
(KEYWORD True)
(NEWLINE)
(KEYWORD if)
(ID "o")
(PUNCT "==")
(LIT "-b")
(PUNCT ":")
(ID "backup")
(PUNCT "=")
(ID "a")
(NEWLINE)
(DEDENT)
(KEYWORD for)
(ID "line")
(KEYWORD in)
(ID "input")
(PUNCT "(")
(ID "args")
(PUNCT ",")
(ID "inplace")
(PUNCT "=")
(ID "inplace")
(PUNCT ",")
(ID "backup")
(PUNCT "=")
(ID "backup")
(PUNCT ")")
(PUNCT ":")
(NEWLINE)
(INDENT)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "\n")
(PUNCT ":")
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(KEYWORD if)
(ID "line")
(PUNCT "[")
(PUNCT "-")
(LIT 1)
(PUNCT ":")
(PUNCT "]")
(PUNCT "==")
(LIT "\r")
(PUNCT ":")
(ID "line")
(PUNCT "=")
(ID "line")
(PUNCT "[")
(PUNCT ":")
(PUNCT "-")
(LIT 1)
(PUNCT "]")
(NEWLINE)
(ID "print")
(PUNCT "(")
(LIT "%d: %s[%d]%s %s")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "filename")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "filelineno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "isfirstline")
(PUNCT "(")
(PUNCT ")")
(KEYWORD and)
(LIT "*")
(KEYWORD or)
(LIT "")
(PUNCT ",")
(ID "line")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ID "print")
(PUNCT "(")
(LIT "%d: %s[%d]")
(PUNCT "%")
(PUNCT "(")
(ID "lineno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "filename")
(PUNCT "(")
(PUNCT ")")
(PUNCT ",")
(ID "filelineno")
(PUNCT "(")
(PUNCT ")")
(PUNCT ")")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(KEYWORD if)
(ID "__name__")
(PUNCT "==")
(LIT "__main__")
(PUNCT ":")
(NEWLINE)
(INDENT)
(ID "_test")
(PUNCT "(")
(PUNCT ")")
(NEWLINE)
(DEDENT)
(ENDMARKER)
